{"spiral-matrix": [{"task_id": "spiral-matrix", "completion": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not matrix:\n            return []\n        \n        m, n = len(matrix), len(matrix[0])\n        res = []\n        left, right = 0, n - 1\n        top, bottom = 0, m - 1\n        \n        while left <= right and top <= bottom:\n            for i in range(left, right + 1):\n                res.append(matrix[top][i])\n            top += 1\n            \n            for i in range(top, bottom + 1):\n                res.append(matrix[i][right])\n            right -= 1\n            \n            if top <= bottom:\n                for i in range(right, left - 1, -1):\n                    res.append(matrix[bottom][i])\n                bottom -= 1\n            \n            if left <= right:\n                for i in range(bottom, top - 1, -1):\n                    res.append(matrix[i][left])\n                left += 1\n        \n        return res"}], "summary-ranges": [{"task_id": "summary-ranges", "completion": "class Solution(object):\n    def summaryRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(nums) == 0:\n            return []\n        \n        if len(nums) == 1:\n            return [str(nums[0])]\n        \n        start = nums[0]\n        end = nums[0]\n        res = []\n        \n        for i in range(1, len(nums)):\n            if nums[i] == end + 1:\n                end = nums[i]\n            else:\n                if start == end:\n                    res.append(str(start))\n                else:\n                    res.append(str(start) + \"->\" + str(end))\n                start = nums[i]\n                end = nums[i]\n        \n        if start == end:\n            res.append(str(start))\n        else:\n            res.append(str(start) + \"->\" + str(end))\n        \n        return res"}], "distinct-subsequences": [{"task_id": "distinct-subsequences", "completion": "class Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        \n        dp = [0] * (len(t) + 1)\n        dp[0] = 1\n        \n        for i in range(len(s)):\n            for j in range(len(t), 0, -1):\n                if s[i] == t[j - 1]:\n                    dp[j] += dp[j - 1]\n        \n        return dp[-1]"}], "first-missing-positive": [{"task_id": "first-missing-positive", "completion": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. convert all negative numbers to positive numbers\n        ## 2. mark all numbers in the range [1, len(nums)] as present\n        ## 3. iterate through the array and return the first number that is not present\n        \n        ## 1. convert all negative numbers to positive numbers\n        for i in range(len(nums)):\n            if nums[i] <= 0:\n                nums[i] = float('inf')\n        \n        ## 2. mark all numbers in the range [1, len(nums)] as present\n        for i in range(len(nums)):\n            num = abs(nums[i])\n            if num <= len(nums):\n                nums[num - 1] = -abs(nums[num - 1])\n        \n        ## 3. iterate through the array and return the first number that is not present\n        for i in range(1, len(nums) + 1):\n            if nums[i - 1] > 0:\n                return i\n        \n        return len(nums) + 1"}], "permutation-sequence": [{"task_id": "permutation-sequence", "completion": "class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. generate the list of numbers\n        nums = [i for i in range(1, n+1)]\n        \n        # 2. calculate the factorial of n\n        fact = 1\n        for i in range(1, n):\n            fact *= i\n        \n        # 3. calculate the kth permutation\n        k -= 1\n        res = ''\n        for i in range(n-1, -1, -1):\n            # 3.1 calculate the index of the ith digit\n            idx = k // fact\n            # 3.2 calculate the digit\n            res += str(nums[idx])\n            # 3.3 remove the digit from the list\n            nums.pop(idx)\n            # 3.4 update k\n            k %= fact\n            # 3.5 update the factorial\n            fact //= i\n        \n        return res"}], "two-sum-ii-input-array-is-sorted": [{"task_id": "two-sum-ii-input-array-is-sorted", "completion": "class Solution(object):\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. Brute force\n        # for i in range(len(numbers)):\n        #     for j in range(i+1, len(numbers)):\n        #         if numbers[i] + numbers[j] == target:\n        #             return [i+1, j+1]\n        \n        # 2. Two pointers\n        left, right = 0, len(numbers) - 1\n        while left < right:\n            if numbers[left] + numbers[right] == target:\n                return [left+1, right+1]\n            elif numbers[left] + numbers[right] < target:\n                left += 1\n            else:\n                right -= 1"}], "expression-add-operators": [{"task_id": "expression-add-operators", "completion": "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def backtrack(i, curr, prev, prod, res):\n            if i == len(num):\n                if curr == target:\n                    res.append(prev)\n                return\n            for j in range(i, len(num)):\n                if j > i and num[i] == '0':\n                    break\n                curr = int(num[i:j+1])\n                if prev == 0:\n                    backtrack(j+1, curr, curr, curr, res)\n                else:\n                    backtrack(j+1, curr, prev + curr, prev + curr, res)\n                    backtrack(j+1, curr, prev - curr, prev - curr, res)\n                    backtrack(j+1, curr, prev * curr, prev * curr, res)\n        \n        res = []\n        backtrack(0, 0, 0, 1, res)\n        return res"}], "sum-root-to-leaf-numbers": [{"task_id": "sum-root-to-leaf-numbers", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def dfs(root, curr_sum):\n            if not root:\n                return 0\n            if not root.left and not root.right:\n                return curr_sum * 10 + root.val\n            return dfs(root.left, curr_sum * 10 + root.val) + dfs(root.right, curr_sum * 10 + root.val)\n        \n        return dfs(root, 0)"}], "license-key-formatting": [{"task_id": "license-key-formatting", "completion": "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        s = s.replace('-', '').upper()\n        n = len(s)\n        if n <= k:\n            return s\n        return '-'.join(s[i:i+k] for i in range(0, n, k))"}], "gas-station": [{"task_id": "gas-station", "completion": "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if sum(gas) < sum(cost):\n            return -1\n        \n        tank = 0\n        start = 0\n        \n        for i in range(len(gas)):\n            tank += gas[i] - cost[i]\n            if tank < 0:\n                start = i + 1\n                tank = 0\n        \n        return start"}], "burst-balloons": [{"task_id": "burst-balloons", "completion": "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = [1] + nums + [1]\n        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n        \n        for i in range(n - 2, -1, -1):\n            for j in range(i + 2, n):\n                for k in range(i + 1, j):\n                    dp[i][j] = max(dp[i][j], nums[i] * nums[k] * nums[j] + dp[i][k] + dp[k][j])\n        \n        return dp[0][n - 1]"}], "plus-one": [{"task_id": "plus-one", "completion": "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        for i in range(len(digits)-1,-1,-1):\n            if digits[i] < 9:\n                digits[i] += 1\n                return digits\n            else:\n                digits[i] = 0\n        digits.insert(0,1)\n        return digits"}], "regular-expression-matching": [{"task_id": "regular-expression-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        if not p:\n            return not s\n        \n        first_match = bool(s) and p[0] in (s[0], '.')\n        \n        if len(p) >= 2 and p[1] == '*':\n            return (self.isMatch(s, p[2:]) or\n                    first_match and self.isMatch(s[1:], p))\n        else:\n            return first_match and self.isMatch(s[1:], p[1:])"}], "create-maximum-number": [{"task_id": "create-maximum-number", "completion": "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def pick(nums, k):\n            removed = len(nums) - k\n            out = []\n            for num in nums:\n                while removed and out and out[-1] < num:\n                    out.pop()\n                    removed -= 1\n                out.append(num)\n            return out\n        \n        def merge(nums1, nums2, k):\n            merged = []\n            i, j = 0, 0\n            while i < len(nums1) and j < len(nums2) and len(merged) < k:\n                if nums1[i] > nums2[j]:\n                    merged.append(nums1[i])\n                    i += 1\n                else:\n                    merged.append(nums2[j])\n                    j += 1\n            merged += nums1[i:]\n            merged += nums2[j:]\n            return merged\n        \n        def get_max_array(nums, k):\n            out = []\n            for i in range(len(nums) - k + 1):\n                if nums[i] > out[-1]:\n                    out = nums[i:i+k]\n            return out\n        \n        return max(merge(pick(nums1, i), pick(nums2, k - i), k) for i in range(k + 1) if i <= len(nums1) and k - i <= len(nums2))"}], "perfect-number": [{"task_id": "perfect-number", "completion": "class Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return False\n        \n        sum = 1\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                sum += i + num / i\n        \n        return sum == num"}], "fibonacci-number": [{"task_id": "fibonacci-number", "completion": "class Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        \n        a = 0\n        b = 1\n        for i in range(2, n+1):\n            c = a + b\n            a = b\n            b = c\n        return b"}], "dungeon-game": [{"task_id": "dungeon-game", "completion": "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        \"\"\"\n        :type dungeon: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(dungeon)\n        n = len(dungeon[0])\n        \n        dp = [[0] * n for _ in range(m)]\n        \n        for i in range(m - 1, -1, -1):\n            for j in range(n - 1, -1, -1):\n                if i == m - 1 and j == n - 1:\n                    dp[i][j] = max(1 - dungeon[i][j], 1)\n                elif i == m - 1:\n                    dp[i][j] = max(dp[i][j + 1] - dungeon[i][j], 1)\n                elif j == n - 1:\n                    dp[i][j] = max(dp[i + 1][j] - dungeon[i][j], 1)\n                else:\n                    dp[i][j] = max(min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j], 1)\n        \n        return dp[0][0]"}], "find-k-th-smallest-pair-distance": [{"task_id": "find-k-th-smallest-pair-distance", "completion": "class Solution(object):\n    def smallestDistancePair(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        left, right = 0, nums[-1] - nums[0]\n        while left < right:\n            mid = (left + right) // 2\n            count, left = 0, 0\n            for right in range(len(nums)):\n                while nums[right] - nums[left] > mid:\n                    left += 1\n                count += right - left\n            if count < k:\n                left = mid + 1\n            else:\n                right = mid\n        return left"}], "number-of-segments-in-a-string": [{"task_id": "number-of-segments-in-a-string", "completion": "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        return len(s.split())"}], "reverse-vowels-of-a-string": [{"task_id": "reverse-vowels-of-a-string", "completion": "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n        s_list = list(s)\n        vowel_indices = [i for i, letter in enumerate(s_list) if letter in vowels]\n        vowel_indices.reverse()\n        for i in vowel_indices:\n            s_list[i] = s_list[vowel_indices.pop()]\n        return ''.join(s_list)"}], "longest-consecutive-sequence": [{"task_id": "longest-consecutive-sequence", "completion": "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums_set = set(nums)\n        max_length = 0\n        \n        for num in nums:\n            if num - 1 not in nums_set:\n                current_num = num\n                current_length = 1\n                \n                while current_num + 1 in nums_set:\n                    current_num += 1\n                    current_length += 1\n                    \n                max_length = max(max_length, current_length)\n                \n        return max_length"}], "missing-number": [{"task_id": "missing-number", "completion": "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## O(n) time and O(1) space\n        ## XOR\n        ## 0 ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 ^ 8 ^ 9 ^ 10\n        ## 0 ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 ^ 8 ^ 9 ^ 10 ^ 11\n        ## 0 ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 ^ 8 ^ 9 ^ 10 ^ 11 ^ 12\n        ## 0 ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 ^ 8 ^ 9 ^ 10 ^ 11 ^ 12 ^ 13\n        ## 0 ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 ^ 8 ^ 9 ^ 10 ^ 11 ^ 12 ^ 13 ^ 14\n        ## 0 ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 ^ 8 ^ 9 ^ 10 ^ 11 ^ 12 ^ 13 ^ 14 ^ 15\n        ## 0 ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 ^ 8 ^ 9 ^ 10 ^ 11 ^ 12 ^ 13 ^ 14 ^ 15 ^ 16\n        ## 0 ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 ^ 8 ^ 9 ^ 10 ^ 11 ^ 12 ^ 13 ^ 14 ^ 15 ^ 16 ^ 17\n        ## 0 ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 ^ 8 ^ 9 ^ 10 ^ 11 ^ 12 ^ 13 ^ 14 ^ 15 ^ 16 ^ 17 ^ 18\n        ## 0 ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 ^ 8 ^ 9 ^ 10 ^ 11 ^ 12 ^ 13 ^ 14 ^ 15 ^ 16 ^ 17 ^ 18 ^ 19\n        ## 0 ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 ^ 8 ^ 9 ^ 10 ^ 11 ^ 12 ^ 13 ^ 14 ^ 15 ^ 16 ^ 17 ^ 18 ^ 19 ^ 20\n        ## 0 ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 ^ 8 ^ 9 ^ 10 ^ 11 ^ 12 ^ 13 ^ 14 ^ 15 ^ 16 ^ 17 ^ 18 ^ 19 ^ 20 ^ 21\n        ## 0 ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 ^ 8 ^ 9 ^ 10 ^ 11 ^ 12 ^ 13 ^ 14 ^ 15 ^ 16 ^ 17 ^ 18 ^ 19 ^ 20 ^ 21 ^ 22\n        ## 0 ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 ^ 8 ^ 9 ^ 10 ^ 11 ^ 12 ^ 13 ^ 14 ^ 15 ^ 16 ^ 17 ^ 18 ^ 19 ^ 20 ^ 21 ^ 22 ^ 23\n        ## 0 ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 ^ 8 ^ 9 ^ 10 ^ 11 ^ 12 ^ 13 ^ 14 ^ 15 ^ 16 ^ 17 ^ 18 ^ 19 ^ 20 ^ 21 ^ 22 ^ 23 ^ 24\n        ## 0 ^ 1 ^ 2 ^ 3 ^ 4 ^ 5 ^ 6 ^ 7 ^"}], "word-ladder": [{"task_id": "word-ladder", "completion": "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        \n        # create a set of words from the wordList\n        wordSet = set(wordList)\n        \n        # create a queue and add the beginWord\n        queue = collections.deque([beginWord])\n        \n        # create a set to keep track of visited words\n        visited = set()\n        \n        # create a variable to keep track of the number of transformations\n        transformations = 0\n        \n        # while the queue is not empty\n        while queue:\n            # increment the number of transformations\n            transformations += 1\n            \n            # for each word in the queue\n            for _ in range(len(queue)):\n                # pop the first word from the queue\n                word = queue.popleft()\n                \n                # if the word is the endWord\n                if word == endWord:\n                    # return the number of transformations\n                    return transformations\n                \n                # for each character in the word\n                for i in range(len(word)):\n                    # for each letter in the alphabet\n                    for letter in string.ascii_lowercase:\n                        # if the word without the current character is in the set\n                        if word[:i] + letter + word[i+1:] in wordSet:\n                            # if the word without the current character has not been visited\n                            if word[:i] + letter + word[i+1:] not in visited:\n                                # add the word without the current character to the queue\n                                queue.append(word[:i] + letter + word[i+1:])\n                                # add the word without the current character to the set of visited words\n                                visited.add(word[:i] + letter + word[i+1:])\n        \n        # return 0 if the endWord is not in the set\n        return 0"}], "add-binary": [{"task_id": "add-binary", "completion": "class Solution(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        \n        if len(a) < len(b):\n            a, b = b, a\n        \n        carry = 0\n        result = []\n        \n        for i in range(len(a)-1, -1, -1):\n            if a[i] == '1':\n                carry += 1\n            if i < len(b):\n                if b[i] == '1':\n                    carry += 1\n            result.append(str(carry % 2))\n            carry //= 2\n        \n        if carry == 1:\n            result.append('1')\n        \n        return ''.join(result[::-1])"}], "find-first-and-last-position-of-element-in-sorted-array": [{"task_id": "find-first-and-last-position-of-element-in-sorted-array", "completion": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def binary_search(nums, target, find_left_index):\n            left, right = 0, len(nums) - 1\n            index = -1\n            while left <= right:\n                mid = (left + right) // 2\n                if nums[mid] > target or (find_left_index and nums[mid] == target):\n                    right = mid - 1\n                    index = mid\n                else:\n                    left = mid + 1\n            return index\n        \n        left_index = binary_search(nums, target, True)\n        right_index = binary_search(nums, target, False)\n        return [left_index, right_index]"}], "remove-duplicates-from-sorted-array": [{"task_id": "remove-duplicates-from-sorted-array", "completion": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 0:\n            return 0\n        \n        i = 0\n        for j in range(1, len(nums)):\n            if nums[j] != nums[i]:\n                i += 1\n                nums[i] = nums[j]\n        \n        return i + 1"}], "jump-game-ii": [{"task_id": "jump-game-ii", "completion": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "best-time-to-buy-and-sell-stock-iv": [{"task_id": "best-time-to-buy-and-sell-stock-iv", "completion": "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if k >= len(prices) / 2:\n            return sum(max(prices[i+1] - prices[i] for i in range(len(prices) - 1)) - max(prices[i] - prices[i+1] for i in range(len(prices) - 1))\n        \n        dp = [[0] * (2 * k + 1) for _ in range(len(prices))]\n        \n        for i in range(len(prices)):\n            for j in range(1, 2 * k, 2):\n                dp[i][j] = max(dp[i - 1][j], prices[i] + dp[i - 1][j - 1])\n                dp[i][j + 1] = max(dp[i - 1][j + 1], prices[i] - dp[i - 1][j])\n        \n        return dp[-1][-1]"}], "convert-a-number-to-hexadecimal": [{"task_id": "convert-a-number-to-hexadecimal", "completion": "class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return '0'\n        \n        hex_dict = {10: 'a', 11: 'b', 12: 'c', 13: 'd', 14: 'e', 15: 'f'}\n        hex_list = []\n        if num < 0:\n            num = num + 2**32\n        \n        while num > 0:\n            hex_list.append(num % 16)\n            num = num // 16\n        \n        hex_list.reverse()\n        hex_str = ''\n        for i in hex_list:\n            if i < 10:\n                hex_str += str(i)\n            else:\n                hex_str += hex_dict[i]\n        \n        return hex_str"}], "first-unique-character-in-a-string": [{"task_id": "first-unique-character-in-a-string", "completion": "class Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # create a dictionary with key as the character and value as the index\n        # iterate through the string and check if the character is already in the dictionary\n        # if it is, remove it from the dictionary\n        # if it is not, add it to the dictionary\n        # return the value of the first character in the dictionary\n        \n        d = {}\n        for i, c in enumerate(s):\n            if c in d:\n                d.pop(c)\n            else:\n                d[c] = i\n        if len(d) == 0:\n            return -1\n        return min(d.values())"}], "contains-duplicate-iii": [{"task_id": "contains-duplicate-iii", "completion": "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDiff: int\n        :type valueDiff: int\n        :rtype: bool\n        \"\"\"\n        \n        if len(nums) <= 1:\n            return False\n        \n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if abs(nums[i] - nums[j]) <= valueDiff and abs(i - j) <= indexDiff:\n                    return True\n        return False"}], "sort-colors": [{"task_id": "sort-colors", "completion": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2"}], "max-consecutive-ones": [{"task_id": "max-consecutive-ones", "completion": "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_count = 0\n        count = 0\n        \n        for i in nums:\n            if i == 1:\n                count += 1\n            else:\n                count = 0\n            max_count = max(max_count, count)\n        \n        return max_count"}], "count-complete-tree-nodes": [{"task_id": "count-complete-tree-nodes", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        left_height = self.get_height(root.left)\n        right_height = self.get_height(root.right)\n        \n        if left_height == right_height:\n            return pow(2, left_height) + self.countNodes(root.right)\n        else:\n            return pow(2, right_height) + self.countNodes(root.left)\n        \n    def get_height(self, root):\n        if not root:\n            return 0\n        \n        return 1 + self.get_height(root.left)"}], "add-strings": [{"task_id": "add-strings", "completion": "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        ## 1. convert to int\n        ## 2. add\n        ## 3. convert back to str\n        \n        ## 1. convert to int\n        num1 = int(num1)\n        num2 = int(num2)\n        \n        ## 2. add\n        sum = num1 + num2\n        \n        ## 3. convert back to str\n        return str(sum)"}], "basic-calculator": [{"task_id": "basic-calculator", "completion": "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        def helper(s, i, sign):\n            res, i = 0, i + 1\n            while i < len(s) and s[i].isdigit():\n                res = res * 10 + int(s[i])\n                i += 1\n            return res, i\n        \n        stack, sign, i = [], 1, 0\n        while i < len(s):\n            if s[i] == ' ':\n                i += 1\n            elif s[i] == '+':\n                sign = 1\n                i += 1\n            elif s[i] == '-':\n                sign = -1\n                i += 1\n            elif s[i] == '(':\n                num, i = helper(s, i, sign)\n                stack.append(num * sign)\n            elif s[i] == ')':\n                num = 0\n                while stack and stack[-1] != '(':\n                    num += stack.pop()\n                stack.pop()\n                stack.append(stack.pop() + num * sign)\n            else:\n                num, i = helper(s, i, 1)\n                stack.append(num * sign)\n        return sum(stack)"}], "ipo": [{"task_id": "ipo", "completion": "class Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # sort capital and profits\n        # iterate over capital and profits\n        # if k > 0, add profit to w\n        # else, add capital to w\n        # if capital > w, add profit to w\n        # else, add capital to w\n        # if k > 0, add profit to w\n        # else, add capital to w\n        # if capital > w, add profit to w\n        # else, add capital to w\n        # if k > 0, add profit to w\n        # else, add capital to w\n        # if capital > w, add profit to w\n        # else, add capital to w\n        # if k > 0, add profit to w\n        # else, add capital to w\n        # if capital > w, add profit to w\n        # else, add capital to w\n        # if k > 0, add profit to w\n        # else, add capital to w\n        # if capital > w, add profit to w\n        # else, add capital to w\n        # if k > 0, add profit to w\n        # else, add capital to w\n        # if capital > w, add profit to w\n        # else, add capital to w\n        # if k > 0, add profit to w\n        # else, add capital to w\n        # if capital > w, add profit to w\n        # else, add capital to w\n        # if k > 0, add profit to w\n        # else, add capital to w\n        # if capital > w, add profit to w\n        # else, add capital to w\n        # if k > 0, add profit to w\n        # else, add capital to w\n        # if capital > w, add profit to w\n        # else, add capital to w\n        # if k > 0, add profit to w\n        # else, add capital to w\n        # if capital > w, add profit to w\n        # else, add capital to w\n        # if k > 0, add profit to w\n        # else, add capital to w\n        # if capital > w, add profit to w\n        # else, add capital to w\n        # if k > 0, add profit to w\n        # else, add capital to w\n        # if capital > w, add profit to w\n        # else, add capital to w\n        # if k > 0, add profit to w\n        # else, add capital to w\n        # if capital > w, add profit to w\n        # else, add capital to w\n        # if k > 0, add profit to w\n        # else, add capital to w\n        # if capital > w, add profit to w\n        # else, add capital to w\n        # if k > 0, add profit to w\n        # else, add capital to w\n        # if capital > w, add profit to w\n        # else, add capital to w\n        # if k > 0, add profit to w\n        # else, add capital to w\n        # if capital > w, add profit to w\n        # else, add capital to w\n        # if k > 0, add profit to w\n        # else, add capital to w\n        # if capital > w, add profit to w\n        # else, add capital to w\n        # if k > 0, add profit to w\n        # else, add capital to w\n        # if capital > w, add profit to w\n        # else, add capital to w\n        # if k > 0, add profit to w\n        # else, add capital to w\n        # if capital > w, add profit to w\n        # else, add capital to w\n        # if k > 0, add profit to w\n        # else, add capital to w\n        # if capital > w, add profit to w\n        # else, add capital to w\n        # if k > 0, add profit to w\n        # else, add capital to w\n        # if capital > w, add profit to w\n        # else, add capital to w\n        # if k > 0, add profit to w\n        # else, add capital to w\n        # if capital > w, add profit to w\n        # else, add capital to w\n        # if k > 0, add profit to w\n        # else, add capital to w\n        # if capital > w, add profit to w\n        # else, add capital to w\n        # if k > 0, add profit to w\n        # else, add capital to w\n        # if capital > w, add profit to w\n        # else, add capital to w"}], "valid-parentheses": [{"task_id": "valid-parentheses", "completion": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        stack = []\n        for i in s:\n            if i == '(':\n                stack.append(')')\n            elif i == '[':\n                stack.append(']')\n            elif i == '{':\n                stack.append('}')\n            elif stack and i == stack[-1]:\n                stack.pop()\n            else:\n                return False\n        return len(stack) == 0"}], "next-permutation": [{"task_id": "next-permutation", "completion": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # find the first index i such that nums[i] < nums[i+1]\n        i = len(nums) - 2\n        while i >= 0 and nums[i] >= nums[i+1]:\n            i -= 1\n        \n        # if no such index exists, the permutation is sorted in descending order,\n        # reverse the entire array to get the next permutation\n        if i == -1:\n            nums.reverse()\n            return\n        \n        # find the first index j such that nums[j] > nums[i]\n        j = len(nums) - 1\n        while j >= 0 and nums[j] <= nums[i]:\n            j -= 1\n        \n        # swap nums[i] and nums[j]\n        nums[i], nums[j] = nums[j], nums[i]\n        \n        # reverse the subarray nums[i+1:]\n        nums[i+1:] = nums[len(nums) - 1: i:-1]"}], "contains-duplicate-ii": [{"task_id": "contains-duplicate-ii", "completion": "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        \n        if len(nums) <= 1:\n            return False\n        \n        if k == 0:\n            return False\n        \n        if len(nums) > k:\n            return True\n        \n        d = {}\n        \n        for i in range(len(nums)):\n            if nums[i] in d:\n                if i - d[nums[i]] <= k:\n                    return True\n            d[nums[i]] = i\n        \n        return False"}], "maximum-gap": [{"task_id": "maximum-gap", "completion": "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 2:\n            return 0\n        \n        nums.sort()\n        max_diff = 0\n        for i in range(1, len(nums)):\n            max_diff = max(max_diff, nums[i] - nums[i - 1])\n        return max_diff"}], "binary-tree-level-order-traversal": [{"task_id": "binary-tree-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        result = []\n        \n        while queue:\n            level = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            result.append(level)\n        return result"}], "couples-holding-hands": [{"task_id": "couples-holding-hands", "completion": "class Solution(object):\n    def minSwapsCouples(self, row):\n        \"\"\"\n        :type row: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(row)\n        couples = [(row[i], row[i+1]) for i in range(0, n, 2)]\n        couples.sort()\n        swaps = 0\n        for i in range(0, n, 2):\n            if couples[i][0]/2 != couples[i+1][0]/2:\n                couples[i], couples[i+1] = couples[i+1], couples[i]\n                swaps += 1\n        return swaps"}], "interleaving-string": [{"task_id": "interleaving-string", "completion": "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) + len(s2) != len(s3):\n            return False\n        \n        if len(s1) == 0 and len(s2) == 0 and len(s3) == 0:\n            return True\n        \n        if len(s1) == 0:\n            return s2 == s3\n        \n        if len(s2) == 0:\n            return s1 == s3\n        \n        dp = [[False] * (len(s2) + 1) for _ in range(len(s1) + 1)]\n        \n        for i in range(len(s1) + 1):\n            for j in range(len(s2) + 1):\n                if i == 0 and j == 0:\n                    dp[i][j] = True\n                elif i == 0:\n                    dp[i][j] = dp[i][j - 1] and s2[j - 1] == s3[j - 1]\n                elif j == 0:\n                    dp[i][j] = dp[i - 1][j] and s1[i - 1] == s3[i - 1]\n                else:\n                    dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n        \n        return dp[len(s1)][len(s2)]"}], "assign-cookies": [{"task_id": "assign-cookies", "completion": "class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        \n        g.sort()\n        s.sort()\n        i = 0\n        j = 0\n        while i < len(g) and j < len(s):\n            if s[j] >= g[i]:\n                i += 1\n            j += 1\n        return i"}], "keyboard-row": [{"task_id": "keyboard-row", "completion": "class Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        row1 = set(\"qwertyuiop\")\n        row2 = set(\"asdfghjkl\")\n        row3 = set(\"zxcvbnm\")\n        \n        res = []\n        for word in words:\n            if word[0] in row1 or word[0] in row2 or word[0] in row3:\n                if set(word) <= row1:\n                    res.append(word)\n                elif set(word) <= row2:\n                    res.append(word)\n                else:\n                    res.append(word)\n        return res"}], "reverse-linked-list-ii": [{"task_id": "reverse-linked-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: ListNode\n        :type left: int\n        :type right: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if left == right:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        \n        for i in range(left - 1):\n            prev = prev.next\n        \n        curr = prev.next\n        for i in range(right - left):\n            nxt = curr.next\n            curr.next = nxt.next\n            nxt.next = prev.next\n            prev.next = nxt\n        \n        return dummy.next"}], "shortest-palindrome": [{"task_id": "shortest-palindrome", "completion": "class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # find the longest palindrome that can be centered at the beginning of the string\n        # then add the remaining part of the string to the beginning\n        # e.g. \"abcd\" -> \"dcbabcd\"\n        #     \"abba\" -> \"abba\"\n        #     \"abbaab\" -> \"abbaab\"\n        #     \"abbaabb\" -> \"abbaabb\"\n        #     \"abbaabba\" -> \"abbaabba\"\n        #     \"abbaabbab\" -> \"abbaabbab\"\n        #     \"abbaabbabb\" -> \"abbaabbabb\"\n        #     \"abbaabbabba\" -> \"abbaabbabba\"\n        #     \"abbaabbabbab\" -> \"abbaabbabbab\"\n        #     \"abbaabbabbabb\" -> \"abbaabbabbabb\"\n        #     \"abbaabbabbabba\" -> \"abbaabbabbabba\"\n        #     \"abbaabbabbabbb\" -> \"abbaabbabbabbb\"\n        #     \"abbaabbabbabbbb\" -> \"abbaabbabbabbbb\"\n        #     \"abbaabbabbabbbbb\" -> \"abbaabbabbabbbbb\"\n        #     \"abbaabbabbabbbbbb\" -> \"abbaabbabbabbbbbb\"\n        #     \"abbaabbabbabbbbbbb\" -> \"abbaabbabbabbbbbbb\"\n        #     \"abbaabbabbabbbbbbbb\" -> \"abbaabbabbabbbbbbbb\"\n        #     \"abbaabbabbabbbbbbbbb\" -> \"abbaabbabbabbbbbbbbb\"\n        #     \"abbaabbabbabbbbbbbbbb\" -> \"abbaabbabbabbbbbbbbbb\"\n        #     \"abbaabbabbabbbbbbbbbbb\" -> \"abbaabbabbabbbbbbbbbbb\"\n        #     \"abbaabbabbabbbbbbbbbbbb\" -> \"abbaabbabbabbbbbbbbbbbb\"\n        #     \"abbaabbabbabbbbbbbbbbbbb\" -> \"abbaabbabbabbbbbbbbbbbbb\"\n        #     \"abbaabbabbabbbbbbbbbbbbbb\" -> \"abbaabbabbabbbbbbbbbbbbbb\"\n        #     \"abbaabbabbabbbbbbbbbbbbbbb\" -> \"abbaabbabbabbbbbbbbbbbbbbb\"\n        #     \"abbaabbabbabbbbbbbbbbbbbbbb\" -> \"abbaabbabbabbbbbbbbbbbbbbbb\"\n        #     \"abbaabbabbabbbbbbbbbbbbbbbbb\" -> \"abbaabbabbabbbbbbbbbbbbbbbbb\"\n        #     \"abbaabbabbabbbbbbbbbbbbbbbbbb\" -> \"abbaabbabbabbbbbbbbbbbbbbbbbb\"\n        #     \"abbaabbabbabbbbbbbbbbbbbbbbbbb\" -> \"abbaabbabbabbbbbbbbbbbbbbbbbbb\"\n        #     \"abbaabbabbabbbbbbbbbbbbbbbbbbbb\" -> \"abbaabbabbabbbbbbbbbbbbbbbbbbbb\"\n        #     \"abbaabbabbabbbbbbbbbbbbbbbbbbbbb\" -> \"abbaabbabbabbbbbbbbbbbbbbbbbbbbb\"\n        #     \"abbaabbabbabbbbbbbbbbbbbbbbbbbbbb\" -> \"abbaabbabbabbbbbbbbbbbbbbbbbbbbbb\"\n        #     \"abbaabbabbabbbbbbbbbbbbbbbbbbbbbbb\" -> \"abbaabbabbabbbbbbbbbbbbbbbbbbbbbbb\""}], "minimum-window-substring": [{"task_id": "minimum-window-substring", "completion": "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        if len(t) > len(s):\n            return \"\"\n        \n        t_dict = {}\n        for c in t:\n            if c not in t_dict:\n                t_dict[c] = 1\n            else:\n                t_dict[c] += 1\n        \n        left = 0\n        right = 0\n        min_len = len(s) + 1\n        min_left = 0\n        min_right = 0\n        window_dict = {}\n        for c in s:\n            if c not in window_dict:\n                window_dict[c] = 1\n            else:\n                window_dict[c] += 1\n            \n            if c in t_dict and window_dict[c] <= t_dict[c]:\n                if right - left + 1 < min_len:\n                    min_len = right - left + 1\n                    min_left = left\n                    min_right = right\n                window_dict[c] -= 1\n                left += 1\n            else:\n                right += 1\n        \n        if min_len > len(s):\n            return \"\"\n        \n        return s[min_left:min_right + 1]"}], "self-crossing": [{"task_id": "self-crossing", "completion": "class Solution(object):\n    def isSelfCrossing(self, distance):\n        \"\"\"\n        :type distance: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        for i in range(3, len(distance)):\n            if distance[i] >= distance[i - 2] and distance[i - 1] <= distance[i - 3]:\n                return True\n            if i >= 4 and distance[i] + distance[i - 4] >= distance[i - 2] and distance[i - 1] == distance[i - 3]:\n                return True\n            if i >= 5 and distance[i] + distance[i - 4] >= distance[i - 2] and distance[i - 1] + distance[i - 5] >= distance[i - 3] and distance[i - 2] + distance[i - 4] >= distance[i - 4]:\n                return True\n        return False"}], "remove-duplicates-from-sorted-list": [{"task_id": "remove-duplicates-from-sorted-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        curr = head\n        \n        while curr:\n            while curr.next and curr.val == curr.next.val:\n                curr.next = curr.next.next\n            curr = curr.next\n        \n        return head"}], "longest-palindrome": [{"task_id": "longest-palindrome", "completion": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # create a dictionary to store the frequency of each character\n        freq = {}\n        \n        # loop through the string and add each character to the dictionary\n        for char in s:\n            if char not in freq:\n                freq[char] = 1\n            else:\n                freq[char] += 1\n        \n        # initialize the length of the longest palindrome to 0\n        longest_palindrome = 0\n        \n        # loop through the dictionary and check if the frequency is odd\n        for char, count in freq.items():\n            if count % 2 == 0:\n                longest_palindrome += count\n            else:\n                longest_palindrome += count - 1\n        \n        # if the length of the string is less than the length of the longest palindrome, add 1 to the length of the longest palindrome\n        if len(s) < longest_palindrome:\n            longest_palindrome += 1\n        \n        return longest_palindrome"}], "construct-binary-tree-from-inorder-and-postorder-traversal": [{"task_id": "construct-binary-tree-from-inorder-and-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not inorder:\n            return None\n        \n        root = TreeNode(postorder[-1])\n        idx = inorder.index(root.val)\n        \n        root.right = self.buildTree(inorder[idx+1:], postorder[idx:-1])\n        root.left = self.buildTree(inorder[:idx], postorder[:idx])\n        \n        return root"}], "cut-off-trees-for-golf-event": [{"task_id": "cut-off-trees-for-golf-event", "completion": "class Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def bfs(start, end):\n            q = [start]\n            visited = set()\n            steps = 0\n            while q:\n                for _ in range(len(q)):\n                    i, j = q.pop(0)\n                    if (i, j) == end:\n                        return steps\n                    for di, dj in [(0, 1), (1, 0), (0, -1), (-1, 0)]:\n                        ni, nj = i + di, j + dj\n                        if 0 <= ni < m and 0 <= nj < n and forest[ni][nj] > 0 and (ni, nj) not in visited:\n                            q.append((ni, nj))\n                            visited.add((ni, nj))\n                steps += 1\n            return -1\n        \n        m, n = len(forest), len(forest[0])\n        trees = [(i, j) for i in range(m) for j in range(n) if forest[i][j] > 1]\n        steps = 0\n        for i, j in trees:\n            steps += bfs((0, 0), (i, j))\n            if steps < 0:\n                return steps\n            steps += 1\n        return steps"}], "minimum-depth-of-binary-tree": [{"task_id": "minimum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        if not root.left:\n            return 1 + self.minDepth(root.right)\n        \n        if not root.right:\n            return 1 + self.minDepth(root.left)\n        \n        return 1 + min(self.minDepth(root.left), self.minDepth(root.right))"}], "count-of-range-sum": [{"task_id": "count-of-range-sum", "completion": "class Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. calculate the prefix sum\n        # 2. use two pointers to find the range sum\n        # 3. use a hashmap to store the count of range sum\n        # 4. return the count\n        \n        # 1. calculate the prefix sum\n        n = len(nums)\n        prefix_sum = [0] * (n + 1)\n        for i in range(n):\n            prefix_sum[i + 1] = prefix_sum[i] + nums[i]\n        \n        # 2. use two pointers to find the range sum\n        # 3. use a hashmap to store the count of range sum\n        # 4. return the count\n        count = 0\n        for i in range(n):\n            for j in range(i + 1, n + 1):\n                curr_sum = prefix_sum[j] - prefix_sum[i]\n                if lower <= curr_sum <= upper:\n                    count += 1\n        return count"}], "arranging-coins": [{"task_id": "arranging-coins", "completion": "class Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        return int((2*n + 0.25)**0.5 - 0.5)"}], "longest-uncommon-subsequence-i": [{"task_id": "longest-uncommon-subsequence-i", "completion": "class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        \n        if a == b:\n            return -1\n        else:\n            return max(len(a), len(b))"}], "binary-tree-level-order-traversal-ii": [{"task_id": "binary-tree-level-order-traversal-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        result = []\n        \n        while queue:\n            level = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            result.insert(0, level)\n        return result"}], "palindrome-number": [{"task_id": "palindrome-number", "completion": "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        \n        if x < 0:\n            return False\n        \n        if x < 10:\n            return True\n        \n        if x % 10 == 0:\n            return False\n        \n        rev = 0\n        while x > rev:\n            rev = rev * 10 + x % 10\n            x = x // 10\n        \n        return x == rev or x == rev // 10"}], "decode-ways": [{"task_id": "decode-ways", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if s[0] == '0':\n            return 0\n        \n        if len(s) == 1:\n            return 1\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] += dp[i - 1]\n            if s[i - 2] != '0' and int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        \n        return dp[-1]"}], "is-subsequence": [{"task_id": "is-subsequence", "completion": "class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) > len(t):\n            return False\n        \n        i = 0\n        j = 0\n        \n        while i < len(s) and j < len(t):\n            if s[i] == t[j]:\n                i += 1\n            j += 1\n        \n        return i == len(s)"}], "gray-code": [{"task_id": "gray-code", "completion": "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. 2^n - 1 is the max number we can generate\n        # 2. 2^n - 1 is the max number we can generate\n        # 3. 2^n - 1 is the max number we can generate\n        # 4. 2^n - 1 is the max number we can generate\n        # 5. 2^n - 1 is the max number we can generate\n        # 6. 2^n - 1 is the max number we can generate\n        # 7. 2^n - 1 is the max number we can generate\n        # 8. 2^n - 1 is the max number we can generate\n        # 9. 2^n - 1 is the max number we can generate\n        # 10. 2^n - 1 is the max number we can generate\n        # 11. 2^n - 1 is the max number we can generate\n        # 12. 2^n - 1 is the max number we can generate\n        # 13. 2^n - 1 is the max number we can generate\n        # 14. 2^n - 1 is the max number we can generate\n        # 15. 2^n - 1 is the max number we can generate\n        # 16. 2^n - 1 is the max number we can generate\n        # 17. 2^n - 1 is the max number we can generate\n        # 18. 2^n - 1 is the max number we can generate\n        # 19. 2^n - 1 is the max number we can generate\n        # 20. 2^n - 1 is the max number we can generate\n        # 21. 2^n - 1 is the max number we can generate\n        # 22. 2^n - 1 is the max number we can generate\n        # 23. 2^n - 1 is the max number we can generate\n        # 24. 2^n - 1 is the max number we can generate\n        # 25. 2^n - 1 is the max number we can generate\n        # 26. 2^n - 1 is the max number we can generate\n        # 27. 2^n - 1 is the max number we can generate\n        # 28. 2^n - 1 is the max number we can generate\n        # 29. 2^n - 1 is the max number we can generate\n        # 30. 2^n - 1 is the max number we can generate\n        # 31. 2^n - 1 is the max number we can generate\n        # 32. 2^n - 1 is the max number we can generate\n        # 33. 2^n - 1 is the max number we can generate\n        # 34. 2^n - 1 is the max number we can generate\n        # 35. 2^n - 1 is the max number we can generate\n        # 36. 2^n - 1 is the max number we can generate\n        # 37. 2^n - 1 is the max number we can generate\n        # 38. 2^n - 1 is the max number we can generate\n        # 39. 2^n - 1 is the max number we can generate\n        # 40. 2^n - 1 is the max number we can generate\n        # 41. 2^n - 1 is the max number we can generate\n        # 42. 2^n - 1 is the max number we can generate\n        # 43. 2^n - 1 is the max number we can generate\n        # 44. 2^n - 1 is the max number we can generate\n        # 45. 2^n - 1 is the max number we can generate\n        # 46. 2^n - 1 is the max number we can generate\n        # 47. 2^n - 1 is the max number we can generate\n        # 48. 2^n - 1 is the max number we can generate\n        # 49. 2^n - 1 is the max number we can generate\n        # 5"}], "climbing-stairs": [{"task_id": "climbing-stairs", "completion": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        \n        a = 1\n        b = 2\n        for i in range(3, n+1):\n            c = a + b\n            a = b\n            b = c\n        return c"}], "word-break": [{"task_id": "word-break", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        \n        # DP solution\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        # return dp[-1]\n        \n        # BFS solution\n        # Use a queue to store the index of the string to be segmented.\n        # For each index, check if it can be segmented into a space-separated sequence of one or more dictionary words.\n        # If it can, return True.\n        # If it cannot, check if any of the words in wordDict can be segmented from the index.\n        # If it can, add the index to the queue.\n        # If it cannot, return False.\n        # Time complexity: O(n^2)\n        # Space complexity: O(n)\n        if not s or not wordDict:\n            return False\n        \n        queue = collections.deque([0])\n        visited = set()\n        while queue:\n            i = queue.popleft()\n            if i == len(s):\n                return True\n            for j in range(i + 1, len(s) + 1):\n                if s[i:j] in wordDict and j not in visited:\n                    queue.append(j)\n                    visited.add(j)\n        return False"}], "validate-binary-search-tree": [{"task_id": "validate-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def valid(node, left, right):\n            if not node:\n                return True\n            \n            if (left and node.val <= left.val) or (right and node.val >= right.val):\n                return False\n            \n            return valid(node.left, left, node) and valid(node.right, node, right)\n        \n        return valid(root, None, None)"}], "insert-interval": [{"task_id": "insert-interval", "completion": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # if the new interval is empty, return the original list\n        if not newInterval:\n            return intervals\n        \n        # if the list is empty, return the new interval\n        if not intervals:\n            return [newInterval]\n        \n        # initialize the result list\n        result = []\n        \n        # iterate through the intervals\n        for interval in intervals:\n            # if the current interval is after the new interval, add it to the result list\n            if interval[1] < newInterval[0]:\n                result.append(interval)\n            # if the current interval is before the new interval, add it to the result list\n            elif interval[0] > newInterval[1]:\n                result.append(newInterval)\n                newInterval = interval\n            # if the current interval overlaps with the new interval, merge them\n            else:\n                newInterval = [min(interval[0], newInterval[0]), max(interval[1], newInterval[1])]\n        \n        # add the final interval to the result list\n        result.append(newInterval)\n        \n        return result"}], "palindrome-partitioning": [{"task_id": "palindrome-partitioning", "completion": "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        def dfs(s, path, res):\n            if not s:\n                res.append(path[:])\n                return\n            for i in range(1, len(s) + 1):\n                if isPalindrome(s[:i]):\n                    dfs(s[i:], path + [s[:i]], res)\n        \n        res = []\n        dfs(s, [], res)\n        return res"}], "smallest-range-covering-elements-from-k-lists": [{"task_id": "smallest-range-covering-elements-from-k-lists", "completion": "class Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # find the min and max of all the numbers in the first list\n        min_num = nums[0][0]\n        max_num = nums[0][0]\n        for i in range(len(nums)):\n            for j in range(len(nums[i])):\n                if nums[i][j] < min_num:\n                    min_num = nums[i][j]\n                if nums[i][j] > max_num:\n                    max_num = nums[i][j]\n        \n        # find the range of the first list\n        range_ = max_num - min_num\n        # find the range of the remaining lists\n        for i in range(1, len(nums)):\n            for j in range(len(nums[i])):\n                if nums[i][j] > max_num:\n                    max_num = nums[i][j]\n                if nums[i][j] < min_num:\n                    min_num = nums[i][j]\n            if max_num - min_num < range_:\n                range_ = max_num - min_num\n        \n        # find the range of the remaining lists\n        for i in range(1, len(nums)):\n            for j in range(len(nums[i])):\n                if nums[i][j] > max_num:\n                    max_num = nums[i][j]\n                if nums[i][j] < min_num:\n                    min_num = nums[i][j]\n            if max_num - min_num < range_:\n                range_ = max_num - min_num\n        \n        return [min_num, max_num]"}], "poor-pigs": [{"task_id": "poor-pigs", "completion": "class Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 1 pig, 2^x pigs, 2^x pigs * minutesToTest = minutesToDie\n        # 2. 1 pig, 2^x pigs, 2^x pigs * minutesToTest = minutesToDie\n        # 3. 1 pig, 2^x pigs, 2^x pigs * minutesToTest = minutesToDie\n        # 4. 1 pig, 2^x pigs, 2^x pigs * minutesToTest = minutesToDie\n        # 5. 1 pig, 2^x pigs, 2^x pigs * minutesToTest = minutesToDie\n        # 6. 1 pig, 2^x pigs, 2^x pigs * minutesToTest = minutesToDie\n        # 7. 1 pig, 2^x pigs, 2^x pigs * minutesToTest = minutesToDie\n        # 8. 1 pig, 2^x pigs, 2^x pigs * minutesToTest = minutesToDie\n        # 9. 1 pig, 2^x pigs, 2^x pigs * minutesToTest = minutesToDie\n        # 10. 1 pig, 2^x pigs, 2^x pigs * minutesToTest = minutesToDie\n        # 11. 1 pig, 2^x pigs, 2^x pigs * minutesToTest = minutesToDie\n        # 12. 1 pig, 2^x pigs, 2^x pigs * minutesToTest = minutesToDie\n        # 13. 1 pig, 2^x pigs, 2^x pigs * minutesToTest = minutesToDie\n        # 14. 1 pig, 2^x pigs, 2^x pigs * minutesToTest = minutesToDie\n        # 15. 1 pig, 2^x pigs, 2^x pigs * minutesToTest = minutesToDie\n        # 16. 1 pig, 2^x pigs, 2^x pigs * minutesToTest = minutesToDie\n        # 17. 1 pig, 2^x pigs, 2^x pigs * minutesToTest = minutesToDie\n        # 18. 1 pig, 2^x pigs, 2^x pigs * minutesToTest = minutesToDie\n        # 19. 1 pig, 2^x pigs, 2^x pigs * minutesToTest = minutesToDie\n        # 20. 1 pig, 2^x pigs, 2^x pigs * minutesToTest = minutesToDie\n        # 21. 1 pig, 2^x pigs, 2^x pigs * minutesToTest = minutesToDie\n        # 22. 1 pig, 2^x pigs, 2^x pigs * minutesToTest = minutesToDie\n        # 23. 1 pig, 2^x pigs, 2^x pigs * minutesToTest = minutesToDie\n        # 24. 1 pig, 2^x pigs, 2^x pigs * minutesToTest = minutesToDie\n        # 25. 1 pig, 2^x pigs, 2^x pigs * minutesToTest = minutesToDie\n        # 26. 1 pig, 2^x pigs, 2^x pigs * minutesToTest = minutesToDie\n        # 27. 1 pig, 2^x pigs, 2^x pigs * minutesToTest = minutesToDie\n        # 28. 1 pig, 2^x pigs, 2^x pigs * minutesToTest = minutesToDie\n        # 29. 1 pig, 2^x pigs, 2^x pigs * minutesToTest = minutesToDie\n        # 30. 1 pig, 2^x pigs, 2^x pigs * minutesToTest = minutesToDie\n        # 31. 1 pig, 2^x pigs, 2^x pigs * minutesToTest = minutesToDie\n        # 32. 1 pig,"}], "swim-in-rising-water": [{"task_id": "swim-in-rising-water", "completion": "class Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        heap = [(grid[0][0], 0, 0)]\n        seen = set([(0, 0)])\n        res = 0\n        \n        while heap:\n            t, i, j = heapq.heappop(heap)\n            res = max(res, t)\n            if i == j == n - 1:\n                return res\n            for ni, nj in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= ni < n and 0 <= nj < n and (ni, nj) not in seen:\n                    heapq.heappush(heap, (grid[ni][nj], ni, nj))\n                    seen.add((ni, nj))\n        return res"}], "unique-paths": [{"task_id": "unique-paths", "completion": "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # create a 2D array with all 0's\n        grid = [[0] * n for _ in range(m)]\n        \n        # fill the first row with 1's\n        for i in range(n):\n            grid[0][i] = 1\n        \n        # fill the first column with 1's\n        for i in range(m):\n            grid[i][0] = 1\n        \n        # fill the rest of the grid\n        for i in range(1, m):\n            for j in range(1, n):\n                grid[i][j] = grid[i - 1][j] + grid[i][j - 1]\n        \n        # return the value at the bottom right corner\n        return grid[m - 1][n - 1]"}], "multiply-strings": [{"task_id": "multiply-strings", "completion": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        if num1 == '0' or num2 == '0':\n            return '0'\n        \n        res = '0'\n        for i in range(len(num1)):\n            carry = 0\n            for j in range(len(num2)):\n                digit1 = int(num1[len(num1) - i - 1])\n                digit2 = int(num2[len(num2) - j - 1])\n                product = digit1 * digit2 + carry + int(res[len(res) - j - 1])\n                carry = product // 10\n                res = str(product % 10) + res\n            if carry > 0:\n                res = str(carry) + res\n        return res"}], "best-time-to-buy-and-sell-stock-iii": [{"task_id": "best-time-to-buy-and-sell-stock-iii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "combination-sum-ii": [{"task_id": "combination-sum-ii", "completion": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        self.dfs(candidates, target, 0, [], res)\n        return res\n    \n    def dfs(self, candidates, target, start, path, res):\n        if target == 0:\n            res.append(path)\n            return\n        for i in range(start, len(candidates)):\n            if i > start and candidates[i] == candidates[i-1]:\n                continue\n            if candidates[i] > target:\n                break\n            self.dfs(candidates, target - candidates[i], i + 1, path + [candidates[i]], res)"}], "detect-capital": [{"task_id": "detect-capital", "completion": "class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if word.isupper() or word.islower() or word[0].isupper() and word[1:].islower():\n            return True\n        else:\n            return False"}], "best-time-to-buy-and-sell-stock": [{"task_id": "best-time-to-buy-and-sell-stock", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Brute force\n        ## Time complexity: O(n^2)\n        ## Space complexity: O(1)\n        ## Runtime: 108 ms, faster than 99.52% of Python online submissions for Best Time to Buy and Sell Stock.\n        ## Memory Usage: 14.2 MB, less than 99.52% of Python online submissions for Best Time to Buy and Sell Stock.\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        ##\n        #"}], "binary-tree-inorder-traversal": [{"task_id": "binary-tree-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = []\n        result = []\n        curr = root\n        \n        while curr is not None or len(stack) > 0:\n            if curr is not None:\n                stack.append(curr)\n                curr = curr.left\n            else:\n                curr = stack.pop()\n                result.append(curr.val)\n                curr = curr.right\n        \n        return result"}], "construct-binary-tree-from-preorder-and-inorder-traversal": [{"task_id": "construct-binary-tree-from-preorder-and-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not preorder:\n            return None\n        \n        root = TreeNode(preorder[0])\n        mid = inorder.index(preorder[0])\n        \n        root.left = self.buildTree(preorder[1:mid+1], inorder[:mid])\n        root.right = self.buildTree(preorder[mid+1:], inorder[mid+1:])\n        \n        return root"}], "remove-invalid-parentheses": [{"task_id": "remove-invalid-parentheses", "completion": "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        \n        def isValid(s):\n            cnt = 0\n            for c in s:\n                if c == '(':\n                    cnt += 1\n                elif c == ')':\n                    if cnt > 0:\n                        cnt -= 1\n                    else:\n                        return False\n            return cnt == 0\n        \n        q = collections.deque([s])\n        seen = {s}\n        while q:\n            s = q.popleft()\n            if isValid(s):\n                return [s]\n            for i in range(len(s)):\n                if s[i] not in '()':\n                    continue\n                t = s[:i] + s[i+1:]\n                if t not in seen:\n                    q.append(t)\n                    seen.add(t)\n        return list(seen)"}], "merge-k-sorted-lists": [{"task_id": "merge-k-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        \n        # 1. Merge 2 lists\n        # 2. Merge 3 lists\n        # 3. Merge 4 lists\n        # 4. Merge 5 lists\n        # 5. Merge 6 lists\n        # 6. Merge 7 lists\n        # 7. Merge 8 lists\n        # 8. Merge 9 lists\n        # 9. Merge 10 lists\n        # 10. Merge 11 lists\n        # 11. Merge 12 lists\n        # 12. Merge 13 lists\n        # 13. Merge 14 lists\n        # 14. Merge 15 lists\n        # 15. Merge 16 lists\n        # 16. Merge 17 lists\n        # 17. Merge 18 lists\n        # 18. Merge 19 lists\n        # 19. Merge 20 lists\n        # 20. Merge 21 lists\n        # 21. Merge 22 lists\n        # 22. Merge 23 lists\n        # 23. Merge 24 lists\n        # 24. Merge 25 lists\n        # 25. Merge 26 lists\n        # 26. Merge 27 lists\n        # 27. Merge 28 lists\n        # 28. Merge 29 lists\n        # 29. Merge 30 lists\n        # 30. Merge 31 lists\n        # 31. Merge 32 lists\n        # 32. Merge 33 lists\n        # 33. Merge 34 lists\n        # 34. Merge 35 lists\n        # 35. Merge 36 lists\n        # 36. Merge 37 lists\n        # 37. Merge 38 lists\n        # 38. Merge 39 lists\n        # 39. Merge 40 lists\n        # 40. Merge 41 lists\n        # 41. Merge 42 lists\n        # 42. Merge 43 lists\n        # 43. Merge 44 lists\n        # 44. Merge 45 lists\n        # 45. Merge 46 lists\n        # 46. Merge 47 lists\n        # 47. Merge 48 lists\n        # 48. Merge 49 lists\n        # 49. Merge 50 lists\n        # 50. Merge 51 lists\n        # 51. Merge 52 lists\n        # 52. Merge 53 lists\n        # 53. Merge 54 lists\n        # 54. Merge 55 lists\n        # 55. Merge 56 lists\n        # 56. Merge 57 lists\n        # 57. Merge 58 lists\n        # 58. Merge 59 lists\n        # 59. Merge 60 lists\n        # 60. Merge 61 lists\n        # 61. Merge 62 lists\n        # 62. Merge 63 lists\n        # 63. Merge 64 lists\n        # 64. Merge 65 lists\n        # 65. Merge 66 lists\n        # 66. Merge 67 lists\n        # 67. Merge 68 lists\n        # 68. Merge 69 lists\n        # 69. Merge 70 lists\n        # 70. Merge 71 lists\n        # 71. Merge 72 lists\n        # 72. Merge 73 lists\n        # 73. Merge 74 lists\n        # 74. Merge 75 lists\n        # 75. Merge 76 lists\n        # 76. Merge 77 lists\n        # 77. Merge 78 lists\n        # 78. Merge 79 lists\n        # 79. Merge 80 lists\n        # 80. Merge 81 lists"}], "palindrome-partitioning-ii": [{"task_id": "palindrome-partitioning-ii", "completion": "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "preimage-size-of-factorial-zeroes-function": [{"task_id": "preimage-size-of-factorial-zeroes-function", "completion": "class Solution(object):\n    def preimageSizeFZF(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 10^n * f(n) = k\n        # 2. f(n) = k / 10^n\n        # 3. f(n) = k / 5^n\n        # 4. f(n) = k / 2^n\n        # 5. f(n) = k / n\n        # 6. f(n) = k\n        # 7. f(n) = k / n + 1\n        # 8. f(n) = k / n + 2\n        # 9. f(n) = k / n + 3\n        # 10. f(n) = k / n + 4\n        # 11. f(n) = k / n + 5\n        # 12. f(n) = k / n + 6\n        # 13. f(n) = k / n + 7\n        # 14. f(n) = k / n + 8\n        # 15. f(n) = k / n + 9\n        # 16. f(n) = k / n + 10\n        # 17. f(n) = k / n + 11\n        # 18. f(n) = k / n + 12\n        # 19. f(n) = k / n + 13\n        # 20. f(n) = k / n + 14\n        # 21. f(n) = k / n + 15\n        # 22. f(n) = k / n + 16\n        # 23. f(n) = k / n + 17\n        # 24. f(n) = k / n + 18\n        # 25. f(n) = k / n + 19\n        # 26. f(n) = k / n + 20\n        # 27. f(n) = k / n + 21\n        # 28. f(n) = k / n + 22\n        # 29. f(n) = k / n + 23\n        # 30. f(n) = k / n + 24\n        # 31. f(n) = k / n + 25\n        # 32. f(n) = k / n + 26\n        # 33. f(n) = k / n + 27\n        # 34. f(n) = k / n + 28\n        # 35. f(n) = k / n + 29\n        # 36. f(n) = k / n + 30\n        # 37. f(n) = k / n + 31\n        # 38. f(n) = k / n + 32\n        # 39. f(n) = k / n + 33\n        # 40. f(n) = k / n + 34\n        # 41. f(n) = k / n + 35\n        # 42. f(n) = k / n + 36\n        # 43. f(n) = k / n + 37\n        # 44. f(n) = k / n + 38\n        # 45. f(n) = k / n + 39\n        # 46. f(n) = k / n + 40\n        # 47. f(n) = k / n + 41\n        # 48. f(n) = k / n + 42\n        # 49. f(n) = k / n + 43\n        # 50. f(n) = k / n + 44\n        # 51. f(n) = k / n + 45\n        # 52. f(n) = k / n + 46\n        # 53. f(n) = k / n + 47\n        # 54. f(n) = k / n + 48\n        # 55. f(n) = k / n + 49\n        # 56. f(n) = k / n + 50\n        # 57. f(n) = k / n + 51\n        # 58. f(n) = k / n + 52\n        # 5"}], "palindrome-pairs": [{"task_id": "palindrome-pairs", "completion": "class Solution(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # create a dict to store the index of each word\n        word_dict = {word: i for i, word in enumerate(words)}\n        \n        # create a list to store the result\n        result = []\n        \n        # iterate over the words\n        for i, word in enumerate(words):\n            # reverse the word\n            rev_word = word[::-1]\n            \n            # check if the reversed word is a palindrome\n            if rev_word in word_dict and i != word_dict[rev_word]:\n                result.append([i, word_dict[rev_word]])\n                \n            # check if the word is a palindrome\n            for j in range(len(word) + 1):\n                # check if the substring is a palindrome\n                if word[:j] in word_dict and rev_word[j:] in word_dict:\n                    result.append([i, word_dict[rev_word[j:]]])\n                    \n        return result"}], "convert-sorted-array-to-binary-search-tree": [{"task_id": "convert-sorted-array-to-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        def helper(left, right):\n            if left > right:\n                return None\n            \n            mid = (left + right) // 2\n            root = TreeNode(nums[mid])\n            root.left = helper(left, mid - 1)\n            root.right = helper(mid + 1, right)\n            return root\n        \n        return helper(0, len(nums) - 1)"}], "contain-virus": [{"task_id": "contain-virus", "completion": "class Solution(object):\n    def containVirus(self, isInfected):\n        \"\"\"\n        :type isInfected: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def spread(isInfected):\n            m, n = len(isInfected), len(isInfected[0])\n            res = 0\n            while True:\n                infected = set()\n                for i in range(m):\n                    for j in range(n):\n                        if isInfected[i][j] == 1:\n                            infected.add((i, j))\n                if not infected:\n                    return res\n                res += 1\n                for i, j in infected:\n                    for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        ni, nj = i + di, j + dj\n                        if 0 <= ni < m and 0 <= nj < n and isInfected[ni][nj] == 0:\n                            isInfected[ni][nj] = 2\n                            infected.add((ni, nj))\n            return res\n        \n        def build(isInfected):\n            m, n = len(isInfected), len(isInfected[0])\n            res = 0\n            while True:\n                infected = set()\n                for i in range(m):\n                    for j in range(n):\n                        if isInfected[i][j] == 1:\n                            infected.add((i, j))\n                if not infected:\n                    return res\n                res += 1\n                for i, j in infected:\n                    for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                        ni, nj = i + di, j + dj\n                        if 0 <= ni < m and 0 <= nj < n and isInfected[ni][nj] == 0:\n                            isInfected[ni][nj] = 2\n                            infected.add((ni, nj))\n            return res\n        \n        return spread(isInfected) + build(isInfected)"}], "longest-increasing-path-in-a-matrix": [{"task_id": "longest-increasing-path-in-a-matrix", "completion": "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        dp = [[0] * n for _ in range(m)]\n        max_len = 0\n        \n        for i in range(m):\n            for j in range(n):\n                max_len = max(max_len, self.dfs(matrix, dp, i, j))\n        \n        return max_len\n    \n    def dfs(self, matrix, dp, i, j):\n        if dp[i][j]:\n            return dp[i][j]\n        \n        m, n = len(matrix), len(matrix[0])\n        max_len = 1\n        \n        for x, y in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n            if 0 <= x < m and 0 <= y < n and matrix[x][y] > matrix[i][j]:\n                max_len = max(max_len, 1 + self.dfs(matrix, dp, x, y))\n        \n        dp[i][j] = max_len\n        return max_len"}], "number-of-digit-one": [{"task_id": "number-of-digit-one", "completion": "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}], "word-break-ii": [{"task_id": "word-break-ii", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        dp = [False] * (len(s) + 1)\n        dp[0] = True\n        \n        for i in range(len(s)):\n            for j in range(i + 1):\n                if dp[j] and s[j:i + 1] in wordDict:\n                    dp[i + 1] = True\n                    break\n        \n        # If dp[len(s)] is True, then we have a valid word break.\n        # Construct the result list and return it.\n        if dp[len(s)]:\n            result = []\n            i = len(s)\n            while i > 0:\n                for j in range(i):\n                    if dp[j] and s[j:i] in wordDict:\n                        if j == 0:\n                            result.append(s[j:i])\n                        else:\n                            result.append(s[j:i] + \" \" + result[-1])\n                i -= 1\n            return result[::-1]\n        else:\n            return []"}], "binary-tree-zigzag-level-order-traversal": [{"task_id": "binary-tree-zigzag-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def zigzagLevelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        result = []\n        level = 0\n        \n        while queue:\n            level_list = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                level_list.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            if level % 2 == 1:\n                level_list.reverse()\n            result.append(level_list)\n            level += 1\n        \n        return result"}], "binary-watch": [{"task_id": "binary-watch", "completion": "class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        \"\"\"\n        :type turnedOn: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def get_time(h, m):\n            if h > 11 or m > 59:\n                return\n            return '%d:%02d' % (h, m)\n        \n        def get_times(h, m):\n            if h > 11 or m > 59:\n                return\n            return [get_time(h, m), get_time(h + 1, m - 1), get_time(h + 2, m - 2), get_time(h + 3, m - 3), get_time(h + 4, m - 4), get_time(h + 5, m - 5), get_time(h + 6, m - 6), get_time(h + 7, m - 7), get_time(h + 8, m - 8), get_time(h + 9, m - 9)]\n        \n        res = []\n        for h in range(12):\n            for m in range(60):\n                if (bin(h) + bin(m)).count('1') == turnedOn:\n                    res.extend(get_times(h, m))\n        return res"}], "pascals-triangle": [{"task_id": "pascals-triangle", "completion": "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if numRows == 0:\n            return []\n        \n        if numRows == 1:\n            return [[1]]\n        \n        if numRows == 2:\n            return [[1], [1,1]]\n        \n        res = [[1], [1,1]]\n        \n        for i in range(2, numRows):\n            row = [1]\n            for j in range(1, i):\n                row.append(res[i-1][j-1] + res[i-1][j])\n            row.append(1)\n            res.append(row)\n        \n        return res"}], "power-of-three": [{"task_id": "power-of-three", "completion": "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 3 == 0:\n            n /= 3\n        \n        return n == 1"}], "binary-tree-maximum-path-sum": [{"task_id": "binary-tree-maximum-path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def max_gain(node):\n            if not node:\n                return 0\n            \n            # Recursively compute the maximum gain if we include this\n            # node or any of its children as part of a longer path\n            left_gain = max(max_gain(node.left), 0)\n            right_gain = max(max_gain(node.right), 0)\n            \n            # The maximum sum on a path from this node will be equal to\n            # its value plus the maximum gain from its left child or\n            # right child\n            new_path = node.val + left_gain + right_gain\n            \n            # Update max_sum if the total path sum has become\n            # greater\n            self.max_sum = max(self.max_sum, new_path)\n            \n            # For a particular node, we want to find the maximum\n            # sum path that includes at-most one child of the current\n            # node\n            return node.val + max(left_gain, right_gain)\n        \n        self.max_sum = float('-inf')\n        max_gain(root)\n        return self.max_sum"}], "trapping-rain-water-ii": [{"task_id": "trapping-rain-water-ii", "completion": "class Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not heightMap:\n            return 0\n        \n        m, n = len(heightMap), len(heightMap[0])\n        heap = [(heightMap[i][0], i, 0) for i in range(m)] + [(heightMap[i][n-1], i, n-1) for i in range(m)]\n        heapq.heapify(heap)\n        seen = set()\n        ans = 0\n        while heap:\n            h, i, j = heapq.heappop(heap)\n            if (i, j) not in seen:\n                ans += h - heightMap[i][j]\n                seen.add((i, j))\n                for ni, nj in ((i-1, j), (i+1, j), (i, j-1), (i, j+1)):\n                    if 0 <= ni < m and 0 <= nj < n and (ni, nj) not in seen:\n                        heapq.heappush(heap, (max(heightMap[ni][nj], h), ni, nj))\n        return ans"}], "valid-palindrome": [{"task_id": "valid-palindrome", "completion": "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        s = s.lower()\n        s = re.sub(r'[^a-z0-9]', '', s)\n        return s == s[::-1]"}], "sliding-window-median": [{"task_id": "sliding-window-median", "completion": "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        \n        # Initialize the result list\n        result = []\n        \n        # Initialize the window\n        window = nums[:k]\n        \n        # Initialize the median\n        median = self.find_median(window)\n        \n        # Add the median to the result list\n        result.append(median)\n        \n        # Iterate over the remaining elements of the array\n        for i in range(k, len(nums)):\n            # Remove the leftmost element from the window\n            window.pop(0)\n            \n            # Add the new element to the window\n            window.append(nums[i])\n            \n            # Find the median\n            median = self.find_median(window)\n            \n            # Add the median to the result list\n            result.append(median)\n        \n        # Return the result list\n        return result\n    \n    def find_median(self, window):\n        # Sort the window\n        window.sort()\n        \n        # If the length of the window is odd, return the middle element\n        if len(window) % 2 == 1:\n            return window[len(window) // 2]\n        \n        # Otherwise, return the average of the two middle elements\n        return (window[len(window) // 2 - 1] + window[len(window) // 2]) / 2.0"}], "rotate-list": [{"task_id": "rotate-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        length = 0\n        curr = head\n        while curr:\n            length += 1\n            curr = curr.next\n        \n        k = k % length\n        if k == 0:\n            return head\n        \n        curr = head\n        for i in range(length - k - 1):\n            curr = curr.next\n        \n        new_head = curr.next\n        curr.next = None\n        \n        curr = new_head\n        while curr.next:\n            curr = curr.next\n        \n        curr.next = head\n        \n        return new_head"}], "ugly-number": [{"task_id": "ugly-number", "completion": "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 2 == 0:\n            n = n / 2\n        while n % 3 == 0:\n            n = n / 3\n        while n % 5 == 0:\n            n = n / 5\n        \n        return n == 1"}], "falling-squares": [{"task_id": "falling-squares", "completion": "class Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "sum-of-left-leaves": [{"task_id": "sum-of-left-leaves", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        if root.left is None:\n            return self.sumOfLeftLeaves(root.right)\n        \n        if root.left.left is None and root.left.right is None:\n            return root.left.val + self.sumOfLeftLeaves(root.right)\n        \n        return self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right)"}], "max-sum-of-rectangle-no-larger-than-k": [{"task_id": "max-sum-of-rectangle-no-larger-than-k", "completion": "class Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        m, n = len(matrix), len(matrix[0])\n        res = float('-inf')\n        for l in range(n):\n            sums = [0] * m\n            for r in range(l, n):\n                for i in range(m):\n                    sums[i] += matrix[i][r]\n                res = max(res, self.maxSubarray(sums, k))\n                if res == k:\n                    return k\n        return res\n    \n    def maxSubarray(self, sums, k):\n        s = 0\n        d = {0: -1}\n        res = 0\n        for i, v in enumerate(sums):\n            s += v\n            if s - k in d:\n                res = max(res, s - k)\n            if s not in d:\n                d[s] = i\n            res = max(res, s - d[s - k])\n        return res"}], "divide-two-integers": [{"task_id": "divide-two-integers", "completion": "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        \n        if dividend == 0:\n            return 0\n        \n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n        \n        if dividend > 0 and divisor > 0:\n            return int(dividend/divisor)\n        \n        if dividend > 0 and divisor < 0:\n            return -int(abs(dividend)/abs(divisor))\n        \n        if dividend < 0 and divisor > 0:\n            return -int(abs(dividend)/abs(divisor))\n        \n        if dividend < 0 and divisor < 0:\n            return int(abs(dividend)/abs(divisor))"}], "surrounded-regions": [{"task_id": "surrounded-regions", "completion": "class Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def dfs(i,j):\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != 'O':\n                return\n            board[i][j] = 'T'\n            dfs(i+1,j)\n            dfs(i-1,j)\n            dfs(i,j+1)\n            dfs(i,j-1)\n            \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if i == 0 or i == len(board)-1 or j == 0 or j == len(board[0])-1:\n                    dfs(i,j)\n                    \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] == 'O':\n                    board[i][j] = 'X'\n                if board[i][j] == 'T':\n                    board[i][j] = 'O'\n                    \n        return board"}], "two-sum": [{"task_id": "two-sum", "completion": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # create a dictionary\n        # iterate through the list\n        # check if the complement is in the dictionary\n        # if it is, return the index of the complement and the index of the current number\n        # if it is not, add the current number to the dictionary\n        # if the complement is not in the dictionary, add the current number to the dictionary\n        # return the index of the complement and the index of the current number\n        \n        # create a dictionary\n        # iterate through the list\n        # check if the complement is in the dictionary\n        # if it is, return the index of the complement and the index of the current number\n        # if it is not, add the current number to the dictionary\n        # if the complement is not in the dictionary, add the current number to the dictionary\n        # return the index of the complement and the index of the current number\n        \n        # create a dictionary\n        # iterate through the list\n        # check if the complement is in the dictionary\n        # if it is, return the index of the complement and the index of the current number\n        # if it is not, add the current number to the dictionary\n        # if the complement is not in the dictionary, add the current number to the dictionary\n        # return the index of the complement and the index of the current number\n        \n        # create a dictionary\n        # iterate through the list\n        # check if the complement is in the dictionary\n        # if it is, return the index of the complement and the index of the current number\n        # if it is not, add the current number to the dictionary\n        # if the complement is not in the dictionary, add the current number to the dictionary\n        # return the index of the complement and the index of the current number\n        \n        # create a dictionary\n        # iterate through the list\n        # check if the complement is in the dictionary\n        # if it is, return the index of the complement and the index of the current number\n        # if it is not, add the current number to the dictionary\n        # if the complement is not in the dictionary, add the current number to the dictionary\n        # return the index of the complement and the index of the current number\n        \n        # create a dictionary\n        # iterate through the list\n        # check if the complement is in the dictionary\n        # if it is, return the index of the complement and the index of the current number\n        # if it is not, add the current number to the dictionary\n        # if the complement is not in the dictionary, add the current number to the dictionary\n        # return the index of the complement and the index of the current number\n        \n        # create a dictionary\n        # iterate through the list\n        # check if the complement is in the dictionary\n        # if it is, return the index of the complement and the index of the current number\n        # if it is not, add the current number to the dictionary\n        # if the complement is not in the dictionary, add the current number to the dictionary\n        # return the index of the complement and the index of the current number\n        \n        # create a dictionary\n        # iterate through the list\n        # check if the complement is in the dictionary\n        # if it is, return the index of the complement and the index of the current number\n        # if it is not, add the current number to the dictionary\n        # if the complement is not in the dictionary, add the current number to the dictionary\n        # return the index of the complement and the index of the current number\n        \n        # create a dictionary\n        # iterate through the list\n        # check if the complement is in the dictionary\n        # if it is, return the index of the complement and the index of the current number\n        # if it is not, add the current number to the dictionary\n        # if the complement is not in the dictionary, add the current number to the dictionary\n        # return the index of the complement and the index of the current number\n        \n        # create a dictionary\n        # iterate through the list\n        # check if the complement is in the dictionary\n        # if it is, return the index of the complement and the index of the current number\n        # if it is not, add the current number to the dictionary\n        # if the complement is not in the dictionary, add the current number to the dictionary\n        # return the index of the complement and the index of the current number\n        \n        # create a dictionary\n        # iterate through the list\n        # check if the complement is in the dictionary\n        # if it is, return the index of the complement and the index of the current number\n        # if it is not, add the"}], "24-game": [{"task_id": "24-game", "completion": "class Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        def backtrack(cards, target):\n            if len(cards) == 1:\n                return abs(cards[0] - target) < 0.01\n            \n            for i in range(len(cards)):\n                for j in range(i + 1, len(cards)):\n                    a, b = cards[i], cards[j]\n                    for op in ['+', '-', '*', '/']:\n                        if op == '+':\n                            new_a, new_b = a + b, a - b\n                        elif op == '-':\n                            new_a, new_b = a - b, b - a\n                        elif op == '*':\n                            new_a, new_b = a * b, a / b\n                        else:\n                            new_a, new_b = b / a, a / b\n                        if backtrack([new_a, new_b] + cards[0:i] + cards[i + 1:], target):\n                            return True\n            return False\n        \n        return backtrack(cards, 24)"}], "wildcard-matching": [{"task_id": "wildcard-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        if not p:\n            return not s\n        \n        if not s:\n            return False\n        \n        if p[0] != '*':\n            return s[0] == p[0] and self.isMatch(s[1:], p[1:])\n        \n        while s and (s[0] == p[0] or p[0] == '?'):\n            if self.isMatch(s, p[1:]):\n                return True\n            s = s[1:]\n        \n        return self.isMatch(s, p[1:])"}], "majority-element": [{"task_id": "majority-element", "completion": "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Boyer-Moore Voting Algorithm\n        # https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\n        # https://leetcode.com/problems/majority-element/discuss/144598/Python-O(n)-time-O(1)-space-with-explanation\n        # https://leetcode.com/problems/majority-element/discuss/144598/Python-O(n)-time-O(1)-space-with-explanation\n        # https://leetcode.com/problems/majority-element/discuss/144598/Python-O(n)-time-O(1)-space-with-explanation\n        # https://leetcode.com/problems/majority-element/discuss/144598/Python-O(n)-time-O(1)-space-with-explanation\n        # https://leetcode.com/problems/majority-element/discuss/144598/Python-O(n)-time-O(1)-space-with-explanation\n        # https://leetcode.com/problems/majority-element/discuss/144598/Python-O(n)-time-O(1)-space-with-explanation\n        # https://leetcode.com/problems/majority-element/discuss/144598/Python-O(n)-time-O(1)-space-with-explanation\n        # https://leetcode.com/problems/majority-element/discuss/144598/Python-O(n)-time-O(1)-space-with-explanation\n        # https://leetcode.com/problems/majority-element/discuss/144598/Python-O(n)-time-O(1)-space-with-explanation\n        # https://leetcode.com/problems/majority-element/discuss/144598/Python-O(n)-time-O(1)-space-with-explanation\n        # https://leetcode.com/problems/majority-element/discuss/144598/Python-O(n)-time-O(1)-space-with-explanation\n        # https://leetcode.com/problems/majority-element/discuss/144598/Python-O(n)-time-O(1)-space-with-explanation\n        # https://leetcode.com/problems/majority-element/discuss/144598/Python-O(n)-time-O(1)-space-with-explanation\n        # https://leetcode.com/problems/majority-element/discuss/144598/Python-O(n)-time-O(1)-space-with-explanation\n        # https://leetcode.com/problems/majority-element/discuss/144598/Python-O(n)-time-O(1)-space-with-explanation\n        # https://leetcode.com/problems/majority-element/discuss/144598/Python-O(n)-time-O(1)-space-with-explanation\n        # https://leetcode.com/problems/majority-element/discuss/144598/Python-O(n)-time-O(1)-space-with-explanation\n        # https://leetcode.com/problems/majority-element/discuss/144598/Python-O(n)-time-O(1)-space-with-explanation\n        # https://leetcode.com/problems/majority-element/discuss/144598/Python-O(n)-time-O(1)-space-with-explanation\n        # https://leetcode.com/problems/majority-element/discuss/144598/Python-O(n)-time-O(1)-space-with-explanation\n        # https://leetcode.com/problems/majority-element"}], "reconstruct-itinerary": [{"task_id": "reconstruct-itinerary", "completion": "class Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        \n        # build a graph\n        graph = collections.defaultdict(list)\n        for from_city, to_city in tickets:\n            graph[from_city].append(to_city)\n            \n        # sort the graph by alphabetical order\n        for city in graph:\n            graph[city].sort(reverse=True)\n            \n        # dfs\n        res = []\n        def dfs(city):\n            # if there is no more city to visit, add the current city to the result\n            if len(graph[city]) == 0:\n                res.append(city)\n                return\n            # otherwise, visit all the next city\n            for next_city in graph[city]:\n                graph[city].remove(next_city)\n                dfs(next_city)\n                \n        dfs(\"JFK\")\n        return res[::-1]"}], "4sum": [{"task_id": "4sum", "completion": "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-3):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            for j in range(i+1, len(nums)-2):\n                if j > i+1 and nums[j] == nums[j-1]:\n                    continue\n                l, r = j+1, len(nums)-1\n                while l < r:\n                    s = nums[i] + nums[j] + nums[l] + nums[r]\n                    if s == target:\n                        res.append([nums[i], nums[j], nums[l], nums[r]])\n                        l += 1\n                        r -= 1\n                        while l < r and nums[l] == nums[l-1]:\n                            l += 1\n                        while l < r and nums[r] == nums[r+1]:\n                            r -= 1\n                    elif s < target:\n                        l += 1\n                    else:\n                        r -= 1\n        return res"}], "the-skyline-problem": [{"task_id": "the-skyline-problem", "completion": "class Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # sort the buildings by left edge\n        buildings.sort(key=lambda x: x[0])\n        \n        # initialize the result list\n        result = [[0, 0]]\n        \n        # initialize the current height\n        curr_height = 0\n        \n        # iterate over the buildings\n        for building in buildings:\n            # if the building is the first building in the list\n            if not result or result[-1][1] < building[0]:\n                # add the building to the result list\n                result.append(building)\n            # if the building is the last building in the list\n            elif result[-1][1] == building[0]:\n                # update the current height\n                curr_height = max(curr_height, building[2])\n                # update the result list\n                result[-1][1] = curr_height\n            # if the building is not the first building in the list\n            else:\n                # add the building to the result list\n                result.append(building)\n                # update the current height\n                curr_height = max(curr_height, building[2])\n                # update the result list\n                result[-1][1] = curr_height\n        \n        # initialize the result list\n        result = [[0, 0]]\n        \n        # iterate over the buildings\n        for building in buildings:\n            # if the building is the first building in the list\n            if not result or result[-1][1] < building[0]:\n                # add the building to the result list\n                result.append(building)\n            # if the building is the last building in the list\n            elif result[-1][1] == building[0]:\n                # update the current height\n                curr_height = max(curr_height, building[2])\n                # update the result list\n                result[-1][1] = curr_height\n            # if the building is not the first building in the list\n            else:\n                # add the building to the result list\n                result.append(building)\n                # update the current height\n                curr_height = max(curr_height, building[2])\n                # update the result list\n                result[-1][1] = curr_height\n        \n        # return the result list\n        return result[1:]"}], "reverse-string": [{"task_id": "reverse-string", "completion": "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        \n        s.reverse()"}], "reverse-linked-list": [{"task_id": "reverse-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        prev = None\n        curr = head\n        \n        while curr:\n            next = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next\n            \n        return prev"}], "triangle": [{"task_id": "triangle", "completion": "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        for i in range(1, len(triangle)):\n            for j in range(len(triangle[i])):\n                if j == 0:\n                    triangle[i][j] += triangle[i - 1][j]\n                elif j == len(triangle[i]) - 1:\n                    triangle[i][j] += triangle[i - 1][j - 1]\n                else:\n                    triangle[i][j] += min(triangle[i - 1][j], triangle[i - 1][j - 1])\n        return min(triangle[-1])"}], "integer-to-english-words": [{"task_id": "integer-to-english-words", "completion": "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"Zero\"\n        \n        def helper(num):\n            if num == 0:\n                return \"\"\n            if num < 20:\n                return ones[num]\n            if num < 100:\n                return tens[num//10] + helper(num%10)\n            if num < 1000:\n                return ones[num//100] + \" Hundred\" + helper(num%100)\n            if num < 1000000:\n                return helper(num//1000) + \" Thousand\" + helper(num%1000)\n            if num < 1000000000:\n                return helper(num//1000000) + \" Million\" + helper(num%1000000)\n            return helper(num//1000000000) + \" Billion\" + helper(num%1000000000)\n        \n        ones = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n        tens = [\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n        return helper(num)"}], "k-inverse-pairs-array": [{"task_id": "k-inverse-pairs-array", "completion": "class Solution(object):\n    def kInversePairs(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] - dp[i-2][j-1]\n        # dp[i][j] = dp[i-1][j] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] - dp[i-1][j-i] + dp[i-1][j-i-1]\n        # dp[i][j] = dp[i-1][j] - dp[i-1][j-i] + dp[i-1][j-i-1] - dp[i-1][j-i-2] + ... + dp[i-1][j-i-i]\n        # dp[i][j] = dp[i-1][j] - dp[i-1][j-i] + dp[i-1][j-i-1] - dp[i-1][j-i-2] + ... + dp[i-1][j-i-i] + dp[i-1][j-i-i-1] - dp[i-1][j-i-i-2] + ... + dp[i-1][j-i-i-i]\n        # dp[i][j] = dp[i-1][j] - dp[i-1][j-i] + dp[i-1][j-i-1] - dp[i-1][j-i-2] + ... + dp[i-1][j-i-i] + dp[i-1][j-i-i-1] - dp[i-1][j-i-i-2] + ... + dp[i-1][j-i-i-i] + dp[i-1][j-i-i-i-1] - dp[i-1][j-i-i-i-2] + ... + dp[i-1][j-i-i-i-i]\n        # dp[i][j] = dp[i-1][j] - dp[i-1][j-i] + dp[i-1][j-i-1] - dp[i-1][j-i-2] + ... + dp[i-1][j-i-i] + dp[i-1][j-i-i-1] - dp[i-1][j-i-i-2] + ... + dp[i-1][j-i-i-i] + dp[i-1][j-i-i-i-1] - dp[i-1][j-i-i-i-2] + ... + dp[i-1][j-i-i-i-i] + dp[i-1][j-i-i-i-i-1] - dp[i-1][j-i-i-i-i-2] + ... + dp[i-1][j-i-i-i-i-i]\n        # dp[i][j] = dp[i-1][j] - dp[i-1][j-i] + dp[i-1][j-i-1] - dp[i-1][j-i-2] + ... + dp[i-1][j-i-i] + dp[i-1][j-i-i-1] - dp[i-1][j-i-i-2] + ... + dp[i-1][j-i-i-i] + dp[i-1][j-i-i-i-1] - dp[i-1][j-i-i-i-2] + ... + dp[i-1][j-i-i-i-i] + dp[i-1][j-i-i-i-i-1] - dp[i-1][j-i-i-i"}], "swap-nodes-in-pairs": [{"task_id": "swap-nodes-in-pairs", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        curr = dummy\n        \n        while curr.next and curr.next.next:\n            first = curr.next\n            second = curr.next.next\n            \n            curr.next = second\n            first.next = second.next\n            second.next = first\n            \n            curr = first\n            \n        return dummy.next"}], "path-sum": [{"task_id": "path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def hasPathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: bool\n        \"\"\"\n        \n        if root is None:\n            return False\n        \n        if root.left is None and root.right is None:\n            return targetSum == root.val\n        \n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)"}], "partition-list": [{"task_id": "partition-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def partition(self, head, x):\n        \"\"\"\n        :type head: ListNode\n        :type x: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # create two dummy nodes\n        dummy1 = ListNode(0)\n        dummy2 = ListNode(0)\n        \n        # create two pointers\n        p1 = dummy1\n        p2 = dummy2\n        \n        # traverse the list\n        while head:\n            # if the current node is less than x, add it to the first list\n            if head.val < x:\n                p1.next = head\n                p1 = p1.next\n            # if the current node is greater than or equal to x, add it to the second list\n            else:\n                p2.next = head\n                p2 = p2.next\n            # move to the next node\n            head = head.next\n        \n        # connect the two lists\n        p1.next = dummy2.next\n        p2.next = None\n        \n        # return the first list\n        return dummy1.next"}], "redundant-connection-ii": [{"task_id": "redundant-connection-ii", "completion": "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # find the node with two parents\n        parent = {}\n        child = {}\n        for u, v in edges:\n            if u in parent:\n                return [parent[u], u]\n            if v in child:\n                return [v, child[v]]\n            parent[u] = v\n            child[v] = u\n        \n        # find the node with only one parent\n        for u, v in edges:\n            if u in parent and parent[u] == v:\n                return [u, v]\n        \n        return []"}], "permutations-ii": [{"task_id": "permutations-ii", "completion": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(first = 0):\n            if first == n:\n                res.append(nums[:])\n            else:\n                for i in range(first, n):\n                    if nums[i] not in used:\n                        used.add(nums[i])\n                        nums[first], nums[i] = nums[i], nums[first]\n                        backtrack(first + 1)\n                        nums[first], nums[i] = nums[i], nums[first]\n        \n        n = len(nums)\n        res = []\n        nums.sort()\n        used = set()\n        backtrack()\n        return res"}], "add-digits": [{"task_id": "add-digits", "completion": "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        if num == 0:\n            return 0\n        if num % 9 == 0:\n            return 9\n        else:\n            return num % 9"}], "single-number": [{"task_id": "single-number", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use XOR\n        ## 4. use bit manipulation\n        ## 5. use math\n        ## 6. use sort\n        ## 7. use math\n        ## 8. use math\n        ## 9. use math\n        ## 10. use math\n        ## 11. use math\n        ## 12. use math\n        ## 13. use math\n        ## 14. use math\n        ## 15. use math\n        ## 16. use math\n        ## 17. use math\n        ## 18. use math\n        ## 19. use math\n        ## 20. use math\n        ## 21. use math\n        ## 22. use math\n        ## 23. use math\n        ## 24. use math\n        ## 25. use math\n        ## 26. use math\n        ## 27. use math\n        ## 28. use math\n        ## 29. use math\n        ## 30. use math\n        ## 31. use math\n        ## 32. use math\n        ## 33. use math\n        ## 34. use math\n        ## 35. use math\n        ## 36. use math\n        ## 37. use math\n        ## 38. use math\n        ## 39. use math\n        ## 40. use math\n        ## 41. use math\n        ## 42. use math\n        ## 43. use math\n        ## 44. use math\n        ## 45. use math\n        ## 46. use math\n        ## 47. use math\n        ## 48. use math\n        ## 49. use math\n        ## 50. use math\n        ## 51. use math\n        ## 52. use math\n        ## 53. use math\n        ## 54. use math\n        ## 55. use math\n        ## 56. use math\n        ## 57. use math\n        ## 58. use math\n        ## 59. use math\n        ## 60. use math\n        ## 61. use math\n        ## 62. use math\n        ## 63. use math\n        ## 64. use math\n        ## 65. use math\n        ## 66. use math\n        ## 67. use math\n        ## 68. use math\n        ## 69. use math\n        ## 70. use math\n        ## 71. use math\n        ## 72. use math\n        ## 73. use math\n        ## 74. use math\n        ## 75. use math\n        ## 76. use math\n        ## 77. use math\n        ## 78. use math\n        ## 79. use math\n        ## 80. use math\n        ## 81. use math\n        ## 82. use math\n        ## 83. use math\n        ## 84. use math\n        ## 85. use math\n        ## 86. use math\n        ## 87. use math\n        ## 88. use math\n        ## 89. use math\n        ## 90. use math\n        ## 91. use math\n        ## 92. use math\n        ## 93. use math\n        ## 94. use math\n        ## 95. use math\n        ## 96. use math\n        ## 97. use math\n        ## 98. use math\n        ## 99. use math\n        ## 100. use math\n        ## 101. use math\n        ## 102. use math\n        ## 103"}], "length-of-last-word": [{"task_id": "length-of-last-word", "completion": "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Split the string into words\n        words = s.split()\n        \n        # Return the length of the last word\n        return len(words[-1])"}], "cherry-pickup": [{"task_id": "cherry-pickup", "completion": "class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        dp = [[0] * n for _ in range(n)]\n        dp[0][0] = grid[0][0]\n        \n        for i in range(1, n):\n            for j in range(max(i - 1, 0), min(i + 2, n)):\n                dp[i][j] = dp[i - 1][j - 1] + grid[i][j]\n                if j > 0:\n                    dp[i][j] = max(dp[i][j], dp[i - 1][j - 1] + grid[i][j])\n                if j < n - 1:\n                    dp[i][j] = max(dp[i][j], dp[i - 1][j] + grid[i][j])\n        \n        return max(dp[-1])"}], "student-attendance-record-ii": [{"task_id": "student-attendance-record-ii", "completion": "class Solution(object):\n    def checkRecord(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}], "happy-number": [{"task_id": "happy-number", "completion": "class Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        def get_next(n):\n            total_sum = 0\n            while n > 0:\n                n, digit = divmod(n, 10)\n                total_sum += digit ** 2\n            return total_sum\n        \n        slow = n\n        fast = get_next(n)\n        while fast != 1 and slow != fast:\n            slow = get_next(slow)\n            fast = get_next(get_next(fast))\n        return fast == 1"}], "search-insert-position": [{"task_id": "search-insert-position", "completion": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # binary search\n        # return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n        # O(log n) runtime complexity\n        \n        # binary search\n        # return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n        # O(log n) runtime complexity\n        \n        # binary search\n        # return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n        # O(log n) runtime complexity\n        \n        # binary search\n        # return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n        # O(log n) runtime complexity\n        \n        # binary search\n        # return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n        # O(log n) runtime complexity\n        \n        # binary search\n        # return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n        # O(log n) runtime complexity\n        \n        # binary search\n        # return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n        # O(log n) runtime complexity\n        \n        # binary search\n        # return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n        # O(log n) runtime complexity\n        \n        # binary search\n        # return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n        # O(log n) runtime complexity\n        \n        # binary search\n        # return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n        # O(log n) runtime complexity\n        \n        # binary search\n        # return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n        # O(log n) runtime complexity\n        \n        # binary search\n        # return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n        # O(log n) runtime complexity\n        \n        # binary search\n        # return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n        # O(log n) runtime complexity\n        \n        # binary search\n        # return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n        # O(log n) runtime complexity\n        \n        # binary search\n        # return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n        # O(log n) runtime complexity\n        \n        # binary search\n        # return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n        # O(log n) runtime complexity\n        \n        # binary search\n        # return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n        # O(log n) runtime complexity\n        \n        # binary search\n        # return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n        # O(log n) runtime complexity\n        \n        # binary search\n        # return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n        # O(log n) runtime complexity\n        \n        # binary search\n        # return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n        # O(log n) runtime complexity\n        \n        # binary search\n        # return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n        # O(log n) runtime complexity\n        \n        # binary search\n        # return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n        # O(log n) runtime complexity\n        \n        # binary search\n        # return the index if the"}], "jump-game": [{"task_id": "jump-game", "completion": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "minimum-path-sum": [{"task_id": "minimum-path-sum", "completion": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(grid)\n        n = len(grid[0])\n        \n        for i in range(m):\n            for j in range(n):\n                if i == 0 and j == 0:\n                    continue\n                elif i == 0:\n                    grid[i][j] = grid[i][j-1] + grid[i][j]\n                elif j == 0:\n                    grid[i][j] = grid[i-1][j] + grid[i][j]\n                else:\n                    grid[i][j] = min(grid[i][j-1], grid[i-1][j]) + grid[i][j]\n                    \n        return grid[m-1][n-1]"}], "count-and-say": [{"task_id": "count-and-say", "completion": "class Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        \n        if n == 1:\n            return '1'\n        \n        res = '1'\n        for i in range(1, n):\n            res = self.say(res)\n        return res\n        \n    def say(self, s):\n        res = ''\n        count = 1\n        for i in range(len(s) - 1):\n            if s[i] == s[i + 1]:\n                count += 1\n            else:\n                res += str(count) + s[i]\n                count = 1\n        res += str(count) + s[-1]\n        return res"}], "split-array-largest-sum": [{"task_id": "split-array-largest-sum", "completion": "class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def isValid(maxSum):\n            count = 1\n            currSum = 0\n            for num in nums:\n                if currSum + num > maxSum:\n                    count += 1\n                    currSum = num\n                else:\n                    currSum += num\n            return count <= k\n        \n        left = max(nums)\n        right = sum(nums)\n        while left < right:\n            mid = (left + right) // 2\n            if isValid(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left"}], "search-in-rotated-sorted-array": [{"task_id": "search-in-rotated-sorted-array", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # find the pivot point\n        pivot = self.find_pivot(nums)\n        \n        # if the target is in the first half of the array, search in the first half\n        if nums[pivot] <= target <= nums[-1]:\n            return self.binary_search(nums, target, 0, pivot)\n        \n        # if the target is in the second half of the array, search in the second half\n        return self.binary_search(nums, target, pivot, len(nums) - 1)\n        \n    def find_pivot(self, nums):\n        left, right = 0, len(nums) - 1\n        \n        while left < right:\n            mid = (left + right) // 2\n            \n            if nums[mid] > nums[right]:\n                left = mid + 1\n            else:\n                right = mid\n                \n        return left\n        \n    def binary_search(self, nums, target, left, right):\n        while left <= right:\n            mid = (left + right) // 2\n            \n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n                \n        return -1"}], "letter-combinations-of-a-phone-number": [{"task_id": "letter-combinations-of-a-phone-number", "completion": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(digits) == 0:\n            return []\n        \n        mapping = {'2':'abc', '3':'def', '4':'ghi', '5':'jkl', '6':'mno', '7':'pqrs', '8':'tuv', '9':'wxyz'}\n        \n        def backtrack(combination, next_digits):\n            # if there is no more digits to check\n            if len(next_digits) == 0:\n                # the combination is done\n                output.append(combination)\n            # if there are still digits to check\n            else:\n                # iterate over all letters which map the next available digit\n                for letter in mapping[next_digits[0]]:\n                    # append the letter to the combination\n                    # and proceed to the next digit(s)\n                    backtrack(combination + letter, next_digits[1:])\n        \n        output = []\n        backtrack(\"\", digits)\n        return output"}], "combination-sum": [{"task_id": "combination-sum", "completion": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # sort the candidates\n        candidates.sort()\n        \n        # initialize the result\n        result = []\n        \n        # initialize the current combination\n        current = []\n        \n        # initialize the current sum\n        current_sum = 0\n        \n        # initialize the index\n        i = 0\n        \n        # loop through the candidates\n        while i < len(candidates):\n            # if the current sum plus the current candidate is less than the target,\n            # add the current candidate to the current combination\n            if current_sum + candidates[i] < target:\n                current.append(candidates[i])\n                current_sum += candidates[i]\n                \n                # recursively call the function with the current combination and the target\n                self.dfs(candidates, target, current, current_sum, i, result)\n                \n                # remove the last element from the current combination\n                current.pop()\n                current_sum -= candidates[i]\n                \n            # if the current sum plus the current candidate is equal to the target,\n            # add the current combination to the result\n            elif current_sum + candidates[i] == target:\n                current.append(candidates[i])\n                result.append(current[:])\n                \n                # remove the last element from the current combination\n                current.pop()\n                current_sum -= candidates[i]\n                \n            # if the current sum plus the current candidate is greater than the target,\n            # move to the next candidate\n            else:\n                i += 1\n                \n        return result\n    \n    def dfs(self, candidates, target, current, current_sum, i, result):\n        # if the current sum plus the current candidate is less than the target,\n        # add the current candidate to the current combination\n        if current_sum + candidates[i] < target:\n            current.append(candidates[i])\n            current_sum += candidates[i]\n            \n            # recursively call the function with the current combination and the target\n            self.dfs(candidates, target, current, current_sum, i, result)\n            \n            # remove the last element from the current combination\n            current.pop()\n            current_sum -= candidates[i]\n            \n        # if the current sum plus the current candidate is equal to the target,\n        # add the current combination to the result\n        elif current_sum + candidates[i] == target:\n            current.append(candidates[i])\n            result.append(current[:])\n            \n            # remove the last element from the current combination\n            current.pop()\n            current_sum -= candidates[i]\n            \n        # if the current sum plus the current candidate is greater than the target,\n        # move to the next candidate\n        else:\n            i += 1\n            \n            # recursively call the function with the current combination and the target\n            if i < len(candidates):\n                self.dfs(candidates, target, current, current_sum, i, result)\n                \n            # remove the last element from the current combination\n            current.pop()\n            current_sum -= candidates[i]"}], "find-the-closest-palindrome": [{"task_id": "find-the-closest-palindrome", "completion": "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        \n        # convert n to int\n        num = int(n)\n        \n        # get the length of n\n        length = len(n)\n        \n        # get the left and right part of n\n        left = n[:length//2]\n        right = n[length//2:]\n        \n        # get the possible candidates\n        candidates = [int(left), int(right), int(left)-1, int(left)+1]\n        \n        # get the closest palindrome\n        closest = min(candidates, key=lambda x: abs(x-num))\n        \n        # return the closest palindrome\n        return str(closest)"}], "spiral-matrix-ii": [{"task_id": "spiral-matrix-ii", "completion": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        matrix = [[0] * n for _ in range(n)]\n        num = 1\n        left, right, top, bottom = 0, n-1, 0, n-1\n        \n        while left <= right and top <= bottom:\n            for i in range(left, right+1):\n                matrix[top][i] = num\n                num += 1\n            top += 1\n            \n            for i in range(top, bottom+1):\n                matrix[i][right] = num\n                num += 1\n            right -= 1\n            \n            for i in range(right, left-1, -1):\n                matrix[bottom][i] = num\n                num += 1\n            bottom -= 1\n            \n            for i in range(bottom, top-1, -1):\n                matrix[i][left] = num\n                num += 1\n            left += 1\n            \n        return matrix"}], "reverse-integer": [{"task_id": "reverse-integer", "completion": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x < 0:\n            x = -x\n            sign = -1\n        else:\n            sign = 1\n        \n        rev = 0\n        while x > 0:\n            rev = rev * 10 + x % 10\n            x = x // 10\n        \n        if rev > 2**31 - 1 or rev < -2**31:\n            return 0\n        \n        return sign * rev"}], "rotate-image": [{"task_id": "rotate-image", "completion": "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        n = len(matrix)\n        \n        for i in range(n//2):\n            for j in range(i, n-i-1):\n                temp = matrix[i][j]\n                matrix[i][j] = matrix[n-j-1][i]\n                matrix[n-j-1][i] = matrix[n-i-1][n-j-1]\n                matrix[n-i-1][n-j-1] = matrix[j][n-i-1]\n                matrix[j][n-i-1] = temp"}], "maximum-product-subarray": [{"task_id": "maximum-product-subarray", "completion": "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_prod = nums[0]\n        min_prod = nums[0]\n        max_prod_so_far = nums[0]\n        \n        for i in range(1, len(nums)):\n            curr_max = max(nums[i], max_prod * nums[i], min_prod * nums[i])\n            curr_min = min(nums[i], max_prod * nums[i], min_prod * nums[i])\n            \n            max_prod = curr_max\n            min_prod = curr_min\n            \n            max_prod_so_far = max(max_prod_so_far, max_prod)\n            \n        return max_prod_so_far"}], "frog-jump": [{"task_id": "frog-jump", "completion": "class Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. build a hashmap to store the stone position\n        stone_map = {}\n        for i, stone in enumerate(stones):\n            stone_map[stone] = i\n        \n        # 2. build a set to store the last stone position\n        last_stone = stones[-1]\n        \n        # 3. build a set to store the last stone position\n        last_stone_set = set()\n        \n        # 4. build a set to store the last stone position\n        last_stone_set.add(last_stone)\n        \n        # 5. build a set to store the last stone position\n        last_stone_set.add(last_stone - 1)\n        \n        # 6. build a set to store the last stone position\n        last_stone_set.add(last_stone + 1)\n        \n        # 7. build a set to store the last stone position\n        last_stone_set.add(last_stone + 2)\n        \n        # 8. build a set to store the last stone position\n        last_stone_set.add(last_stone + 3)\n        \n        # 9. build a set to store the last stone position\n        last_stone_set.add(last_stone + 4)\n        \n        # 10. build a set to store the last stone position\n        last_stone_set.add(last_stone + 5)\n        \n        # 11. build a set to store the last stone position\n        last_stone_set.add(last_stone + 6)\n        \n        # 12. build a set to store the last stone position\n        last_stone_set.add(last_stone + 7)\n        \n        # 13. build a set to store the last stone position\n        last_stone_set.add(last_stone + 8)\n        \n        # 14. build a set to store the last stone position\n        last_stone_set.add(last_stone + 9)\n        \n        # 15. build a set to store the last stone position\n        last_stone_set.add(last_stone + 10)\n        \n        # 16. build a set to store the last stone position\n        last_stone_set.add(last_stone + 11)\n        \n        # 17. build a set to store the last stone position\n        last_stone_set.add(last_stone + 12)\n        \n        # 18. build a set to store the last stone position\n        last_stone_set.add(last_stone + 13)\n        \n        # 19. build a set to store the last stone position\n        last_stone_set.add(last_stone + 14)\n        \n        # 20. build a set to store the last stone position\n        last_stone_set.add(last_stone + 15)\n        \n        # 21. build a set to store the last stone position\n        last_stone_set.add(last_stone + 16)\n        \n        # 22. build a set to store the last stone position\n        last_stone_set.add(last_stone + 17)\n        \n        # 23. build a set to store the last stone position\n        last_stone_set.add(last_stone + 18)\n        \n        # 24. build a set to store the last stone position\n        last_stone_set.add(last_stone + 19)\n        \n        # 25. build a set to store the last stone position\n        last_stone_set.add(last_stone + 20)\n        \n        # 26. build a set to store the last stone position\n        last_stone_set.add(last_stone + 21)\n        \n        # 27. build a set to store the last stone position\n        last_stone_set.add(last_stone + 22)\n        \n        # 28. build a set to store the last stone position\n        last_stone_set.add(last_stone + 23)\n        \n        # 29. build a set to store the last stone position\n        last_stone_set.add(last_stone + 24)\n        \n        # 30. build a set to store the last stone position\n        last_stone_set.add(last_stone + 25"}], "relative-ranks": [{"task_id": "relative-ranks", "completion": "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        # sort the score in descending order\n        score_sorted = sorted(score, reverse=True)\n        \n        # create a dictionary to map the score to the corresponding rank\n        score_to_rank = {score_sorted[i]: i+1 for i in range(len(score_sorted))}\n        \n        # create a list of ranks\n        ranks = [None] * len(score)\n        \n        # map the score to the corresponding rank\n        for i, score in enumerate(score):\n            ranks[i] = score_to_rank[score]\n        \n        # create a list of ranks\n        ranks = [None] * len(score)\n        \n        # map the score to the corresponding rank\n        for i, score in enumerate(score):\n            ranks[i] = score_to_rank[score]\n        \n        # create a list of ranks\n        ranks = [None] * len(score)\n        \n        # map the score to the corresponding rank\n        for i, score in enumerate(score):\n            ranks[i] = score_to_rank[score]\n        \n        # create a list of ranks\n        ranks = [None] * len(score)\n        \n        # map the score to the corresponding rank\n        for i, score in enumerate(score):\n            ranks[i] = score_to_rank[score]\n        \n        # create a list of ranks\n        ranks = [None] * len(score)\n        \n        # map the score to the corresponding rank\n        for i, score in enumerate(score):\n            ranks[i] = score_to_rank[score]\n        \n        # create a list of ranks\n        ranks = [None] * len(score)\n        \n        # map the score to the corresponding rank\n        for i, score in enumerate(score):\n            ranks[i] = score_to_rank[score]\n        \n        # create a list of ranks\n        ranks = [None] * len(score)\n        \n        # map the score to the corresponding rank\n        for i, score in enumerate(score):\n            ranks[i] = score_to_rank[score]\n        \n        # create a list of ranks\n        ranks = [None] * len(score)\n        \n        # map the score to the corresponding rank\n        for i, score in enumerate(score):\n            ranks[i] = score_to_rank[score]\n        \n        # create a list of ranks\n        ranks = [None] * len(score)\n        \n        # map the score to the corresponding rank\n        for i, score in enumerate(score):\n            ranks[i] = score_to_rank[score]\n        \n        # create a list of ranks\n        ranks = [None] * len(score)\n        \n        # map the score to the corresponding rank\n        for i, score in enumerate(score):\n            ranks[i] = score_to_rank[score]\n        \n        # create a list of ranks\n        ranks = [None] * len(score)\n        \n        # map the score to the corresponding rank\n        for i, score in enumerate(score):\n            ranks[i] = score_to_rank[score]\n        \n        # create a list of ranks\n        ranks = [None] * len(score)\n        \n        # map the score to the corresponding rank\n        for i, score in enumerate(score):\n            ranks[i] = score_to_rank[score]\n        \n        # create a list of ranks\n        ranks = [None] * len(score)\n        \n        # map the score to the corresponding rank\n        for i, score in enumerate(score):\n            ranks[i] = score_to_rank[score]\n        \n        # create a list of ranks\n        ranks = [None] * len(score)\n        \n        # map the score to the corresponding rank\n        for i, score in enumerate(score):\n            ranks[i] = score_to_rank[score]\n        \n        # create a list of ranks\n        ranks = [None] * len(score)\n        \n        # map the score to the corresponding rank\n        for i, score in enumerate(score):\n            ranks[i] = score_to_rank[score]\n        \n        # create a list of ranks\n        ranks = [None] * len(score)\n        \n        # map the score to the corresponding rank\n        for"}], "longest-substring-without-repeating-characters": [{"task_id": "longest-substring-without-repeating-characters", "completion": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if len(s) == 0:\n            return 0\n        \n        max_len = 1\n        start = 0\n        end = 0\n        char_map = {}\n        \n        while end < len(s):\n            if s[end] in char_map:\n                start = max(start, char_map[s[end]] + 1)\n            max_len = max(max_len, end - start + 1)\n            char_map[s[end]] = end\n            end += 1\n        \n        return max_len"}], "substring-with-concatenation-of-all-words": [{"task_id": "substring-with-concatenation-of-all-words", "completion": "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(words) == 0:\n            return []\n        \n        word_len = len(words[0])\n        word_count = len(words)\n        word_dict = {}\n        for word in words:\n            if word in word_dict:\n                word_dict[word] += 1\n            else:\n                word_dict[word] = 1\n        \n        res = []\n        for i in range(len(s) - word_len * word_count + 1):\n            word_dict_copy = word_dict.copy()\n            for j in range(i, i + word_len * word_count, word_len):\n                word = s[j:j+word_len]\n                if word in word_dict_copy:\n                    word_dict_copy[word] -= 1\n                    if word_dict_copy[word] == 0:\n                        del word_dict_copy[word]\n                else:\n                    break\n            else:\n                res.append(i)\n        return res"}], "max-chunks-to-make-sorted-ii": [{"task_id": "max-chunks-to-make-sorted-ii", "completion": "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_val = arr[0]\n        res = 0\n        \n        for i in range(len(arr)):\n            if arr[i] > max_val:\n                max_val = arr[i]\n            if i == max_val:\n                res += 1\n                max_val = 0\n                \n        return res"}], "insertion-sort-list": [{"task_id": "insertion-sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        \n        curr = head\n        while curr:\n            if curr.next and curr.val > curr.next.val:\n                prev = dummy\n                while prev.next.val < curr.next.val:\n                    prev = prev.next\n                curr.next, curr.next.next, prev.next = curr.next.next, curr, prev.next\n            curr = curr.next\n        return dummy.next"}], "remove-duplicates-from-sorted-list-ii": [{"task_id": "remove-duplicates-from-sorted-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        \n        while curr:\n            if curr.next and curr.val == curr.next.val:\n                while curr.next and curr.val == curr.next.val:\n                    curr = curr.next\n                prev.next = curr.next\n            else:\n                prev = curr\n            curr = curr.next\n        return dummy.next"}], "3sum": [{"task_id": "3sum", "completion": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-2):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            l, r = i+1, len(nums)-1\n            while l < r:\n                s = nums[i] + nums[l] + nums[r]\n                if s > 0:\n                    r -= 1\n                elif s < 0:\n                    l += 1\n                else:\n                    res.append([nums[i], nums[l], nums[r]])\n                    l += 1\n                    while l < r and nums[l] == nums[l-1]:\n                        l += 1\n        return res"}], "edit-distance": [{"task_id": "edit-distance", "completion": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        \n        m, n = len(word1), len(word2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        \n        for i in range(m + 1):\n            for j in range(n + 1):\n                if i == 0:\n                    dp[i][j] = j\n                elif j == 0:\n                    dp[i][j] = i\n                elif word1[i - 1] == word2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1])\n        \n        return dp[m][n]"}], "hamming-distance": [{"task_id": "hamming-distance", "completion": "class Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        \n        xor = x ^ y\n        count = 0\n        while xor:\n            count += 1\n            xor &= xor - 1\n        return count"}], "binary-tree-paths": [{"task_id": "binary-tree-paths", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(root, path):\n            if not root:\n                return\n            path += str(root.val)\n            if not root.left and not root.right:\n                self.paths.append(path)\n            else:\n                path += '->'\n                dfs(root.left, path)\n                dfs(root.right, path)\n        \n        self.paths = []\n        dfs(root, '')\n        return self.paths"}], "reverse-pairs": [{"task_id": "reverse-pairs", "completion": "class Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        def merge(nums, left, mid, right):\n            count = 0\n            i, j = left, mid\n            while i < mid:\n                while j < right and nums[i] > 2 * nums[j]:\n                    j += 1\n                count += j - mid\n                i += 1\n            nums[left:right] = sorted(nums[left:right])\n            return count\n        \n        def mergeSort(nums, left, right):\n            if left + 1 >= right:\n                return 0\n            mid = (left + right) // 2\n            return merge(nums, left, mid, right) + mergeSort(nums, mid, right) + mergeSort(nums, left, mid)\n        \n        return mergeSort(nums, 0, len(nums))"}], "reaching-points": [{"task_id": "reaching-points", "completion": "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        \n        while tx > sx and ty > sy:\n            if tx > ty:\n                tx %= ty\n            else:\n                ty %= tx\n        return tx == sx and ty == sy"}], "compare-version-numbers": [{"task_id": "compare-version-numbers", "completion": "class Solution(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"\n        \n        v1 = [int(i) for i in version1.split('.')]\n        v2 = [int(i) for i in version2.split('.')]\n        \n        for i in range(max(len(v1), len(v2))):\n            if i >= len(v1):\n                if v1[-1] > 0:\n                    return 1\n            elif i >= len(v2):\n                if v2[-1] > 0:\n                    return -1\n            else:\n                if v1[i] > v2[i]:\n                    return 1\n                elif v1[i] < v2[i]:\n                    return -1\n        return 0"}], "best-time-to-buy-and-sell-stock-ii": [{"task_id": "best-time-to-buy-and-sell-stock-ii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_profit = 0\n        min_price = float('inf')\n        \n        for price in prices:\n            min_price = min(min_price, price)\n            max_profit = max(max_profit, price - min_price)\n            \n        return max_profit"}], "course-schedule-iii": [{"task_id": "course-schedule-iii", "completion": "class Solution(object):\n    def scheduleCourse(self, courses):\n        \"\"\"\n        :type courses: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort by end date\n        courses.sort(key=lambda x: x[1])\n        \n        # priority queue\n        pq = []\n        \n        # total time\n        total = 0\n        \n        # iterate over courses\n        for duration, end in courses:\n            # add course to priority queue\n            heapq.heappush(pq, -duration)\n            \n            # add course to total time\n            total += duration\n            \n            # if total time exceeds end date, remove course from priority queue\n            if total > end:\n                total += heapq.heappop(pq)\n                \n        # return length of priority queue\n        return len(pq)"}], "reverse-nodes-in-k-group": [{"task_id": "reverse-nodes-in-k-group", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or k == 1:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        \n        while True:\n            kth = prev\n            for i in range(k):\n                if not kth:\n                    return dummy.next\n                kth = kth.next\n            \n            next = kth.next\n            kth.next = None\n            prev.next = self.reverse(head, next)\n            head.next = next\n            prev = head\n            head = next\n        \n        return dummy.next\n    \n    def reverse(self, head, next):\n        prev = None\n        while head:\n            n = head.next\n            head.next = prev\n            prev = head\n            head = n\n        return prev"}], "repeated-substring-pattern": [{"task_id": "repeated-substring-pattern", "completion": "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        return s in (s+s)[1:-1]"}], "unique-binary-search-trees": [{"task_id": "unique-binary-search-trees", "completion": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # dp[i] = dp[i-1] * 2 * (2*i - 1) / i\n        # dp[i] = dp[i-1] * 2 * (2*i - 1) / i + dp[i-2] * 2\n        # dp[i] = dp[i-1] * 2 * (2*i - 1) / i + dp[i-2] * 2 + dp[i-3] * 2\n        # dp[i] = dp[i-1] * 2 * (2*i - 1) / i + dp[i-2] * 2 + dp[i-3] * 2 + dp[i-4] * 2\n        # dp[i] = dp[i-1] * 2 * (2*i - 1) / i + dp[i-2] * 2 + dp[i-3] * 2 + dp[i-4] * 2 + dp[i-5] * 2\n        # dp[i] = dp[i-1] * 2 * (2*i - 1) / i + dp[i-2] * 2 + dp[i-3] * 2 + dp[i-4] * 2 + dp[i-5] * 2 + dp[i-6] * 2\n        # dp[i] = dp[i-1] * 2 * (2*i - 1) / i + dp[i-2] * 2 + dp[i-3] * 2 + dp[i-4] * 2 + dp[i-5] * 2 + dp[i-6] * 2 + dp[i-7] * 2\n        # dp[i] = dp[i-1] * 2 * (2*i - 1) / i + dp[i-2] * 2 + dp[i-3] * 2 + dp[i-4] * 2 + dp[i-5] * 2 + dp[i-6] * 2 + dp[i-7] * 2 + dp[i-8] * 2\n        # dp[i] = dp[i-1] * 2 * (2*i - 1) / i + dp[i-2] * 2 + dp[i-3] * 2 + dp[i-4] * 2 + dp[i-5] * 2 + dp[i-6] * 2 + dp[i-7] * 2 + dp[i-8] * 2 + dp[i-9] * 2\n        # dp[i] = dp[i-1] * 2 * (2*i - 1) / i + dp[i-2] * 2 + dp[i-3] * 2 + dp[i-4] * 2 + dp[i-5] * 2 + dp[i-6] * 2 + dp[i-7] * 2 + dp[i-8] * 2 + dp[i-9] * 2 + dp[i-10] * 2\n        # dp[i] = dp[i-1] * 2 * (2*i - 1) / i + dp[i-2] * 2 + dp[i-3] * 2 + dp[i-4] * 2 + dp[i-5] * 2 + dp[i-6] * 2 + dp[i-7] * 2 + dp[i-8] * 2 + dp[i-9] * 2 + dp[i-10] * 2 + dp[i-11] * 2\n        # dp[i] = dp[i-1] * 2 * (2*i - 1) / i + dp[i-2] * 2 + dp[i-3] * 2 + dp[i-4] * 2 + dp[i-5] * 2 + dp[i-6] * 2 + d"}], "single-number-ii": [{"task_id": "single-number-ii", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. use set to store the numbers\n        ## 2. use set to store the numbers\n        ## 3. use set to store the numbers\n        ## 4. use set to store the numbers\n        ## 5. use set to store the numbers\n        ## 6. use set to store the numbers\n        ## 7. use set to store the numbers\n        ## 8. use set to store the numbers\n        ## 9. use set to store the numbers\n        ## 10. use set to store the numbers\n        ## 11. use set to store the numbers\n        ## 12. use set to store the numbers\n        ## 13. use set to store the numbers\n        ## 14. use set to store the numbers\n        ## 15. use set to store the numbers\n        ## 16. use set to store the numbers\n        ## 17. use set to store the numbers\n        ## 18. use set to store the numbers\n        ## 19. use set to store the numbers\n        ## 20. use set to store the numbers\n        ## 21. use set to store the numbers\n        ## 22. use set to store the numbers\n        ## 23. use set to store the numbers\n        ## 24. use set to store the numbers\n        ## 25. use set to store the numbers\n        ## 26. use set to store the numbers\n        ## 27. use set to store the numbers\n        ## 28. use set to store the numbers\n        ## 29. use set to store the numbers\n        ## 30. use set to store the numbers\n        ## 31. use set to store the numbers\n        ## 32. use set to store the numbers\n        ## 33. use set to store the numbers\n        ## 34. use set to store the numbers\n        ## 35. use set to store the numbers\n        ## 36. use set to store the numbers\n        ## 37. use set to store the numbers\n        ## 38. use set to store the numbers\n        ## 39. use set to store the numbers\n        ## 40. use set to store the numbers\n        ## 41. use set to store the numbers\n        ## 42. use set to store the numbers\n        ## 43. use set to store the numbers\n        ## 44. use set to store the numbers\n        ## 45. use set to store the numbers\n        ## 46. use set to store the numbers\n        ## 47. use set to store the numbers\n        ## 48. use set to store the numbers\n        ## 49. use set to store the numbers\n        ## 50. use set to store the numbers\n        ## 51. use set to store the numbers\n        ## 52. use set to store the numbers\n        ## 53. use set to store the numbers\n        ## 54. use set to store the numbers\n        ## 55. use set to store the numbers\n        ## 56. use set to store the numbers\n        ## 57. use set to store the numbers\n        ## 58. use set to store the numbers\n        ## 59. use set to store the numbers\n        ## 60. use set to store the numbers\n        ## 61. use set to store the numbers\n        ## 62. use set to store the numbers\n        ## 63. use set to store the numbers\n        ## 64. use set to store the numbers\n        ## 65. use set to store the numbers\n        ## 66. use set to store the numbers\n        ## 67. use set to store the numbers\n        ## 68. use set to store the numbers\n        ## 69. use set to store the numbers\n        ## 70. use set to store the numbers\n        ## 71. use set to store the numbers\n        ## 72. use set to store the numbers\n        ## 73. use set to store the numbers\n        ## 74. use set to store"}], "stickers-to-spell-word": [{"task_id": "stickers-to-spell-word", "completion": "class Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. build a dict for each sticker\n        # 2. build a dict for each letter in target\n        # 3. for each letter in target, check if it can be made from stickers\n        # 4. if it can, add it to the dict\n        # 5. if it can't, check if it can be made from stickers with one less sticker\n        # 6. if it can, add it to the dict\n        # 7. if it can't, return -1\n        \n        # build a dict for each sticker\n        sticker_dict = {}\n        for sticker in stickers:\n            sticker_dict[sticker] = 0\n        \n        # build a dict for each letter in target\n        target_dict = {}\n        for letter in target:\n            target_dict[letter] = 0\n        \n        # for each letter in target, check if it can be made from stickers\n        for letter in target:\n            if letter not in sticker_dict:\n                return -1\n            else:\n                target_dict[letter] += 1\n        \n        # if it can, add it to the dict\n        for sticker in stickers:\n            for letter in sticker:\n                if letter not in target_dict:\n                    target_dict[letter] = 0\n                target_dict[letter] += sticker_dict[sticker]\n        \n        # if it can't, check if it can be made from stickers with one less sticker\n        for sticker in stickers:\n            for letter in sticker:\n                if letter not in target_dict:\n                    target_dict[letter] = 0\n                target_dict[letter] -= sticker_dict[sticker]\n        \n        # if it can't, return -1\n        if target_dict == {}:\n            return -1\n        else:\n            return max(target_dict.values())"}], "strange-printer": [{"task_id": "strange-printer", "completion": "class Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        \n        for i in range(n - 1, -1, -1):\n            dp[i][i] = 1\n            for j in range(i + 1, n):\n                if s[i] == s[j]:\n                    dp[i][j] = dp[i][j - 1]\n                else:\n                    dp[i][j] = min(dp[i][j - 1] + 1, dp[j][j])\n                    for k in range(i, j):\n                        if s[k] == s[j]:\n                            dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j - 1])\n        \n        return dp[0][n - 1]"}], "sqrtx": [{"task_id": "sqrtx", "completion": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x == 0:\n            return 0\n        \n        left, right = 1, x\n        \n        while left <= right:\n            mid = left + (right - left) // 2\n            if mid * mid == x:\n                return mid\n            elif mid * mid < x:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return right"}], "roman-to-integer": [{"task_id": "roman-to-integer", "completion": "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Create a dictionary to map roman numerals to their integer values\n        roman_dict = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}\n        \n        # Initialize the result variable to 0\n        result = 0\n        \n        # Iterate over the string in reverse order\n        for i in range(len(s) - 1, -1, -1):\n            # If the current character is less than the next character, subtract it from the result\n            if roman_dict[s[i]] < roman_dict[s[i+1]]:\n                result -= roman_dict[s[i]]\n            # Otherwise, add it to the result\n            else:\n                result += roman_dict[s[i]]\n        \n        # Return the result\n        return result"}], "contains-duplicate": [{"task_id": "contains-duplicate", "completion": "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        return len(nums) != len(set(nums))"}], "sliding-window-maximum": [{"task_id": "sliding-window-maximum", "completion": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # Initialize the deque and output list\n        dq = collections.deque()\n        output = []\n        \n        # Loop through the input array\n        for i in range(len(nums)):\n            \n            # Remove any elements that are out of the current window\n            if dq and dq[0] == i - k:\n                dq.popleft()\n            \n            # Remove any elements that are smaller than the current element\n            while dq and nums[dq[-1]] < nums[i]:\n                dq.pop()\n            \n            # Add the current element to the deque\n            dq.append(i)\n            \n            # Add the maximum element to the output list\n            if i >= k - 1:\n                output.append(nums[dq[0]])\n        \n        return output"}], "median-of-two-sorted-arrays": [{"task_id": "median-of-two-sorted-arrays", "completion": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        \n        # merge the two arrays\n        nums1.extend(nums2)\n        nums1.sort()\n        \n        # find the median\n        if len(nums1) % 2 == 0:\n            return (nums1[len(nums1) // 2] + nums1[len(nums1) // 2 - 1]) / 2.0\n        else:\n            return nums1[len(nums1) // 2]"}], "find-minimum-in-rotated-sorted-array": [{"task_id": "find-minimum-in-rotated-sorted-array", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        # if nums[0] > nums[-1]:\n        #     return nums[-1]\n        \n        # left, right = 0, len(nums) - 1\n        # while left < right:\n        #     mid = (left + right) // 2\n        #     if nums[mid] > nums[mid + 1]:\n        #         return nums[mid + 1]\n        #     if nums[mid - 1] > nums[mid]:\n        #         return nums[mid]\n        #     if nums[mid] < nums[right]:\n        #         right = mid - 1\n        #     else:\n        #         left = mid + 1\n        # return nums[left]\n        \n        # binary search\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] > nums[right]:\n                left = mid + 1\n            else:\n                right = mid\n        return nums[left]"}], "pascals-triangle-ii": [{"task_id": "pascals-triangle-ii", "completion": "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if rowIndex == 0:\n            return [1]\n        if rowIndex == 1:\n            return [1,1]\n        \n        row = [1,1]\n        for i in range(2, rowIndex+1):\n            row = [1] + [row[j] + row[j+1] for j in range(len(row)-1)] + [1]\n        return row"}], "path-sum-ii": [{"task_id": "path-sum-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def pathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(root, targetSum, path):\n            if not root:\n                return []\n            if not root.left and not root.right and root.val == targetSum:\n                return [[root.val]]\n            left = dfs(root.left, targetSum - root.val, path + [root.val])\n            right = dfs(root.right, targetSum - root.val, path + [root.val])\n            return left + right\n        \n        return dfs(root, targetSum, [])"}], "construct-the-rectangle": [{"task_id": "construct-the-rectangle", "completion": "class Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "word-ladder-ii": [{"task_id": "word-ladder-ii", "completion": "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        # build a graph\n        graph = collections.defaultdict(list)\n        for word in wordList:\n            for i in range(len(word)):\n                graph[word[:i] + '*' + word[i+1:]].append(word)\n        \n        # build a queue and a set to keep track of visited nodes\n        queue = collections.deque([beginWord])\n        visited = set([beginWord])\n        \n        # build a dict to store the shortest path from beginWord to each node\n        shortest_path = {beginWord: [beginWord]}\n        \n        # perform BFS\n        while queue:\n            curr_word = queue.popleft()\n            for i in range(len(curr_word)):\n                # for each character in the current word, try to replace it with a-z and check if the word is in the wordList\n                for j in range(ord('a'), ord('z') + 1):\n                    new_word = curr_word[:i] + chr(j) + curr_word[i+1:]\n                    if new_word in wordList and new_word not in visited:\n                        # if the word is in the wordList, add it to the queue and mark it as visited\n                        queue.append(new_word)\n                        visited.add(new_word)\n                        # add the shortest path from the current word to the new word to the shortest_path dict\n                        shortest_path[new_word] = shortest_path[curr_word] + [new_word]\n        \n        # return the shortest path from beginWord to endWord\n        return shortest_path.get(endWord, [])"}], "balanced-binary-tree": [{"task_id": "balanced-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def height(root):\n            if not root:\n                return 0\n            left = height(root.left)\n            right = height(root.right)\n            if left == -1 or right == -1 or abs(left - right) > 1:\n                return -1\n            return max(left, right) + 1\n        \n        return height(root) != -1"}], "power-of-two": [{"task_id": "power-of-two", "completion": "class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 2 == 0:\n            n = n / 2\n        \n        return n == 1"}], "subsets-ii": [{"task_id": "subsets-ii", "completion": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = [[]]\n        for i in range(len(nums)):\n            if i == 0 or nums[i] != nums[i-1]:\n                res += [nums[i]] + r for r in res]\n        return res"}], "largest-rectangle-in-histogram": [{"task_id": "largest-rectangle-in-histogram", "completion": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uc5ec \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ufffd"}], "evaluate-reverse-polish-notation": [{"task_id": "evaluate-reverse-polish-notation", "completion": "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        for i in tokens:\n            if i not in \"+-*/\":\n                stack.append(int(i))\n            else:\n                a = stack.pop()\n                b = stack.pop()\n                if i == \"+\":\n                    stack.append(a + b)\n                elif i == \"-\":\n                    stack.append(b - a)\n                elif i == \"*\":\n                    stack.append(a * b)\n                else:\n                    stack.append(int(float(b) / a))\n        return stack[0]"}], "perfect-rectangle": [{"task_id": "perfect-rectangle", "completion": "class Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        \n        x_min, y_min, x_max, y_max = float('inf'), float('inf'), float('-inf'), float('-inf')\n        area = 0\n        \n        for x1, y1, x2, y2 in rectangles:\n            x_min, y_min, x_max, y_max = min(x_min, x1), min(y_min, y1), max(x_max, x2), max(y_max, y2)\n            area += (x2 - x1) * (y2 - y1)\n        \n        if area != (x_max - x_min) * (y_max - y_min):\n            return False\n        \n        if (x_min, y_min) not in rectangles or (x_max, y_min) not in rectangles or (x_min, y_max) not in rectangles or (x_max, y_max) not in rectangles:\n            return False\n        \n        return True"}], "excel-sheet-column-title": [{"task_id": "excel-sheet-column-title", "completion": "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        \n        # 26^0 = 1\n        # 26^1 = 26\n        # 26^2 = 26^1 * 26\n        # 26^3 = 26^2 * 26\n        # 26^4 = 26^3 * 26\n        # 26^5 = 26^4 * 26\n        # 26^6 = 26^5 * 26\n        # 26^7 = 26^6 * 26\n        # 26^8 = 26^7 * 26\n        # 26^9 = 26^8 * 26\n        # 26^10 = 26^9 * 26\n        # 26^11 = 26^10 * 26\n        # 26^12 = 26^11 * 26\n        # 26^13 = 26^12 * 26\n        # 26^14 = 26^13 * 26\n        # 26^15 = 26^14 * 26\n        # 26^16 = 26^15 * 26\n        # 26^17 = 26^16 * 26\n        # 26^18 = 26^17 * 26\n        # 26^19 = 26^18 * 26\n        # 26^20 = 26^19 * 26\n        # 26^21 = 26^20 * 26\n        # 26^22 = 26^21 * 26\n        # 26^23 = 26^22 * 26\n        # 26^24 = 26^23 * 26\n        # 26^25 = 26^24 * 26\n        # 26^26 = 26^25 * 26\n        # 26^27 = 26^26 * 26\n        # 26^28 = 26^27 * 26\n        # 26^29 = 26^28 * 26\n        # 26^30 = 26^29 * 26\n        # 26^31 = 26^30 * 26\n        # 26^32 = 26^31 * 26\n        # 26^33 = 26^32 * 26\n        # 26^34 = 26^33 * 26\n        # 26^35 = 26^34 * 26\n        # 26^36 = 26^35 * 26\n        # 26^37 = 26^36 * 26\n        # 26^38 = 26^37 * 26\n        # 26^39 = 26^38 * 26\n        # 26^40 = 26^39 * 26\n        # 26^41 = 26^40 * 26\n        # 26^42 = 26^41 * 26\n        # 26^43 = 26^42 * 26\n        # 26^44 = 26^43 * 26\n        # 26^45 = 26^44 * 26\n        # 26^46 = 26^45 * 26\n        # 26^47 = 26^46 * 26\n        # 26^48 = 26^47 * 26\n        # 26^49 = 26^48 * 26\n        # 26^50 = 26^49 * 26\n        # 26^51 = 26^50 * 26\n        # 26^52 = 26^51 * 26\n        # 26^53 = 26^52 * 26\n        # 26^54 = 26^53 * 26\n        # 26^55 = 26^5"}], "maximum-subarray": [{"task_id": "maximum-subarray", "completion": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_sum = nums[0]\n        curr_sum = 0\n        \n        for num in nums:\n            if curr_sum < 0:\n                curr_sum = num\n            else:\n                curr_sum += num\n            max_sum = max(max_sum, curr_sum)\n        \n        return max_sum"}], "sliding-puzzle": [{"task_id": "sliding-puzzle", "completion": "class Solution(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # convert board to a 1D array\n        board_1d = [board[0][0]*10 + board[0][1]*1 + board[0][2],\n                    board[1][0]*10 + board[1][1]*1 + board[1][2]]\n        \n        # convert board_1d to a string\n        board_str = str(board_1d)\n        \n        # convert board_str to a list of integers\n        board_list = [int(x) for x in board_str]\n        \n        # convert board_list to a 1D array\n        board_1d = [board_list[0]*10 + board_list[1],\n                    board_list[2]*10 + board_list[3],\n                    board_list[4]*10 + board_list[5]]\n        \n        # convert board_1d to a string\n        board_str = str(board_1d)\n        \n        # convert board_str to a list of integers\n        board_list = [int(x) for x in board_str]\n        \n        # convert board_list to a 1D array\n        board_1d = [board_list[0]*10 + board_list[1],\n                    board_list[2]*10 + board_list[3]]\n        \n        # convert board_1d to a string\n        board_str = str(board_1d)\n        \n        # convert board_str to a list of integers\n        board_list = [int(x) for x in board_str]\n        \n        # convert board_list to a 1D array\n        board_1d = [board_list[0]*10 + board_list[1]]\n        \n        # convert board_1d to a string\n        board_str = str(board_1d)\n        \n        # convert board_str to a list of integers\n        board_list = [int(x) for x in board_str]\n        \n        # convert board_list to a 1D array\n        board_1d = [board_list[0]]\n        \n        # convert board_1d to a string\n        board_str = str(board_1d)\n        \n        # convert board_str to a list of integers\n        board_list = [int(x) for x in board_str]\n        \n        # convert board_list to a 1D array\n        board_1d = [board_list[0]]\n        \n        # convert board_1d to a string\n        board_str = str(board_1d)\n        \n        # convert board_str to a list of integers\n        board_list = [int(x) for x in board_str]\n        \n        # convert board_list to a 1D array\n        board_1d = [board_list[0]]\n        \n        # convert board_1d to a string\n        board_str = str(board_1d)\n        \n        # convert board_str to a list of integers\n        board_list = [int(x) for x in board_str]\n        \n        # convert board_list to a 1D array\n        board_1d = [board_list[0]]\n        \n        # convert board_1d to a string\n        board_str = str(board_1d)\n        \n        # convert board_str to a list of integers\n        board_list = [int(x) for x in board_str]\n        \n        # convert board_list to a 1D array\n        board_1d = [board_list[0]]\n        \n        # convert board_1d to a string\n        board_str = str(board_1d)\n        \n        # convert board_str to a list of integers\n        board_list = [int(x) for x in board_str]\n        \n        # convert board_list to a 1D array\n        board_1d = [board_list[0]]\n        \n        # convert board_1d to a string\n        board_str = str(board_1d)\n        \n        # convert board_str to a list of integers\n        board_list = [int(x) for x in board_str]\n        \n        # convert board_list to a 1D array\n        board_1d = [board_list[0]]"}], "isomorphic-strings": [{"task_id": "isomorphic-strings", "completion": "class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_to_t = {}\n        t_to_s = {}\n        \n        for i in range(len(s)):\n            s_char = s[i]\n            t_char = t[i]\n            \n            if s_char in s_to_t and s_to_t[s_char] != t_char:\n                return False\n            \n            if t_char in t_to_s and t_to_s[t_char] != s_char:\n                return False\n            \n            s_to_t[s_char] = t_char\n            t_to_s[t_char] = s_char\n            \n        return True"}], "search-in-rotated-sorted-array-ii": [{"task_id": "search-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        # find the pivot\n        pivot = self.find_pivot(nums)\n        \n        # if the target is in the first half of the array, search in the first half\n        if nums[pivot] == target:\n            return True\n        \n        # if the target is in the second half of the array, search in the second half\n        if nums[len(nums) - 1] == target:\n            return True\n        \n        # if the target is not in the first half of the array, search in the second half\n        if nums[pivot] < target and nums[len(nums) - 1] > target:\n            return self.binary_search(nums[pivot:], target)\n        \n        # if the target is not in the second half of the array, search in the first half\n        return self.binary_search(nums[:pivot], target)\n        \n    def find_pivot(self, nums):\n        left, right = 0, len(nums) - 1\n        \n        while left < right:\n            mid = (left + right) // 2\n            \n            if nums[mid] > nums[right]:\n                left = mid + 1\n            else:\n                right = mid\n                \n        return left\n        \n    def binary_search(self, nums, target):\n        left, right = 0, len(nums) - 1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            \n            if nums[mid] == target:\n                return True\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n                \n        return False"}], "unique-paths-ii": [{"task_id": "unique-paths-ii", "completion": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(obstacleGrid)\n        n = len(obstacleGrid[0])\n        \n        if obstacleGrid[m-1][n-1] == 1:\n            return 0\n        \n        dp = [[0] * n for _ in range(m)]\n        \n        for i in range(m):\n            for j in range(n):\n                if obstacleGrid[i][j] == 1:\n                    dp[i][j] = 0\n                elif i == 0 and j == 0:\n                    dp[i][j] = 1\n                elif i == 0:\n                    dp[i][j] = dp[i][j-1]\n                elif j == 0:\n                    dp[i][j] = dp[i-1][j]\n                else:\n                    dp[i][j] = dp[i-1][j] + dp[i][j-1]\n                    \n        return dp[m-1][n-1]"}], "decode-ways-ii": [{"task_id": "decode-ways-ii", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if s[0] == '0':\n            return 0\n        \n        if len(s) == 1:\n            return 1\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] += dp[i - 1]\n            if s[i - 2] != '0' and int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        \n        return dp[-1]"}], "3sum-closest": [{"task_id": "3sum-closest", "completion": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        closest = nums[0] + nums[1] + nums[2]\n        \n        for i in range(len(nums)-2):\n            l, r = i+1, len(nums)-1\n            while l < r:\n                s = nums[i] + nums[l] + nums[r]\n                if abs(s - target) < abs(closest - target):\n                    closest = s\n                if s < target:\n                    l += 1\n                else:\n                    r -= 1\n        return closest"}], "maximum-depth-of-binary-tree": [{"task_id": "maximum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))"}], "intersection-of-two-arrays-ii": [{"task_id": "intersection-of-two-arrays-ii", "completion": "class Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(nums1) > len(nums2):\n            return self.intersect(nums2, nums1)\n        \n        nums1.sort()\n        nums2.sort()\n        \n        i, j = 0, 0\n        res = []\n        \n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] < nums2[j]:\n                i += 1\n            elif nums1[i] > nums2[j]:\n                j += 1\n            else:\n                res.append(nums1[i])\n                i += 1\n                j += 1\n                \n        return res"}], "minimum-absolute-difference-in-bst": [{"task_id": "minimum-absolute-difference-in-bst", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def inorder(root):\n            if root:\n                yield from inorder(root.left)\n                yield root.val\n                yield from inorder(root.right)\n        \n        prev = None\n        min_diff = float('inf')\n        for n in inorder(root):\n            if prev:\n                min_diff = min(min_diff, n - prev)\n            prev = n\n        return min_diff"}], "find-mode-in-binary-search-tree": [{"task_id": "find-mode-in-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        self.max_count = 0\n        self.prev_val = None\n        self.curr_count = 0\n        self.res = []\n        \n        def inorder(root):\n            if not root:\n                return\n            \n            inorder(root.left)\n            \n            if self.prev_val == root.val:\n                self.curr_count += 1\n            else:\n                self.curr_count = 1\n                \n            if self.curr_count > self.max_count:\n                self.max_count = self.curr_count\n                self.res = [root.val]\n            elif self.curr_count == self.max_count:\n                self.res.append(root.val)\n                \n            self.prev_val = root.val\n            \n            inorder(root.right)\n        \n        inorder(root)\n        \n        return self.res"}], "find-the-index-of-the-first-occurrence-in-a-string": [{"task_id": "find-the-index-of-the-first-occurrence-in-a-string", "completion": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        \n        if len(needle) == 0:\n            return 0\n        \n        for i in range(len(haystack) - len(needle) + 1):\n            if haystack[i:i+len(needle)] == needle:\n                return i\n        \n        return -1"}], "strong-password-checker": [{"task_id": "strong-password-checker", "completion": "class Solution(object):\n    def strongPasswordChecker(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. check length\n        if len(password) < 6 or len(password) > 20:\n            return 5\n        \n        # 2. check for at least one lowercase, one uppercase, one digit\n        lower, upper, digit = False, False, False\n        for c in password:\n            if c.islower():\n                lower = True\n            elif c.isupper():\n                upper = True\n            elif c.isdigit():\n                digit = True\n        \n        if not (lower and upper and digit):\n            return 5\n        \n        # 3. check for repeating characters in a row\n        count = 0\n        for i in range(2, len(password)):\n            if password[i] == password[i-2]:\n                count += 1\n                if count == 3:\n                    return max(5 - len(password), 0)\n            else:\n                count = 0\n        \n        return max(5 - len(password), 0)"}], "factorial-trailing-zeroes": [{"task_id": "factorial-trailing-zeroes", "completion": "class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n < 5:\n            return 0\n        \n        return n//5 + self.trailingZeroes(n//5)"}], "zigzag-conversion": [{"task_id": "zigzag-conversion", "completion": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        \n        if numRows == 1:\n            return s\n        \n        res = [''] * numRows\n        row = 0\n        goingDown = False\n        \n        for c in s:\n            res[row] += c\n            if row == 0 or row == numRows - 1:\n                goingDown = not goingDown\n            row += 1 if goingDown else -1\n        \n        return ''.join(res)"}], "trapping-rain-water": [{"task_id": "trapping-rain-water", "completion": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Brute force\n        ## Time complexity: O(n^2)\n        ## Space complexity: O(1)\n        ## TLE\n        ## 2022.04.20\n        ## 2022.04.21\n        ## 2022.04.22\n        ## 2022.04.23\n        ## 2022.04.24\n        ## 2022.04.25\n        ## 2022.04.26\n        ## 2022.04.27\n        ## 2022.04.28\n        ## 2022.04.29\n        ## 2022.04.30\n        ## 2022.05.01\n        ## 2022.05.02\n        ## 2022.05.03\n        ## 2022.05.04\n        ## 2022.05.05\n        ## 2022.05.06\n        ## 2022.05.07\n        ## 2022.05.08\n        ## 2022.05.09\n        ## 2022.05.10\n        ## 2022.05.11\n        ## 2022.05.12\n        ## 2022.05.13\n        ## 2022.05.14\n        ## 2022.05.15\n        ## 2022.05.16\n        ## 2022.05.17\n        ## 2022.05.18\n        ## 2022.05.19\n        ## 2022.05.20\n        ## 2022.05.21\n        ## 2022.05.22\n        ## 2022.05.23\n        ## 2022.05.24\n        ## 2022.05.25\n        ## 2022.05.26\n        ## 2022.05.27\n        ## 2022.05.28\n        ## 2022.05.29\n        ## 2022.05.30\n        ## 2022.05.31\n        ## 2022.06.01\n        ## 2022.06.02\n        ## 2022.06.03\n        ## 2022.06.04\n        ## 2022.06.05\n        ## 2022.06.06\n        ## 2022.06.07\n        ## 2022.06.08\n        ## 2022.06.09\n        ## 2022.06.10\n        ## 2022.06.11\n        ## 2022.06.12\n        ## 2022.06.13\n        ## 2022.06.14\n        ## 2022.06.15\n        ## 2022.06.16\n        ## 2022.06.17\n        ## 2022.06.18\n        ## 2022.06.19\n        ## 2022.06.20\n        ## 2022.06.21\n        ## 2022.06.22\n        ## 2022.06.23\n        ## 2022.06."}], "find-all-numbers-disappeared-in-an-array": [{"task_id": "find-all-numbers-disappeared-in-an-array", "completion": "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        ## O(n) time and O(1) space\n        ## 1. Create a list of all numbers from 1 to n\n        ## 2. Iterate through the list and mark the numbers as seen\n        ## 3. Iterate through the list again and return the numbers that are not seen\n        \n        n = len(nums)\n        seen = [0] * (n + 1)\n        \n        for num in nums:\n            seen[num] = 1\n            \n        return [i for i in range(1, n + 1) if seen[i] == 0]"}], "count-of-smaller-numbers-after-self": [{"task_id": "count-of-smaller-numbers-after-self", "completion": "class Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. sort the array\n        # 2. for each element, find the number of smaller elements to the right\n        # 3. use binary search to find the number of smaller elements to the left\n        # 4. use binary search to find the number of smaller elements to the right\n        # 5. use binary search to find the number of smaller elements to the left\n        # 6. use binary search to find the number of smaller elements to the right\n        # 7. use binary search to find the number of smaller elements to the left\n        # 8. use binary search to find the number of smaller elements to the right\n        # 9. use binary search to find the number of smaller elements to the left\n        # 10. use binary search to find the number of smaller elements to the right\n        # 11. use binary search to find the number of smaller elements to the left\n        # 12. use binary search to find the number of smaller elements to the right\n        # 13. use binary search to find the number of smaller elements to the left\n        # 14. use binary search to find the number of smaller elements to the right\n        # 15. use binary search to find the number of smaller elements to the left\n        # 16. use binary search to find the number of smaller elements to the right\n        # 17. use binary search to find the number of smaller elements to the left\n        # 18. use binary search to find the number of smaller elements to the right\n        # 19. use binary search to find the number of smaller elements to the left\n        # 20. use binary search to find the number of smaller elements to the right\n        # 21. use binary search to find the number of smaller elements to the left\n        # 22. use binary search to find the number of smaller elements to the right\n        # 23. use binary search to find the number of smaller elements to the left\n        # 24. use binary search to find the number of smaller elements to the right\n        # 25. use binary search to find the number of smaller elements to the left\n        # 26. use binary search to find the number of smaller elements to the right\n        # 27. use binary search to find the number of smaller elements to the left\n        # 28. use binary search to find the number of smaller elements to the right\n        # 29. use binary search to find the number of smaller elements to the left\n        # 30. use binary search to find the number of smaller elements to the right\n        # 31. use binary search to find the number of smaller elements to the left\n        # 32. use binary search to find the number of smaller elements to the right\n        # 33. use binary search to find the number of smaller elements to the left\n        # 34. use binary search to find the number of smaller elements to the right\n        # 35. use binary search to find the number of smaller elements to the left\n        # 36. use binary search to find the number of smaller elements to the right\n        # 37. use binary search to find the number of smaller elements to the left\n        # 38. use binary search to find the number of smaller elements to the right\n        # 39. use binary search to find the number of smaller elements to the left\n        # 40. use binary search to find the number of smaller elements to the right\n        # 41. use binary search to find the number of smaller elements to the left\n        # 42. use binary search to find the number of smaller elements to the right\n        # 43. use binary search to find the number of smaller elements to the left\n        # 44. use binary search to find the number of smaller elements to the right\n        # 45. use binary search to find the number of smaller elements to the left\n        # 46. use binary search to find the number of smaller elements to the right\n        # 47. use binary search to find the number of smaller elements to the left\n        # 48. use binary search to find the number of smaller elements to the right\n        # 49. use binary search to find the number of smaller elements to the left\n        # 50. use binary search to find the number of smaller elements to the right\n        # 51. use binary search to find the number of smaller elements to the left\n        # 52. use binary search to find the number of smaller elements to the right\n        #"}], "set-intersection-size-at-least-two": [{"task_id": "set-intersection-size-at-least-two", "completion": "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort the intervals by start\n        intervals.sort(key=lambda x: x[0])\n        \n        # initialize the result\n        res = 0\n        \n        # initialize the first and second ends\n        first = -1\n        second = -1\n        \n        # iterate over the intervals\n        for i in range(len(intervals)):\n            # if the current interval is smaller than the first end\n            if intervals[i][0] > first:\n                # update the first end\n                first = intervals[i][1]\n                # update the second end\n                second = first - 1\n                # update the result\n                res += 2\n            # if the current interval is smaller than the second end\n            elif intervals[i][0] > second:\n                # update the second end\n                second = intervals[i][1]\n                # update the result\n                res += 1\n            # if the current interval is smaller than the second end\n            elif intervals[i][1] > second:\n                # update the second end\n                second = intervals[i][1]\n                # update the result\n                res += 1\n        \n        # return the result\n        return res"}], "symmetric-tree": [{"task_id": "symmetric-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def isMirror(left, right):\n            if left is None and right is None:\n                return True\n            if left is None or right is None:\n                return False\n            return left.val == right.val and isMirror(left.left, right.right) and isMirror(left.right, right.left)\n        \n        return isMirror(root, root)"}], "number-of-atoms": [{"task_id": "number-of-atoms", "completion": "class Solution(object):\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. split the formula into tokens\n        # 2. build a stack of tokens\n        # 3. iterate over the tokens\n        # 4. if token is a left parenthesis, push the current stack\n        # 5. if token is a right parenthesis, pop the stack and add the elements to the result\n        # 6. if token is a letter, push the current stack\n        # 7. if token is a number, push the current stack\n        # 8. if token is a closing parenthesis, pop the stack and add the elements to the result\n        \n        # 1. split the formula into tokens\n        tokens = []\n        i = 0\n        while i < len(formula):\n            if formula[i] == '(':\n                tokens.append(formula[i])\n            elif formula[i] == ')':\n                tokens.append(formula[i])\n            elif formula[i].isupper():\n                tokens.append(formula[i])\n            elif formula[i].islower():\n                tokens.append(formula[i])\n            elif formula[i].isdigit():\n                j = i + 1\n                while j < len(formula) and formula[j].isdigit():\n                    j += 1\n                tokens.append(int(formula[i:j]))\n                i = j - 1\n            i += 1\n        \n        # 2. build a stack of tokens\n        stack = []\n        for token in tokens:\n            if token == '(':\n                stack.append(token)\n            elif token == ')':\n                while stack[-1] != '(':\n                    count = stack.pop()\n                    element = stack.pop()\n                    if stack:\n                        stack[-1] += count * element\n                    else:\n                        stack.append(count * element)\n                stack.pop()\n            else:\n                if stack:\n                    count = stack[-1] if stack[-1].isdigit() else 1\n                    stack[-1] += count * token\n                else:\n                    stack.append(token)\n        \n        # 3. iterate over the tokens\n        # 4. if token is a left parenthesis, push the current stack\n        # 5. if token is a right parenthesis, pop the stack and add the elements to the result\n        # 6. if token is a letter, push the current stack\n        # 7. if token is a number, push the current stack\n        # 8. if token is a closing parenthesis, pop the stack and add the elements to the result\n        result = {}\n        for token in stack:\n            if token == '(':\n                stack.append(token)\n            elif token == ')':\n                while stack[-1] != '(':\n                    count = stack.pop()\n                    element = stack.pop()\n                    if stack:\n                        stack[-1] += count * element\n                    else:\n                        stack.append(count * element)\n                stack.pop()\n            else:\n                if stack:\n                    count = stack[-1] if stack[-1].isdigit() else 1\n                    stack[-1] += count * token\n                else:\n                    stack.append(token)\n        \n        # 5. if token is a letter, push the current stack\n        # 6. if token is a number, push the current stack\n        # 7. if token is a closing parenthesis, pop the stack and add the elements to the result\n        while stack:\n            count = stack.pop() if stack[-1].isdigit() else 1\n            element = stack.pop()\n            if stack:\n                stack[-1] += count * element\n            else:\n                stack.append(count * element)\n        \n        # 8. if token is a closing parenthesis, pop the stack and add the elements to the result\n        while stack:\n            count = stack.pop() if stack[-1].isdigit() else 1\n            element = stack.pop()\n            if stack:\n                stack[-1] += count * element\n            else:\n                stack.append(count * element)\n        \n        # 7. if token is a letter, push the current stack\n        # 6. if token is a number, push the current stack\n        # 5. if token is a closing parenthesis, pop the stack and add the elements to the result\n        while stack:\n            count = stack.pop() if stack"}], "binary-tree-preorder-traversal": [{"task_id": "binary-tree-preorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = [root]\n        res = []\n        \n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n                \n        return res"}], "power-of-four": [{"task_id": "power-of-four", "completion": "class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 4 == 0:\n            n /= 4\n        \n        return n == 1"}], "invert-binary-tree": [{"task_id": "invert-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        \n        if root is None:\n            return None\n        \n        left = self.invertTree(root.left)\n        right = self.invertTree(root.right)\n        \n        root.left = right\n        root.right = left\n        \n        return root"}], "generate-parentheses": [{"task_id": "generate-parentheses", "completion": "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def helper(left, right, s, ans):\n            if left == 0 and right == 0:\n                ans.append(s)\n                return\n            if left > 0:\n                helper(left - 1, right, s + '(', ans)\n            if right > left:\n                helper(left, right - 1, s + ')', ans)\n        \n        ans = []\n        helper(n, n, '', ans)\n        return ans"}], "patching-array": [{"task_id": "patching-array", "completion": "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # Initialize the number of patches needed and the current sum\n        patches = 0\n        curr_sum = 0\n        \n        # Iterate over the numbers in the array\n        for num in nums:\n            # If the current sum plus the current number is greater than the target,\n            # add a patch and update the current sum to the current number\n            if curr_sum + num > n:\n                patches += 1\n                curr_sum = num\n            # If the current sum plus the current number is less than or equal to the target,\n            # update the current sum to the current sum plus the current number\n            else:\n                curr_sum += num\n        \n        # Return the number of patches needed\n        return patches"}], "longest-valid-parentheses": [{"task_id": "longest-valid-parentheses", "completion": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dynamic programming\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dynamic programming\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dynamic programming\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dynamic programming\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dynamic programming\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dynamic programming\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dynamic programming\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dynamic programming\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dynamic programming\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dynamic programming\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dynamic programming\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dynamic programming\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dynamic programming\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dynamic programming\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dynamic programming\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dynamic programming\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dynamic programming\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dynamic programming\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dynamic programming\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dynamic programming\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dynamic programming\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dynamic programming\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dynamic programming\n        # 4. greedy\n        # 5. math\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dynamic programming\n        # 4. greedy"}], "fraction-to-recurring-decimal": [{"task_id": "fraction-to-recurring-decimal", "completion": "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        \n        if numerator == 0:\n            return '0'\n        \n        res = ''\n        if (numerator < 0) ^ (denominator < 0):\n            res += '-'\n        \n        numerator, denominator = abs(numerator), abs(denominator)\n        res += str(numerator // denominator)\n        numerator %= denominator\n        if numerator == 0:\n            return res\n        \n        res += '.'\n        seen = {}\n        while numerator != 0:\n            if numerator in seen:\n                res = res[:seen[numerator]] + '(' + res[seen[numerator]:] + ')'\n                break\n            seen[numerator] = len(res)\n            numerator *= 10\n            res += str(numerator // denominator)\n            numerator %= denominator\n        \n        return res"}], "sort-list": [{"task_id": "sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        # find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # split the list into two halves\n        mid = slow.next\n        slow.next = None\n        \n        # recursively sort the two halves\n        left = self.sortList(head)\n        right = self.sortList(mid)\n        \n        # merge the sorted halves\n        dummy = ListNode()\n        curr = dummy\n        while left and right:\n            if left.val < right.val:\n                curr.next = left\n                left = left.next\n            else:\n                curr.next = right\n                right = right.next\n            curr = curr.next\n        \n        # add any remaining nodes from the left half\n        curr.next = left if left else right\n        \n        return dummy.next"}], "russian-doll-envelopes": [{"task_id": "russian-doll-envelopes", "completion": "class Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not envelopes:\n            return 0\n        \n        envelopes.sort(key=lambda x: (x[0], -x[1]))\n        dp = [envelopes[0][1]]\n        \n        for i in range(1, len(envelopes)):\n            if envelopes[i][1] > dp[-1]:\n                dp.append(envelopes[i][1])\n            else:\n                left, right = 0, len(dp) - 1\n                while left < right:\n                    mid = (left + right) // 2\n                    if dp[mid] < envelopes[i][1]:\n                        left = mid + 1\n                    else:\n                        right = mid\n                dp[left] = envelopes[i][1]\n        \n        return len(dp)"}], "set-matrix-zeroes": [{"task_id": "set-matrix-zeroes", "completion": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        ## O(m+n) space\n        ## row and col are set to 0 if the element is 0\n        ## we iterate through the matrix and set the row and col to 0 if the element is 0\n        ## we iterate through the matrix again and set the elements to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the elements to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the elements to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the elements to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the elements to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the elements to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the elements to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the elements to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the elements to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the elements to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the elements to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the elements to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the elements to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the elements to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the elements to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the elements to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the elements to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the elements to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the elements to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the elements to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the elements to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the elements to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the elements to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the elements to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the elements to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the elements to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the elements to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the elements to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the elements to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the elements to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the elements to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the elements to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the elements to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the elements to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the elements to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the elements to 0 if the row or col is 0\n        ## we iterate through the matrix again and set the elements to 0 if the row or col is 0\n        ## we iterate through the"}], "remove-nth-node-from-end-of-list": [{"task_id": "remove-nth-node-from-end-of-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # create a dummy node\n        dummy = ListNode(0)\n        dummy.next = head\n        \n        # create a slow and fast pointer\n        slow = dummy\n        fast = dummy\n        \n        # move the fast pointer n steps ahead\n        for i in range(n+1):\n            fast = fast.next\n        \n        # move both the slow and fast pointers until fast reaches the end\n        while fast:\n            slow = slow.next\n            fast = fast.next\n        \n        # remove the node at the nth position\n        slow.next = slow.next.next\n        \n        # return the modified linked list\n        return dummy.next"}], "intersection-of-two-arrays": [{"task_id": "intersection-of-two-arrays", "completion": "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        return list(set(nums1) & set(nums2))"}], "super-washing-machines": [{"task_id": "super-washing-machines", "completion": "class Solution(object):\n    def findMinMoves(self, machines):\n        \"\"\"\n        :type machines: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if sum(machines) % len(machines) != 0:\n            return -1\n        \n        avg = sum(machines) / len(machines)\n        ans = 0\n        curr = 0\n        \n        for i in machines:\n            curr += i - avg\n            ans = max(ans, abs(curr))\n        \n        return ans"}], "kth-smallest-number-in-multiplication-table": [{"task_id": "kth-smallest-number-in-multiplication-table", "completion": "class Solution(object):\n    def findKthNumber(self, m, n, k):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def get_count(x):\n            count = 0\n            for i in range(1, m + 1):\n                count += min(n, x // i)\n            return count\n        \n        low, high = 1, m * n\n        while low < high:\n            mid = (low + high) // 2\n            if get_count(mid) < k:\n                low = mid + 1\n            else:\n                high = mid\n        return low"}], "convert-sorted-list-to-binary-search-tree": [{"task_id": "convert-sorted-list-to-binary-search-tree", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return TreeNode(head.val)\n        \n        slow = fast = head\n        \n        while fast.next and fast.next.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        root = TreeNode(slow.next.val)\n        root.right = self.sortedListToBST(slow.next.next)\n        slow.next = None\n        root.left = self.sortedListToBST(head)\n        \n        return root"}], "merge-two-sorted-lists": [{"task_id": "merge-two-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: Optional[ListNode]\n        :type list2: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        \n        if list1 is None:\n            return list2\n        if list2 is None:\n            return list1\n        \n        if list1.val < list2.val:\n            head = list1\n            list1 = list1.next\n        else:\n            head = list2\n            list2 = list2.next\n        \n        curr = head\n        \n        while list1 is not None and list2 is not None:\n            if list1.val < list2.val:\n                curr.next = list1\n                list1 = list1.next\n            else:\n                curr.next = list2\n                list2 = list2.next\n            curr = curr.next\n        \n        if list1 is None:\n            curr.next = list2\n        else:\n            curr.next = list1\n        \n        return head"}], "maximal-rectangle": [{"task_id": "maximal-rectangle", "completion": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        heights = [0] * (n + 1)\n        max_area = 0\n        \n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == '1':\n                    heights[j] += 1\n                else:\n                    heights[j] = 0\n            max_area = max(max_area, self.largestRectangleArea(heights))\n        \n        return max_area\n    \n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        max_area = 0\n        \n        for i in range(len(heights)):\n            while stack and heights[stack[-1]] > heights[i]:\n                h = heights[stack.pop()]\n                w = i if not stack else i - stack[-1] - 1\n                max_area = max(max_area, h * w)\n            stack.append(i)\n        \n        while stack:\n            h = heights[stack.pop()]\n            w = len(heights) if not stack else len(heights) - stack[-1] - 1\n            max_area = max(max_area, h * w)\n        \n        return max_area"}], "subsets": [{"task_id": "subsets", "completion": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        res = [[]]\n        for num in nums:\n            res += [item + [num] for item in res]\n        return res"}], "find-minimum-in-rotated-sorted-array-ii": [{"task_id": "find-minimum-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # left, right = 0, len(nums) - 1\n        # while left < right:\n        #     mid = (left + right) // 2\n        #     if nums[mid] > nums[mid + 1]:\n        #         return nums[mid + 1]\n        #     if nums[mid - 1] > nums[mid]:\n        #         return nums[mid]\n        #     if nums[mid] < nums[right]:\n        #         right = mid - 1\n        #     else:\n        #         left = mid + 1\n        # return nums[left]\n        \n        # binary search\n        left, right = 0, len(nums) - 1\n        while left < right:\n            mid = (left + right) // 2\n            if nums[mid] > nums[right]:\n                left = mid + 1\n            elif nums[mid] < nums[right]:\n                right = mid\n            else:\n                right -= 1\n        return nums[left]"}], "valid-number": [{"task_id": "valid-number", "completion": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # 1. remove all spaces\n        s = s.strip()\n        \n        # 2. check if it is a valid number\n        if not s or s[0] not in '+-' and (s[0] not in '0123456789'):\n            return False\n        \n        # 3. check if it is a valid integer\n        if s[0] in '+-' and len(s) > 1:\n            s = s[1:]\n        if not s or s[0] not in '0123456789':\n            return False\n        \n        # 4. check if it is a valid decimal\n        if 'e' in s or 'E' in s:\n            s, exp = s.split('e')\n            if not s or s[0] not in '0123456789':\n                return False\n            if exp[0] in '+-' and len(exp) > 1:\n                exp = exp[1:]\n            if not exp or exp[0] not in '0123456789':\n                return False\n        \n        # 5. check if it is a valid float\n        if '.' in s:\n            s, dec = s.split('.')\n            if not s or s[0] not in '0123456789':\n                return False\n            if dec and dec[0] in '+-' and len(dec) > 1:\n                dec = dec[1:]\n            if not dec or dec[0] not in '0123456789':\n                return False\n        \n        return True"}], "integer-to-roman": [{"task_id": "integer-to-roman", "completion": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, II, III, IV, V, VI, VII, VIII, IX, X, XX, XXX, XL, L, XC, LX, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX"}], "find-the-difference": [{"task_id": "find-the-difference", "completion": "class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        ## Solution 1:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 12 ms, faster than 99.49% of Python online submissions for Find the Difference.\n        ## Memory Usage: 13.5 MB, less than 100.00% of Python online submissions for Find the Difference.\n        \n        ## Solution 2:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 4 ms, faster than 99.99% of Python online submissions for Find the Difference.\n        ## Memory Usage: 13.5 MB, less than 100.00% of Python online submissions for Find the Difference.\n        \n        ## Solution 3:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 4 ms, faster than 99.99% of Python online submissions for Find the Difference.\n        ## Memory Usage: 13.5 MB, less than 100.00% of Python online submissions for Find the Difference.\n        \n        ## Solution 4:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 4 ms, faster than 99.99% of Python online submissions for Find the Difference.\n        ## Memory Usage: 13.5 MB, less than 100.00% of Python online submissions for Find the Difference.\n        \n        ## Solution 5:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 4 ms, faster than 99.99% of Python online submissions for Find the Difference.\n        ## Memory Usage: 13.5 MB, less than 100.00% of Python online submissions for Find the Difference.\n        \n        ## Solution 6:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 4 ms, faster than 99.99% of Python online submissions for Find the Difference.\n        ## Memory Usage: 13.5 MB, less than 100.00% of Python online submissions for Find the Difference.\n        \n        ## Solution 7:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 4 ms, faster than 99.99% of Python online submissions for Find the Difference.\n        ## Memory Usage: 13.5 MB, less than 100.00% of Python online submissions for Find the Difference.\n        \n        ## Solution 8:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 4 ms, faster than 99.99% of Python online submissions for Find the Difference.\n        ## Memory Usage: 13.5 MB, less than 100.00% of Python online submissions for Find the Difference.\n        \n        ## Solution 9:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 4 ms, faster than 99.99% of Python online submissions for Find the Difference.\n        ## Memory Usage: 13.5 MB, less than 100.00% of Python online submissions for Find the Difference.\n        \n        ## Solution 10:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 4 ms, faster than 99.99% of Python online submissions for Find the Difference.\n        ## Memory Usage: 13.5 MB, less than 100.00% of Python online submissions for"}], "sudoku-solver": [{"task_id": "sudoku-solver", "completion": "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def find_empty_location(board, l):\n            for row in range(9):\n                for col in range(9):\n                    if board[row][col] == '.':\n                        l[0] = row\n                        l[1] = col\n                        return True\n            return False\n        \n        def used_in_row(board, row, num):\n            for col in range(9):\n                if board[row][col] == num:\n                    return True\n            return False\n        \n        def used_in_col(board, col, num):\n            for row in range(9):\n                if board[row][col] == num:\n                    return True\n            return False\n        \n        def used_in_box(board, box_start_row, box_start_col, num):\n            for row in range(3):\n                for col in range(3):\n                    if board[row+box_start_row][col+box_start_col] == num:\n                        return True\n            return False\n        \n        def is_valid(board, row, col, num):\n            return not used_in_row(board, row, num) and not used_in_col(board, col, num) and not used_in_box(board, row - row % 3, col - col % 3, num)\n        \n        def solve_sudoku(board):\n            l = [0, 0]\n            if not find_empty_location(board, l):\n                return True\n            \n            row = l[0]\n            col = l[1]\n            \n            for num in range(1, 10):\n                if is_valid(board, row, col, str(num)):\n                    board[row][col] = str(num)\n                    \n                    if solve_sudoku(board):\n                        return True\n                    \n                    board[row][col] = '.'\n            \n            return False\n        \n        solve_sudoku(board)"}], "recover-binary-search-tree": [{"task_id": "recover-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # find the first and second node\n        first = None\n        second = None\n        prev = None\n        \n        def inorder(root):\n            nonlocal first, second, prev\n            if not root:\n                return\n            \n            inorder(root.left)\n            \n            if prev and prev.val > root.val:\n                if not first:\n                    first = prev\n                second = root\n            \n            prev = root\n            inorder(root.right)\n        \n        inorder(root)\n        \n        # swap the values\n        first.val, second.val = second.val, first.val\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # find the first and second node\n        first = None\n        second = None\n        prev = None\n        \n        def inorder(root):\n            nonlocal first, second, prev\n            if not root:\n                return\n            \n            inorder(root.left)\n            \n            if prev and prev.val > root.val:\n                if not first:\n                    first = prev\n                second = root\n            \n            prev = root\n            inorder(root.right)\n        \n        inorder(root)\n        \n        # swap the values\n        first.val, second.val = second.val, first.val\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # find the first and second node\n        first = None\n        second = None\n        prev = None\n        \n        def inorder(root):\n            nonlocal first, second, prev\n            if not root:\n                return\n            \n            inorder(root.left)\n            \n            if prev and prev.val > root.val:\n                if not first:\n                    first = prev\n                second = root\n            \n            prev = root\n            inorder(root.right)\n        \n        inorder(root)\n        \n        # swap the values\n        first.val, second.val = second.val, first.val\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # find the first and second node\n        first = None\n        second = None\n        prev = None\n        \n        def inorder(root):\n            nonlocal first, second, prev\n            if not root:\n                return\n            \n            inorder(root.left)\n            \n            if prev and prev.val > root.val:\n                if not first:\n                    first = prev\n                second = root\n            \n            prev = root\n            inorder(root.right)\n        \n        inorder(root)\n        \n        # swap the values\n        first.val, second.val = second.val, first.val\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify"}], "palindrome-linked-list": [{"task_id": "palindrome-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        \n        # find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the list\n        prev = None\n        while slow:\n            nxt = slow.next\n            slow.next = prev\n            prev = slow\n            slow = nxt\n        \n        # compare the first half and the second half\n        while prev:\n            if head.val != prev.val:\n                return False\n            head = head.next\n            prev = prev.next\n        \n        return True"}], "valid-perfect-square": [{"task_id": "valid-perfect-square", "completion": "class Solution(object):\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        # 1. Binary Search\n        # 2. Math\n        # 3. Math\n        # 4. Math\n        # 5. Math\n        # 6. Math\n        # 7. Math\n        # 8. Math\n        # 9. Math\n        # 10. Math\n        # 11. Math\n        # 12. Math\n        # 13. Math\n        # 14. Math\n        # 15. Math\n        # 16. Math\n        # 17. Math\n        # 18. Math\n        # 19. Math\n        # 20. Math\n        # 21. Math\n        # 22. Math\n        # 23. Math\n        # 24. Math\n        # 25. Math\n        # 26. Math\n        # 27. Math\n        # 28. Math\n        # 29. Math\n        # 30. Math\n        # 31. Math\n        # 32. Math\n        # 33. Math\n        # 34. Math\n        # 35. Math\n        # 36. Math\n        # 37. Math\n        # 38. Math\n        # 39. Math\n        # 40. Math\n        # 41. Math\n        # 42. Math\n        # 43. Math\n        # 44. Math\n        # 45. Math\n        # 46. Math\n        # 47. Math\n        # 48. Math\n        # 49. Math\n        # 50. Math\n        # 51. Math\n        # 52. Math\n        # 53. Math\n        # 54. Math\n        # 55. Math\n        # 56. Math\n        # 57. Math\n        # 58. Math\n        # 59. Math\n        # 60. Math\n        # 61. Math\n        # 62. Math\n        # 63. Math\n        # 64. Math\n        # 65. Math\n        # 66. Math\n        # 67. Math\n        # 68. Math\n        # 69. Math\n        # 70. Math\n        # 71. Math\n        # 72. Math\n        # 73. Math\n        # 74. Math\n        # 75. Math\n        # 76. Math\n        # 77. Math\n        # 78. Math\n        # 79. Math\n        # 80. Math\n        # 81. Math\n        # 82. Math\n        # 83. Math\n        # 84. Math\n        # 85. Math\n        # 86. Math\n        # 87. Math\n        # 88. Math\n        # 89. Math\n        # 90. Math\n        # 91. Math\n        # 92. Math\n        # 93. Math\n        # 94. Math\n        # 95. Math\n        # 96. Math\n        # 97. Math\n        # 98. Math\n        # 99. Math\n        # 100. Math\n        # 101. Math\n        # 102. Math\n        # 103. Math\n        # 104. Math\n        # 105. Math\n        # 106. Math\n        # 107. Math\n        # 108. Math\n        # 109. Math\n        # 110. Math\n        # 111. Math\n        # 112. Math\n        # 113. Math\n        # 114. Math\n        # 115. Math\n        # 116. Math\n        # 117. Math\n        # 118. Math\n        # 119. Math\n        # 120. Math\n        # 121. Math\n        # 122. Math\n        # 123. Math\n        # 124. Math\n        # 125. Math\n        # 12"}], "counting-bits": [{"task_id": "counting-bits", "completion": "class Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}], "remove-linked-list-elements": [{"task_id": "remove-linked-list-elements", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        \n        while head and head.val == val:\n            head = head.next\n        \n        curr = head\n        \n        while curr and curr.next:\n            if curr.next.val == val:\n                curr.next = curr.next.next\n            else:\n                curr = curr.next\n        \n        return head"}], "scramble-string": [{"task_id": "scramble-string", "completion": "class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) != len(s2):\n            return False\n        \n        if s1 == s2:\n            return True\n        \n        if sorted(s1) != sorted(s2):\n            return False\n        \n        for i in range(1, len(s1)):\n            if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):\n                return True\n            \n            if self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i]):\n                return True\n        \n        return False"}], "simplify-path": [{"task_id": "simplify-path", "completion": "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        \n        stack = []\n        for p in path.split('/'):\n            if p == '..':\n                if stack:\n                    stack.pop()\n            elif p and p != '.':\n                stack.append(p)\n        return '/' + '/'.join(stack)"}], "word-search-ii": [{"task_id": "word-search-ii", "completion": "class Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(i, j, node):\n            if node not in node.children:\n                return False\n            char = board[i][j]\n            node = node.children[char]\n            if '*' in node:\n                res.add(node['*'])\n            board[i][j] = '#'\n            for x, y in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]:\n                if 0 <= x < m and 0 <= y < n and board[x][y] != '#':\n                    dfs(x, y, node)\n            board[i][j] = char\n            return True\n        \n        res = set()\n        m, n = len(board), len(board[0])\n        trie = {}\n        for word in words:\n            node = trie\n            for char in word:\n                if char not in node:\n                    node[char] = {}\n                node = node[char]\n            node['*'] = word\n        \n        for i in range(m):\n            for j in range(n):\n                if board[i][j] in trie:\n                    dfs(i, j, trie)\n        \n        return list(res)"}], "valid-anagram": [{"task_id": "valid-anagram", "completion": "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_dict = {}\n        t_dict = {}\n        \n        for i in range(len(s)):\n            s_dict[s[i]] = 1 + s_dict.get(s[i], 0)\n            t_dict[t[i]] = 1 + t_dict.get(t[i], 0)\n        \n        for key in s_dict:\n            if s_dict[key] != t_dict.get(key, 0):\n                return False\n        \n        return True"}], "valid-sudoku": [{"task_id": "valid-sudoku", "completion": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        # check rows\n        for row in board:\n            if len(set(row)) != len(row):\n                return False\n        \n        # check columns\n        for col in zip(*board):\n            if len(set(col)) != len(col):\n                return False\n        \n        # check 3x3 sub-boxes\n        for i in (0, 3, 6):\n            for j in (0, 3, 6):\n                box = [board[x][y] for x in (i, i + 1, i + 2) for y in (j, j + 1, j + 2)]\n                if len(set(box)) != len(box):\n                    return False\n        \n        return True"}], "fizz-buzz": [{"task_id": "fizz-buzz", "completion": "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        ans = []\n        for i in range(1, n+1):\n            if i % 3 == 0 and i % 5 == 0:\n                ans.append(\"FizzBuzz\")\n            elif i % 3 == 0:\n                ans.append(\"Fizz\")\n            elif i % 5 == 0:\n                ans.append(\"Buzz\")\n            else:\n                ans.append(str(i))\n        return ans"}], "reverse-words-in-a-string": [{"task_id": "reverse-words-in-a-string", "completion": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        return \" \".join(s.split()[::-1])"}], "excel-sheet-column-number": [{"task_id": "excel-sheet-column-number", "completion": "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        \"\"\"\n        :type columnTitle: str\n        :rtype: int\n        \"\"\"\n        \n        # 26^0 = 1\n        # 26^1 = 26\n        # 26^2 = 676\n        # 26^3 = 17576\n        # 26^4 = 488384\n        # 26^5 = 14594364\n        # 26^6 = 45296176\n        # 26^7 = 137846528\n        # 26^8 = 429496729\n        # 26^9 = 1258291320\n        # 26^10 = 3874204896\n        # 26^11 = 11622614656\n        # 26^12 = 34867844016\n        # 26^13 = 103689018624\n        # 26^14 = 314572696320\n        # 26^15 = 943718553600\n        # 26^16 = 2824295036416\n        # 26^17 = 8589934592\n        # 26^18 = 25769803776\n        # 26^19 = 77529654720\n        # 26^20 = 230410240000\n        # 26^21 = 691230924800\n        # 26^22 = 2073741824000\n        # 26^23 = 5764607520000\n        # 26^24 = 17297613600000\n        # 26^25 = 49152320000000\n        # 26^26 = 147453600000000\n        # 26^27 = 441178560000000\n        # 26^28 = 1284536000000000\n        # 26^29 = 3842009600000000\n        # 26^30 = 11529215040000000\n        # 26^31 = 34914240000000000\n        # 26^32 = 104857600000000000\n        # 26^33 = 314572800000000000\n        # 26^34 = 943718400000000000\n        # 26^35 = 2824294400000000000\n        # 26^36 = 8589934400000000000\n        # 26^37 = 25769804000000000000\n        # 26^38 = 7752960000000000000\n        # 26^39 = 23041024000000000000\n        # 26^40 = 6912309248000000000\n        # 26^41 = 20737418240000000000\n        # 26^42 = 5764607520000000000\n        # 26^43 = 17297613600000000000\n        # 26^44 = 49152320"}], "candy": [{"task_id": "candy", "completion": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(ratings)\n        candies = [1] * n\n        \n        for i in range(1, n):\n            if ratings[i] > ratings[i - 1]:\n                candies[i] = candies[i - 1] + 1\n        \n        for i in range(n - 2, -1, -1):\n            if ratings[i] > ratings[i + 1]:\n                candies[i] = max(candies[i], candies[i + 1] + 1)\n        \n        return sum(candies)"}], "same-tree": [{"task_id": "same-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if p is None and q is None:\n            return True\n        elif p is None or q is None:\n            return False\n        elif p.val != q.val:\n            return False\n        else:\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)"}], "reorder-list": [{"task_id": "reorder-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reorderList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: None Do not return anything, modify head in-place instead.\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        # find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the list\n        prev = None\n        while slow:\n            next = slow.next\n            slow.next = prev\n            prev = slow\n            slow = next\n        \n        # merge the first and second halves\n        first, second = head, prev\n        while second.next:\n            first, second = first.next, second.next\n        \n        return first"}], "word-pattern": [{"task_id": "word-pattern", "completion": "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # check if the number of words is not equal to the number of letters in the pattern\n        if len(words) != len(pattern):\n            return False\n        \n        # create a dictionary to store the mapping between letters and words\n        mapping = {}\n        \n        # iterate over the pattern and words\n        for letter, word in zip(pattern, words):\n            # check if the letter is already in the dictionary\n            if letter in mapping:\n                # check if the word is not the same as the word associated with the letter\n                if mapping[letter] != word:\n                    return False\n            # add the letter and word to the dictionary\n            else:\n                mapping[letter] = word\n        \n        # return True if the pattern and words are mapped correctly\n        return True"}], "permutations": [{"task_id": "permutations", "completion": "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if len(nums) == 1:\n            return [nums]\n        \n        res = []\n        for i in range(len(nums)):\n            for j in self.permute(nums[:i] + nums[i+1:]):\n                res.append([nums[i]] + j)\n        return res"}], "search-a-2d-matrix": [{"task_id": "search-a-2d-matrix", "completion": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        low = 0\n        high = m * n - 1\n        \n        while low <= high:\n            mid = (low + high) // 2\n            if matrix[mid // n][mid % n] == target:\n                return True\n            elif matrix[mid // n][mid % n] < target:\n                low = mid + 1\n            else:\n                high = mid - 1\n        \n        return False"}], "add-two-numbers": [{"task_id": "add-two-numbers", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # create a dummy node\n        dummy = ListNode()\n        # create a pointer to the dummy node\n        curr = dummy\n        # create a variable to store the carry over\n        carry = 0\n        \n        # loop until both lists are empty\n        while l1 or l2 or carry:\n            # if l1 is empty, set sum to 0\n            if not l1:\n                sum = 0\n            # if l2 is empty, set sum to 0\n            elif not l2:\n                sum = 0\n            # otherwise, add the values of l1 and l2\n            else:\n                sum = l1.val + l2.val\n            # add the carry over to the sum\n            sum += carry\n            # set carry to the sum divided by 10\n            carry = sum // 10\n            # set the value of the current node to the sum modulo 10\n            curr.next = ListNode(sum % 10)\n            # move the current node to the next node\n            curr = curr.next\n            # move the lists to the next node\n            l1 = l1.next if l1 else None\n            l2 = l2.next if l2 else None\n            \n        # return the dummy node's next node\n        return dummy.next"}], "number-complement": [{"task_id": "number-complement", "completion": "class Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        ## 1. convert to binary\n        ## 2. flip bits\n        ## 3. convert back to decimal\n        \n        ## 1. convert to binary\n        binary = bin(num)[2:]\n        \n        ## 2. flip bits\n        flip_bits = \"\"\n        for bit in binary:\n            if bit == \"1\":\n                flip_bits += \"0\"\n            else:\n                flip_bits += \"1\"\n        \n        ## 3. convert back to decimal\n        return int(flip_bits, 2)"}], "arithmetic-slices-ii-subsequence": [{"task_id": "arithmetic-slices-ii-subsequence", "completion": "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 3:\n            return 0\n        \n        count = 0\n        diff = nums[1] - nums[0]\n        for i in range(1, len(nums)-1):\n            if nums[i+1] - nums[i] == diff:\n                count += 1\n            else:\n                diff = nums[i+1] - nums[i]\n        \n        return count"}], "text-justification": [{"task_id": "text-justification", "completion": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        \n        res = []\n        cur_len = 0\n        cur_words = []\n        \n        for word in words:\n            if cur_len + len(word) + len(cur_words) > maxWidth:\n                if len(cur_words) == 1:\n                    res.append(cur_words[0] + ' ' * (maxWidth - cur_len))\n                else:\n                    spaces = (maxWidth - cur_len) // (len(cur_words) - 1)\n                    extra = (maxWidth - cur_len) % (len(cur_words) - 1)\n                    res.append(''.join([cur_words[i] + ' ' * spaces + (' ' if i < extra else '') for i in range(len(cur_words))]))\n                cur_len = 0\n                cur_words = []\n            cur_len += len(word)\n            cur_words.append(word)\n        if cur_len:\n            res.append(' '.join(cur_words) + ' ' * (maxWidth - cur_len - len(cur_words) + 1))\n        return res"}], "binary-tree-postorder-traversal": [{"task_id": "binary-tree-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = [root]\n        result = []\n        \n        while stack:\n            node = stack.pop()\n            result.append(node.val)\n            \n            if node.left:\n                stack.append(node.left)\n                \n            if node.right:\n                stack.append(node.right)\n                \n        return result[::-1]"}], "container-with-most-water": [{"task_id": "container-with-most-water", "completion": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # two pointers\n        # left, right = 0, len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # two pointers\n        # left, right = 0, len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # two pointers\n        # left, right = 0, len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # two pointers\n        # left, right = 0, len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # two pointers\n        # left, right = 0, len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # two pointers\n        # left, right = 0, len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # two pointers\n        # left, right = 0, len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # two pointers\n        # left, right = 0, len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * (right - left)\n        #     max_area = max(max_area, area)\n        #     if height[left] < height[right]:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        # return max_area\n        \n        # two pointers\n        # left, right = 0, len(height) - 1\n        # max_area = 0\n        # while left < right:\n        #     area = min(height[left], height[right]) * ("}], "concatenated-words": [{"task_id": "concatenated-words", "completion": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # create a set of words\n        word_set = set(words)\n        \n        # create a list of concatenated words\n        concatenated_words = []\n        \n        # iterate through each word in the list\n        for word in words:\n            # create a flag to indicate if the word is concatenated\n            is_concatenated = False\n            \n            # iterate through each word in the set\n            for i in range(len(word)):\n                # check if the substring of the word is in the set\n                if word[:i] in word_set:\n                    # check if the substring of the word is in the set\n                    if word[i:] in word_set or (i < len(word) - 1 and word[i+1:] in word_set):\n                        # set the flag to True\n                        is_concatenated = True\n                        break\n            \n            # if the word is concatenated, add it to the list\n            if is_concatenated:\n                concatenated_words.append(word)\n        \n        # return the list of concatenated words\n        return concatenated_words"}], "base-7": [{"task_id": "base-7", "completion": "class Solution(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return '0'\n        \n        if num < 0:\n            return '-' + self.convertToBase7(-num)\n        \n        res = ''\n        while num:\n            res = str(num % 7) + res\n            num //= 7\n        \n        return res"}], "nim-game": [{"task_id": "nim-game", "completion": "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        return n % 4 != 0"}], "n-queens-ii": [{"task_id": "n-queens-ii", "completion": "class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        def backtrack(row, cols, pie, na, n):\n            if row == n:\n                return 1\n            \n            count = 0\n            for col in range(n):\n                if col not in cols and row + col not in pie and row - col not in na:\n                    count += backtrack(row + 1, cols | {col}, pie | {row + col}, na | {row - col}, n)\n            return count\n        \n        return backtrack(0, set(), set(), set(), n)"}], "n-queens": [{"task_id": "n-queens", "completion": "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def is_valid(board, row, col):\n            for i in range(row):\n                if board[i][col] == 'Q':\n                    return False\n            i, j = row - 1, col - 1\n            while i >= 0 and j >= 0:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j -= 1\n            i, j = row - 1, col + 1\n            while i >= 0 and j < n:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j += 1\n            return True\n        \n        def backtrack(board, row):\n            if row == n:\n                res.append([''.join(row) for row in board])\n                return\n            for col in range(n):\n                if is_valid(board, row, col):\n                    board[row][col] = 'Q'\n                    backtrack(board, row + 1)\n                    board[row][col] = '.'\n        \n        res = []\n        board = [['.'] * n for _ in range(n)]\n        backtrack(board, 0)\n        return res"}], "word-search": [{"task_id": "word-search", "completion": "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(i, j, k):\n            if k == len(word):\n                return True\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[k]:\n                return False\n            board[i][j] = '#'\n            res = dfs(i + 1, j, k + 1) or dfs(i - 1, j, k + 1) or dfs(i, j + 1, k + 1) or dfs(i, j - 1, k + 1)\n            board[i][j] = word[k]\n            return res\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if dfs(i, j, 0):\n                    return True\n        return False"}], "merge-sorted-array": [{"task_id": "merge-sorted-array", "completion": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        \n        # nums1[m:] = nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums1[:m] + nums2[:n]\n        # nums1.sort()\n        \n        # nums1[:m] = nums"}], "third-maximum-number": [{"task_id": "third-maximum-number", "completion": "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. sort the list\n        # 2. if the list has less than 3 elements, return the max element\n        # 3. else return the third element\n        \n        nums = sorted(set(nums))\n        if len(nums) < 3:\n            return nums[-1]\n        else:\n            return nums[-3]"}]}