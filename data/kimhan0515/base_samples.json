{"spiral-matrix": [{"task_id": "spiral-matrix", "completion": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not matrix:\n            return []\n        \n        m, n = len(matrix), len(matrix[0])\n        visited = [[False] * n for _ in range(m)]\n        ans = []\n        dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        dir_idx = 0\n        i, j = 0, 0\n        for _ in range(m * n):\n            ans.append(matrix[i][j])\n            visited[i][j] = True\n            nxt_i, nxt_j = i + dirs[dir_idx][0], j + dirs[dir_idx][1]\n            if 0 <= nxt_i < m and 0 <= nxt_j < n and not visited[nxt_i][nxt_j]:\n                i, j = nxt_i, nxt_j\n            else:\n                dir_idx = (dir_idx + 1) % 4\n                i, j = i + dirs[dir_idx][0], j + dirs[dir_idx][1]\n        return ans"}, {"task_id": "spiral-matrix", "completion": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not matrix:\n            return []\n        \n        m, n = len(matrix), len(matrix[0])\n        visited = [[False] * n for _ in range(m)]\n        ans = []\n        dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        dir_idx = 0\n        i, j = 0, 0\n        for _ in range(m * n):\n            ans.append(matrix[i][j])\n            visited[i][j] = True\n            nxt_i, nxt_j = i + dirs[dir_idx][0], j + dirs[dir_idx][1]\n            if 0 <= nxt_i < m and 0 <= nxt_j < n and not visited[nxt_i][nxt_j]:\n                i, j = nxt_i, nxt_j\n            else:\n                dir_idx = (dir_idx + 1) % 4\n                i, j = i + dirs[dir_idx][0], j + dirs[dir_idx][1]\n        return ans"}, {"task_id": "spiral-matrix", "completion": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not matrix:\n            return []\n        \n        m, n = len(matrix), len(matrix[0])\n        visited = [[False] * n for _ in range(m)]\n        ans = []\n        dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        dir_idx = 0\n        i, j = 0, 0\n        for _ in range(m * n):\n            ans.append(matrix[i][j])\n            visited[i][j] = True\n            nxt_i, nxt_j = i + dirs[dir_idx][0], j + dirs[dir_idx][1]\n            if 0 <= nxt_i < m and 0 <= nxt_j < n and not visited[nxt_i][nxt_j]:\n                i, j = nxt_i, nxt_j\n            else:\n                dir_idx = (dir_idx + 1) % 4\n                i, j = i + dirs[dir_idx][0], j + dirs[dir_idx][1]\n        return ans"}, {"task_id": "spiral-matrix", "completion": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not matrix:\n            return []\n        \n        m, n = len(matrix), len(matrix[0])\n        visited = [[False] * n for _ in range(m)]\n        ans = []\n        dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        dir_idx = 0\n        i, j = 0, 0\n        for _ in range(m * n):\n            ans.append(matrix[i][j])\n            visited[i][j] = True\n            next_i, next_j = i + dirs[dir_idx][0], j + dirs[dir_idx][1]\n            if 0 <= next_i < m and 0 <= next_j < n and not visited[next_i][next_j]:\n                i, j = next_i, next_j\n            else:\n                dir_idx = (dir_idx + 1) % 4\n                i, j = i + dirs[dir_idx][0], j + dirs[dir_idx][1]\n        return ans"}, {"task_id": "spiral-matrix", "completion": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not matrix:\n            return []\n        \n        m, n = len(matrix), len(matrix[0])\n        visited = [[False] * n for _ in range(m)]\n        ans = []\n        dirs = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n        dir_idx = 0\n        i, j = 0, 0\n        for _ in range(m * n):\n            ans.append(matrix[i][j])\n            visited[i][j] = True\n            nxt_i, nxt_j = i + dirs[dir_idx][0], j + dirs[dir_idx][1]\n            if 0 <= nxt_i < m and 0 <= nxt_j < n and not visited[nxt_i][nxt_j]:\n                i, j = nxt_i, nxt_j\n            else:\n                dir_idx = (dir_idx + 1) % 4\n                i, j = i + dirs[dir_idx][0], j + dirs[dir_idx][1]\n        return ans"}], "summary-ranges": [{"task_id": "summary-ranges", "completion": "class Solution(object):\n    def summaryRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(nums) == 0:\n            return []\n        \n        if len(nums) == 1:\n            return [str(nums[0])]\n        \n        start = nums[0]\n        end = nums[0]\n        res = []\n        \n        for i in range(1, len(nums)):\n            if nums[i] == end + 1:\n                end = nums[i]\n            else:\n                if start == end:\n                    res.append(str(start))\n                else:\n                    res.append(str(start) + \"->\" + str(end))\n                start = nums[i]\n                end = nums[i]\n        \n        if start == end:\n            res.append(str(start))\n        else:\n            res.append(str(start) + \"->\" + str(end))\n        \n        return res"}, {"task_id": "summary-ranges", "completion": "class Solution(object):\n    def summaryRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(nums) == 0:\n            return []\n        \n        if len(nums) == 1:\n            return [str(nums[0])]\n        \n        res = []\n        start = nums[0]\n        end = nums[0]\n        \n        for i in range(1, len(nums)):\n            if nums[i] == end + 1:\n                end = nums[i]\n            else:\n                if start == end:\n                    res.append(str(start))\n                else:\n                    res.append(str(start) + \"->\" + str(end))\n                start = nums[i]\n                end = nums[i]\n        \n        if start == end:\n            res.append(str(start))\n        else:\n            res.append(str(start) + \"->\" + str(end))\n        \n        return res"}, {"task_id": "summary-ranges", "completion": "class Solution(object):\n    def summaryRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(nums) == 0:\n            return []\n        \n        if len(nums) == 1:\n            return [str(nums[0])]\n        \n        res = []\n        start = nums[0]\n        end = nums[0]\n        \n        for i in range(1, len(nums)):\n            if nums[i] == end + 1:\n                end = nums[i]\n            else:\n                if start == end:\n                    res.append(str(start))\n                else:\n                    res.append(str(start) + \"->\" + str(end))\n                start = nums[i]\n                end = nums[i]\n        \n        if start == end:\n            res.append(str(start))\n        else:\n            res.append(str(start) + \"->\" + str(end))\n        \n        return res"}, {"task_id": "summary-ranges", "completion": "class Solution(object):\n    def summaryRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(nums) == 0:\n            return []\n        \n        if len(nums) == 1:\n            return [str(nums[0])]\n        \n        start = 0\n        end = 0\n        res = []\n        \n        for i in range(1, len(nums)):\n            if nums[i] == nums[i-1] + 1:\n                end = i\n            else:\n                if start == end:\n                    res.append(str(nums[start]))\n                else:\n                    res.append(str(nums[start]) + \"->\" + str(nums[end]))\n                start = i\n                end = i\n        \n        if start == end:\n            res.append(str(nums[start]))\n        else:\n            res.append(str(nums[start]) + \"->\" + str(nums[end]))\n        \n        return res"}, {"task_id": "summary-ranges", "completion": "class Solution(object):\n    def summaryRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(nums) == 0:\n            return []\n        \n        if len(nums) == 1:\n            return [str(nums[0])]\n        \n        res = []\n        start = nums[0]\n        end = nums[0]\n        \n        for i in range(1, len(nums)):\n            if nums[i] == end + 1:\n                end = nums[i]\n            else:\n                if start == end:\n                    res.append(str(start))\n                else:\n                    res.append(str(start) + \"->\" + str(end))\n                start = nums[i]\n                end = nums[i]\n        \n        if start == end:\n            res.append(str(start))\n        else:\n            res.append(str(start) + \"->\" + str(end))\n        \n        return res"}], "distinct-subsequences": [{"task_id": "distinct-subsequences", "completion": "class Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        \n        dp = [[0] * (len(t) + 1) for _ in range(len(s) + 1)]\n        \n        for i in range(len(s) + 1):\n            dp[i][0] = 1\n        \n        for i in range(1, len(s) + 1):\n            for j in range(1, len(t) + 1):\n                if s[i - 1] == t[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n                else:\n                    dp[i][j] = dp[i - 1][j]\n        \n        return dp[-1][-1]"}, {"task_id": "distinct-subsequences", "completion": "class Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        \n        dp = [[0] * (len(t) + 1) for _ in range(len(s) + 1)]\n        \n        for i in range(len(s) + 1):\n            dp[i][0] = 1\n        \n        for i in range(1, len(s) + 1):\n            for j in range(1, len(t) + 1):\n                if s[i - 1] == t[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n                else:\n                    dp[i][j] = dp[i - 1][j]\n        \n        return dp[-1][-1]"}, {"task_id": "distinct-subsequences", "completion": "class Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        \n        dp = [[0] * (len(t) + 1) for _ in range(len(s) + 1)]\n        \n        for i in range(len(s) + 1):\n            dp[i][0] = 1\n        \n        for i in range(1, len(s) + 1):\n            for j in range(1, len(t) + 1):\n                if s[i - 1] == t[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n                else:\n                    dp[i][j] = dp[i - 1][j]\n        \n        return dp[-1][-1]"}, {"task_id": "distinct-subsequences", "completion": "class Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        \n        dp = [[0] * (len(t) + 1) for _ in range(len(s) + 1)]\n        \n        for i in range(len(s) + 1):\n            dp[i][0] = 1\n        \n        for i in range(1, len(s) + 1):\n            for j in range(1, len(t) + 1):\n                if s[i - 1] == t[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n                else:\n                    dp[i][j] = dp[i - 1][j]\n        \n        return dp[-1][-1]"}, {"task_id": "distinct-subsequences", "completion": "class Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        \n        dp = [[0] * (len(t) + 1) for _ in range(len(s) + 1)]\n        \n        for i in range(len(s) + 1):\n            dp[i][0] = 1\n        \n        for i in range(1, len(s) + 1):\n            for j in range(1, len(t) + 1):\n                if s[i - 1] == t[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n                else:\n                    dp[i][j] = dp[i - 1][j]\n        \n        return dp[-1][-1]"}], "first-missing-positive": [{"task_id": "first-missing-positive", "completion": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. convert all negative numbers to positive numbers\n        ## 2. convert all numbers to their corresponding index\n        ## 3. iterate through the array and check if the index is valid\n        ## 4. if the index is valid, check if the number at that index is valid\n        ## 5. if the number at that index is valid, mark it as negative\n        ## 6. iterate through the array again and find the first positive number\n        ## 7. return the index of that number\n        \n        ## 1. convert all negative numbers to positive numbers\n        for i in range(len(nums)):\n            if nums[i] < 0:\n                nums[i] = 0\n                \n        ## 2. convert all numbers to their corresponding index\n        for i in range(len(nums)):\n            if nums[i] > 0:\n                nums[nums[i] - 1] = nums[i]\n                \n        ## 3. iterate through the array and check if the index is valid\n        for i in range(len(nums)):\n            if nums[i] != i + 1:\n                return i + 1\n                \n        ## 4. if the index is valid, check if the number at that index is valid\n        return len(nums) + 1"}, {"task_id": "first-missing-positive", "completion": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. check if the array is empty\n        if not nums:\n            return 1\n        \n        ## 2. check if the array contains 0\n        if 0 in nums:\n            return 1\n        \n        ## 3. check if the array contains negative numbers\n        if any(num < 0 for num in nums):\n            return 1\n        \n        ## 4. check if the array contains 0\n        if 0 in nums:\n            return 1\n        \n        ## 5. check if the array contains 1\n        if 1 in nums:\n            return 1\n        \n        ## 6. check if the array contains 2\n        if 2 in nums:\n            return 1\n        \n        ## 7. check if the array contains 3\n        if 3 in nums:\n            return 1\n        \n        ## 8. check if the array contains 4\n        if 4 in nums:\n            return 1\n        \n        ## 9. check if the array contains 5\n        if 5 in nums:\n            return 1\n        \n        ## 10. check if the array contains 6\n        if 6 in nums:\n            return 1\n        \n        ## 11. check if the array contains 7\n        if 7 in nums:\n            return 1\n        \n        ## 12. check if the array contains 8\n        if 8 in nums:\n            return 1\n        \n        ## 13. check if the array contains 9\n        if 9 in nums:\n            return 1\n        \n        ## 14. check if the array contains 10\n        if 10 in nums:\n            return 1\n        \n        ## 15. check if the array contains 11\n        if 11 in nums:\n            return 1\n        \n        ## 16. check if the array contains 12\n        if 12 in nums:\n            return 1\n        \n        ## 17. check if the array contains 13\n        if 13 in nums:\n            return 1\n        \n        ## 18. check if the array contains 14\n        if 14 in nums:\n            return 1\n        \n        ## 19. check if the array contains 15\n        if 15 in nums:\n            return 1\n        \n        ## 20. check if the array contains 16\n        if 16 in nums:\n            return 1\n        \n        ## 21. check if the array contains 17\n        if 17 in nums:\n            return 1\n        \n        ## 22. check if the array contains 18\n        if 18 in nums:\n            return 1\n        \n        ## 23. check if the array contains 19\n        if 19 in nums:\n            return 1\n        \n        ## 24. check if the array contains 20\n        if 20 in nums:\n            return 1\n        \n        ## 25. check if the array contains 21\n        if 21 in nums:\n            return 1\n        \n        ## 26. check if the array contains 22\n        if 22 in nums:\n            return 1\n        \n        ## 27. check if the array contains 23\n        if 23 in nums:\n            return 1\n        \n        ## 28. check if the array contains 24\n        if 24 in nums:\n            return 1\n        \n        ## 29. check if the array contains 25\n        if 25 in nums:\n            return 1\n        \n        ## 30. check if the array contains 26\n        if 26 in nums:\n            return 1\n        \n        ## 31. check if the array contains 27\n        if 27 in nums:\n            return 1\n        \n        ## 32. check if the array contains 28\n        if 28 in nums:\n            return 1"}, {"task_id": "first-missing-positive", "completion": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Sort the array\n        ## 2. Iterate through the array and check if the current number is positive and less than the length of the array\n        ## 3. If the current number is positive and less than the length of the array, check if the current number is equal to the index of the current number\n        ## 4. If the current number is positive and less than the length of the array, and the current number is equal to the index of the current number, return the current number\n        ## 5. If the current number is positive and less than the length of the array, and the current number is not equal to the index of the current number, return the current number\n        ## 6. If the current number is positive and less than the length of the array, and the current number is not equal to the index of the current number, return the current number + 1\n        ## 7. If the current number is positive and less than the length of the array, and the current number is equal to the length of the array, return the current number + 1\n        ## 8. If the current number is positive and less than the length of the array, and the current number is equal to the length of the array, return the current number + 1\n        ## 9. If the current number is positive and less than the length of the array, and the current number is equal to the length of the array, return the current number + 1\n        ## 10. If the current number is positive and less than the length of the array, and the current number is equal to the length of the array, return the current number + 1\n        ## 11. If the current number is positive and less than the length of the array, and the current number is equal to the length of the array, return the current number + 1\n        ## 12. If the current number is positive and less than the length of the array, and the current number is equal to the length of the array, return the current number + 1\n        ## 13. If the current number is positive and less than the length of the array, and the current number is equal to the length of the array, return the current number + 1\n        ## 14. If the current number is positive and less than the length of the array, and the current number is equal to the length of the array, return the current number + 1\n        ## 15. If the current number is positive and less than the length of the array, and the current number is equal to the length of the array, return the current number + 1\n        ## 16. If the current number is positive and less than the length of the array, and the current number is equal to the length of the array, return the current number + 1\n        ## 17. If the current number is positive and less than the length of the array, and the current number is equal to the length of the array, return the current number + 1\n        ## 18. If the current number is positive and less than the length of the array, and the current number is equal to the length of the array, return the current number + 1\n        ## 19. If the current number is positive and less than the length of the array, and the current number is equal to the length of the array, return the current number + 1\n        ## 20. If the current number is positive and less than the length of the array, and the current number is equal to the length of the array, return the current number + 1\n        ## 21. If the current number is positive and less than the length of the array, and the current number is equal to the length of the array, return the current number + 1\n        ## 22. If the current number is positive and less than the length of the array, and the current number is equal to the length of the array, return the current number + 1\n        ## 23. If the current number is positive and less than the length of the array, and the current number is equal to the length of the array, return the current number + 1\n        ## 24. If the current number is positive and less than the length of the array, and the current number is equal to the length of the array, return the current number + 1\n        ## 25. If the current number is positive and less than the length of the array, and the current number is equal to the length of the array, return the current number + 1\n        ## 26. If the current number is positive and less than the length of the array, and the current number is equal to the length"}, {"task_id": "first-missing-positive", "completion": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. check if the array is empty\n        if not nums:\n            return 1\n        \n        # 2. check if the array contains only negative numbers\n        if all(num < 0 for num in nums):\n            return 1\n        \n        # 3. check if the array contains only positive numbers\n        if all(num > 0 for num in nums):\n            return nums[-1] + 1\n        \n        # 4. check if the array contains only 1\n        if len(set(nums)) == 1:\n            return 2\n        \n        # 5. check if the array contains only 2\n        if len(set(nums)) == 2:\n            return 1\n        \n        # 6. check if the array contains only 3\n        if len(set(nums)) == 3:\n            return 2\n        \n        # 7. check if the array contains only 4\n        if len(set(nums)) == 4:\n            return 3\n        \n        # 8. check if the array contains only 5\n        if len(set(nums)) == 5:\n            return 4\n        \n        # 9. check if the array contains only 6\n        if len(set(nums)) == 6:\n            return 5\n        \n        # 10. check if the array contains only 7\n        if len(set(nums)) == 7:\n            return 6\n        \n        # 11. check if the array contains only 8\n        if len(set(nums)) == 8:\n            return 7\n        \n        # 12. check if the array contains only 9\n        if len(set(nums)) == 9:\n            return 8\n        \n        # 13. check if the array contains only 10\n        if len(set(nums)) == 10:\n            return 9\n        \n        # 14. check if the array contains only 11\n        if len(set(nums)) == 11:\n            return 10\n        \n        # 15. check if the array contains only 12\n        if len(set(nums)) == 12:\n            return 11\n        \n        # 16. check if the array contains only 13\n        if len(set(nums)) == 13:\n            return 12\n        \n        # 17. check if the array contains only 14\n        if len(set(nums)) == 14:\n            return 13\n        \n        # 18. check if the array contains only 15\n        if len(set(nums)) == 15:\n            return 14\n        \n        # 19. check if the array contains only 16\n        if len(set(nums)) == 16:\n            return 15\n        \n        # 20. check if the array contains only 17\n        if len(set(nums)) == 17:\n            return 16\n        \n        # 21. check if the array contains only 18\n        if len(set(nums)) == 18:\n            return 17\n        \n        # 22. check if the array contains only 19\n        if len(set(nums)) == 19:\n            return 18\n        \n        # 23. check if the array contains only 20\n        if len(set(nums)) == 20:\n            return 19\n        \n        # 24. check if the array contains only 21\n        if len(set(nums)) == 21:\n            return 20\n        \n        # 25. check if the array contains only 22\n        if len(set(nums)) == 22:\n            return 21\n        \n        # 26. check if the array contains only 23\n        if len(set(nums)) == 23:\n            return 22\n        \n        # 27. check if the array contains only 24\n        if len(set(nums)) == 24:\n            return 23\n        \n        # 28. check if the array contains only 25\n        if len(set(nums)) == 25:\n            return 24\n        \n        # 29. check"}, {"task_id": "first-missing-positive", "completion": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. Sort the array\n        # 2. Find the first positive number\n        # 3. Iterate through the array and check if the number is in the range [1, len(nums)]\n        # 4. If not, return the number\n        \n        nums.sort()\n        for i in range(1, len(nums) + 1):\n            if i not in nums:\n                return i\n        return len(nums) + 1"}], "permutation-sequence": [{"task_id": "permutation-sequence", "completion": "class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 1.1 generate all permutations of 1, 2, ..., n\n        # 1.2 generate all permutations of 1, 2, ..., n\n        # 1.3 generate all permutations of 1, 2, ..., n\n        # 1.4 generate all permutations of 1, 2, ..., n\n        # 1.5 generate all permutations of 1, 2, ..., n\n        # 1.6 generate all permutations of 1, 2, ..., n\n        # 1.7 generate all permutations of 1, 2, ..., n\n        # 1.8 generate all permutations of 1, 2, ..., n\n        # 1.9 generate all permutations of 1, 2, ..., n\n        # 1.10 generate all permutations of 1, 2, ..., n\n        # 1.11 generate all permutations of 1, 2, ..., n\n        # 1.12 generate all permutations of 1, 2, ..., n\n        # 1.13 generate all permutations of 1, 2, ..., n\n        # 1.14 generate all permutations of 1, 2, ..., n\n        # 1.15 generate all permutations of 1, 2, ..., n\n        # 1.16 generate all permutations of 1, 2, ..., n\n        # 1.17 generate all permutations of 1, 2, ..., n\n        # 1.18 generate all permutations of 1, 2, ..., n\n        # 1.19 generate all permutations of 1, 2, ..., n\n        # 1.20 generate all permutations of 1, 2, ..., n\n        # 1.21 generate all permutations of 1, 2, ..., n\n        # 1.22 generate all permutations of 1, 2, ..., n\n        # 1.23 generate all permutations of 1, 2, ..., n\n        # 1.24 generate all permutations of 1, 2, ..., n\n        # 1.25 generate all permutations of 1, 2, ..., n\n        # 1.26 generate all permutations of 1, 2, ..., n\n        # 1.27 generate all permutations of 1, 2, ..., n\n        # 1.28 generate all permutations of 1, 2, ..., n\n        # 1.29 generate all permutations of 1, 2, ..., n\n        # 1.30 generate all permutations of 1, 2, ..., n\n        # 1.31 generate all permutations of 1, 2, ..., n\n        # 1.32 generate all permutations of 1, 2, ..., n\n        # 1.33 generate all permutations of 1, 2, ..., n\n        # 1.34 generate all permutations of 1, 2, ..., n\n        # 1.35 generate all permutations of 1, 2, ..., n\n        # 1.36 generate all permutations of 1, 2, ..., n\n        # 1.37 generate all permutations of 1, 2, ..., n\n        # 1.38 generate all permutations of 1, 2, ..., n\n        # 1.39 generate all permutations of 1, 2, ..., n\n        # 1.40 generate all permutations of 1, 2, ..., n\n        # 1.41 generate all permutations of 1, 2, ..., n\n        # 1.42 generate all permutations of 1, 2, ..., n\n        # 1.43 generate all permutations of 1, 2, ..., n\n        # 1.44 generate all permutations of 1, 2, ..., n\n        # 1.45 generate all permutations of 1, 2, ..."}, {"task_id": "permutation-sequence", "completion": "class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 1.1 generate all permutations of [1, 2, 3, ..., n]\n        # 1.2 generate all permutations of [1, 2, 3, ..., n]\n        # 1.3 generate all permutations of [1, 2, 3, ..., n]\n        # 1.4 generate all permutations of [1, 2, 3, ..., n]\n        # 1.5 generate all permutations of [1, 2, 3, ..., n]\n        # 1.6 generate all permutations of [1, 2, 3, ..., n]\n        # 1.7 generate all permutations of [1, 2, 3, ..., n]\n        # 1.8 generate all permutations of [1, 2, 3, ..., n]\n        # 1.9 generate all permutations of [1, 2, 3, ..., n]\n        # 1.10 generate all permutations of [1, 2, 3, ..., n]\n        # 1.11 generate all permutations of [1, 2, 3, ..., n]\n        # 1.12 generate all permutations of [1, 2, 3, ..., n]\n        # 1.13 generate all permutations of [1, 2, 3, ..., n]\n        # 1.14 generate all permutations of [1, 2, 3, ..., n]\n        # 1.15 generate all permutations of [1, 2, 3, ..., n]\n        # 1.16 generate all permutations of [1, 2, 3, ..., n]\n        # 1.17 generate all permutations of [1, 2, 3, ..., n]\n        # 1.18 generate all permutations of [1, 2, 3, ..., n]\n        # 1.19 generate all permutations of [1, 2, 3, ..., n]\n        # 1.20 generate all permutations of [1, 2, 3, ..., n]\n        # 1.21 generate all permutations of [1, 2, 3, ..., n]\n        # 1.22 generate all permutations of [1, 2, 3, ..., n]\n        # 1.23 generate all permutations of [1, 2, 3, ..., n]\n        # 1.24 generate all permutations of [1, 2, 3, ..., n]\n        # 1.25 generate all permutations of [1, 2, 3, ..., n]\n        # 1.26 generate all permutations of [1, 2, 3, ..., n]\n        # 1.27 generate all permutations of [1, 2, 3, ..., n]\n        # 1.28 generate all permutations of [1, 2, 3, ..., n]\n        # 1.29 generate all permutations of [1, 2, 3, ..., n]\n        # 1.30 generate all permutations of [1, 2, 3, ..., n]\n        # 1.31 generate all permutations of [1, 2, 3, ..., n]\n        # 1.32 generate all permutations of [1, 2, 3, ..., n]\n        # 1.33 generate all permutations of [1, 2, 3, ..., n]\n        # 1.34 generate all permutations of [1, 2, 3, ..., n]\n        # 1.35 generate all permutations of [1, 2, 3, ..., n]\n        # 1.36 generate all permutations of [1, 2, 3, ..., n]\n        # 1.37 generate all permutations of [1, 2, 3, ..., n]\n        # 1.38 generate all permutations of [1, 2, 3, ..., n]"}, {"task_id": "permutation-sequence", "completion": "class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 1.1 generate all permutations of 1 to n\n        # 1.2 generate all permutations of n to 1\n        # 1.3 generate all permutations of 2 to n\n        # 1.4 generate all permutations of n to 2\n        # 1.5 ...\n        # 1.6 generate all permutations of n to n\n        # 1.7 generate all permutations of 1 to n\n        \n        # 2. find the kth permutation\n        # 2.1 find the index of the kth permutation\n        # 2.2 find the kth permutation\n        \n        # 3. return the kth permutation\n        \n        # 1. generate all permutations of 1 to n\n        # 1.1 generate all permutations of 1 to 1\n        # 1.2 generate all permutations of 1 to 2\n        # 1.3 generate all permutations of 1 to 3\n        # 1.4 ...\n        # 1.5 generate all permutations of 1 to n\n        # 1.6 generate all permutations of 2 to n\n        # 1.7 generate all permutations of 1 to n\n        \n        # 2. find the index of the kth permutation\n        # 2.1 find the index of the kth permutation\n        # 2.2 find the kth permutation\n        \n        # 3. return the kth permutation\n        \n        # 1. generate all permutations of 1 to n\n        # 1.1 generate all permutations of 1 to 1\n        # 1.2 generate all permutations of 1 to 2\n        # 1.3 generate all permutations of 1 to 3\n        # 1.4 ...\n        # 1.5 generate all permutations of 1 to n\n        # 1.6 generate all permutations of 2 to n\n        # 1.7 generate all permutations of 1 to n\n        \n        # 2. find the index of the kth permutation\n        # 2.1 find the index of the kth permutation\n        # 2.2 find the kth permutation\n        \n        # 3. return the kth permutation\n        \n        # 1. generate all permutations of 1 to n\n        # 1.1 generate all permutations of 1 to 1\n        # 1.2 generate all permutations of 1 to 2\n        # 1.3 generate all permutations of 1 to 3\n        # 1.4 ...\n        # 1.5 generate all permutations of 1 to n\n        # 1.6 generate all permutations of 2 to n\n        # 1.7 generate all permutations of 1 to n\n        \n        # 2. find the index of the kth permutation\n        # 2.1 find the index of the kth permutation\n        # 2.2 find the kth permutation\n        \n        # 3. return the kth permutation\n        \n        # 1. generate all permutations of 1 to n\n        # 1.1 generate all permutations of 1 to 1\n        # 1.2 generate all permutations of 1 to 2\n        # 1.3 generate all permutations of 1 to 3\n        # 1.4 ...\n        # 1.5 generate all permutations of 1 to n\n        # 1.6 generate all permutations of 2 to n\n        # 1.7 generate all permutations of 1 to n\n        \n        # 2. find the index of the kth permutation\n        # 2.1 find the index of the kth permutation\n        # 2.2 find the kth permutation\n        \n        # 3. return the kth permutation\n        \n        # 1. generate all permutations of 1 to n\n        # 1.1 generate all permutations of 1 to 1\n        # 1.2 generate all permutations of 1 to 2\n        # 1.3 generate all permutations of 1 to 3\n        # 1.4 ...\n        # 1.5"}, {"task_id": "permutation-sequence", "completion": "class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 1.1 generate all permutations of 1, 2, 3, ..., n\n        # 1.2 generate all permutations of 1, 2, 3, ..., n\n        # 1.3 generate all permutations of 1, 2, 3, ..., n\n        # 1.4 generate all permutations of 1, 2, 3, ..., n\n        # 1.5 generate all permutations of 1, 2, 3, ..., n\n        # 1.6 generate all permutations of 1, 2, 3, ..., n\n        # 1.7 generate all permutations of 1, 2, 3, ..., n\n        # 1.8 generate all permutations of 1, 2, 3, ..., n\n        # 1.9 generate all permutations of 1, 2, 3, ..., n\n        # 1.10 generate all permutations of 1, 2, 3, ..., n\n        # 1.11 generate all permutations of 1, 2, 3, ..., n\n        # 1.12 generate all permutations of 1, 2, 3, ..., n\n        # 1.13 generate all permutations of 1, 2, 3, ..., n\n        # 1.14 generate all permutations of 1, 2, 3, ..., n\n        # 1.15 generate all permutations of 1, 2, 3, ..., n\n        # 1.16 generate all permutations of 1, 2, 3, ..., n\n        # 1.17 generate all permutations of 1, 2, 3, ..., n\n        # 1.18 generate all permutations of 1, 2, 3, ..., n\n        # 1.19 generate all permutations of 1, 2, 3, ..., n\n        # 1.20 generate all permutations of 1, 2, 3, ..., n\n        # 1.21 generate all permutations of 1, 2, 3, ..., n\n        # 1.22 generate all permutations of 1, 2, 3, ..., n\n        # 1.23 generate all permutations of 1, 2, 3, ..., n\n        # 1.24 generate all permutations of 1, 2, 3, ..., n\n        # 1.25 generate all permutations of 1, 2, 3, ..., n\n        # 1.26 generate all permutations of 1, 2, 3, ..., n\n        # 1.27 generate all permutations of 1, 2, 3, ..., n\n        # 1.28 generate all permutations of 1, 2, 3, ..., n\n        # 1.29 generate all permutations of 1, 2, 3, ..., n\n        # 1.30 generate all permutations of 1, 2, 3, ..., n\n        # 1.31 generate all permutations of 1, 2, 3, ..., n\n        # 1.32 generate all permutations of 1, 2, 3, ..., n\n        # 1.33 generate all permutations of 1, 2, 3, ..., n\n        # 1.34 generate all permutations of 1, 2, 3, ..., n\n        # 1.35 generate all permutations of 1, 2, 3, ..., n\n        # 1.36 generate all permutations of 1, 2, 3, ..., n\n        # 1.37 generate all permutations of 1, 2, 3, ..., n\n        # 1.38 generate all permutations of 1, 2, 3, ..., n\n        # 1.39 generate all permutations of 1, 2, 3, ..., n\n        # 1.40 generate all permutations of"}, {"task_id": "permutation-sequence", "completion": "class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. generate all permutations\n        # 2. find the kth permutation\n        # 3. return the kth permutation\n        \n        # 1. generate all permutations\n        # 1.1 generate all permutations of 1, 2, ..., n\n        # 1.2 generate all permutations of 1, 2, ..., n\n        # 1.3 generate all permutations of 1, 2, ..., n\n        # 1.4 generate all permutations of 1, 2, ..., n\n        # 1.5 generate all permutations of 1, 2, ..., n\n        # 1.6 generate all permutations of 1, 2, ..., n\n        # 1.7 generate all permutations of 1, 2, ..., n\n        # 1.8 generate all permutations of 1, 2, ..., n\n        # 1.9 generate all permutations of 1, 2, ..., n\n        # 1.10 generate all permutations of 1, 2, ..., n\n        # 1.11 generate all permutations of 1, 2, ..., n\n        # 1.12 generate all permutations of 1, 2, ..., n\n        # 1.13 generate all permutations of 1, 2, ..., n\n        # 1.14 generate all permutations of 1, 2, ..., n\n        # 1.15 generate all permutations of 1, 2, ..., n\n        # 1.16 generate all permutations of 1, 2, ..., n\n        # 1.17 generate all permutations of 1, 2, ..., n\n        # 1.18 generate all permutations of 1, 2, ..., n\n        # 1.19 generate all permutations of 1, 2, ..., n\n        # 1.20 generate all permutations of 1, 2, ..., n\n        # 1.21 generate all permutations of 1, 2, ..., n\n        # 1.22 generate all permutations of 1, 2, ..., n\n        # 1.23 generate all permutations of 1, 2, ..., n\n        # 1.24 generate all permutations of 1, 2, ..., n\n        # 1.25 generate all permutations of 1, 2, ..., n\n        # 1.26 generate all permutations of 1, 2, ..., n\n        # 1.27 generate all permutations of 1, 2, ..., n\n        # 1.28 generate all permutations of 1, 2, ..., n\n        # 1.29 generate all permutations of 1, 2, ..., n\n        # 1.30 generate all permutations of 1, 2, ..., n\n        # 1.31 generate all permutations of 1, 2, ..., n\n        # 1.32 generate all permutations of 1, 2, ..., n\n        # 1.33 generate all permutations of 1, 2, ..., n\n        # 1.34 generate all permutations of 1, 2, ..., n\n        # 1.35 generate all permutations of 1, 2, ..., n\n        # 1.36 generate all permutations of 1, 2, ..., n\n        # 1.37 generate all permutations of 1, 2, ..., n\n        # 1.38 generate all permutations of 1, 2, ..., n\n        # 1.39 generate all permutations of 1, 2, ..., n\n        # 1.40 generate all permutations of 1, 2, ..., n\n        # 1.41 generate all permutations of 1, 2, ..., n\n        # 1.42 generate all permutations of 1, 2, ..., n\n        # 1.43 generate all permutations of 1, 2, ..., n\n        # 1.44 generate all permutations of 1, 2, ..., n\n        # 1.45 generate all permutations of 1, 2, ..."}], "two-sum-ii-input-array-is-sorted": [{"task_id": "two-sum-ii-input-array-is-sorted", "completion": "class Solution(object):\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. Brute force\n        # for i in range(len(numbers)):\n        #     for j in range(i+1, len(numbers)):\n        #         if numbers[i] + numbers[j] == target:\n        #             return [i+1, j+1]\n        \n        # 2. Two pointers\n        # left, right = 0, len(numbers) - 1\n        # while left < right:\n        #     if numbers[left] + numbers[right] == target:\n        #         return [left+1, right+1]\n        #     elif numbers[left] + numbers[right] < target:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        \n        # 3. Binary search\n        # for i in range(len(numbers)):\n        #     left, right = i+1, len(numbers) - 1\n        #     while left <= right:\n        #         mid = (left + right) // 2\n        #         if numbers[mid] + numbers[i] == target:\n        #             return [i+1, mid+1]\n        #         elif numbers[mid] + numbers[i] < target:\n        #             left = mid + 1\n        #         else:\n        #             right = mid - 1\n        \n        # 4. Binary search\n        # for i in range(len(numbers)):\n        #     left, right = i+1, len(numbers) - 1\n        #     while left <= right:\n        #         mid = (left + right) // 2\n        #         if numbers[mid] + numbers[i] == target:\n        #             return [i+1, mid+1]\n        #         elif numbers[mid] + numbers[i] < target:\n        #             left = mid + 1\n        #         else:\n        #             right = mid - 1\n        \n        # 5. Binary search\n        # for i in range(len(numbers)):\n        #     left, right = i+1, len(numbers) - 1\n        #     while left <= right:\n        #         mid = (left + right) // 2\n        #         if numbers[mid] + numbers[i] == target:\n        #             return [i+1, mid+1]\n        #         elif numbers[mid] + numbers[i] < target:\n        #             left = mid + 1\n        #         else:\n        #             right = mid - 1\n        \n        # 6. Binary search\n        # for i in range(len(numbers)):\n        #     left, right = i+1, len(numbers) - 1\n        #     while left <= right:\n        #         mid = (left + right) // 2\n        #         if numbers[mid] + numbers[i] == target:\n        #             return [i+1, mid+1]\n        #         elif numbers[mid] + numbers[i] < target:\n        #             left = mid + 1\n        #         else:\n        #             right = mid - 1\n        \n        # 7. Binary search\n        # for i in range(len(numbers)):\n        #     left, right = i+1, len(numbers) - 1\n        #     while left <= right:\n        #         mid = (left + right) // 2\n        #         if numbers[mid] + numbers[i] == target:\n        #             return [i+1, mid+1]\n        #         elif numbers[mid] + numbers[i] < target:\n        #             left = mid + 1\n        #         else:\n        #             right = mid - 1\n        \n        # 8. Binary search\n        # for i in range(len(numbers)):\n        #     left, right = i+1, len(numbers) - 1\n        #     while left <= right:\n        #         mid = (left + right) // 2\n        #         if numbers[mid] + numbers[i] == target:\n        #             return [i+1, mid+1]\n        #         elif numbers[mid] + numbers[i] < target:\n        #             left = mid + 1\n        #         else:\n        #             right = mid - 1"}, {"task_id": "two-sum-ii-input-array-is-sorted", "completion": "class Solution(object):\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        ## Brute force\n        # for i in range(len(numbers)):\n        #     for j in range(i+1, len(numbers)):\n        #         if numbers[i] + numbers[j] == target:\n        #             return [i+1, j+1]\n        \n        ## Two pointers\n        left = 0\n        right = len(numbers) - 1\n        \n        while left < right:\n            if numbers[left] + numbers[right] == target:\n                return [left+1, right+1]\n            elif numbers[left] + numbers[right] < target:\n                left += 1\n            else:\n                right -= 1\n        \n        return [-1, -1]"}, {"task_id": "two-sum-ii-input-array-is-sorted", "completion": "class Solution(object):\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. Brute force\n        # for i in range(len(numbers)):\n        #     for j in range(i+1, len(numbers)):\n        #         if numbers[i] + numbers[j] == target:\n        #             return [i+1, j+1]\n        \n        # 2. Two pointers\n        # left, right = 0, len(numbers) - 1\n        # while left < right:\n        #     if numbers[left] + numbers[right] == target:\n        #         return [left+1, right+1]\n        #     elif numbers[left] + numbers[right] < target:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        \n        # 3. Binary search\n        # for i in range(len(numbers)):\n        #     left, right = i+1, len(numbers) - 1\n        #     while left <= right:\n        #         mid = (left + right) // 2\n        #         if numbers[mid] + numbers[i] == target:\n        #             return [i+1, mid+1]\n        #         elif numbers[mid] + numbers[i] < target:\n        #             left = mid + 1\n        #         else:\n        #             right = mid - 1\n        \n        # 4. Binary search\n        # for i in range(len(numbers)):\n        #     left, right = i+1, len(numbers) - 1\n        #     while left <= right:\n        #         mid = (left + right) // 2\n        #         if numbers[mid] + numbers[i] == target:\n        #             return [i+1, mid+1]\n        #         elif numbers[mid] + numbers[i] < target:\n        #             left = mid + 1\n        #         else:\n        #             right = mid - 1\n        \n        # 5. Binary search\n        # for i in range(len(numbers)):\n        #     left, right = i+1, len(numbers) - 1\n        #     while left <= right:\n        #         mid = (left + right) // 2\n        #         if numbers[mid] + numbers[i] == target:\n        #             return [i+1, mid+1]\n        #         elif numbers[mid] + numbers[i] < target:\n        #             left = mid + 1\n        #         else:\n        #             right = mid - 1\n        \n        # 6. Binary search\n        # for i in range(len(numbers)):\n        #     left, right = i+1, len(numbers) - 1\n        #     while left <= right:\n        #         mid = (left + right) // 2\n        #         if numbers[mid] + numbers[i] == target:\n        #             return [i+1, mid+1]\n        #         elif numbers[mid] + numbers[i] < target:\n        #             left = mid + 1\n        #         else:\n        #             right = mid - 1\n        \n        # 7. Binary search\n        # for i in range(len(numbers)):\n        #     left, right = i+1, len(numbers) - 1\n        #     while left <= right:\n        #         mid = (left + right) // 2\n        #         if numbers[mid] + numbers[i] == target:\n        #             return [i+1, mid+1]\n        #         elif numbers[mid] + numbers[i] < target:\n        #             left = mid + 1\n        #         else:\n        #             right = mid - 1\n        \n        # 8. Binary search\n        # for i in range(len(numbers)):\n        #     left, right = i+1, len(numbers) - 1\n        #     while left <= right:\n        #         mid = (left + right) // 2\n        #         if numbers[mid] + numbers[i] == target:\n        #             return [i+1, mid+1]\n        #         elif numbers[mid] + numbers[i] < target:\n        #             left = mid + 1\n        #         else:\n        #             right = mid - 1"}, {"task_id": "two-sum-ii-input-array-is-sorted", "completion": "class Solution(object):\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # create a dictionary\n        # key = number\n        # value = index\n        # create a dictionary\n        # key = number\n        # value = index\n        # create a dictionary\n        # key = number\n        # value = index\n        # create a dictionary\n        # key = number\n        # value = index\n        # create a dictionary\n        # key = number\n        # value = index\n        # create a dictionary\n        # key = number\n        # value = index\n        # create a dictionary\n        # key = number\n        # value = index\n        # create a dictionary\n        # key = number\n        # value = index\n        # create a dictionary\n        # key = number\n        # value = index\n        # create a dictionary\n        # key = number\n        # value = index\n        # create a dictionary\n        # key = number\n        # value = index\n        # create a dictionary\n        # key = number\n        # value = index\n        # create a dictionary\n        # key = number\n        # value = index\n        # create a dictionary\n        # key = number\n        # value = index\n        # create a dictionary\n        # key = number\n        # value = index\n        # create a dictionary\n        # key = number\n        # value = index\n        # create a dictionary\n        # key = number\n        # value = index\n        # create a dictionary\n        # key = number\n        # value = index\n        # create a dictionary\n        # key = number\n        # value = index\n        # create a dictionary\n        # key = number\n        # value = index\n        # create a dictionary\n        # key = number\n        # value = index\n        # create a dictionary\n        # key = number\n        # value = index\n        # create a dictionary\n        # key = number\n        # value = index\n        # create a dictionary\n        # key = number\n        # value = index\n        # create a dictionary\n        # key = number\n        # value = index\n        # create a dictionary\n        # key = number\n        # value = index\n        # create a dictionary\n        # key = number\n        # value = index\n        # create a dictionary\n        # key = number\n        # value = index\n        # create a dictionary\n        # key = number\n        # value = index\n        # create a dictionary\n        # key = number\n        # value = index\n        # create a dictionary\n        # key = number\n        # value = index\n        # create a dictionary\n        # key = number\n        # value = index\n        # create a dictionary\n        # key = number\n        # value = index\n        # create a dictionary\n        # key = number\n        # value = index\n        # create a dictionary\n        # key = number\n        # value = index\n        # create a dictionary\n        # key = number\n        # value = index\n        # create a dictionary\n        # key = number\n        # value = index\n        # create a dictionary\n        # key = number\n        # value = index\n        # create a dictionary\n        # key = number\n        # value = index\n        # create a dictionary\n        # key = number\n        # value = index\n        # create a dictionary\n        # key = number\n        # value = index\n        # create a dictionary\n        # key = number\n        # value = index\n        # create a dictionary\n        # key = number\n        # value = index\n        # create a dictionary\n        # key = number\n        # value = index\n        # create a dictionary\n        # key = number\n        # value = index\n        # create a dictionary\n        # key = number\n        # value = index\n        # create a dictionary\n        # key = number\n        # value = index\n        # create a dictionary\n        # key = number\n        # value = index\n        # create a dictionary\n        # key = number\n        # value = index\n        # create a dictionary\n        # key = number\n        # value = index\n        # create a dictionary\n        # key = number\n        # value = index\n        # create a dictionary\n        # key = number\n        # value = index\n        # create a dictionary\n        # key = number\n        # value = index\n        # create a dictionary\n        # key = number\n        # value = index\n        # create a dictionary\n        # key = number\n        # value = index\n        # create a dictionary\n        # key = number\n        # value = index\n        # create a dictionary\n        # key = number\n        # value ="}, {"task_id": "two-sum-ii-input-array-is-sorted", "completion": "class Solution(object):\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. Brute force\n        # for i in range(len(numbers)):\n        #     for j in range(i+1, len(numbers)):\n        #         if numbers[i] + numbers[j] == target:\n        #             return [i+1, j+1]\n        \n        # 2. Two pointers\n        # left, right = 0, len(numbers) - 1\n        # while left < right:\n        #     if numbers[left] + numbers[right] == target:\n        #         return [left+1, right+1]\n        #     elif numbers[left] + numbers[right] < target:\n        #         left += 1\n        #     else:\n        #         right -= 1\n        \n        # 3. Binary search\n        # for i in range(len(numbers)):\n        #     left, right = i+1, len(numbers) - 1\n        #     while left <= right:\n        #         mid = (left + right) // 2\n        #         if numbers[mid] + numbers[i] == target:\n        #             return [i+1, mid+1]\n        #         elif numbers[mid] + numbers[i] < target:\n        #             left = mid + 1\n        #         else:\n        #             right = mid - 1\n        \n        # 4. Binary search\n        # for i in range(len(numbers)):\n        #     left, right = i+1, len(numbers) - 1\n        #     while left <= right:\n        #         mid = (left + right) // 2\n        #         if numbers[mid] + numbers[i] == target:\n        #             return [i+1, mid+1]\n        #         elif numbers[mid] + numbers[i] < target:\n        #             left = mid + 1\n        #         else:\n        #             right = mid - 1\n        \n        # 5. Binary search\n        # for i in range(len(numbers)):\n        #     left, right = i+1, len(numbers) - 1\n        #     while left <= right:\n        #         mid = (left + right) // 2\n        #         if numbers[mid] + numbers[i] == target:\n        #             return [i+1, mid+1]\n        #         elif numbers[mid] + numbers[i] < target:\n        #             left = mid + 1\n        #         else:\n        #             right = mid - 1\n        \n        # 6. Binary search\n        # for i in range(len(numbers)):\n        #     left, right = i+1, len(numbers) - 1\n        #     while left <= right:\n        #         mid = (left + right) // 2\n        #         if numbers[mid] + numbers[i] == target:\n        #             return [i+1, mid+1]\n        #         elif numbers[mid] + numbers[i] < target:\n        #             left = mid + 1\n        #         else:\n        #             right = mid - 1\n        \n        # 7. Binary search\n        # for i in range(len(numbers)):\n        #     left, right = i+1, len(numbers) - 1\n        #     while left <= right:\n        #         mid = (left + right) // 2\n        #         if numbers[mid] + numbers[i] == target:\n        #             return [i+1, mid+1]\n        #         elif numbers[mid] + numbers[i] < target:\n        #             left = mid + 1\n        #         else:\n        #             right = mid - 1\n        \n        # 8. Binary search\n        # for i in range(len(numbers)):\n        #     left, right = i+1, len(numbers) - 1\n        #     while left <= right:\n        #         mid = (left + right) // 2\n        #         if numbers[mid] + numbers[i] == target:\n        #             return [i+1, mid+1]\n        #         elif numbers[mid] + numbers[i] < target:\n        #             left = mid + 1\n        #         else:\n        #             right = mid - 1"}], "expression-add-operators": [{"task_id": "expression-add-operators", "completion": "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def backtrack(i, curr, prev, op, res):\n            if i == len(num):\n                if curr == target and op == '+':\n                    res.append(curr)\n                return\n            for j in range(i, len(num)):\n                if j > i and num[i] == '0':\n                    break\n                curr = curr * 10 + int(num[j])\n                if op == '+':\n                    backtrack(j + 1, curr, curr, '+', res)\n                elif op == '-':\n                    backtrack(j + 1, curr - prev, -curr, '-', res)\n                elif op == '*':\n                    backtrack(j + 1, curr * prev, curr, '*', res)\n                curr = curr // 10\n        \n        res = []\n        backtrack(0, 0, 0, '+', res)\n        return res"}, {"task_id": "expression-add-operators", "completion": "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def backtrack(i, curr, prev, res, op):\n            if i == len(num):\n                if curr == target:\n                    res.append(op)\n                return\n            for j in range(i, len(num)):\n                if j > i and num[i] == '0':\n                    break\n                curr_num = int(num[i:j+1])\n                if op:\n                    backtrack(j+1, curr + curr_num, curr_num, res, op + '+' + str(curr_num))\n                    backtrack(j+1, curr - curr_num, -curr_num, res, op + '-' + str(curr_num))\n                else:\n                    backtrack(j+1, curr_num, curr_num, res, str(curr_num))\n        \n        res = []\n        backtrack(0, 0, 0, res, '')\n        return res"}, {"task_id": "expression-add-operators", "completion": "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def backtrack(i, curr, prev, prod, res):\n            if i == len(num):\n                if curr == target:\n                    res.append(prev)\n                return\n            for j in range(i, len(num)):\n                if j > i and num[i] == '0':\n                    break\n                curr = int(num[i:j+1])\n                if prev == 0:\n                    backtrack(j+1, curr, curr, curr, res)\n                else:\n                    backtrack(j+1, curr, prev + curr, prev + curr, res)\n                    backtrack(j+1, curr, prev - curr, prev - curr, res)\n                    backtrack(j+1, curr, prev * curr, prev * curr, res)\n        \n        res = []\n        backtrack(0, 0, 0, 1, res)\n        return res"}, {"task_id": "expression-add-operators", "completion": "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def backtrack(i, curr, prev, prod, res):\n            if i == len(num):\n                if curr == target:\n                    res.append(prev)\n                return\n            for j in range(i, len(num)):\n                if j > i and num[i] == '0':\n                    break\n                curr = int(num[i:j+1])\n                if prev == 0:\n                    backtrack(j+1, curr, curr, curr, res)\n                else:\n                    backtrack(j+1, curr, prev + curr, prod + curr, res)\n                    backtrack(j+1, curr, prev - curr, (prod - prev) + curr, res)\n                    backtrack(j+1, curr, prev * curr, prod * curr, res)\n        \n        res = []\n        backtrack(0, 0, 0, 0, res)\n        return res"}, {"task_id": "expression-add-operators", "completion": "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def backtrack(i, curr, prev, res, op):\n            if i == len(num):\n                if curr == target:\n                    res.append(op)\n                return\n            for j in range(i, len(num)):\n                if j > i and num[i] == '0':\n                    break\n                curr = int(num[i:j+1])\n                if op == '':\n                    backtrack(j+1, curr, curr, res, num[i])\n                else:\n                    backtrack(j+1, curr, curr + prev, res, op + '+' + num[i])\n                    backtrack(j+1, curr, curr - prev, res, op + '-' + num[i])\n                    backtrack(j+1, curr, curr * prev, res, op + '*' + num[i])\n        \n        res = []\n        backtrack(0, 0, 0, res, '')\n        return res"}], "sum-root-to-leaf-numbers": [{"task_id": "sum-root-to-leaf-numbers", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def dfs(root, curr_sum):\n            if not root:\n                return 0\n            if not root.left and not root.right:\n                return curr_sum * 10 + root.val\n            return dfs(root.left, curr_sum * 10 + root.val) + dfs(root.right, curr_sum * 10 + root.val)\n        \n        return dfs(root, 0)"}, {"task_id": "sum-root-to-leaf-numbers", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def dfs(root, curr_sum):\n            if not root:\n                return 0\n            if not root.left and not root.right:\n                return curr_sum * 10 + root.val\n            return dfs(root.left, curr_sum * 10 + root.val) + dfs(root.right, curr_sum * 10 + root.val)\n        \n        return dfs(root, 0)"}, {"task_id": "sum-root-to-leaf-numbers", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def dfs(root, curr_sum):\n            if not root:\n                return 0\n            if not root.left and not root.right:\n                return curr_sum * 10 + root.val\n            return dfs(root.left, curr_sum * 10 + root.val) + dfs(root.right, curr_sum * 10 + root.val)\n        \n        return dfs(root, 0)"}, {"task_id": "sum-root-to-leaf-numbers", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def dfs(root, curr_sum):\n            if not root:\n                return 0\n            if not root.left and not root.right:\n                return curr_sum * 10 + root.val\n            return dfs(root.left, curr_sum * 10 + root.val) + dfs(root.right, curr_sum * 10 + root.val)\n        \n        return dfs(root, 0)"}, {"task_id": "sum-root-to-leaf-numbers", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def dfs(root, curr_sum):\n            if not root:\n                return 0\n            \n            if not root.left and not root.right:\n                return curr_sum * 10 + root.val\n            \n            left = dfs(root.left, curr_sum * 10 + root.val)\n            right = dfs(root.right, curr_sum * 10 + root.val)\n            \n            return left + right\n        \n        return dfs(root, 0)"}], "license-key-formatting": [{"task_id": "license-key-formatting", "completion": "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        s = s.replace('-', '')\n        s = s.upper()\n        s = s[::-1]\n        s = s[k:]\n        s = s[::-1]\n        s = s.replace('-', '')\n        return s"}, {"task_id": "license-key-formatting", "completion": "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        s = s.replace('-', '')\n        s = s.upper()\n        s = s[::-1]\n        s = s[k:]\n        s = s[::-1]\n        s = s.replace('-', '')\n        return s"}, {"task_id": "license-key-formatting", "completion": "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        s = s.replace('-', '')\n        s = s.upper()\n        s = s[::-1]\n        s = s[k:]\n        s = s[::-1]\n        s = s.replace('-', '')\n        return s"}, {"task_id": "license-key-formatting", "completion": "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        s = s.replace('-', '')\n        s = s.upper()\n        s = s[::-1]\n        s = s[k:]\n        s = s[::-1]\n        s = s.replace('-', '')\n        return s"}, {"task_id": "license-key-formatting", "completion": "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        s = s.replace('-', '')\n        s = s.upper()\n        s = s[::-1]\n        s = s[k:]\n        s = s[::-1]\n        s = s.replace('-', '')\n        return s"}], "gas-station": [{"task_id": "gas-station", "completion": "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if sum(gas) < sum(cost):\n            return -1\n        \n        start = 0\n        tank = 0\n        \n        for i in range(len(gas)):\n            tank += gas[i] - cost[i]\n            if tank < 0:\n                start = i + 1\n                tank = 0\n                \n        return start"}, {"task_id": "gas-station", "completion": "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if sum(gas) < sum(cost):\n            return -1\n        \n        start = 0\n        tank = 0\n        \n        for i in range(len(gas)):\n            tank += gas[i] - cost[i]\n            if tank < 0:\n                start = i + 1\n                tank = 0\n                \n        return start"}, {"task_id": "gas-station", "completion": "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. find the sum of gas and cost\n        ## 2. find the sum of gas and cost\n        ## 3. find the sum of gas and cost\n        ## 4. find the sum of gas and cost\n        ## 5. find the sum of gas and cost\n        ## 6. find the sum of gas and cost\n        ## 7. find the sum of gas and cost\n        ## 8. find the sum of gas and cost\n        ## 9. find the sum of gas and cost\n        ## 10. find the sum of gas and cost\n        ## 11. find the sum of gas and cost\n        ## 12. find the sum of gas and cost\n        ## 13. find the sum of gas and cost\n        ## 14. find the sum of gas and cost\n        ## 15. find the sum of gas and cost\n        ## 16. find the sum of gas and cost\n        ## 17. find the sum of gas and cost\n        ## 18. find the sum of gas and cost\n        ## 19. find the sum of gas and cost\n        ## 20. find the sum of gas and cost\n        ## 21. find the sum of gas and cost\n        ## 22. find the sum of gas and cost\n        ## 23. find the sum of gas and cost\n        ## 24. find the sum of gas and cost\n        ## 25. find the sum of gas and cost\n        ## 26. find the sum of gas and cost\n        ## 27. find the sum of gas and cost\n        ## 28. find the sum of gas and cost\n        ## 29. find the sum of gas and cost\n        ## 30. find the sum of gas and cost\n        ## 31. find the sum of gas and cost\n        ## 32. find the sum of gas and cost\n        ## 33. find the sum of gas and cost\n        ## 34. find the sum of gas and cost\n        ## 35. find the sum of gas and cost\n        ## 36. find the sum of gas and cost\n        ## 37. find the sum of gas and cost\n        ## 38. find the sum of gas and cost\n        ## 39. find the sum of gas and cost\n        ## 40. find the sum of gas and cost\n        ## 41. find the sum of gas and cost\n        ## 42. find the sum of gas and cost\n        ## 43. find the sum of gas and cost\n        ## 44. find the sum of gas and cost\n        ## 45. find the sum of gas and cost\n        ## 46. find the sum of gas and cost\n        ## 47. find the sum of gas and cost\n        ## 48. find the sum of gas and cost\n        ## 49. find the sum of gas and cost\n        ## 50. find the sum of gas and cost\n        ## 51. find the sum of gas and cost\n        ## 52. find the sum of gas and cost\n        ## 53. find the sum of gas and cost\n        ## 54. find the sum of gas and cost\n        ## 55. find the sum of gas and cost\n        ## 56. find the sum of gas and cost\n        ## 57. find the sum of gas and cost\n        ## 58. find the sum of gas and cost\n        ## 59. find the sum of gas and cost\n        ## 60. find the sum of gas and cost\n        ## 61. find the sum of gas and cost\n        ## 62. find the sum of gas and cost\n        ## 63. find the sum of gas and cost\n        ## 64. find the sum of gas and cost\n        ## 65. find the sum of gas and cost\n        ## 66. find the sum of gas and cost\n        ## 67. find the sum of gas and cost\n        ## 68. find the sum of gas and cost\n        ## 69. find the sum of gas and"}, {"task_id": "gas-station", "completion": "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if sum(gas) < sum(cost):\n            return -1\n        \n        n = len(gas)\n        start = 0\n        tank = 0\n        \n        for i in range(n):\n            tank += gas[i] - cost[i]\n            if tank < 0:\n                start = i + 1\n                tank = 0\n                \n        return start"}, {"task_id": "gas-station", "completion": "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Find the total gas in the tank\n        total_gas = sum(gas)\n        \n        ## 2. Find the total cost of gas\n        total_cost = sum(cost)\n        \n        ## 3. If the total gas is less than the total cost, then we can't complete the circuit\n        if total_gas < total_cost:\n            return -1\n        \n        ## 4. Find the starting point\n        start = 0\n        \n        ## 5. Find the remaining gas\n        remaining_gas = total_gas\n        \n        ## 6. Loop through the gas and cost\n        for i in range(len(gas)):\n            \n            ## 7. Find the remaining gas\n            remaining_gas -= gas[i]\n            \n            ## 8. If the remaining gas is less than 0, then we need to start from the next station\n            if remaining_gas < 0:\n                start = i + 1\n                remaining_gas = 0\n                \n        ## 9. If the remaining gas is 0, then we can complete the circuit\n        if remaining_gas == 0:\n            return start\n        \n        ## 10. If the remaining gas is not 0, then we can't complete the circuit\n        else:\n            return -1"}], "burst-balloons": [{"task_id": "burst-balloons", "completion": "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = [1] + nums + [1]\n        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n        \n        for i in range(n - 2, -1, -1):\n            for j in range(i + 2, n):\n                for k in range(i + 1, j):\n                    dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + nums[i] * nums[k] * nums[j])\n        \n        return dp[0][n - 1]"}, {"task_id": "burst-balloons", "completion": "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = [1] + nums + [1]\n        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n        \n        for i in range(n - 2, -1, -1):\n            for j in range(i + 2, n):\n                for k in range(i + 1, j):\n                    dp[i][j] = max(dp[i][j], nums[i] * nums[k] * nums[j] + dp[i][k] + dp[k][j])\n        \n        return dp[0][n - 1]"}, {"task_id": "burst-balloons", "completion": "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = [1] + nums + [1]\n        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n        \n        for i in range(n - 2, -1, -1):\n            for j in range(i + 2, n):\n                for k in range(i + 1, j):\n                    dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + nums[i] * nums[k] * nums[j])\n        \n        return dp[0][n - 1]"}, {"task_id": "burst-balloons", "completion": "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        def maxCoins(nums):\n            if not nums:\n                return 0\n            if len(nums) == 1:\n                return nums[0]\n            max_coins = 0\n            for i in range(len(nums)):\n                max_coins = max(max_coins, nums[i] * nums[i - 1] * nums[i + 1] + maxCoins(nums[:i] + nums[i + 1:]) )\n            return max_coins\n        \n        nums = [1] + nums + [1]\n        return maxCoins(nums)"}, {"task_id": "burst-balloons", "completion": "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        def maxCoins(nums):\n            if not nums:\n                return 0\n            if len(nums) == 1:\n                return nums[0]\n            if len(nums) == 2:\n                return nums[0] * nums[1]\n            max_coins = 0\n            for i in range(len(nums)):\n                max_coins = max(max_coins, nums[i] * maxCoins(nums[:i] + nums[i+1:]) + maxCoins(nums[:i] + nums[i+1:]))\n            return max_coins\n        \n        nums = [1] + nums + [1]\n        return maxCoins(nums)"}], "plus-one": [{"task_id": "plus-one", "completion": "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        for i in range(len(digits)-1,-1,-1):\n            if digits[i] < 9:\n                digits[i] += 1\n                return digits\n            else:\n                digits[i] = 0\n        digits.insert(0,1)\n        return digits"}, {"task_id": "plus-one", "completion": "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        for i in range(len(digits)-1,-1,-1):\n            if digits[i] < 9:\n                digits[i] += 1\n                return digits\n            else:\n                digits[i] = 0\n        digits.insert(0,1)\n        return digits"}, {"task_id": "plus-one", "completion": "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        for i in range(len(digits)-1,-1,-1):\n            if digits[i] < 9:\n                digits[i] += 1\n                return digits\n            else:\n                digits[i] = 0\n        digits.insert(0,1)\n        return digits"}, {"task_id": "plus-one", "completion": "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        for i in range(len(digits)-1,-1,-1):\n            if digits[i] < 9:\n                digits[i] += 1\n                return digits\n            else:\n                digits[i] = 0\n        digits.insert(0,1)\n        return digits"}, {"task_id": "plus-one", "completion": "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        for i in range(len(digits)-1,-1,-1):\n            if digits[i] < 9:\n                digits[i] += 1\n                return digits\n            else:\n                digits[i] = 0\n        digits.insert(0,1)\n        return digits"}], "regular-expression-matching": [{"task_id": "regular-expression-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        if not p:\n            return not s\n        \n        first_match = bool(s) and p[0] in (s[0], '.')\n        \n        if len(p) >= 2 and p[1] == '*':\n            return (self.isMatch(s, p[2:]) or\n                    first_match and self.isMatch(s[1:], p))\n        else:\n            return first_match and self.isMatch(s[1:], p[1:])"}, {"task_id": "regular-expression-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        if not p:\n            return not s\n        \n        first_match = bool(s) and p[0] in (s[0], '.')\n        \n        if len(p) >= 2 and p[1] == '*':\n            return (self.isMatch(s, p[2:]) or\n                    first_match and self.isMatch(s[1:], p))\n        else:\n            return first_match and self.isMatch(s[1:], p[1:])"}, {"task_id": "regular-expression-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        if not p:\n            return not s\n        \n        first_match = bool(s) and p[0] in (s[0], '.')\n        \n        if len(p) >= 2 and p[1] == '*':\n            return (self.isMatch(s, p[2:]) or\n                    first_match and self.isMatch(s[1:], p))\n        else:\n            return first_match and self.isMatch(s[1:], p[1:])"}, {"task_id": "regular-expression-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        if not p:\n            return not s\n        \n        first_match = bool(s) and p[0] in (s[0], '.')\n        \n        if len(p) >= 2 and p[1] == '*':\n            return (self.isMatch(s, p[2:]) or\n                    first_match and self.isMatch(s[1:], p))\n        else:\n            return first_match and self.isMatch(s[1:], p[1:])"}, {"task_id": "regular-expression-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        if not p:\n            return not s\n        \n        first_match = bool(s) and p[0] in (s[0], '.')\n        \n        if len(p) >= 2 and p[1] == '*':\n            return (self.isMatch(s, p[2:]) or\n                    first_match and self.isMatch(s[1:], p))\n        else:\n            return first_match and self.isMatch(s[1:], p[1:])"}], "create-maximum-number": [{"task_id": "create-maximum-number", "completion": "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def pick(nums, k):\n            out = []\n            for i, n in enimport itertools\n            for i in range(len(nums)):\n                if len(out) < k:\n                    if nums[i] > out[-1]:\n                        out.append(nums[i])\n                else:\n                    if nums[i] > out[-1]:\n                        out.pop()\n                        out.append(nums[i])\n            return out\n        \n        def merge(nums1, nums2):\n            out = []\n            while nums1 or nums2:\n                if nums1 > nums2:\n                    out.append(nums1.pop(0))\n                else:\n                    out.append(nums2.pop(0))\n            return out\n        \n        def merge_k(nums1, nums2, k):\n            if k == 0:\n                return []\n            if len(nums1) < k or len(nums2) < k:\n                return []\n            if len(nums1) == 0:\n                return nums2[:k]\n            if len(nums2) == 0:\n                return nums1[:k]\n            if len(nums1) > len(nums2):\n                return merge(nums1, nums2)\n            else:\n                return merge(nums2, nums1)\n        \n        def merge_k_helper(nums1, nums2, k):\n            if k == 0:\n                return []\n            if len(nums1) < k or len(nums2) < k:\n                return []\n            if len(nums1) == 0:\n                return nums2[:k]\n            if len(nums2) == 0:\n                return nums1[:k]\n            if len(nums1) > len(nums2):\n                return merge(nums1, nums2)\n            else:\n                return merge(nums2, nums1)\n        \n        def merge_k_helper(nums1, nums2, k):\n            if k == 0:\n                return []\n            if len(nums1) < k or len(nums2) < k:\n                return []\n            if len(nums1) == 0:\n                return nums2[:k]\n            if len(nums2) == 0:\n                return nums1[:k]\n            if len(nums1) > len(nums2):\n                return merge(nums1, nums2)\n            else:\n                return merge(nums2, nums1)\n        \n        def merge_k_helper(nums1, nums2, k):\n            if k == 0:\n                return []\n            if len(nums1) < k or len(nums2) < k:\n                return []\n            if len(nums1) == 0:\n                return nums2[:k]\n            if len(nums2) == 0:\n                return nums1[:k]\n            if len(nums1) > len(nums2):\n                return merge(nums1, nums2)\n            else:\n                return merge(nums2, nums1)\n        \n        def merge_k_helper(nums1, nums2, k):\n            if k == 0:\n                return []\n            if len(nums1) < k or len(nums2) < k:\n                return []\n            if len(nums1) == 0:\n                return nums2[:k]\n            if len(nums2) == 0:\n                return nums1[:k]\n            if len(nums1) > len(nums2):\n                return merge(nums1, nums2)\n            else:\n                return merge(nums2, nums1)\n        \n        def merge_k_helper(nums1, nums2, k):\n            if k == 0:\n                return []\n            if len(nums1) < k or len(nums2) < k:\n                return []\n            if len(nums1) == 0:\n                return nums2[:k]\n            if len(nums2) == 0:\n                return nums1[:k]\n            if len(nums1) > len(nums"}, {"task_id": "create-maximum-number", "completion": "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def pick(nums, k):\n            out = []\n            for i, n in enimport itertools\n            for i in range(len(nums)):\n                if len(out) < k:\n                    if nums[i] > out[-1]:\n                        out.append(nums[i])\n                else:\n                    if nums[i] > out[-1]:\n                        out.pop()\n                        out.append(nums[i])\n            return out\n        \n        def merge(nums1, nums2):\n            out = []\n            while nums1 or nums2:\n                if nums1 > nums2:\n                    out.append(nums1.pop(0))\n                else:\n                    out.append(nums2.pop(0))\n            return out\n        \n        def merge_k(nums1, nums2, k):\n            if k == 0:\n                return []\n            if len(nums1) < k or len(nums2) < k:\n                return []\n            if k == 1:\n                return nums1 + nums2\n            if len(nums1) == k:\n                return nums1\n            if len(nums2) == k:\n                return nums2\n            mid = k // 2\n            l1 = merge_k(nums1[:mid], nums2[:mid], k - mid)\n            l2 = merge_k(nums1[mid:], nums2[mid:], k - mid)\n            return merge(l1, l2)\n        \n        def merge_k_helper(nums1, nums2, k):\n            if k == 0:\n                return []\n            if len(nums1) < k or len(nums2) < k:\n                return []\n            if k == 1:\n                return nums1 + nums2\n            if len(nums1) == k:\n                return nums1\n            if len(nums2) == k:\n                return nums2\n            mid = k // 2\n            l1 = merge_k_helper(nums1[:mid], nums2[:mid], k - mid)\n            l2 = merge_k_helper(nums1[mid:], nums2[mid:], k - mid)\n            return merge(l1, l2)\n        \n        def merge_k_helper_2(nums1, nums2, k):\n            if k == 0:\n                return []\n            if len(nums1) < k or len(nums2) < k:\n                return []\n            if k == 1:\n                return nums1 + nums2\n            if len(nums1) == k:\n                return nums1\n            if len(nums2) == k:\n                return nums2\n            mid = k // 2\n            l1 = merge_k_helper_2(nums1[:mid], nums2[:mid], k - mid)\n            l2 = merge_k_helper_2(nums1[mid:], nums2[mid:], k - mid)\n            return merge(l1, l2)\n        \n        def merge_k_helper_3(nums1, nums2, k):\n            if k == 0:\n                return []\n            if len(nums1) < k or len(nums2) < k:\n                return []\n            if k == 1:\n                return nums1 + nums2\n            if len(nums1) == k:\n                return nums1\n            if len(nums2) == k:\n                return nums2\n            mid = k // 2\n            l1 = merge_k_helper_3(nums1[:mid], nums2[:mid], k - mid)\n            l2 = merge_k_helper_3(nums1[mid:], nums2[mid:], k - mid)\n            return merge(l1, l2)\n        \n        def merge_k_helper_4(nums1, nums2, k):\n            if k == 0:\n                return []\n            if len(nums1) < k or len(nums2) < k:\n                return []\n            if k == 1:\n                return nums1 + nums2\n            if len(nums1) == k:"}, {"task_id": "create-maximum-number", "completion": "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def pick(nums, k):\n            out = []\n            for i, n in enimport itertools\n            for i in range(len(nums)):\n                if len(out) < k:\n                    if nums[i] > out[-1]:\n                        out.append(nums[i])\n                else:\n                    if nums[i] > out[-1]:\n                        out.pop()\n                        out.append(nums[i])\n            return out\n        \n        def merge(nums1, nums2):\n            out = []\n            while len(nums1) > 0 or len(nums2) > 0:\n                if len(nums1) > 0 and len(nums2) > 0:\n                    if nums1[0] > nums2[0]:\n                        out.append(nums1[0])\n                        nums1 = nums1[1:]\n                    else:\n                        out.append(nums2[0])\n                        nums2 = nums2[1:]\n                elif len(nums1) > 0:\n                    out.append(nums1[0])\n                    nums1 = nums1[1:]\n                else:\n                    out.append(nums2[0])\n                    nums2 = nums2[1:]\n            return out\n        \n        def merge_k(nums):\n            if len(nums) == 1:\n                return nums[0]\n            else:\n                return merge(merge_k(nums[::2]), merge_k(nums[1::2]))\n        \n        def merge_k_helper(nums1, nums2):\n            if len(nums1) == 0:\n                return nums2\n            elif len(nums2) == 0:\n                return nums1\n            else:\n                if nums1[0] > nums2[0]:\n                    return [nums1[0]] + merge_k_helper(nums1[1:], nums2)\n                else:\n                    return [nums2[0]] + merge_k_helper(nums1, nums2[1:])\n        \n        def merge_k_helper_2(nums1, nums2):\n            if len(nums1) == 0:\n                return nums2\n            elif len(nums2) == 0:\n                return nums1\n            else:\n                if nums1[0] > nums2[0]:\n                    return [nums2[0]] + merge_k_helper_2(nums1, nums2[1:])\n                else:\n                    return [nums1[0]] + merge_k_helper_2(nums1[1:], nums2)\n        \n        def merge_k_helper_3(nums1, nums2):\n            if len(nums1) == 0:\n                return nums2\n            elif len(nums2) == 0:\n                return nums1\n            else:\n                if nums1[0] > nums2[0]:\n                    return [nums2[0]] + merge_k_helper_3(nums1, nums2[1:])\n                else:\n                    return [nums1[0]] + merge_k_helper_3(nums1[1:], nums2)\n        \n        def merge_k_helper_4(nums1, nums2):\n            if len(nums1) == 0:\n                return nums2\n            elif len(nums2) == 0:\n                return nums1\n            else:\n                if nums1[0] > nums2[0]:\n                    return [nums2[0]] + merge_k_helper_4(nums1, nums2[1:])\n                else:\n                    return [nums1[0]] + merge_k_helper_4(nums1[1:], nums2)\n        \n        def merge_k_helper_5(nums1, nums2):\n            if len(nums1) == 0:\n                return nums2\n            elif len(nums2) == 0:\n                return nums1\n            else:\n                if nums1[0] > nums2[0]:\n                    return [nums2[0]] + merge_k_helper_5("}, {"task_id": "create-maximum-number", "completion": "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def pick(nums, k):\n            out = []\n            for i, n in enimport itertools\n            for i in range(len(nums)):\n                if len(out) < k:\n                    if nums[i] > out[-1]:\n                        out.append(nums[i])\n                else:\n                    if nums[i] > out[-1]:\n                        out.pop()\n                        out.append(nums[i])\n            return out\n        \n        def merge(nums1, nums2):\n            out = []\n            while len(nums1) > 0 or len(nums2) > 0:\n                if len(nums1) > 0 and len(nums2) > 0:\n                    if nums1[0] > nums2[0]:\n                        out.append(nums1[0])\n                        nums1.pop(0)\n                    else:\n                        out.append(nums2[0])\n                        nums2.pop(0)\n                elif len(nums1) > 0:\n                    out.append(nums1[0])\n                    nums1.pop(0)\n                else:\n                    out.append(nums2[0])\n                    nums2.pop(0)\n            return out\n        \n        def merge_k(nums):\n            if len(nums) == 1:\n                return nums[0]\n            else:\n                return merge(merge_k(nums[::2]), merge_k(nums[1::2]))\n        \n        def merge_k_helper(nums1, nums2):\n            if len(nums1) == 0:\n                return nums2\n            elif len(nums2) == 0:\n                return nums1\n            else:\n                if nums1[0] > nums2[0]:\n                    return [nums1[0]] + merge_k_helper(nums1[1:], nums2)\n                else:\n                    return [nums2[0]] + merge_k_helper(nums1, nums2[1:])\n        \n        def merge_k_helper_2(nums1, nums2):\n            if len(nums1) == 0:\n                return nums2\n            elif len(nums2) == 0:\n                return nums1\n            else:\n                if nums1[0] > nums2[0]:\n                    return [nums2[0]] + merge_k_helper_2(nums1, nums2[1:])\n                else:\n                    return [nums1[0]] + merge_k_helper_2(nums1[1:], nums2)\n        \n        def merge_k_helper_3(nums1, nums2):\n            if len(nums1) == 0:\n                return nums2\n            elif len(nums2) == 0:\n                return nums1\n            else:\n                if nums1[0] > nums2[0]:\n                    return [nums2[0]] + merge_k_helper_3(nums1, nums2[1:])\n                else:\n                    return [nums1[0]] + merge_k_helper_3(nums1[1:], nums2)\n        \n        def merge_k_helper_4(nums1, nums2):\n            if len(nums1) == 0:\n                return nums2\n            elif len(nums2) == 0:\n                return nums1\n            else:\n                if nums1[0] > nums2[0]:\n                    return [nums2[0]] + merge_k_helper_4(nums1, nums2[1:])\n                else:\n                    return [nums1[0]] + merge_k_helper_4(nums1[1:], nums2)\n        \n        def merge_k_helper_5(nums1, nums2):\n            if len(nums1) == 0:\n                return nums2\n            elif len(nums2) == 0:\n                return nums1\n            else:\n                if nums1[0] > nums2[0]:\n                    return [nums2[0]] + merge_k_helper_5(nums1, nums2["}, {"task_id": "create-maximum-number", "completion": "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def pick(nums, k):\n            out = []\n            for i, n in enimport itertools\n            for i in range(len(nums)):\n                if len(out) < k:\n                    if nums[i] > out[-1]:\n                        out.append(nums[i])\n                else:\n                    if nums[i] > out[-1]:\n                        out.pop()\n                        out.append(nums[i])\n            return out\n        \n        def merge(nums1, nums2):\n            out = []\n            while len(nums1) > 0 or len(nums2) > 0:\n                if len(nums1) > 0 and len(nums2) > 0:\n                    if nums1[0] > nums2[0]:\n                        out.append(nums1[0])\n                        nums1 = nums1[1:]\n                    else:\n                        out.append(nums2[0])\n                        nums2 = nums2[1:]\n                elif len(nums1) > 0:\n                    out.append(nums1[0])\n                    nums1 = nums1[1:]\n                else:\n                    out.append(nums2[0])\n                    nums2 = nums2[1:]\n            return out\n        \n        def merge_k(nums):\n            if len(nums) == 1:\n                return nums[0]\n            else:\n                return merge(merge_k(nums[::2]), merge_k(nums[1::2]))\n        \n        def merge_k_helper(nums1, nums2):\n            if len(nums1) == 0:\n                return nums2\n            elif len(nums2) == 0:\n                return nums1\n            else:\n                if nums1[0] > nums2[0]:\n                    return [nums1[0]] + merge_k_helper(nums1[1:], nums2)\n                else:\n                    return [nums2[0]] + merge_k_helper(nums1, nums2[1:])\n        \n        def merge_k_helper_2(nums1, nums2):\n            if len(nums1) == 0:\n                return nums2\n            elif len(nums2) == 0:\n                return nums1\n            else:\n                if nums1[0] > nums2[0]:\n                    return [nums2[0]] + merge_k_helper_2(nums1, nums2[1:])\n                else:\n                    return [nums1[0]] + merge_k_helper_2(nums1[1:], nums2)\n        \n        def merge_k_helper_3(nums1, nums2):\n            if len(nums1) == 0:\n                return nums2\n            elif len(nums2) == 0:\n                return nums1\n            else:\n                if nums1[0] > nums2[0]:\n                    return [nums2[0]] + merge_k_helper_3(nums1, nums2[1:])\n                else:\n                    return [nums1[0]] + merge_k_helper_3(nums1[1:], nums2)\n        \n        def merge_k_helper_4(nums1, nums2):\n            if len(nums1) == 0:\n                return nums2\n            elif len(nums2) == 0:\n                return nums1\n            else:\n                if nums1[0] > nums2[0]:\n                    return [nums2[0]] + merge_k_helper_4(nums1, nums2[1:])\n                else:\n                    return [nums1[0]] + merge_k_helper_4(nums1[1:], nums2)\n        \n        def merge_k_helper_5(nums1, nums2):\n            if len(nums1) == 0:\n                return nums2\n            elif len(nums2) == 0:\n                return nums1\n            else:\n                if nums1[0] > nums2[0]:\n                    return [nums2[0]] + merge_k_helper_5("}], "perfect-number": [{"task_id": "perfect-number", "completion": "class Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return False\n        \n        sum = 1\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if i == num / i:\n                    sum += i\n                else:\n                    sum += i + num / i\n        \n        return sum == num"}, {"task_id": "perfect-number", "completion": "class Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return False\n        \n        sum = 1\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if i == num / i:\n                    sum += i\n                else:\n                    sum += i + num / i\n        \n        return sum == num"}, {"task_id": "perfect-number", "completion": "class Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return False\n        \n        sum = 1\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if i == num / i:\n                    sum += i\n                else:\n                    sum += i + num / i\n        \n        return sum == num"}, {"task_id": "perfect-number", "completion": "class Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return False\n        \n        sum = 1\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                if i != num // i:\n                    sum += i + num // i\n                else:\n                    sum += i\n        \n        return sum == num"}, {"task_id": "perfect-number", "completion": "class Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return False\n        \n        sum = 1\n        for i in range(2, int(math.sqrt(num)) + 1):\n            if num % i == 0:\n                sum += i\n                if i != num / i:\n                    sum += num / i\n        \n        return sum == num"}], "fibonacci-number": [{"task_id": "fibonacci-number", "completion": "class Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        return self.fib(n-1) + self.fib(n-2)"}, {"task_id": "fibonacci-number", "completion": "class Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        \n        return self.fib(n-1) + self.fib(n-2)"}, {"task_id": "fibonacci-number", "completion": "class Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        return self.fib(n-1) + self.fib(n-2)"}, {"task_id": "fibonacci-number", "completion": "class Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        \n        return self.fib(n-1) + self.fib(n-2)"}, {"task_id": "fibonacci-number", "completion": "class Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        \n        return self.fib(n-1) + self.fib(n-2)"}], "dungeon-game": [{"task_id": "dungeon-game", "completion": "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        \"\"\"\n        :type dungeon: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(dungeon)\n        n = len(dungeon[0])\n        \n        dp = [[0] * n for _ in range(m)]\n        \n        for i in range(m-1,-1,-1):\n            for j in range(n-1,-1,-1):\n                if i == m-1 and j == n-1:\n                    dp[i][j] = max(1, 1-dungeon[i][j])\n                elif i == m-1:\n                    dp[i][j] = max(1, dp[i][j+1]-dungeon[i][j])\n                elif j == n-1:\n                    dp[i][j] = max(1, dp[i+1][j]-dungeon[i][j])\n                else:\n                    dp[i][j] = max(1, min(dp[i][j+1], dp[i+1][j])-dungeon[i][j])\n        \n        return dp[0][0]"}, {"task_id": "dungeon-game", "completion": "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        \"\"\"\n        :type dungeon: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(dungeon)\n        n = len(dungeon[0])\n        \n        dp = [[0] * n for _ in range(m)]\n        \n        for i in range(m-1,-1,-1):\n            for j in range(n-1,-1,-1):\n                if i == m-1 and j == n-1:\n                    dp[i][j] = max(1, 1-dungeon[i][j])\n                elif i == m-1:\n                    dp[i][j] = max(1, dp[i][j+1]-dungeon[i][j])\n                elif j == n-1:\n                    dp[i][j] = max(1, dp[i+1][j]-dungeon[i][j])\n                else:\n                    dp[i][j] = max(1, min(dp[i+1][j], dp[i][j+1])-dungeon[i][j])\n                    \n        return dp[0][0]"}, {"task_id": "dungeon-game", "completion": "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        \"\"\"\n        :type dungeon: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(dungeon)\n        n = len(dungeon[0])\n        \n        dp = [[0] * n for _ in range(m)]\n        \n        for i in range(m-1,-1,-1):\n            for j in range(n-1,-1,-1):\n                if i == m-1 and j == n-1:\n                    dp[i][j] = max(1, 1-dungeon[i][j])\n                elif i == m-1:\n                    dp[i][j] = max(1, dp[i][j+1]-dungeon[i][j])\n                elif j == n-1:\n                    dp[i][j] = max(1, dp[i+1][j]-dungeon[i][j])\n                else:\n                    dp[i][j] = max(1, min(dp[i][j+1], dp[i+1][j])-dungeon[i][j])\n                    \n        return dp[0][0]"}, {"task_id": "dungeon-game", "completion": "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        \"\"\"\n        :type dungeon: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(dungeon)\n        n = len(dungeon[0])\n        \n        dp = [[0] * n for _ in range(m)]\n        \n        for i in range(m-1,-1,-1):\n            for j in range(n-1,-1,-1):\n                if i == m-1 and j == n-1:\n                    dp[i][j] = max(1, 1-dungeon[i][j])\n                elif i == m-1:\n                    dp[i][j] = max(1, dp[i][j+1]-dungeon[i][j])\n                elif j == n-1:\n                    dp[i][j] = max(1, dp[i+1][j]-dungeon[i][j])\n                else:\n                    dp[i][j] = max(1, min(dp[i+1][j], dp[i][j+1])-dungeon[i][j])\n                    \n        return dp[0][0]"}, {"task_id": "dungeon-game", "completion": "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        \"\"\"\n        :type dungeon: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(dungeon)\n        n = len(dungeon[0])\n        \n        dp = [[0] * n for _ in range(m)]\n        \n        for i in range(m-1,-1,-1):\n            for j in range(n-1,-1,-1):\n                if i == m-1 and j == n-1:\n                    dp[i][j] = max(1, 1-dungeon[i][j])\n                elif i == m-1:\n                    dp[i][j] = max(1, dp[i][j+1]-dungeon[i][j])\n                elif j == n-1:\n                    dp[i][j] = max(1, dp[i+1][j]-dungeon[i][j])\n                else:\n                    dp[i][j] = max(1, min(dp[i][j+1], dp[i+1][j])-dungeon[i][j])\n                    \n        return dp[0][0]"}], "find-k-th-smallest-pair-distance": [{"task_id": "find-k-th-smallest-pair-distance", "completion": "class Solution(object):\n    def smallestDistancePair(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        n = len(nums)\n        l, r = 0, nums[-1] - nums[0]\n        while l < r:\n            mid = (l + r) // 2\n            cnt = 0\n            j = 0\n            for i in range(n):\n                while j < n and nums[j] - nums[i] <= mid:\n                    j += 1\n                cnt += j - i - 1\n            if cnt >= k:\n                r = mid\n            else:\n                l = mid + 1\n        return l"}, {"task_id": "find-k-th-smallest-pair-distance", "completion": "class Solution(object):\n    def smallestDistancePair(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        n = len(nums)\n        l, r = 0, nums[-1] - nums[0]\n        while l < r:\n            mid = (l + r) // 2\n            cnt = 0\n            j = 0\n            for i in range(n):\n                while j < n and nums[j] - nums[i] <= mid:\n                    j += 1\n                cnt += j - i - 1\n            if cnt >= k:\n                r = mid\n            else:\n                l = mid + 1\n        return l"}, {"task_id": "find-k-th-smallest-pair-distance", "completion": "class Solution(object):\n    def smallestDistancePair(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        n = len(nums)\n        l, r = 0, nums[-1] - nums[0]\n        while l < r:\n            mid = (l + r) // 2\n            cnt = 0\n            j = 0\n            for i in range(n):\n                while j < n and nums[j] - nums[i] <= mid:\n                    j += 1\n                cnt += j - i - 1\n            if cnt >= k:\n                r = mid\n            else:\n                l = mid + 1\n        return l"}, {"task_id": "find-k-th-smallest-pair-distance", "completion": "class Solution(object):\n    def smallestDistancePair(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        n = len(nums)\n        left, right = 0, nums[-1] - nums[0]\n        while left < right:\n            mid = (left + right) // 2\n            count = 0\n            j = 0\n            for i in range(n):\n                while j < n and nums[j] - nums[i] <= mid:\n                    j += 1\n                count += j - i - 1\n            if count < k:\n                left = mid + 1\n            else:\n                right = mid\n        return left"}, {"task_id": "find-k-th-smallest-pair-distance", "completion": "class Solution(object):\n    def smallestDistancePair(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        n = len(nums)\n        left, right = 0, nums[-1] - nums[0]\n        while left < right:\n            mid = (left + right) // 2\n            count = 0\n            j = 0\n            for i in range(n):\n                while j < n and nums[j] - nums[i] <= mid:\n                    j += 1\n                count += j - i - 1\n            if count < k:\n                left = mid + 1\n            else:\n                right = mid\n        return left"}], "number-of-segments-in-a-string": [{"task_id": "number-of-segments-in-a-string", "completion": "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        return len(s.split())"}, {"task_id": "number-of-segments-in-a-string", "completion": "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        return len(s.split())"}, {"task_id": "number-of-segments-in-a-string", "completion": "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        return len(s.split())"}, {"task_id": "number-of-segments-in-a-string", "completion": "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        return len(s.split())"}, {"task_id": "number-of-segments-in-a-string", "completion": "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        return len(s.split())"}], "reverse-vowels-of-a-string": [{"task_id": "reverse-vowels-of-a-string", "completion": "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n        s_list = list(s)\n        vowel_list = []\n        for i in range(len(s_list)):\n            if s_list[i] in vowels:\n                vowel_list.append(s_list[i])\n        vowel_list.reverse()\n        for i in range(len(s_list)):\n            if s_list[i] in vowels:\n                s_list[i] = vowel_list.pop(0)\n        return ''.join(s_list)"}, {"task_id": "reverse-vowels-of-a-string", "completion": "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n        s_list = list(s)\n        vowel_indices = []\n        for i in range(len(s_list)):\n            if s_list[i] in vowels:\n                vowel_indices.append(i)\n        vowel_indices.reverse()\n        for i in range(len(vowel_indices)):\n            s_list[vowel_indices[i]] = s[i]\n        return ''.join(s_list)"}, {"task_id": "reverse-vowels-of-a-string", "completion": "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n        s_list = list(s)\n        vowel_list = []\n        for i in range(len(s_list)):\n            if s_list[i] in vowels:\n                vowel_list.append(s_list[i])\n        vowel_list.reverse()\n        for i in range(len(s_list)):\n            if s_list[i] in vowels:\n                s_list[i] = vowel_list.pop(0)\n        return ''.join(s_list)"}, {"task_id": "reverse-vowels-of-a-string", "completion": "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n        s_list = list(s)\n        vowel_indices = []\n        for i in range(len(s_list)):\n            if s_list[i] in vowels:\n                vowel_indices.append(i)\n        vowel_indices.reverse()\n        for i in range(len(vowel_indices)):\n            s_list[vowel_indices[i]] = s[i]\n        return ''.join(s_list)"}, {"task_id": "reverse-vowels-of-a-string", "completion": "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n        s_list = list(s)\n        vowel_indices = []\n        for i in range(len(s_list)):\n            if s_list[i] in vowels:\n                vowel_indices.append(i)\n        \n        vowel_indices.reverse()\n        for i in range(len(vowel_indices)):\n            s_list[vowel_indices[i]] = s[i]\n        \n        return ''.join(s_list)"}], "longest-consecutive-sequence": [{"task_id": "longest-consecutive-sequence", "completion": "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums_set = set(nums)\n        max_len = 0\n        \n        for num in nums:\n            if num - 1 not in nums_set:\n                curr_len = 1\n                while num + 1 in nums_set:\n                    curr_len += 1\n                    num += 1\n                max_len = max(max_len, curr_len)\n        \n        return max_len"}, {"task_id": "longest-consecutive-sequence", "completion": "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums_set = set(nums)\n        max_len = 0\n        \n        for num in nums:\n            if num - 1 not in nums_set:\n                curr_len = 1\n                while num + 1 in nums_set:\n                    curr_len += 1\n                    num += 1\n                max_len = max(max_len, curr_len)\n        \n        return max_len"}, {"task_id": "longest-consecutive-sequence", "completion": "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums_set = set(nums)\n        max_len = 0\n        \n        for num in nums:\n            if num - 1 not in nums_set:\n                curr_len = 1\n                while num + 1 in nums_set:\n                    curr_len += 1\n                    num += 1\n                max_len = max(max_len, curr_len)\n        \n        return max_len"}, {"task_id": "longest-consecutive-sequence", "completion": "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums_set = set(nums)\n        max_len = 0\n        \n        for num in nums:\n            if num - 1 not in nums_set:\n                curr_len = 1\n                while num + 1 in nums_set:\n                    curr_len += 1\n                    num += 1\n                max_len = max(max_len, curr_len)\n        \n        return max_len"}, {"task_id": "longest-consecutive-sequence", "completion": "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums_set = set(nums)\n        max_len = 0\n        \n        for num in nums:\n            if num - 1 not in nums_set:\n                curr_len = 1\n                while num + 1 in nums_set:\n                    curr_len += 1\n                    num += 1\n                max_len = max(max_len, curr_len)\n        \n        return max_len"}], "missing-number": [{"task_id": "missing-number", "completion": "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Solution 1:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 104 ms, faster than 99.45% of Python online submissions for Missing Number.\n        ## Memory Usage: 14.4 MB, less than 99.45% of Python online submissions for Missing Number.\n        \n        ## Solution 2:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 104 ms, faster than 99.45% of Python online submissions for Missing Number.\n        ## Memory Usage: 14.4 MB, less than 99.45% of Python online submissions for Missing Number.\n        \n        ## Solution 3:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 104 ms, faster than 99.45% of Python online submissions for Missing Number.\n        ## Memory Usage: 14.4 MB, less than 99.45% of Python online submissions for Missing Number.\n        \n        ## Solution 4:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 104 ms, faster than 99.45% of Python online submissions for Missing Number.\n        ## Memory Usage: 14.4 MB, less than 99.45% of Python online submissions for Missing Number.\n        \n        ## Solution 5:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 104 ms, faster than 99.45% of Python online submissions for Missing Number.\n        ## Memory Usage: 14.4 MB, less than 99.45% of Python online submissions for Missing Number.\n        \n        ## Solution 6:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 104 ms, faster than 99.45% of Python online submissions for Missing Number.\n        ## Memory Usage: 14.4 MB, less than 99.45% of Python online submissions for Missing Number.\n        \n        ## Solution 7:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 104 ms, faster than 99.45% of Python online submissions for Missing Number.\n        ## Memory Usage: 14.4 MB, less than 99.45% of Python online submissions for Missing Number.\n        \n        ## Solution 8:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 104 ms, faster than 99.45% of Python online submissions for Missing Number.\n        ## Memory Usage: 14.4 MB, less than 99.45% of Python online submissions for Missing Number.\n        \n        ## Solution 9:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 104 ms, faster than 99.45% of Python online submissions for Missing Number.\n        ## Memory Usage: 14.4 MB, less than 99.45% of Python online submissions for Missing Number.\n        \n        ## Solution 10:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 104 ms, faster than 99.45% of Python online submissions for Missing Number.\n        ## Memory Usage: 14.4 MB, less than 99.45% of Python online submissions for Missing Number.\n        \n        ##"}, {"task_id": "missing-number", "completion": "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## O(n) time and O(1) space\n        ## 1. sum of all numbers from 0 to n\n        ## 2. sum of all numbers in nums\n        ## 3. difference\n        ## 4. return the missing number\n        \n        n = len(nums)\n        sum_all = n * (n + 1) / 2\n        sum_nums = sum(nums)\n        return sum_all - sum_nums"}, {"task_id": "missing-number", "completion": "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## O(n) time and O(1) space\n        ## 1. sum all the numbers in the array\n        ## 2. subtract the sum of the array from the sum of the numbers in the range\n        ## 3. return the difference\n        \n        ## O(n) time and O(1) space\n        ## 1. use the sum of the numbers in the range as the index\n        ## 2. subtract the sum of the array from the sum of the numbers in the range\n        ## 3. return the difference\n        \n        ## O(n) time and O(1) space\n        ## 1. use the sum of the numbers in the range as the index\n        ## 2. subtract the sum of the array from the sum of the numbers in the range\n        ## 3. return the difference\n        \n        ## O(n) time and O(1) space\n        ## 1. use the sum of the numbers in the range as the index\n        ## 2. subtract the sum of the array from the sum of the numbers in the range\n        ## 3. return the difference\n        \n        ## O(n) time and O(1) space\n        ## 1. use the sum of the numbers in the range as the index\n        ## 2. subtract the sum of the array from the sum of the numbers in the range\n        ## 3. return the difference\n        \n        ## O(n) time and O(1) space\n        ## 1. use the sum of the numbers in the range as the index\n        ## 2. subtract the sum of the array from the sum of the numbers in the range\n        ## 3. return the difference\n        \n        ## O(n) time and O(1) space\n        ## 1. use the sum of the numbers in the range as the index\n        ## 2. subtract the sum of the array from the sum of the numbers in the range\n        ## 3. return the difference\n        \n        ## O(n) time and O(1) space\n        ## 1. use the sum of the numbers in the range as the index\n        ## 2. subtract the sum of the array from the sum of the numbers in the range\n        ## 3. return the difference\n        \n        ## O(n) time and O(1) space\n        ## 1. use the sum of the numbers in the range as the index\n        ## 2. subtract the sum of the array from the sum of the numbers in the range\n        ## 3. return the difference\n        \n        ## O(n) time and O(1) space\n        ## 1. use the sum of the numbers in the range as the index\n        ## 2. subtract the sum of the array from the sum of the numbers in the range\n        ## 3. return the difference\n        \n        ## O(n) time and O(1) space\n        ## 1. use the sum of the numbers in the range as the index\n        ## 2. subtract the sum of the array from the sum of the numbers in the range\n        ## 3. return the difference\n        \n        ## O(n) time and O(1) space\n        ## 1. use the sum of the numbers in the range as the index\n        ## 2. subtract the sum of the array from the sum of the numbers in the range\n        ## 3. return the difference\n        \n        ## O(n) time and O(1) space\n        ## 1. use the sum of the numbers in the range as the index\n        ## 2. subtract the sum of the array from the sum of the numbers in the range\n        ## 3. return the difference\n        \n        ## O(n) time and O(1) space\n        ## 1. use the sum of the numbers in the range as the index\n        ## 2. subtract the sum of the array from the sum of the numbers in the range\n        ## 3. return the difference\n        \n        ## O(n) time and O(1) space\n        ## 1. use the sum of the numbers in the range as the index\n        ## 2. subtract the sum of the array from the sum of the numbers in the range\n        ## 3."}, {"task_id": "missing-number", "completion": "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## O(n) time and O(1) space\n        ## 1. sum of all numbers from 0 to n\n        ## 2. sum of all numbers in nums\n        ## 3. difference\n        ## 4. return the missing number\n        \n        n = len(nums)\n        sum_all = n * (n + 1) / 2\n        sum_nums = sum(nums)\n        return sum_all - sum_nums"}, {"task_id": "missing-number", "completion": "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## O(n) time and O(1) space\n        ## 1. sum of all numbers from 0 to n\n        ## 2. sum of all numbers in nums\n        ## 3. difference\n        ## 4. return the difference\n        \n        n = len(nums)\n        sum_all = n * (n + 1) / 2\n        sum_nums = sum(nums)\n        return sum_all - sum_nums"}], "word-ladder": [{"task_id": "word-ladder", "completion": "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        \n        # BFS\n        # Time: O(N * 26 * W)\n        # Space: O(N * 26 * W)\n        # N: number of words in wordList\n        # W: average length of a word\n        # 26: number of letters in the alphabet\n        \n        # BFS\n        # Time: O(N * 26 * W)\n        # Space: O(N * 26 * W)\n        # N: number of words in wordList\n        # W: average length of a word\n        # 26: number of letters in the alphabet\n        \n        # BFS\n        # Time: O(N * 26 * W)\n        # Space: O(N * 26 * W)\n        # N: number of words in wordList\n        # W: average length of a word\n        # 26: number of letters in the alphabet\n        \n        # BFS\n        # Time: O(N * 26 * W)\n        # Space: O(N * 26 * W)\n        # N: number of words in wordList\n        # W: average length of a word\n        # 26: number of letters in the alphabet\n        \n        # BFS\n        # Time: O(N * 26 * W)\n        # Space: O(N * 26 * W)\n        # N: number of words in wordList\n        # W: average length of a word\n        # 26: number of letters in the alphabet\n        \n        # BFS\n        # Time: O(N * 26 * W)\n        # Space: O(N * 26 * W)\n        # N: number of words in wordList\n        # W: average length of a word\n        # 26: number of letters in the alphabet\n        \n        # BFS\n        # Time: O(N * 26 * W)\n        # Space: O(N * 26 * W)\n        # N: number of words in wordList\n        # W: average length of a word\n        # 26: number of letters in the alphabet\n        \n        # BFS\n        # Time: O(N * 26 * W)\n        # Space: O(N * 26 * W)\n        # N: number of words in wordList\n        # W: average length of a word\n        # 26: number of letters in the alphabet\n        \n        # BFS\n        # Time: O(N * 26 * W)\n        # Space: O(N * 26 * W)\n        # N: number of words in wordList\n        # W: average length of a word\n        # 26: number of letters in the alphabet\n        \n        # BFS\n        # Time: O(N * 26 * W)\n        # Space: O(N * 26 * W)\n        # N: number of words in wordList\n        # W: average length of a word\n        # 26: number of letters in the alphabet\n        \n        # BFS\n        # Time: O(N * 26 * W)\n        # Space: O(N * 26 * W)\n        # N: number of words in wordList\n        # W: average length of a word\n        # 26: number of letters in the alphabet\n        \n        # BFS\n        # Time: O(N * 26 * W)\n        # Space: O(N * 26 * W)\n        # N: number of words in wordList\n        # W: average length of a word\n        # 26: number of letters in the alphabet\n        \n        # BFS\n        # Time: O(N * 26 * W)\n        # Space: O(N * 26 * W)\n        # N: number of words in wordList\n        # W: average length of a word\n        # 26: number of letters in the alphabet\n        \n        # BFS\n        # Time: O(N * 26 * W)\n        # Space: O(N * 26 * W)\n        # N: number of words in wordList\n        # W: average length of a word\n        # 26: number of letters in the alphabet\n        \n        # BFS\n        # Time: O(N * 26"}, {"task_id": "word-ladder", "completion": "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        \n        # BFS\n        # Time: O(n^2)\n        # Space: O(n)\n        # 1. BFS\n        # 2. BFS\n        # 3. BFS\n        # 4. BFS\n        # 5. BFS\n        # 6. BFS\n        # 7. BFS\n        # 8. BFS\n        # 9. BFS\n        # 10. BFS\n        # 11. BFS\n        # 12. BFS\n        # 13. BFS\n        # 14. BFS\n        # 15. BFS\n        # 16. BFS\n        # 17. BFS\n        # 18. BFS\n        # 19. BFS\n        # 20. BFS\n        # 21. BFS\n        # 22. BFS\n        # 23. BFS\n        # 24. BFS\n        # 25. BFS\n        # 26. BFS\n        # 27. BFS\n        # 28. BFS\n        # 29. BFS\n        # 30. BFS\n        # 31. BFS\n        # 32. BFS\n        # 33. BFS\n        # 34. BFS\n        # 35. BFS\n        # 36. BFS\n        # 37. BFS\n        # 38. BFS\n        # 39. BFS\n        # 40. BFS\n        # 41. BFS\n        # 42. BFS\n        # 43. BFS\n        # 44. BFS\n        # 45. BFS\n        # 46. BFS\n        # 47. BFS\n        # 48. BFS\n        # 49. BFS\n        # 50. BFS\n        # 51. BFS\n        # 52. BFS\n        # 53. BFS\n        # 54. BFS\n        # 55. BFS\n        # 56. BFS\n        # 57. BFS\n        # 58. BFS\n        # 59. BFS\n        # 60. BFS\n        # 61. BFS\n        # 62. BFS\n        # 63. BFS\n        # 64. BFS\n        # 65. BFS\n        # 66. BFS\n        # 67. BFS\n        # 68. BFS\n        # 69. BFS\n        # 70. BFS\n        # 71. BFS\n        # 72. BFS\n        # 73. BFS\n        # 74. BFS\n        # 75. BFS\n        # 76. BFS\n        # 77. BFS\n        # 78. BFS\n        # 79. BFS\n        # 80. BFS\n        # 81. BFS\n        # 82. BFS\n        # 83. BFS\n        # 84. BFS\n        # 85. BFS\n        # 86. BFS\n        # 87. BFS\n        # 88. BFS\n        # 89. BFS\n        # 90. BFS\n        # 91. BFS\n        # 92. BFS\n        # 93. BFS\n        # 94. BFS\n        # 95. BFS\n        # 96. BFS\n        # 97. BFS\n        # 98. BFS\n        # 99. BFS\n        # 100. BFS\n        # 101. BFS\n        # 102. BFS\n        # 103. BFS\n        # 104. BFS\n        # 105. BFS\n        # 106. BFS\n        # 107. BFS\n        # 108. BFS\n        # 109. BFS\n        # 110. BFS\n        # 111."}, {"task_id": "word-ladder", "completion": "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        \n        # BFS\n        # Time: O(N * 26 * W)\n        # Space: O(N * 26 * W)\n        # N: number of words in wordList\n        # W: average length of a word\n        # 26: number of possible characters in a word\n        \n        # BFS\n        # Time: O(N * 26 * W)\n        # Space: O(N * 26 * W)\n        # N: number of words in wordList\n        # W: average length of a word\n        # 26: number of possible characters in a word\n        \n        # BFS\n        # Time: O(N * 26 * W)\n        # Space: O(N * 26 * W)\n        # N: number of words in wordList\n        # W: average length of a word\n        # 26: number of possible characters in a word\n        \n        # BFS\n        # Time: O(N * 26 * W)\n        # Space: O(N * 26 * W)\n        # N: number of words in wordList\n        # W: average length of a word\n        # 26: number of possible characters in a word\n        \n        # BFS\n        # Time: O(N * 26 * W)\n        # Space: O(N * 26 * W)\n        # N: number of words in wordList\n        # W: average length of a word\n        # 26: number of possible characters in a word\n        \n        # BFS\n        # Time: O(N * 26 * W)\n        # Space: O(N * 26 * W)\n        # N: number of words in wordList\n        # W: average length of a word\n        # 26: number of possible characters in a word\n        \n        # BFS\n        # Time: O(N * 26 * W)\n        # Space: O(N * 26 * W)\n        # N: number of words in wordList\n        # W: average length of a word\n        # 26: number of possible characters in a word\n        \n        # BFS\n        # Time: O(N * 26 * W)\n        # Space: O(N * 26 * W)\n        # N: number of words in wordList\n        # W: average length of a word\n        # 26: number of possible characters in a word\n        \n        # BFS\n        # Time: O(N * 26 * W)\n        # Space: O(N * 26 * W)\n        # N: number of words in wordList\n        # W: average length of a word\n        # 26: number of possible characters in a word\n        \n        # BFS\n        # Time: O(N * 26 * W)\n        # Space: O(N * 26 * W)\n        # N: number of words in wordList\n        # W: average length of a word\n        # 26: number of possible characters in a word\n        \n        # BFS\n        # Time: O(N * 26 * W)\n        # Space: O(N * 26 * W)\n        # N: number of words in wordList\n        # W: average length of a word\n        # 26: number of possible characters in a word\n        \n        # BFS\n        # Time: O(N * 26 * W)\n        # Space: O(N * 26 * W)\n        # N: number of words in wordList\n        # W: average length of a word\n        # 26: number of possible characters in a word\n        \n        # BFS\n        # Time: O(N * 26 * W)\n        # Space: O(N * 26 * W)\n        # N: number of words in wordList\n        # W: average length of a word\n        # 26: number of possible characters in a word\n        \n        # BFS\n        # Time: O(N * 26 * W)\n        # Space: O(N * 26 * W)\n        # N: number of words in wordList\n        # W: average length of a word\n        # 26: number of possible characters in a word\n        \n        # BFS\n        # Time: O(N * 26"}, {"task_id": "word-ladder", "completion": "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        # n: number of words in wordList\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of words in wordList\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of words in wordList\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of words in wordList\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of words in wordList\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of words in wordList\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of words in wordList\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of words in wordList\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of words in wordList\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of words in wordList\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of words in wordList\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of words in wordList\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of words in wordList\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of words in wordList\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of words in wordList\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of words in wordList\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of words in wordList\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of words in wordList\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of words in wordList\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of words in wordList\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of words in wordList\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of words in wordList\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of words in wordList\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of words in wordList\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of words in wordList\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of words in wordList\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of words in wordList\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of words in wordList\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of words in wordList\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of words in wordList\n        # m: length of each word\n        # n * m: number of edges in the graph\n        # n: number of words"}, {"task_id": "word-ladder", "completion": "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        \n        # BFS\n        # Time: O(N * M)\n        # Space: O(N * M)\n        # N: number of words in wordList\n        # M: length of each word\n        # N is the number of words in wordList\n        # M is the length of each word\n        \n        # BFS\n        # Time: O(N * M)\n        # Space: O(N * M)\n        # N: number of words in wordList\n        # M: length of each word\n        # N is the number of words in wordList\n        # M is the length of each word\n        \n        # BFS\n        # Time: O(N * M)\n        # Space: O(N * M)\n        # N: number of words in wordList\n        # M: length of each word\n        # N is the number of words in wordList\n        # M is the length of each word\n        \n        # BFS\n        # Time: O(N * M)\n        # Space: O(N * M)\n        # N: number of words in wordList\n        # M: length of each word\n        # N is the number of words in wordList\n        # M is the length of each word\n        \n        # BFS\n        # Time: O(N * M)\n        # Space: O(N * M)\n        # N: number of words in wordList\n        # M: length of each word\n        # N is the number of words in wordList\n        # M is the length of each word\n        \n        # BFS\n        # Time: O(N * M)\n        # Space: O(N * M)\n        # N: number of words in wordList\n        # M: length of each word\n        # N is the number of words in wordList\n        # M is the length of each word\n        \n        # BFS\n        # Time: O(N * M)\n        # Space: O(N * M)\n        # N: number of words in wordList\n        # M: length of each word\n        # N is the number of words in wordList\n        # M is the length of each word\n        \n        # BFS\n        # Time: O(N * M)\n        # Space: O(N * M)\n        # N: number of words in wordList\n        # M: length of each word\n        # N is the number of words in wordList\n        # M is the length of each word\n        \n        # BFS\n        # Time: O(N * M)\n        # Space: O(N * M)\n        # N: number of words in wordList\n        # M: length of each word\n        # N is the number of words in wordList\n        # M is the length of each word\n        \n        # BFS\n        # Time: O(N * M)\n        # Space: O(N * M)\n        # N: number of words in wordList\n        # M: length of each word\n        # N is the number of words in wordList\n        # M is the length of each word\n        \n        # BFS\n        # Time: O(N * M)\n        # Space: O(N * M)\n        # N: number of words in wordList\n        # M: length of each word\n        # N is the number of words in wordList\n        # M is the length of each word\n        \n        # BFS\n        # Time: O(N * M)\n        # Space: O(N * M)\n        # N: number of words in wordList\n        # M: length of each word\n        # N is the number of words in wordList\n        # M is the length of each word\n        \n        # BFS\n        # Time: O(N * M)\n        # Space: O(N * M)\n        # N: number of words in wordList\n        # M: length of each word\n        # N is the number of words in wordList\n        # M is the length of each word\n        \n        # BFS\n        # Time: O(N * M)\n        # Space: O(N * M)\n        # N: number of words in wordList\n        # M: length of each word\n        # N is the number of words in wordList\n        # M is the length of each word\n        \n        # BFS\n        # Time: O(N * M)\n        # Space: O(N * M)\n        # N"}], "add-binary": [{"task_id": "add-binary", "completion": "class Solution(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        \n        if len(a) > len(b):\n            b = '0' * (len(a) - len(b)) + b\n        elif len(b) > len(a):\n            a = '0' * (len(b) - len(a)) + a\n        \n        carry = 0\n        result = ''\n        for i in range(len(a) - 1, -1, -1):\n            if a[i] == '1' and b[i] == '1':\n                if carry == 1:\n                    result = '1' + result\n                else:\n                    result = '0' + result\n                carry = 1\n            elif a[i] == '0' and b[i] == '0':\n                if carry == 1:\n                    result = '1' + result\n                else:\n                    result = '0' + result\n                carry = 0\n            else:\n                if carry == 1:\n                    result = '0' + result\n                else:\n                    result = '1' + result\n                carry = 1\n        \n        if carry == 1:\n            result = '1' + result\n        \n        return result"}, {"task_id": "add-binary", "completion": "class Solution(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        \n        if len(a) > len(b):\n            b = '0' * (len(a) - len(b)) + b\n        elif len(b) > len(a):\n            a = '0' * (len(b) - len(a)) + a\n        \n        carry = 0\n        res = ''\n        for i in range(len(a) - 1, -1, -1):\n            if a[i] == '1' and b[i] == '1':\n                if carry == 1:\n                    res = '1' + res\n                else:\n                    res = '0' + res\n                carry = 1\n            elif a[i] == '0' and b[i] == '0':\n                if carry == 1:\n                    res = '1' + res\n                else:\n                    res = '0' + res\n                carry = 0\n            else:\n                if carry == 1:\n                    res = '0' + res\n                else:\n                    res = '1' + res\n                carry = 1\n        if carry == 1:\n            res = '1' + res\n        return res"}, {"task_id": "add-binary", "completion": "class Solution(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        \n        if len(a) > len(b):\n            b = '0' * (len(a) - len(b)) + b\n        elif len(b) > len(a):\n            a = '0' * (len(b) - len(a)) + a\n        \n        carry = 0\n        res = ''\n        for i in range(len(a) - 1, -1, -1):\n            if a[i] == '1' and b[i] == '1':\n                if carry == 1:\n                    res = '1' + res\n                else:\n                    res = '0' + res\n                carry = 1\n            elif a[i] == '0' and b[i] == '0':\n                if carry == 1:\n                    res = '1' + res\n                else:\n                    res = '0' + res\n                carry = 0\n            else:\n                if carry == 1:\n                    res = '0' + res\n                else:\n                    res = '1' + res\n                carry = 1\n        if carry == 1:\n            res = '1' + res\n        return res"}, {"task_id": "add-binary", "completion": "class Solution(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        \n        if len(a) > len(b):\n            b = '0' * (len(a) - len(b)) + b\n        elif len(b) > len(a):\n            a = '0' * (len(b) - len(a)) + a\n        \n        carry = 0\n        result = ''\n        for i in range(len(a) - 1, -1, -1):\n            if a[i] == '1' and b[i] == '1':\n                if carry == 1:\n                    result = '1' + result\n                else:\n                    result = '0' + result\n                carry = 1\n            elif a[i] == '0' and b[i] == '0':\n                if carry == 1:\n                    result = '1' + result\n                else:\n                    result = '0' + result\n                carry = 0\n            else:\n                if carry == 1:\n                    result = '0' + result\n                else:\n                    result = '1' + result\n                carry = 1\n        \n        if carry == 1:\n            result = '1' + result\n        \n        return result"}, {"task_id": "add-binary", "completion": "class Solution(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        \n        a = int(a, 2)\n        b = int(b, 2)\n        return bin(a + b)[2:]"}], "find-first-and-last-position-of-element-in-sorted-array": [{"task_id": "find-first-and-last-position-of-element-in-sorted-array", "completion": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def binary_search(nums, target, find_first):\n            left, right = 0, len(nums) - 1\n            index = -1\n            while left <= right:\n                mid = (left + right) // 2\n                if nums[mid] > target or (find_first and nums[mid] == target):\n                    right = mid - 1\n                    index = mid\n                else:\n                    left = mid + 1\n            return index\n        \n        def search_range(nums, target, find_first):\n            left_index = binary_search(nums, target, find_first)\n            if left_index == -1:\n                return [-1, -1]\n            right_index = binary_search(nums, target, not find_first)\n            return [left_index, right_index]\n        \n        return search_range(nums, target, True), search_range(nums, target, False)"}, {"task_id": "find-first-and-last-position-of-element-in-sorted-array", "completion": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def binary_search(nums, target, find_first):\n            left, right = 0, len(nums) - 1\n            index = -1\n            while left <= right:\n                mid = (left + right) // 2\n                if nums[mid] > target or (find_first and nums[mid] == target):\n                    right = mid - 1\n                    index = mid\n                else:\n                    left = mid + 1\n            return index\n        \n        def search_range(nums, target):\n            first_index = binary_search(nums, target, True)\n            if first_index == -1:\n                return [-1, -1]\n            return [first_index, binary_search(nums, target, False)]\n        \n        return search_range(nums, target)"}, {"task_id": "find-first-and-last-position-of-element-in-sorted-array", "completion": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def binary_search(nums, target, lower):\n            left, right = 0, len(nums) - 1\n            while left <= right:\n                mid = (left + right) // 2\n                if nums[mid] > target or (lower and nums[mid] >= target):\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return left\n        \n        left_idx = binary_search(nums, target, True)\n        if left_idx == len(nums) or nums[left_idx] != target:\n            return [-1, -1]\n        return [left_idx, binary_search(nums, target, False) - 1]"}, {"task_id": "find-first-and-last-position-of-element-in-sorted-array", "completion": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def binary_search(nums, target, lower):\n            left, right = 0, len(nums) - 1\n            while left <= right:\n                mid = (left + right) // 2\n                if nums[mid] > target or (lower and nums[mid] >= target):\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return left\n        \n        left_idx = binary_search(nums, target, True)\n        if left_idx == len(nums) or nums[left_idx] != target:\n            return [-1, -1]\n        return [left_idx, binary_search(nums, target, False) - 1]"}, {"task_id": "find-first-and-last-position-of-element-in-sorted-array", "completion": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def binary_search(nums, target, find_first):\n            left, right = 0, len(nums) - 1\n            index = -1\n            while left <= right:\n                mid = (left + right) // 2\n                if nums[mid] > target or (find_first and nums[mid] == target):\n                    right = mid - 1\n                    index = mid\n                else:\n                    left = mid + 1\n            return index\n        \n        def search_range(nums, target, find_first):\n            left_index = binary_search(nums, target, find_first)\n            if left_index == -1:\n                return [-1, -1]\n            right_index = binary_search(nums, target, not find_first)\n            return [left_index, right_index]\n        \n        return search_range(nums, target, True), search_range(nums, target, False)"}], "remove-duplicates-from-sorted-array": [{"task_id": "remove-duplicates-from-sorted-array", "completion": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 0:\n            return 0\n        \n        i = 0\n        for j in range(1, len(nums)):\n            if nums[j] != nums[i]:\n                i += 1\n                nums[i] = nums[j]\n                \n        return i + 1"}, {"task_id": "remove-duplicates-from-sorted-array", "completion": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 0:\n            return 0\n        \n        i = 0\n        for j in range(1, len(nums)):\n            if nums[j] != nums[i]:\n                i += 1\n                nums[i] = nums[j]\n        \n        return i + 1"}, {"task_id": "remove-duplicates-from-sorted-array", "completion": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 0:\n            return 0\n        \n        i = 0\n        for j in range(1, len(nums)):\n            if nums[j] != nums[i]:\n                i += 1\n                nums[i] = nums[j]\n        \n        return i + 1"}, {"task_id": "remove-duplicates-from-sorted-array", "completion": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 0:\n            return 0\n        \n        i = 0\n        for j in range(1, len(nums)):\n            if nums[j] != nums[i]:\n                i += 1\n                nums[i] = nums[j]\n                \n        return i + 1"}, {"task_id": "remove-duplicates-from-sorted-array", "completion": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 0:\n            return 0\n        \n        i = 0\n        for j in range(1, len(nums)):\n            if nums[j] != nums[i]:\n                i += 1\n                nums[i] = nums[j]\n        \n        return i + 1"}], "jump-game-ii": [{"task_id": "jump-game-ii", "completion": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(nums)\n        if n == 1:\n            return 0\n        \n        max_reach = nums[0]\n        jumps = 1\n        curr_reach = 0\n        \n        for i in range(n):\n            if i > curr_reach:\n                jumps += 1\n                curr_reach = max_reach\n            max_reach = max(max_reach, i + nums[i])\n        \n        return jumps"}, {"task_id": "jump-game-ii", "completion": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(nums)\n        if n == 1:\n            return 0\n        \n        max_reach = nums[0]\n        jumps = 1\n        curr_reach = 0\n        \n        for i in range(n):\n            if i > curr_reach:\n                jumps += 1\n                curr_reach = max_reach\n            max_reach = max(max_reach, i + nums[i])\n        \n        return jumps"}, {"task_id": "jump-game-ii", "completion": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(nums)\n        if n == 1:\n            return 0\n        \n        max_reach = nums[0]\n        jumps = 1\n        curr_reach = 0\n        \n        for i in range(n):\n            if i > curr_reach:\n                jumps += 1\n                curr_reach = max_reach\n            max_reach = max(max_reach, i + nums[i])\n        \n        return jumps"}, {"task_id": "jump-game-ii", "completion": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(nums)\n        if n == 1:\n            return 0\n        \n        max_reach = nums[0]\n        jumps = 1\n        curr_reach = 0\n        \n        for i in range(n):\n            if i > curr_reach:\n                jumps += 1\n                curr_reach = max_reach\n            max_reach = max(max_reach, i + nums[i])\n        \n        return jumps"}, {"task_id": "jump-game-ii", "completion": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(nums)\n        if n == 1:\n            return 0\n        \n        max_reach = nums[0]\n        jumps = 1\n        curr_reach = 0\n        \n        for i in range(n):\n            if i > curr_reach:\n                jumps += 1\n                curr_reach = max_reach\n            max_reach = max(max_reach, i + nums[i])\n        \n        return jumps"}], "best-time-to-buy-and-sell-stock-iv": [{"task_id": "best-time-to-buy-and-sell-stock-iv", "completion": "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if k >= len(prices)//2:\n            return sum(max(prices[i+1]-prices[i] for i in range(len(prices)-1)) for _ in range(k))\n        \n        dp = [[0]*2 for _ in range(k+1)]\n        \n        for i in range(len(prices)):\n            for j in range(1,k+1):\n                if i == 0:\n                    dp[j][0] = 0\n                    dp[j][1] = -prices[i]\n                    continue\n                dp[j][0] = max(dp[j][0],dp[j-1][1]+prices[i])\n                dp[j][1] = max(dp[j][1],dp[j-1][0]-prices[i])\n        \n        return dp[k][0]"}, {"task_id": "best-time-to-buy-and-sell-stock-iv", "completion": "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if k >= len(prices)//2:\n            return sum(max(prices[i+1]-prices[i] for i in range(len(prices)-1)) for _ in range(k))\n        \n        dp = [[0]*2 for _ in range(k+1)]\n        \n        for i in range(len(prices)):\n            for j in range(1,k+1):\n                if i == 0:\n                    dp[j][0] = 0\n                    dp[j][1] = -prices[i]\n                    continue\n                dp[j][0] = max(dp[j][0],dp[j-1][1]+prices[i])\n                dp[j][1] = max(dp[j][1],dp[j-1][0]-prices[i])\n        \n        return dp[-1][0]"}, {"task_id": "best-time-to-buy-and-sell-stock-iv", "completion": "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if k >= len(prices)//2:\n            return sum(max(prices[i+1]-prices[i] for i in range(len(prices)-1)) for _ in range(k))\n        \n        dp = [[0]*2 for _ in range(k+1)]\n        \n        for i in range(len(prices)):\n            for j in range(1,k+1):\n                if i == 0:\n                    dp[j][0] = 0\n                    dp[j][1] = -prices[i]\n                    continue\n                dp[j][0] = max(dp[j][0],dp[j-1][1]+prices[i])\n                dp[j][1] = max(dp[j][1],dp[j-1][0]-prices[i])\n        \n        return dp[k][0]"}, {"task_id": "best-time-to-buy-and-sell-stock-iv", "completion": "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if k >= len(prices)//2:\n            return sum(max(prices[i+1]-prices[i] for i in range(len(prices)-1)) for _ in range(k))\n        \n        dp = [[0]*2 for _ in range(k+1)]\n        \n        for i in range(len(prices)):\n            for j in range(1,k+1):\n                if i == 0:\n                    dp[j][0] = 0\n                    dp[j][1] = -prices[i]\n                    continue\n                dp[j][0] = max(dp[j][0],dp[j-1][1]+prices[i])\n                dp[j][1] = max(dp[j][1],dp[j-1][0]-prices[i])\n        \n        return dp[k][0]"}, {"task_id": "best-time-to-buy-and-sell-stock-iv", "completion": "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if k >= len(prices)//2:\n            return sum(max(prices[i+1]-prices[i] for i in range(len(prices)-1)) for _ in range(k))\n        \n        dp = [[0]*2 for _ in range(k+1)]\n        \n        for i in range(len(prices)):\n            for j in range(1,k+1):\n                if i == 0:\n                    dp[j][0] = 0\n                    dp[j][1] = -prices[i]\n                    continue\n                dp[j][0] = max(dp[j][0],dp[j-1][1]+prices[i])\n                dp[j][1] = max(dp[j][1],dp[j-1][0]-prices[i])\n        \n        return dp[-1][0]"}], "convert-a-number-to-hexadecimal": [{"task_id": "convert-a-number-to-hexadecimal", "completion": "class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        if num < 0:\n            num = 2**32 + num\n        \n        hex_dict = {10:\"a\", 11:\"b\", 12:\"c\", 13:\"d\", 14:\"e\", 15:\"f\"}\n        hex_list = []\n        \n        while num > 0:\n            remainder = num % 16\n            if remainder >= 10:\n                hex_list.append(hex_dict[remainder])\n            else:\n                hex_list.append(str(remainder))\n            num = num // 16\n        \n        hex_list.reverse()\n        return \"\".join(hex_list)"}, {"task_id": "convert-a-number-to-hexadecimal", "completion": "class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return '0'\n        \n        if num < 0:\n            num = num + 2**32\n        \n        hex_dict = {10:'a', 11:'b', 12:'c', 13:'d', 14:'e', 15:'f'}\n        hex_list = []\n        \n        while num > 0:\n            remainder = num % 16\n            if remainder >= 10:\n                hex_list.append(hex_dict[remainder])\n            else:\n                hex_list.append(str(remainder))\n            num = num // 16\n        \n        hex_list.reverse()\n        return ''.join(hex_list)"}, {"task_id": "convert-a-number-to-hexadecimal", "completion": "class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        if num < 0:\n            num = 2**32 + num\n        \n        hex_dict = {10:\"a\", 11:\"b\", 12:\"c\", 13:\"d\", 14:\"e\", 15:\"f\"}\n        hex_list = []\n        \n        while num > 0:\n            remainder = num % 16\n            if remainder < 10:\n                hex_list.append(str(remainder))\n            else:\n                hex_list.append(hex_dict[remainder])\n            num = num // 16\n        \n        hex_list.reverse()\n        return \"\".join(hex_list)"}, {"task_id": "convert-a-number-to-hexadecimal", "completion": "class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return '0'\n        \n        if num < 0:\n            num = num + 2**32\n        \n        hex_dict = {10:'a', 11:'b', 12:'c', 13:'d', 14:'e', 15:'f'}\n        hex_list = []\n        \n        while num > 0:\n            hex_list.append(num % 16)\n            num = num // 16\n        \n        hex_list.reverse()\n        \n        for i in range(len(hex_list)):\n            if hex_list[i] >= 10:\n                hex_list[i] = hex_dict[hex_list[i]]\n        \n        return ''.join(map(str, hex_list))"}, {"task_id": "convert-a-number-to-hexadecimal", "completion": "class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        if num < 0:\n            num = 2**32 + num\n        \n        hex_dict = {10:\"a\", 11:\"b\", 12:\"c\", 13:\"d\", 14:\"e\", 15:\"f\"}\n        hex_list = []\n        \n        while num > 0:\n            remainder = num % 16\n            if remainder < 10:\n                hex_list.append(str(remainder))\n            else:\n                hex_list.append(hex_dict[remainder])\n            num = num // 16\n        \n        hex_list.reverse()\n        return \"\".join(hex_list)"}], "first-unique-character-in-a-string": [{"task_id": "first-unique-character-in-a-string", "completion": "class Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # create a dictionary to store the frequency of each character\n        freq = {}\n        \n        # iterate through the string and count the frequency of each character\n        for char in s:\n            if char not in freq:\n                freq[char] = 1\n            else:\n                freq[char] += 1\n        \n        # iterate through the string again and return the first character with frequency 1\n        for i, char in enumerate(s):\n            if freq[char] == 1:\n                return i\n        \n        # if no character with frequency 1 is found, return -1\n        return -1"}, {"task_id": "first-unique-character-in-a-string", "completion": "class Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # create a dictionary with the frequency of each character in the string\n        freq = {}\n        for char in s:\n            if char not in freq:\n                freq[char] = 1\n            else:\n                freq[char] += 1\n        \n        # iterate through the string and return the first character with a frequency of 1\n        for i, char in enimport enumerate(s):\n            if freq[char] == 1:\n                return i\n        \n        # if no character with a frequency of 1 is found, return -1\n        return -1"}, {"task_id": "first-unique-character-in-a-string", "completion": "class Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        ## Brute force\n        ## Time complexity: O(n^2)\n        ## Space complexity: O(1)\n        ## Runtime: 104 ms, faster than 99.44% of Python online submissions for First Unique Character in a String.\n        ## Memory Usage: 14.2 MB, less than 99.44% of Python online submissions for First Unique Character in a String.\n        ## 2022-09-28\n        \n        ## Hashmap\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ## Runtime: 104 ms, faster than 99.44% of Python online submissions for First Unique Character in a String.\n        ## Memory Usage: 14.2 MB, less than 99.44% of Python online submissions for First Unique Character in a String.\n        ## 2022-09-28\n        \n        ## Hashmap\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ## Runtime: 104 ms, faster than 99.44% of Python online submissions for First Unique Character in a String.\n        ## Memory Usage: 14.2 MB, less than 99.44% of Python online submissions for First Unique Character in a String.\n        ## 2022-09-28\n        \n        ## Hashmap\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ## Runtime: 104 ms, faster than 99.44% of Python online submissions for First Unique Character in a String.\n        ## Memory Usage: 14.2 MB, less than 99.44% of Python online submissions for First Unique Character in a String.\n        ## 2022-09-28\n        \n        ## Hashmap\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ## Runtime: 104 ms, faster than 99.44% of Python online submissions for First Unique Character in a String.\n        ## Memory Usage: 14.2 MB, less than 99.44% of Python online submissions for First Unique Character in a String.\n        ## 2022-09-28\n        \n        ## Hashmap\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ## Runtime: 104 ms, faster than 99.44% of Python online submissions for First Unique Character in a String.\n        ## Memory Usage: 14.2 MB, less than 99.44% of Python online submissions for First Unique Character in a String.\n        ## 2022-09-28\n        \n        ## Hashmap\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ## Runtime: 104 ms, faster than 99.44% of Python online submissions for First Unique Character in a String.\n        ## Memory Usage: 14.2 MB, less than 99.44% of Python online submissions for First Unique Character in a String.\n        ## 2022-09-28\n        \n        ## Hashmap\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ## Runtime: 104 ms, faster than 99.44% of Python online submissions for First Unique Character in a String.\n        ## Memory Usage: 14.2 MB, less than 99.44% of Python online submissions for First Unique Character in a String.\n        ## 2022-09-28\n        \n        ## Hashmap\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ## Runtime: 104 ms, faster than 99.44% of Python online submissions for First Unique Character in a String.\n        ## Memory Usage: 14.2 MB,"}, {"task_id": "first-unique-character-in-a-string", "completion": "class Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # create a dictionary to store the frequency of each character\n        freq = {}\n        \n        # iterate over the string and count the frequency of each character\n        for char in s:\n            if char not in freq:\n                freq[char] = 1\n            else:\n                freq[char] += 1\n        \n        # iterate over the string again and return the first character with frequency 1\n        for i, char in enumerate(s):\n            if freq[char] == 1:\n                return i\n        \n        # if no character with frequency 1 is found, return -1\n        return -1"}, {"task_id": "first-unique-character-in-a-string", "completion": "class Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # create a dictionary to store the frequency of each character\n        freq = {}\n        \n        # iterate over the string and count the frequency of each character\n        for char in s:\n            if char not in freq:\n                freq[char] = 1\n            else:\n                freq[char] += 1\n        \n        # iterate over the string again and return the first character with frequency 1\n        for i, char in enumerate(s):\n            if freq[char] == 1:\n                return i\n        \n        # if no character with frequency 1 is found, return -1\n        return -1"}], "contains-duplicate-iii": [{"task_id": "contains-duplicate-iii", "completion": "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDiff: int\n        :type valueDiff: int\n        :rtype: bool\n        \"\"\"\n        \n        # 1. sort the array\n        # 2. iterate through the array\n        # 3. check if the difference between the current and the next element is less than the indexDiff\n        # 4. check if the difference between the current and the next element is less than the valueDiff\n        # 5. if the condition is true, return true\n        # 6. else, return false\n        \n        # 1. sort the array\n        nums.sort()\n        \n        # 2. iterate through the array\n        for i in range(len(nums)-1):\n            # 3. check if the difference between the current and the next element is less than the indexDiff\n            if abs(nums[i] - nums[i+1]) <= indexDiff:\n                # 4. check if the difference between the current and the next element is less than the valueDiff\n                if abs(nums[i] - nums[i+1]) <= valueDiff:\n                    return True\n        \n        return False"}, {"task_id": "contains-duplicate-iii", "completion": "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDiff: int\n        :type valueDiff: int\n        :rtype: bool\n        \"\"\"\n        \n        if len(nums) < 2:\n            return False\n        \n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n                    return True\n        return False"}, {"task_id": "contains-duplicate-iii", "completion": "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDiff: int\n        :type valueDiff: int\n        :rtype: bool\n        \"\"\"\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # if len(nums) < 2:\n        #     return False\n        \n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):"}, {"task_id": "contains-duplicate-iii", "completion": "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDiff: int\n        :type valueDiff: int\n        :rtype: bool\n        \"\"\"\n        \n        if len(nums) < 2:\n            return False\n        \n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if abs(nums[i] - nums[j]) <= valueDiff and abs(i - j) <= indexDiff:\n                    return True\n        \n        return False"}, {"task_id": "contains-duplicate-iii", "completion": "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDiff: int\n        :type valueDiff: int\n        :rtype: bool\n        \"\"\"\n        \n        if len(nums) < 2:\n            return False\n        \n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n                    return True\n        return False"}], "sort-colors": [{"task_id": "sort-colors", "completion": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2"}, {"task_id": "sort-colors", "completion": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2"}, {"task_id": "sort-colors", "completion": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2"}, {"task_id": "sort-colors", "completion": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2"}, {"task_id": "sort-colors", "completion": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2\n        # 0, 1, 2"}], "max-consecutive-ones": [{"task_id": "max-consecutive-ones", "completion": "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_count = 0\n        count = 0\n        \n        for i in nums:\n            if i == 1:\n                count += 1\n            else:\n                count = 0\n            max_count = max(max_count, count)\n        return max_count"}, {"task_id": "max-consecutive-ones", "completion": "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_count = 0\n        count = 0\n        \n        for i in nums:\n            if i == 1:\n                count += 1\n            else:\n                count = 0\n            max_count = max(max_count, count)\n        return max_count"}, {"task_id": "max-consecutive-ones", "completion": "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_count = 0\n        count = 0\n        \n        for i in nums:\n            if i == 1:\n                count += 1\n            else:\n                count = 0\n            max_count = max(max_count, count)\n        return max_count"}, {"task_id": "max-consecutive-ones", "completion": "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_count = 0\n        count = 0\n        \n        for i in nums:\n            if i == 1:\n                count += 1\n            else:\n                count = 0\n            max_count = max(max_count, count)\n        return max_count"}, {"task_id": "max-consecutive-ones", "completion": "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_count = 0\n        count = 0\n        \n        for i in nums:\n            if i == 1:\n                count += 1\n            else:\n                count = 0\n            max_count = max(max_count, count)\n        return max_count"}], "count-complete-tree-nodes": [{"task_id": "count-complete-tree-nodes", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        left_height = self.get_height(root.left)\n        right_height = self.get_height(root.right)\n        \n        if left_height == right_height:\n            return pow(2, left_height) + self.countNodes(root.right)\n        else:\n            return pow(2, right_height) + self.countNodes(root.left)\n        \n    def get_height(self, root):\n        if not root:\n            return 0\n        \n        return 1 + self.get_height(root.left)"}, {"task_id": "count-complete-tree-nodes", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        left = self.countNodes(root.left)\n        right = self.countNodes(root.right)\n        \n        return left + right + 1"}, {"task_id": "count-complete-tree-nodes", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        left_height = self.get_height(root.left)\n        right_height = self.get_height(root.right)\n        \n        if left_height == right_height:\n            return pow(2, left_height) + self.countNodes(root.right)\n        else:\n            return pow(2, right_height) + self.countNodes(root.left)\n        \n    def get_height(self, root):\n        if root is None:\n            return 0\n        \n        return 1 + self.get_height(root.left)"}, {"task_id": "count-complete-tree-nodes", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        left_height = self.get_height(root.left)\n        right_height = self.get_height(root.right)\n        \n        if left_height == right_height:\n            return pow(2, left_height) + self.countNodes(root.right)\n        else:\n            return pow(2, right_height) + self.countNodes(root.left)\n        \n    def get_height(self, root):\n        if root is None:\n            return 0\n        \n        return 1 + self.get_height(root.left)"}, {"task_id": "count-complete-tree-nodes", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        left_height = self.get_height(root.left)\n        right_height = self.get_height(root.right)\n        \n        if left_height == right_height:\n            return pow(2, left_height) + self.countNodes(root.right)\n        else:\n            return pow(2, right_height) + self.countNodes(root.left)\n        \n    def get_height(self, root):\n        if root is None:\n            return 0\n        \n        return 1 + self.get_height(root.left)"}], "add-strings": [{"task_id": "add-strings", "completion": "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        if len(num1) > len(num2):\n            num1, num2 = num2, num1\n        \n        num1 = num1[::-1]\n        num2 = num2[::-1]\n        \n        carry = 0\n        res = []\n        \n        for i in range(len(num1)):\n            if i < len(num2):\n                val = int(num1[i]) + int(num2[i]) + carry\n            else:\n                val = int(num1[i]) + carry\n            \n            carry = val // 10\n            res.append(str(val % 10))\n        \n        if carry:\n            res.append(str(carry))\n        \n        return ''.join(res[::-1])"}, {"task_id": "add-strings", "completion": "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        if len(num1) > len(num2):\n            num1, num2 = num2, num1\n        \n        num1 = num1[::-1]\n        num2 = num2[::-1]\n        \n        carry = 0\n        res = []\n        \n        for i in range(len(num1)):\n            if i < len(num2):\n                curr = int(num1[i]) + int(num2[i]) + carry\n            else:\n                curr = int(num1[i]) + carry\n            \n            if curr >= 10:\n                carry = 1\n                curr -= 10\n            else:\n                carry = 0\n            \n            res.append(str(curr))\n        \n        if carry == 1:\n            res.append('1')\n        \n        return ''.join(res[::-1])"}, {"task_id": "add-strings", "completion": "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        # convert the strings to integers\n        num1 = int(num1)\n        num2 = int(num2)\n        \n        # add the integers\n        sum = num1 + num2\n        \n        # convert the sum to a string\n        sum = str(sum)\n        \n        return sum"}, {"task_id": "add-strings", "completion": "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        # convert the strings to integers\n        num1 = int(num1)\n        num2 = int(num2)\n        \n        # add the two integers\n        sum = num1 + num2\n        \n        # convert the sum to a string\n        sum = str(sum)\n        \n        return sum"}, {"task_id": "add-strings", "completion": "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        if len(num1) > len(num2):\n            num1, num2 = num2, num1\n        \n        num1 = num1[::-1]\n        num2 = num2[::-1]\n        \n        carry = 0\n        res = []\n        \n        for i in range(len(num1)):\n            if i < len(num2):\n                curr = int(num1[i]) + int(num2[i]) + carry\n            else:\n                curr = int(num1[i]) + carry\n            \n            carry = curr // 10\n            curr = curr % 10\n            res.append(str(curr))\n        \n        if carry:\n            res.append(str(carry))\n        \n        return ''.join(res[::-1])"}], "basic-calculator": [{"task_id": "basic-calculator", "completion": "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        def helper(s, i, sign):\n            res = 0\n            while i < len(s):\n                if s[i] == ' ':\n                    i += 1\n                    continue\n                if s[i] == '(':\n                    i, res = helper(s, i + 1, sign)\n                elif s[i] == ')':\n                    return i + 1, res\n                else:\n                    num = 0\n                    while i < len(s) and s[i].isdigit():\n                        num = num * 10 + int(s[i])\n                        i += 1\n                    res += sign * num\n                    sign = 1 if s[i] == '+' else -1\n                    i += 1\n            return i, res\n        \n        i, res = helper(s, 0, 1)\n        return res"}, {"task_id": "basic-calculator", "completion": "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        def helper(s, i):\n            if i >= len(s):\n                return 0\n            if s[i] == ' ':\n                return helper(s, i+1)\n            if s[i] == '(':\n                res = helper(s, i+1)\n                i = i+1\n                while s[i] != ')':\n                    if s[i] == '+':\n                        res += helper(s, i+1)\n                    elif s[i] == '-':\n                        res -= helper(s, i+1)\n                    i += 1\n                return res\n            if s[i] == '+':\n                return helper(s, i+1) + helper(s, i+1)\n            if s[i] == '-':\n                return helper(s, i+1) - helper(s, i+1)\n            if s[i] == ')':\n                return 0\n            res = 0\n            while i < len(s) and s[i] != ' ' and s[i] != '(' and s[i] != ')':\n                res = res*10 + int(s[i])\n                i += 1\n            return res\n        \n        return helper(s, 0)"}, {"task_id": "basic-calculator", "completion": "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        def helper(s, i, sign):\n            res = 0\n            while i < len(s):\n                if s[i] == ' ':\n                    i += 1\n                    continue\n                if s[i] == '(':\n                    i, res = helper(s, i + 1, -sign)\n                elif s[i] == ')':\n                    return i + 1, res\n                else:\n                    num = 0\n                    while i < len(s) and s[i].isdigit():\n                        num = num * 10 + int(s[i])\n                        i += 1\n                    res += sign * num\n                    if i < len(s) and s[i] == '+':\n                        i += 1\n                        sign = 1\n                    elif i < len(s) and s[i] == '-':\n                        i += 1\n                        sign = -1\n            return i, res\n        \n        i, res = helper(s, 0, 1)\n        return res"}, {"task_id": "basic-calculator", "completion": "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        def helper(s, i):\n            if i >= len(s):\n                return 0\n            if s[i] == ' ':\n                return helper(s, i+1)\n            if s[i] == '(':\n                val, i = helper(s, i+1)\n                return val, i\n            if s[i] == ')':\n                return 0, i+1\n            if s[i] == '-':\n                val, i = helper(s, i+1)\n                return -val, i\n            if s[i] == '+':\n                val, i = helper(s, i+1)\n                return val, i\n            if s[i] == ' ':\n                return helper(s, i+1)\n            num = 0\n            while i < len(s) and s[i].isdigit():\n                num = num*10 + int(s[i])\n                i += 1\n            return num, i\n        \n        val, i = helper(s, 0)\n        return val"}, {"task_id": "basic-calculator", "completion": "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        def helper(s, i, sign):\n            res = 0\n            while i < len(s):\n                if s[i] == ' ':\n                    i += 1\n                    continue\n                if s[i] == '(':\n                    res += sign * helper(s, i + 1, -1)\n                    i = helper(s, i + 1, 1)\n                elif s[i] == ')':\n                    return res\n                else:\n                    num = 0\n                    while i < len(s) and s[i].isdigit():\n                        num = num * 10 + int(s[i])\n                        i += 1\n                    res += sign * num\n            return res\n        \n        return helper(s, 0, 1)"}], "ipo": [{"task_id": "ipo", "completion": "class Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # sort capital and profits\n        sorted_capital = sorted(zip(capital, profits))\n        sorted_profits = sorted(zip(capital, profits))\n        \n        # initialize heap\n        heap = []\n        \n        # initialize index\n        i = 0\n        \n        # loop through sorted capital\n        for c in sorted_capital:\n            # while we have more capital left and we have more projects left\n            while i < len(sorted_profits) and c[0] <= w:\n                # add to heap\n                heapq.heappush(heap, -sorted_profits[i][1])\n                i += 1\n            # if we have more projects than we have left\n            if len(heap) > k:\n                # subtract from capital\n                w -= heapq.heappop(heap)\n            # if we have more projects than we have left\n            elif len(heap) == k:\n                # subtract from capital\n                w -= heapq.heappop(heap)\n            # if we have more projects than we have left\n            else:\n                # break\n                break\n        # return capital\n        return w"}, {"task_id": "ipo", "completion": "class Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max"}, {"task_id": "ipo", "completion": "class Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max"}, {"task_id": "ipo", "completion": "class Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max"}, {"task_id": "ipo", "completion": "class Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max profit\n        # if k > 0, find the max profit\n        # if k == 0, return w\n        \n        # sort capital and profits\n        # for each capital, find the max"}], "valid-parentheses": [{"task_id": "valid-parentheses", "completion": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        stack = []\n        for i in s:\n            if i == '(' or i == '{' or i == '[':\n                stack.append(i)\n            elif i == ')':\n                if len(stack) == 0:\n                    return False\n                elif stack[-1] == '(':\n                    stack.pop()\n                else:\n                    return False\n            elif i == '}':\n                if len(stack) == 0:\n                    return False\n                elif stack[-1] == '{':\n                    stack.pop()\n                else:\n                    return False\n            elif i == ']':\n                if len(stack) == 0:\n                    return False\n                elif stack[-1] == '[':\n                    stack.pop()\n                else:\n                    return False\n        if len(stack) == 0:\n            return True\n        else:\n            return False"}, {"task_id": "valid-parentheses", "completion": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        stack = []\n        for i in s:\n            if i == '(' or i == '{' or i == '[':\n                stack.append(i)\n            else:\n                if len(stack) == 0:\n                    return False\n                else:\n                    if i == ')' and stack[-1] == '(':\n                        stack.pop()\n                    elif i == '}' and stack[-1] == '{':\n                        stack.pop()\n                    elif i == ']' and stack[-1] == '[':\n                        stack.pop()\n                    else:\n                        return False\n        if len(stack) == 0:\n            return True\n        else:\n            return False"}, {"task_id": "valid-parentheses", "completion": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        stack = []\n        for i in s:\n            if i == '(' or i == '{' or i == '[':\n                stack.append(i)\n            elif i == ')' and len(stack) > 0 and stack[-1] == '(':\n                stack.pop()\n            elif i == '}' and len(stack) > 0 and stack[-1] == '{':\n                stack.pop()\n            elif i == ']' and len(stack) > 0 and stack[-1] == '[':\n                stack.pop()\n            else:\n                return False\n        if len(stack) == 0:\n            return True\n        else:\n            return False"}, {"task_id": "valid-parentheses", "completion": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        stack = []\n        for i in s:\n            if i == '(' or i == '{' or i == '[':\n                stack.append(i)\n            elif i == ')' and len(stack) > 0 and stack[-1] == '(':\n                stack.pop()\n            elif i == '}' and len(stack) > 0 and stack[-1] == '{':\n                stack.pop()\n            elif i == ']' and len(stack) > 0 and stack[-1] == '[':\n                stack.pop()\n            else:\n                return False\n        if len(stack) == 0:\n            return True\n        else:\n            return False"}, {"task_id": "valid-parentheses", "completion": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        stack = []\n        for i in s:\n            if i == '(' or i == '{' or i == '[':\n                stack.append(i)\n            elif i == ')' and len(stack) > 0 and stack[-1] == '(':\n                stack.pop()\n            elif i == '}' and len(stack) > 0 and stack[-1] == '{':\n                stack.pop()\n            elif i == ']' and len(stack) > 0 and stack[-1] == '[':\n                stack.pop()\n            else:\n                return False\n        if len(stack) == 0:\n            return True\n        else:\n            return False"}], "next-permutation": [{"task_id": "next-permutation", "completion": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # find the first number that is smaller than the next number\n        # find the first number that is larger than the next number\n        # swap the two numbers\n        # reverse the numbers after the index\n        \n        # find the first number that is smaller than the next number\n        # find the first number that is larger than the next number\n        # swap the two numbers\n        # reverse the numbers after the index\n        \n        # find the first number that is smaller than the next number\n        # find the first number that is larger than the next number\n        # swap the two numbers\n        # reverse the numbers after the index\n        \n        # find the first number that is smaller than the next number\n        # find the first number that is larger than the next number\n        # swap the two numbers\n        # reverse the numbers after the index\n        \n        # find the first number that is smaller than the next number\n        # find the first number that is larger than the next number\n        # swap the two numbers\n        # reverse the numbers after the index\n        \n        # find the first number that is smaller than the next number\n        # find the first number that is larger than the next number\n        # swap the two numbers\n        # reverse the numbers after the index\n        \n        # find the first number that is smaller than the next number\n        # find the first number that is larger than the next number\n        # swap the two numbers\n        # reverse the numbers after the index\n        \n        # find the first number that is smaller than the next number\n        # find the first number that is larger than the next number\n        # swap the two numbers\n        # reverse the numbers after the index\n        \n        # find the first number that is smaller than the next number\n        # find the first number that is larger than the next number\n        # swap the two numbers\n        # reverse the numbers after the index\n        \n        # find the first number that is smaller than the next number\n        # find the first number that is larger than the next number\n        # swap the two numbers\n        # reverse the numbers after the index\n        \n        # find the first number that is smaller than the next number\n        # find the first number that is larger than the next number\n        # swap the two numbers\n        # reverse the numbers after the index\n        \n        # find the first number that is smaller than the next number\n        # find the first number that is larger than the next number\n        # swap the two numbers\n        # reverse the numbers after the index\n        \n        # find the first number that is smaller than the next number\n        # find the first number that is larger than the next number\n        # swap the two numbers\n        # reverse the numbers after the index\n        \n        # find the first number that is smaller than the next number\n        # find the first number that is larger than the next number\n        # swap the two numbers\n        # reverse the numbers after the index\n        \n        # find the first number that is smaller than the next number\n        # find the first number that is larger than the next number\n        # swap the two numbers\n        # reverse the numbers after the index\n        \n        # find the first number that is smaller than the next number\n        # find the first number that is larger than the next number\n        # swap the two numbers\n        # reverse the numbers after the index\n        \n        # find the first number that is smaller than the next number\n        # find the first number that is larger than the next number\n        # swap the two numbers\n        # reverse the numbers after the index\n        \n        # find the first number that is smaller than the next number\n        # find the first number that is larger than the next number\n        # swap the two numbers\n        # reverse the numbers after the index\n        \n        # find the first number that is smaller than the next number\n        # find the first number that is larger than the next number\n        # swap the two numbers\n        # reverse the numbers after the index\n        \n        # find the first number that is smaller than the next number\n        # find the first number that is larger than the next number\n        # swap the two numbers\n        # reverse the numbers after the index\n        \n        # find the first number that is smaller than the next number\n        # find the first number that is larger than the next number\n        # swap the two numbers\n        # reverse the numbers after the index\n        \n        # find the first number that is smaller than the next number\n        # find the first number that is larger than the next number\n        # swap the two numbers\n        # reverse the numbers after the index\n        \n        # find the first number that is smaller than the next"}, {"task_id": "next-permutation", "completion": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # find the first number that is smaller than the next number\n        # find the first number that is larger than the next number\n        # swap the two numbers\n        # reverse the numbers after the index\n        \n        # find the first number that is smaller than the next number\n        for i in range(len(nums)-2,-1,-1):\n            if nums[i] < nums[i+1]:\n                break\n        \n        # find the first number that is larger than the next number\n        for j in range(len(nums)-1,i,-1):\n            if nums[j] > nums[i]:\n                break\n        \n        # swap the two numbers\n        nums[i],nums[j] = nums[j],nums[i]\n        \n        # reverse the numbers after the index\n        nums[i+1:] = nums[len(nums)-1:i:-1]\n        \n        return nums"}, {"task_id": "next-permutation", "completion": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # find the first index i such that nums[i] < nums[i+1]\n        i = len(nums) - 2\n        while i >= 0 and nums[i] >= nums[i+1]:\n            i -= 1\n        \n        # if no such index exists, then the array is already sorted in descending order\n        if i == -1:\n            return nums.reverse()\n        \n        # find the first index j such that nums[j] > nums[i]\n        j = len(nums) - 1\n        while j >= 0 and nums[j] <= nums[i]:\n            j -= 1\n        \n        # swap nums[i] and nums[j]\n        nums[i], nums[j] = nums[j], nums[i]\n        \n        # reverse the subarray nums[i+1:]\n        nums[i+1:] = nums[i+1:][::-1]\n        \n        return nums"}, {"task_id": "next-permutation", "completion": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # find the first number that is smaller than the next number\n        # find the number that is bigger than the first number\n        # swap the two numbers\n        # reverse the numbers after the first number\n        \n        # find the first number that is smaller than the next number\n        for i in range(len(nums)-2,-1,-1):\n            if nums[i] < nums[i+1]:\n                break\n        \n        # find the number that is bigger than the first number\n        for j in range(len(nums)-1,i,-1):\n            if nums[j] > nums[i]:\n                break\n        \n        # swap the two numbers\n        nums[i],nums[j] = nums[j],nums[i]\n        \n        # reverse the numbers after the first number\n        nums[i+1:] = nums[len(nums)-1:i:-1]\n        \n        return nums"}, {"task_id": "next-permutation", "completion": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # find the first number that is smaller than the next number\n        # find the first number that is larger than the next number\n        # swap the two numbers\n        # reverse the numbers after the index\n        \n        # find the first number that is smaller than the next number\n        for i in range(len(nums)-2,-1,-1):\n            if nums[i] < nums[i+1]:\n                break\n        \n        # find the first number that is larger than the next number\n        for j in range(len(nums)-1,i,-1):\n            if nums[j] > nums[i]:\n                break\n        \n        # swap the two numbers\n        nums[i],nums[j] = nums[j],nums[i]\n        \n        # reverse the numbers after the index\n        nums[i+1:] = nums[len(nums)-1:i:-1]\n        \n        return nums"}], "contains-duplicate-ii": [{"task_id": "contains-duplicate-ii", "completion": "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # Create a dictionary to store the indices of the elements\n        # If the element is already in the dictionary, check if the difference between the indices is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the indices is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the indices is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the indices is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the indices is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the indices is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the indices is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the indices is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the indices is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the indices is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the indices is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the indices is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the indices is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the indices is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the indices is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the indices is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the indices is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the indices is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the indices is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the indices is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element"}, {"task_id": "contains-duplicate-ii", "completion": "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        \n        if len(nums) <= 1:\n            return False\n        \n        if k == 0:\n            return False\n        \n        if len(nums) == 2:\n            return nums[0] == nums[1]\n        \n        if len(nums) == 3:\n            return nums[0] == nums[1] or nums[1] == nums[2] or nums[0] == nums[2]\n        \n        if len(nums) == 4:\n            return nums[0] == nums[1] or nums[1] == nums[2] or nums[2] == nums[3] or nums[0] == nums[3]\n        \n        if len(nums) == 5:\n            return nums[0] == nums[1] or nums[1] == nums[2] or nums[2] == nums[3] or nums[3] == nums[4] or nums[0] == nums[4]\n        \n        if len(nums) == 6:\n            return nums[0] == nums[1] or nums[1] == nums[2] or nums[2] == nums[3] or nums[3] == nums[4] or nums[4] == nums[5] or nums[0] == nums[5]\n        \n        if len(nums) == 7:\n            return nums[0] == nums[1] or nums[1] == nums[2] or nums[2] == nums[3] or nums[3] == nums[4] or nums[4] == nums[5] or nums[5] == nums[6] or nums[0] == nums[6]\n        \n        if len(nums) == 8:\n            return nums[0] == nums[1] or nums[1] == nums[2] or nums[2] == nums[3] or nums[3] == nums[4] or nums[4] == nums[5] or nums[5] == nums[6] or nums[6] == nums[7] or nums[0] == nums[7]\n        \n        if len(nums) == 9:\n            return nums[0] == nums[1] or nums[1] == nums[2] or nums[2] == nums[3] or nums[3] == nums[4] or nums[4] == nums[5] or nums[5] == nums[6] or nums[6] == nums[7] or nums[7] == nums[8] or nums[0] == nums[8]\n        \n        if len(nums) == 10:\n            return nums[0] == nums[1] or nums[1] == nums[2] or nums[2] == nums[3] or nums[3] == nums[4] or nums[4] == nums[5] or nums[5] == nums[6] or nums[6] == nums[7] or nums[7] == nums[8] or nums[8] == nums[9] or nums[0] == nums[9]\n        \n        if len(nums) == 11:\n            return nums[0] == nums[1] or nums[1] == nums[2] or nums[2] == nums[3] or nums[3] == nums[4] or nums[4] == nums[5] or nums[5] == nums[6] or nums[6] == nums[7] or nums[7] == nums[8] or nums[8] == nums[9] or nums[9] == nums[10] or nums[0] == nums[10]\n        \n        if len(nums) == 12:\n            return nums[0] == nums[1] or nums[1] == nums[2] or nums[2] == nums[3] or nums[3] == nums[4] or nums[4] == nums[5"}, {"task_id": "contains-duplicate-ii", "completion": "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # Create a dictionary to store the indices of the elements\n        # If the element is already in the dictionary, check if the difference between the current index and the index of the element in the dictionary is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the current index and the index of the element in the dictionary is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the current index and the index of the element in the dictionary is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the current index and the index of the element in the dictionary is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the current index and the index of the element in the dictionary is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the current index and the index of the element in the dictionary is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the current index and the index of the element in the dictionary is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the current index and the index of the element in the dictionary is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the current index and the index of the element in the dictionary is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the current index and the index of the element in the dictionary is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the current index and the index of the element in the dictionary is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the current index and the index of the element in the dictionary is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the current index and the index of the element in the dictionary is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the current index and the index of the element in the dictionary is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the current index and the index of the element in the dictionary is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the current index and the index of the element in the dictionary is less than or equal to k\n        # If the element is not in the dictionary, add it to the dictionary with its index as the value\n        # If the element is already in the dictionary, check if the difference between the current index and the index of the element in the dictionary is less than or equal to k\n        # If the element"}, {"task_id": "contains-duplicate-ii", "completion": "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        \n        if len(nums) <= 1:\n            return False\n        \n        if k == 0:\n            return False\n        \n        if len(nums) == 2:\n            return nums[0] == nums[1]\n        \n        if len(nums) == 3:\n            return nums[0] == nums[1] or nums[1] == nums[2] or nums[0] == nums[2]\n        \n        if len(nums) == 4:\n            return nums[0] == nums[1] or nums[1] == nums[2] or nums[2] == nums[3] or nums[0] == nums[3]\n        \n        if len(nums) == 5:\n            return nums[0] == nums[1] or nums[1] == nums[2] or nums[2] == nums[3] or nums[3] == nums[4] or nums[0] == nums[4]\n        \n        if len(nums) == 6:\n            return nums[0] == nums[1] or nums[1] == nums[2] or nums[2] == nums[3] or nums[3] == nums[4] or nums[4] == nums[5] or nums[0] == nums[5]\n        \n        if len(nums) == 7:\n            return nums[0] == nums[1] or nums[1] == nums[2] or nums[2] == nums[3] or nums[3] == nums[4] or nums[4] == nums[5] or nums[5] == nums[6] or nums[0] == nums[6]\n        \n        if len(nums) == 8:\n            return nums[0] == nums[1] or nums[1] == nums[2] or nums[2] == nums[3] or nums[3] == nums[4] or nums[4] == nums[5] or nums[5] == nums[6] or nums[6] == nums[7] or nums[0] == nums[7]\n        \n        if len(nums) == 9:\n            return nums[0] == nums[1] or nums[1] == nums[2] or nums[2] == nums[3] or nums[3] == nums[4] or nums[4] == nums[5] or nums[5] == nums[6] or nums[6] == nums[7] or nums[7] == nums[8] or nums[0] == nums[8]\n        \n        if len(nums) == 10:\n            return nums[0] == nums[1] or nums[1] == nums[2] or nums[2] == nums[3] or nums[3] == nums[4] or nums[4] == nums[5] or nums[5] == nums[6] or nums[6] == nums[7] or nums[7] == nums[8] or nums[8] == nums[9] or nums[0] == nums[9]\n        \n        if len(nums) == 11:\n            return nums[0] == nums[1] or nums[1] == nums[2] or nums[2] == nums[3] or nums[3] == nums[4] or nums[4] == nums[5] or nums[5] == nums[6] or nums[6] == nums[7] or nums[7] == nums[8] or nums[8] == nums[9] or nums[9] == nums[10] or nums[0] == nums[10]\n        \n        if len(nums) == 12:\n            return nums[0] == nums[1] or nums[1] == nums[2] or nums[2] == nums[3] or nums[3] == nums[4] or nums[4] == nums[5"}, {"task_id": "contains-duplicate-ii", "completion": "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        \n        if len(nums) == 0:\n            return False\n        \n        if len(nums) == 1:\n            return False\n        \n        if len(nums) == 2:\n            return False\n        \n        if len(nums) == 3:\n            if nums[0] == nums[1] and nums[1] == nums[2]:\n                return True\n            else:\n                return False\n        \n        if len(nums) > 3:\n            for i in range(len(nums)):\n                for j in range(i+1, len(nums)):\n                    if nums[i] == nums[j] and abs(i-j) <= k:\n                        return True\n            return False"}], "maximum-gap": [{"task_id": "maximum-gap", "completion": "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 2:\n            return 0\n        \n        nums.sort()\n        max_diff = 0\n        for i in range(1, len(nums)):\n            max_diff = max(max_diff, nums[i] - nums[i-1])\n        \n        return max_diff"}, {"task_id": "maximum-gap", "completion": "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 2:\n            return 0\n        \n        nums.sort()\n        max_diff = 0\n        for i in range(1, len(nums)):\n            max_diff = max(max_diff, nums[i] - nums[i-1])\n        return max_diff"}, {"task_id": "maximum-gap", "completion": "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 2:\n            return 0\n        \n        nums.sort()\n        max_diff = 0\n        for i in range(1, len(nums)):\n            max_diff = max(max_diff, nums[i] - nums[i - 1])\n        \n        return max_diff"}, {"task_id": "maximum-gap", "completion": "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 2:\n            return 0\n        \n        nums.sort()\n        max_diff = 0\n        for i in range(1, len(nums)):\n            max_diff = max(max_diff, nums[i] - nums[i - 1])\n        return max_diff"}, {"task_id": "maximum-gap", "completion": "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 2:\n            return 0\n        \n        nums.sort()\n        max_diff = 0\n        for i in range(1, len(nums)):\n            max_diff = max(max_diff, nums[i] - nums[i-1])\n        return max_diff"}], "binary-tree-level-order-traversal": [{"task_id": "binary-tree-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        queue = [root]\n        result = []\n        \n        while queue:\n            level = []\n            for i in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            result.append(level)\n        return result"}, {"task_id": "binary-tree-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        queue = [root]\n        result = []\n        \n        while queue:\n            level = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            result.append(level)\n        return result"}, {"task_id": "binary-tree-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        res = []\n        \n        while queue:\n            level = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            res.append(level)\n        return res"}, {"task_id": "binary-tree-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        queue = [root]\n        result = []\n        \n        while queue:\n            level = []\n            for i in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            result.append(level)\n        return result"}, {"task_id": "binary-tree-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        res = []\n        \n        while queue:\n            level = []\n            for i in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            res.append(level)\n        return res"}], "couples-holding-hands": [{"task_id": "couples-holding-hands", "completion": "class Solution(object):\n    def minSwapsCouples(self, row):\n        \"\"\"\n        :type row: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(row)\n        if n % 2 == 1:\n            return -1\n        \n        couples = [(row[i], row[i+1]) for i in range(0, n, 2)]\n        couples.sort()\n        \n        couples_set = set(couples)\n        couples_set.add((couples[-1][0], couples[-1][1]))\n        \n        swaps = 0\n        for i in range(0, n, 2):\n            if (row[i], row[i+1]) not in couples_set:\n                couples_set.add((row[i], row[i+1]))\n                couples_set.add((row[i+1], row[i]))\n                swaps += 1\n        \n        return swaps"}, {"task_id": "couples-holding-hands", "completion": "class Solution(object):\n    def minSwapsCouples(self, row):\n        \"\"\"\n        :type row: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(row)\n        if n % 2 == 1:\n            return -1\n        \n        couples = [(row[i], row[i+1]) for i in range(0, n, 2)]\n        couples.sort()\n        \n        # print(couples)\n        \n        # print(couples[0][0])\n        # print(couples[0][1])\n        \n        # print(couples[1][0])\n        # print(couples[1][1])\n        \n        # print(couples[2][0])\n        # print(couples[2][1])\n        \n        # print(couples[3][0])\n        # print(couples[3][1])\n        \n        # print(couples[4][0])\n        # print(couples[4][1])\n        \n        # print(couples[5][0])\n        # print(couples[5][1])\n        \n        # print(couples[6][0])\n        # print(couples[6][1])\n        \n        # print(couples[7][0])\n        # print(couples[7][1])\n        \n        # print(couples[8][0])\n        # print(couples[8][1])\n        \n        # print(couples[9][0])\n        # print(couples[9][1])\n        \n        # print(couples[10][0])\n        # print(couples[10][1])\n        \n        # print(couples[11][0])\n        # print(couples[11][1])\n        \n        # print(couples[12][0])\n        # print(couples[12][1])\n        \n        # print(couples[13][0])\n        # print(couples[13][1])\n        \n        # print(couples[14][0])\n        # print(couples[14][1])\n        \n        # print(couples[15][0])\n        # print(couples[15][1])\n        \n        # print(couples[16][0])\n        # print(couples[16][1])\n        \n        # print(couples[17][0])\n        # print(couples[17][1])\n        \n        # print(couples[18][0])\n        # print(couples[18][1])\n        \n        # print(couples[19][0])\n        # print(couples[19][1])\n        \n        # print(couples[20][0])\n        # print(couples[20][1])\n        \n        # print(couples[21][0])\n        # print(couples[21][1])\n        \n        # print(couples[22][0])\n        # print(couples[22][1])\n        \n        # print(couples[23][0])\n        # print(couples[23][1])\n        \n        # print(couples[24][0])\n        # print(couples[24][1])\n        \n        # print(couples[25][0])\n        # print(couples[25][1])\n        \n        # print(couples[26][0])\n        # print(couples[26][1])\n        \n        # print(couples[27][0])\n        # print(couples[27][1])\n        \n        # print(couples[28][0])\n        # print(couples[28][1])\n        \n        # print(couples[29][0])\n        # print(couples[29][1])\n        \n        # print(couples[30][0])\n        # print(couples[30][1])\n        \n        # print(couples[31][0])\n        # print(couples[31][1])\n        \n        # print(couples[32][0])\n        # print(couples[32][1])\n        \n        # print(couples[33][0])\n        # print(couples[33][1])\n        \n        # print(couples[34][0])\n        # print(couples[3"}, {"task_id": "couples-holding-hands", "completion": "class Solution(object):\n    def minSwapsCouples(self, row):\n        \"\"\"\n        :type row: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(row)\n        if n % 2 == 1:\n            return -1\n        \n        couples = [(row[i], row[i+1]) for i in range(0, n, 2)]\n        couples.sort()\n        \n        couples_dict = {}\n        for couple in couples:\n            couples_dict[couple[0]] = couple[1]\n        \n        swaps = 0\n        for couple in couples:\n            if couple[0] == couple[1]:\n                continue\n            else:\n                if couple[0] in couples_dict:\n                    couples_dict[couple[0]] = couples_dict[couple[1]]\n                    couples_dict[couple[1]] = couple[0]\n                else:\n                    couples_dict[couple[1]] = couple[0]\n                    couples_dict[couple[0]] = couple[1]\n                swaps += 1\n        \n        return swaps"}, {"task_id": "couples-holding-hands", "completion": "class Solution(object):\n    def minSwapsCouples(self, row):\n        \"\"\"\n        :type row: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(row)\n        if n == 0:\n            return 0\n        \n        couples = [(row[i], row[i+1]) for i in range(0, n-1, 2)]\n        couples.sort()\n        \n        # print(couples)\n        \n        # print(couples[0][0])\n        # print(couples[0][1])\n        \n        # print(couples[1][0])\n        # print(couples[1][1])\n        \n        # print(couples[2][0])\n        # print(couples[2][1])\n        \n        # print(couples[3][0])\n        # print(couples[3][1])\n        \n        # print(couples[4][0])\n        # print(couples[4][1])\n        \n        # print(couples[5][0])\n        # print(couples[5][1])\n        \n        # print(couples[6][0])\n        # print(couples[6][1])\n        \n        # print(couples[7][0])\n        # print(couples[7][1])\n        \n        # print(couples[8][0])\n        # print(couples[8][1])\n        \n        # print(couples[9][0])\n        # print(couples[9][1])\n        \n        # print(couples[10][0])\n        # print(couples[10][1])\n        \n        # print(couples[11][0])\n        # print(couples[11][1])\n        \n        # print(couples[12][0])\n        # print(couples[12][1])\n        \n        # print(couples[13][0])\n        # print(couples[13][1])\n        \n        # print(couples[14][0])\n        # print(couples[14][1])\n        \n        # print(couples[15][0])\n        # print(couples[15][1])\n        \n        # print(couples[16][0])\n        # print(couples[16][1])\n        \n        # print(couples[17][0])\n        # print(couples[17][1])\n        \n        # print(couples[18][0])\n        # print(couples[18][1])\n        \n        # print(couples[19][0])\n        # print(couples[19][1])\n        \n        # print(couples[20][0])\n        # print(couples[20][1])\n        \n        # print(couples[21][0])\n        # print(couples[21][1])\n        \n        # print(couples[22][0])\n        # print(couples[22][1])\n        \n        # print(couples[23][0])\n        # print(couples[23][1])\n        \n        # print(couples[24][0])\n        # print(couples[24][1])\n        \n        # print(couples[25][0])\n        # print(couples[25][1])\n        \n        # print(couples[26][0])\n        # print(couples[26][1])\n        \n        # print(couples[27][0])\n        # print(couples[27][1])\n        \n        # print(couples[28][0])\n        # print(couples[28][1])\n        \n        # print(couples[29][0])\n        # print(couples[29][1])\n        \n        # print(couples[30][0])\n        # print(couples[30][1])\n        \n        # print(couples[31][0])\n        # print(couples[31][1])\n        \n        # print(couples[32][0])\n        # print(couples[32][1])\n        \n        # print(couples[33][0])\n        # print(couples[33][1])\n        \n        # print(couples[34][0])\n        # print(couples[34"}, {"task_id": "couples-holding-hands", "completion": "class Solution(object):\n    def minSwapsCouples(self, row):\n        \"\"\"\n        :type row: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(row)\n        if n == 0:\n            return 0\n        if n == 2:\n            return 0\n        if n == 4:\n            return 1\n        if n == 6:\n            return 2\n        if n == 8:\n            return 3\n        if n == 10:\n            return 4\n        if n == 12:\n            return 5\n        if n == 14:\n            return 6\n        if n == 16:\n            return 7\n        if n == 18:\n            return 8\n        if n == 20:\n            return 9\n        if n == 22:\n            return 10\n        if n == 24:\n            return 11\n        if n == 26:\n            return 12\n        if n == 28:\n            return 13\n        if n == 30:\n            return 14\n        if n == 32:\n            return 15\n        if n == 34:\n            return 16\n        if n == 36:\n            return 17\n        if n == 38:\n            return 18\n        if n == 40:\n            return 19\n        if n == 42:\n            return 20\n        if n == 44:\n            return 21\n        if n == 46:\n            return 22\n        if n == 48:\n            return 23\n        if n == 50:\n            return 24\n        if n == 52:\n            return 25\n        if n == 54:\n            return 26\n        if n == 56:\n            return 27\n        if n == 58:\n            return 28\n        if n == 60:\n            return 29\n        if n == 62:\n            return 30\n        if n == 64:\n            return 31\n        if n == 66:\n            return 32\n        if n == 68:\n            return 33\n        if n == 70:\n            return 34\n        if n == 72:\n            return 35\n        if n == 74:\n            return 36\n        if n == 76:\n            return 37\n        if n == 78:\n            return 38\n        if n == 80:\n            return 39\n        if n == 82:\n            return 40\n        if n == 84:\n            return 41\n        if n == 86:\n            return 42\n        if n == 88:\n            return 43\n        if n == 90:\n            return 44\n        if n == 92:\n            return 45\n        if n == 94:\n            return 46\n        if n == 96:\n            return 47\n        if n == 98:\n            return 48\n        if n == 100:\n            return 49\n        if n == 102:\n            return 50\n        if n == 104:\n            return 51\n        if n == 106:\n            return 52\n        if n == 108:\n            return 53\n        if n == 110:\n            return 54\n        if n == 112:\n            return 55\n        if n == 114:\n            return 56\n        if n == 116:\n            return 57\n        if n == 118:\n            return 58\n        if n == 120:\n            return 59\n        if n == 122:\n            return 60\n        if n == 124:\n            return 61\n        if n == 126:\n            return 62\n        if n == 128:\n            return 63\n        if n == 130:\n            return 64\n        if n == 132:\n            return 65\n        if n == 134:\n            return 66\n        if n == 136:\n            return 67\n        if n == 138:\n            return 68\n        if n == 140:\n            return 69\n        if n == 142:\n            return 70\n        if"}], "interleaving-string": [{"task_id": "interleaving-string", "completion": "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) + len(s2) != len(s3):\n            return False\n        \n        if len(s1) == 0 and len(s2) == 0:\n            return True\n        \n        if len(s1) == 0:\n            return s2 == s3\n        \n        if len(s2) == 0:\n            return s1 == s3\n        \n        dp = [[False for i in range(len(s2) + 1)] for j in range(len(s1) + 1)]\n        \n        for i in range(len(s1) + 1):\n            for j in range(len(s2) + 1):\n                if i == 0 and j == 0:\n                    dp[i][j] = True\n                elif i == 0:\n                    dp[i][j] = dp[i][j - 1] and s2[j - 1] == s3[j - 1]\n                elif j == 0:\n                    dp[i][j] = dp[i - 1][j] and s1[i - 1] == s3[i - 1]\n                else:\n                    dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n        \n        return dp[len(s1)][len(s2)]"}, {"task_id": "interleaving-string", "completion": "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) + len(s2) != len(s3):\n            return False\n        \n        if len(s1) == 0 and len(s2) == 0:\n            return True\n        \n        if len(s1) == 0:\n            return s2 == s3\n        \n        if len(s2) == 0:\n            return s1 == s3\n        \n        dp = [[False for i in range(len(s2) + 1)] for j in range(len(s1) + 1)]\n        \n        for i in range(len(s1) + 1):\n            for j in range(len(s2) + 1):\n                if i == 0 and j == 0:\n                    dp[i][j] = True\n                elif i == 0:\n                    dp[i][j] = dp[i][j - 1] and s2[j - 1] == s3[j - 1]\n                elif j == 0:\n                    dp[i][j] = dp[i - 1][j] and s1[i - 1] == s3[i - 1]\n                else:\n                    dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n        \n        return dp[len(s1)][len(s2)]"}, {"task_id": "interleaving-string", "completion": "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) + len(s2) != len(s3):\n            return False\n        \n        if len(s1) == 0 and len(s2) == 0 and len(s3) == 0:\n            return True\n        \n        if len(s1) == 0:\n            return s2 == s3\n        \n        if len(s2) == 0:\n            return s1 == s3\n        \n        dp = [[False] * (len(s2) + 1) for _ in range(len(s1) + 1)]\n        \n        for i in range(len(s1) + 1):\n            for j in range(len(s2) + 1):\n                if i == 0 and j == 0:\n                    dp[i][j] = True\n                elif i == 0:\n                    dp[i][j] = dp[i][j - 1] and s2[j - 1] == s3[j - 1]\n                elif j == 0:\n                    dp[i][j] = dp[i - 1][j] and s1[i - 1] == s3[i - 1]\n                else:\n                    dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n        \n        return dp[len(s1)][len(s2)]"}, {"task_id": "interleaving-string", "completion": "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) + len(s2) != len(s3):\n            return False\n        \n        if len(s1) == 0 and len(s2) == 0 and len(s3) == 0:\n            return True\n        \n        if len(s1) == 0:\n            return s2 == s3\n        \n        if len(s2) == 0:\n            return s1 == s3\n        \n        dp = [[False for i in range(len(s2) + 1)] for j in range(len(s1) + 1)]\n        \n        for i in range(len(s1) + 1):\n            for j in range(len(s2) + 1):\n                if i == 0 and j == 0:\n                    dp[i][j] = True\n                elif i == 0:\n                    dp[i][j] = dp[i][j - 1] and s2[j - 1] == s3[j - 1]\n                elif j == 0:\n                    dp[i][j] = dp[i - 1][j] and s1[i - 1] == s3[i - 1]\n                else:\n                    dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n        \n        return dp[len(s1)][len(s2)]"}, {"task_id": "interleaving-string", "completion": "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) + len(s2) != len(s3):\n            return False\n        \n        if len(s1) == 0 and len(s2) == 0 and len(s3) == 0:\n            return True\n        \n        if len(s1) == 0:\n            return s2 == s3\n        \n        if len(s2) == 0:\n            return s1 == s3\n        \n        dp = [[False for i in range(len(s2) + 1)] for j in range(len(s1) + 1)]\n        \n        for i in range(len(s1) + 1):\n            for j in range(len(s2) + 1):\n                if i == 0 and j == 0:\n                    dp[i][j] = True\n                elif i == 0:\n                    dp[i][j] = dp[i][j - 1] and s2[j - 1] == s3[j - 1]\n                elif j == 0:\n                    dp[i][j] = dp[i - 1][j] and s1[i - 1] == s3[i - 1]\n                else:\n                    dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n        \n        return dp[len(s1)][len(s2)]"}], "assign-cookies": [{"task_id": "assign-cookies", "completion": "class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        \n        g.sort()\n        s.sort()\n        count = 0\n        i = 0\n        j = 0\n        while i < len(g) and j < len(s):\n            if s[j] >= g[i]:\n                count += 1\n                i += 1\n            j += 1\n        return count"}, {"task_id": "assign-cookies", "completion": "class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        \n        g.sort()\n        s.sort()\n        count = 0\n        i = 0\n        j = 0\n        while i < len(g) and j < len(s):\n            if s[j] >= g[i]:\n                count += 1\n                i += 1\n            j += 1\n        return count"}, {"task_id": "assign-cookies", "completion": "class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        \n        g.sort()\n        s.sort()\n        count = 0\n        i = 0\n        j = 0\n        while i < len(g) and j < len(s):\n            if s[j] >= g[i]:\n                count += 1\n                i += 1\n            j += 1\n        return count"}, {"task_id": "assign-cookies", "completion": "class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        \n        g.sort()\n        s.sort()\n        count = 0\n        i = 0\n        j = 0\n        while i < len(g) and j < len(s):\n            if s[j] >= g[i]:\n                count += 1\n                i += 1\n            j += 1\n        return count"}, {"task_id": "assign-cookies", "completion": "class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        \n        g.sort()\n        s.sort()\n        i = 0\n        j = 0\n        count = 0\n        while i < len(g) and j < len(s):\n            if s[j] >= g[i]:\n                count += 1\n                i += 1\n            j += 1\n        return count"}], "keyboard-row": [{"task_id": "keyboard-row", "completion": "class Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        row1 = set(\"qwertyuiop\")\n        row2 = set(\"asdfghjkl\")\n        row3 = set(\"zxcvbnm\")\n        \n        res = []\n        \n        for word in words:\n            if word[0] in row1:\n                row = row1\n            elif word[0] in row2:\n                row = row2\n            else:\n                row = row3\n            \n            for c in word:\n                if c not in row:\n                    break\n            else:\n                res.append(word)\n                \n        return res"}, {"task_id": "keyboard-row", "completion": "class Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        row1 = set(\"qwertyuiop\")\n        row2 = set(\"asdfghjkl\")\n        row3 = set(\"zxcvbnm\")\n        \n        res = []\n        \n        for word in words:\n            if set(word.lower()) <= row1 or set(word.lower()) <= row2 or set(word.lower()) <= row3:\n                res.append(word)\n                \n        return res"}, {"task_id": "keyboard-row", "completion": "class Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        row1 = set(\"qwertyuiop\")\n        row2 = set(\"asdfghjkl\")\n        row3 = set(\"zxcvbnm\")\n        \n        ans = []\n        \n        for word in words:\n            if set(word.lower()) <= row1 or set(word.lower()) <= row2 or set(word.lower()) <= row3:\n                ans.append(word)\n                \n        return ans"}, {"task_id": "keyboard-row", "completion": "class Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        row1 = set(\"qwertyuiop\")\n        row2 = set(\"asdfghjkl\")\n        row3 = set(\"zxcvbnm\")\n        \n        ans = []\n        \n        for word in words:\n            if set(word.lower()) <= row1 or set(word.lower()) <= row2 or set(word.lower()) <= row3:\n                ans.append(word)\n                \n        return ans"}, {"task_id": "keyboard-row", "completion": "class Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        row1 = set(\"qwertyuiop\")\n        row2 = set(\"asdfghjkl\")\n        row3 = set(\"zxcvbnm\")\n        \n        ans = []\n        \n        for word in words:\n            if set(word.lower()) <= row1 or set(word.lower()) <= row2 or set(word.lower()) <= row3:\n                ans.append(word)\n                \n        return ans"}], "reverse-linked-list-ii": [{"task_id": "reverse-linked-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: ListNode\n        :type left: int\n        :type right: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if left == right:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        count = 1\n        \n        while count < left:\n            prev = curr\n            curr = curr.next\n            count += 1\n        \n        tail = curr\n        \n        while count <= right:\n            temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = temp\n            count += 1\n        \n        tail.next = curr\n        head = prev\n        \n        return head"}, {"task_id": "reverse-linked-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: ListNode\n        :type left: int\n        :type right: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if left == right:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        for i in range(left-1):\n            prev = prev.next\n            curr = curr.next\n        \n        for i in range(right-left):\n            temp = curr.next\n            curr.next = temp.next\n            temp.next = prev.next\n            prev.next = temp\n        \n        return dummy.next"}, {"task_id": "reverse-linked-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: ListNode\n        :type left: int\n        :type right: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if left == right:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        for i in range(left-1):\n            prev = prev.next\n            curr = curr.next\n        \n        for i in range(right-left):\n            temp = curr.next\n            curr.next = temp.next\n            temp.next = prev.next\n            prev.next = temp\n        \n        return dummy.next"}, {"task_id": "reverse-linked-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: ListNode\n        :type left: int\n        :type right: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if left == right:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        curr = dummy\n        for i in range(left-1):\n            curr = curr.next\n        prev = curr\n        curr = curr.next\n        for i in range(right-left):\n            temp = curr.next\n            curr.next = temp.next\n            temp.next = prev.next\n            prev.next = temp\n        return dummy.next"}, {"task_id": "reverse-linked-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: ListNode\n        :type left: int\n        :type right: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if left == right:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        for i in range(left-1):\n            prev = prev.next\n            curr = curr.next\n        \n        for i in range(right-left):\n            temp = curr.next\n            curr.next = temp.next\n            temp.next = prev.next\n            prev.next = temp\n        \n        return dummy.next"}], "shortest-palindrome": [{"task_id": "shortest-palindrome", "completion": "class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if not, repeat the process\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if not, repeat the process\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if not, repeat the process\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if not, repeat the process\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if not, repeat the process\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if not, repeat the process\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if not, repeat the process\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if not, repeat the process\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if not, repeat the process\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if not, repeat the process\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if not, repeat the process\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if not, repeat the process\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if not, repeat the process\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if not, repeat the process\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if not, repeat the process\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if not, repeat the process\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if not, repeat the process\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if not, repeat the process"}, {"task_id": "shortest-palindrome", "completion": "class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # else, repeat the process\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # else, repeat the process\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # else, repeat the process\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # else, repeat the process\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # else, repeat the process\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # else, repeat the process\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # else, repeat the process\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # else, repeat the process\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # else, repeat the process\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # else, repeat the process\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # else, repeat the process\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # else, repeat the process\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # else, repeat the process\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # else, repeat the process\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # else, repeat the process\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # else, repeat the process\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # else, repeat the process\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # else, repeat the process\n        \n        # find the longest palindrome substring\n        # reverse the string"}, {"task_id": "shortest-palindrome", "completion": "class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if not, repeat the process\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if not, repeat the process\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if not, repeat the process\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if not, repeat the process\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if not, repeat the process\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if not, repeat the process\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if not, repeat the process\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if not, repeat the process\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if not, repeat the process\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if not, repeat the process\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if not, repeat the process\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if not, repeat the process\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if not, repeat the process\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if not, repeat the process\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if not, repeat the process\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if not, repeat the process\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if not, repeat the process\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if not, repeat the process"}, {"task_id": "shortest-palindrome", "completion": "class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if not, repeat the process\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if not, repeat the process\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if not, repeat the process\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if not, repeat the process\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if not, repeat the process\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if not, repeat the process\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if not, repeat the process\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if not, repeat the process\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if not, repeat the process\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if not, repeat the process\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if not, repeat the process\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if not, repeat the process\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if not, repeat the process\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if not, repeat the process\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if not, repeat the process\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if not, repeat the process\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if not, repeat the process\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if not, repeat the process"}, {"task_id": "shortest-palindrome", "completion": "class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if the reversed string is not a palindrome, add the first character of the original string to the reversed string\n        # repeat the process until the reversed string is a palindrome\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if the reversed string is not a palindrome, add the first character of the original string to the reversed string\n        # repeat the process until the reversed string is a palindrome\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if the reversed string is not a palindrome, add the first character of the original string to the reversed string\n        # repeat the process until the reversed string is a palindrome\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if the reversed string is not a palindrome, add the first character of the original string to the reversed string\n        # repeat the process until the reversed string is a palindrome\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if the reversed string is not a palindrome, add the first character of the original string to the reversed string\n        # repeat the process until the reversed string is a palindrome\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if the reversed string is not a palindrome, add the first character of the original string to the reversed string\n        # repeat the process until the reversed string is a palindrome\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if the reversed string is not a palindrome, add the first character of the original string to the reversed string\n        # repeat the process until the reversed string is a palindrome\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if the reversed string is not a palindrome, add the first character of the original string to the reversed string\n        # repeat the process until the reversed string is a palindrome\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if the reversed string is not a palindrome, add the first character of the original string to the reversed string\n        # repeat the process until the reversed string is a palindrome\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if the reversed string is not a palindrome, add the first character of the original string to the reversed string\n        # repeat the process until the reversed string is a palindrome\n        \n        # find the longest palindrome substring\n        # reverse the string and add it to the end of the original string\n        # if the reversed string is a palindrome, return the reversed string\n        # if the reversed string is not a palindrome, add the first character of the original string to the reversed string\n        # repeat the process until the reversed string is a palindrome\n        \n        # find the longest palindrome substring"}], "minimum-window-substring": [{"task_id": "minimum-window-substring", "completion": "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        if len(t) > len(s):\n            return \"\"\n        \n        if len(t) == 0:\n            return \"\"\n        \n        if len(t) == len(s):\n            if t == s:\n                return s\n            else:\n                return \"\"\n        \n        t_dict = {}\n        for c in t:\n            if c not in t_dict:\n                t_dict[c] = 1\n            else:\n                t_dict[c] += 1\n        \n        s_dict = {}\n        for c in s:\n            if c not in s_dict:\n                s_dict[c] = 1\n            else:\n                s_dict[c] += 1\n        \n        if t_dict == s_dict:\n            return s\n        \n        start = 0\n        end = 0\n        min_len = len(s)\n        min_start = 0\n        min_end = 0\n        while end < len(s):\n            if s[end] in t_dict:\n                if s_dict[s[end]] > t_dict[s[end]]:\n                    s_dict[s[end]] -= 1\n                else:\n                    s_dict[s[end]] -= 1\n                    start += 1\n            end += 1\n        \n        while start < len(s):\n            if s[start] in t_dict:\n                if s_dict[s[start]] < t_dict[s[start]]:\n                    s_dict[s[start]] += 1\n                else:\n                    s_dict[s[start]] += 1\n                    if end - start < min_len:\n                        min_len = end - start\n                        min_start = start\n                        min_end = end\n                    start += 1\n            start += 1\n        \n        if min_len == len(s):\n            return \"\"\n        \n        return s[min_start:min_end+1]"}, {"task_id": "minimum-window-substring", "completion": "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        if len(s) < len(t):\n            return \"\"\n        \n        if len(s) == len(t):\n            return s if s == t else \"\"\n        \n        t_dict = {}\n        for char in t:\n            if char not in t_dict:\n                t_dict[char] = 1\n            else:\n                t_dict[char] += 1\n        \n        s_dict = {}\n        for char in s:\n            if char not in s_dict:\n                s_dict[char] = 1\n            else:\n                s_dict[char] += 1\n        \n        if t_dict == s_dict:\n            return s\n        \n        left = 0\n        right = 0\n        min_len = len(s)\n        min_left = 0\n        min_right = 0\n        \n        while right < len(s):\n            if s[right] in t_dict:\n                if s[right] in s_dict:\n                    s_dict[s[right]] -= 1\n                else:\n                    s_dict[s[right]] = 1\n            right += 1\n            \n            while len(s_dict) == len(t_dict):\n                if right - left < min_len:\n                    min_len = right - left\n                    min_left = left\n                    min_right = right\n                if s[left] in s_dict:\n                    s_dict[s[left]] += 1\n                left += 1\n        \n        return s[min_left:min_right]"}, {"task_id": "minimum-window-substring", "completion": "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        if len(t) > len(s):\n            return \"\"\n        \n        if len(t) == 0:\n            return \"\"\n        \n        if len(t) == len(s):\n            if t == s:\n                return s\n            else:\n                return \"\"\n        \n        t_dict = {}\n        for c in t:\n            if c not in t_dict:\n                t_dict[c] = 1\n            else:\n                t_dict[c] += 1\n        \n        s_dict = {}\n        for c in s:\n            if c not in s_dict:\n                s_dict[c] = 1\n            else:\n                s_dict[c] += 1\n        \n        if t_dict == s_dict:\n            return s\n        \n        start = 0\n        end = 0\n        min_len = len(s)\n        min_start = 0\n        min_end = 0\n        while end < len(s):\n            if s[end] in t_dict:\n                if s_dict[s[end]] > t_dict[s[end]]:\n                    s_dict[s[end]] -= 1\n                else:\n                    s_dict[s[end]] -= 1\n                    start += 1\n            end += 1\n        \n        while start < len(s):\n            if s[start] in t_dict:\n                if s_dict[s[start]] < t_dict[s[start]]:\n                    s_dict[s[start]] += 1\n                else:\n                    s_dict[s[start]] += 1\n                    start += 1\n            start += 1\n        \n        if min_len > end - start:\n            min_len = end - start\n            min_start = start\n            min_end = end\n        \n        return s[min_start:min_end]"}, {"task_id": "minimum-window-substring", "completion": "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        if len(t) > len(s):\n            return \"\"\n        \n        if len(t) == 0:\n            return \"\"\n        \n        if len(s) == 0:\n            return \"\"\n        \n        if len(s) == 1:\n            return s\n        \n        if len(s) == 2:\n            if s[0] == t[0] and s[1] == t[1]:\n                return s\n            else:\n                return \"\"\n        \n        if len(s) == 3:\n            if s[0] == t[0] and s[1] == t[1] and s[2] == t[2]:\n                return s\n            else:\n                return \"\"\n        \n        if len(s) == 4:\n            if s[0] == t[0] and s[1] == t[1] and s[2] == t[2] and s[3] == t[3]:\n                return s\n            else:\n                return \"\"\n        \n        if len(s) == 5:\n            if s[0] == t[0] and s[1] == t[1] and s[2] == t[2] and s[3] == t[3] and s[4] == t[4]:\n                return s\n            else:\n                return \"\"\n        \n        if len(s) == 6:\n            if s[0] == t[0] and s[1] == t[1] and s[2] == t[2] and s[3] == t[3] and s[4] == t[4] and s[5] == t[5]:\n                return s\n            else:\n                return \"\"\n        \n        if len(s) == 7:\n            if s[0] == t[0] and s[1] == t[1] and s[2] == t[2] and s[3] == t[3] and s[4] == t[4] and s[5] == t[5] and s[6] == t[6]:\n                return s\n            else:\n                return \"\"\n        \n        if len(s) == 8:\n            if s[0] == t[0] and s[1] == t[1] and s[2] == t[2] and s[3] == t[3] and s[4] == t[4] and s[5] == t[5] and s[6] == t[6] and s[7] == t[7]:\n                return s\n            else:\n                return \"\"\n        \n        if len(s) == 9:\n            if s[0] == t[0] and s[1] == t[1] and s[2] == t[2] and s[3] == t[3] and s[4] == t[4] and s[5] == t[5] and s[6] == t[6] and s[7] == t[7] and s[8] == t[8]:\n                return s\n            else:\n                return \"\"\n        \n        if len(s) == 10:\n            if s[0] == t[0] and s[1] == t[1] and s[2] == t[2] and s[3] == t[3] and s[4] == t[4] and s[5] == t[5] and s[6] == t[6] and s[7] == t[7] and s[8] == t[8] and s[9] == t[9]:\n                return s\n            else:\n                return \"\"\n        \n        if len(s) == 11:\n            if s[0] == t[0] and s[1] == t[1] and s[2] == t[2] and s[3] == t[3] and s[4] == t[4] and s[5] == t[5] and s[6] == t[6] and s[7] == t[7] and s[8] == t[8] and s[9] == t[9] and s[10] == t[10]:\n                return s\n            else:\n                return \"\"\n        \n        if len(s) == 12:\n            if s[0] == t[0] and s[1] == t[1] and s[2] == t[2] and s"}, {"task_id": "minimum-window-substring", "completion": "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        if len(t) > len(s):\n            return \"\"\n        \n        if len(t) == 0:\n            return \"\"\n        \n        if len(t) == len(s):\n            if t == s:\n                return s\n            else:\n                return \"\"\n        \n        t_dict = {}\n        for i in t:\n            if i not in t_dict:\n                t_dict[i] = 1\n            else:\n                t_dict[i] += 1\n        \n        s_dict = {}\n        for i in s:\n            if i not in s_dict:\n                s_dict[i] = 1\n            else:\n                s_dict[i] += 1\n        \n        if t_dict == s_dict:\n            return s\n        \n        start = 0\n        end = 0\n        min_len = len(s)\n        min_start = 0\n        min_end = 0\n        while end < len(s):\n            if s[end] in t_dict:\n                if s_dict[s[end]] > t_dict[s[end]]:\n                    s_dict[s[end]] -= 1\n                else:\n                    s_dict[s[end]] -= 1\n                    start += 1\n            end += 1\n        \n        while start < len(s):\n            if s[start] in t_dict:\n                if s_dict[s[start]] < t_dict[s[start]]:\n                    s_dict[s[start]] += 1\n                else:\n                    s_dict[s[start]] += 1\n                    start += 1\n            start += 1\n        \n        if min_len > end - start:\n            min_len = end - start\n            min_start = start\n            min_end = end\n        \n        return s[min_start:min_end]"}], "self-crossing": [{"task_id": "self-crossing", "completion": "class Solution(object):\n    def isSelfCrossing(self, distance):\n        \"\"\"\n        :type distance: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        for i in range(len(distance)-3):\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            if distance"}, {"task_id": "self-crossing", "completion": "class Solution(object):\n    def isSelfCrossing(self, distance):\n        \"\"\"\n        :type distance: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        for i in range(len(distance)-3):\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            if distance[i] >= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n        return False"}, {"task_id": "self-crossing", "completion": "class Solution(object):\n    def isSelfCrossing(self, distance):\n        \"\"\"\n        :type distance: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        for i in range(len(distance)-3):\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            if distance"}, {"task_id": "self-crossing", "completion": "class Solution(object):\n    def isSelfCrossing(self, distance):\n        \"\"\"\n        :type distance: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        for i in range(len(distance)-3):\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            if distance"}, {"task_id": "self-crossing", "completion": "class Solution(object):\n    def isSelfCrossing(self, distance):\n        \"\"\"\n        :type distance: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        for i in range(len(distance)-3):\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            if distance[i] >= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            if distance[i] >= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] >= distance[i+3] and distance[i] + distance[i+4] <= distance[i+2] and distance[i+1] + distance[i+5] >= distance[i+3]:\n                return True\n            if distance[i] <= distance[i+2] and distance[i+1] <= distance[i+3] and distance[i] + distance[i+4] >= distance[i+2] and distance[i+1] + distance[i+5] <= distance[i+3]:\n                return True\n        return False"}], "remove-duplicates-from-sorted-list": [{"task_id": "remove-duplicates-from-sorted-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if head == None:\n            return None\n        \n        curr = head\n        while curr.next != None:\n            if curr.val == curr.next.val:\n                curr.next = curr.next.next\n            else:\n                curr = curr.next\n        return head"}, {"task_id": "remove-duplicates-from-sorted-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        curr = head\n        while curr:\n            while curr.next and curr.val == curr.next.val:\n                curr.next = curr.next.next\n            curr = curr.next\n        return head"}, {"task_id": "remove-duplicates-from-sorted-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if head == None:\n            return None\n        \n        curr = head\n        while curr.next != None:\n            if curr.val == curr.next.val:\n                curr.next = curr.next.next\n            else:\n                curr = curr.next\n        return head"}, {"task_id": "remove-duplicates-from-sorted-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if head == None:\n            return None\n        \n        curr = head\n        while curr.next != None:\n            if curr.val == curr.next.val:\n                curr.next = curr.next.next\n            else:\n                curr = curr.next\n        return head"}, {"task_id": "remove-duplicates-from-sorted-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        curr = head\n        while curr:\n            while curr.next and curr.val == curr.next.val:\n                curr.next = curr.next.next\n            curr = curr.next\n        return head"}], "longest-palindrome": [{"task_id": "longest-palindrome", "completion": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # create a dictionary to store the frequency of each character in the string\n        freq = {}\n        \n        # loop through the string and add each character to the dictionary\n        for char in s:\n            if char not in freq:\n                freq[char] = 1\n            else:\n                freq[char] += 1\n        \n        # create a variable to store the length of the longest palindrome\n        longest_palindrome = 0\n        \n        # loop through the dictionary and check if the frequency is greater than 1\n        for char, count in freq.items():\n            if count > 1:\n                # if the frequency is greater than 1, add the frequency to the longest palindrome\n                longest_palindrome += count // 2 * 2\n                \n                # if the frequency is odd, add 1 to the longest palindrome\n                if count % 2 == 1:\n                    longest_palindrome += 1\n        \n        # return the longest palindrome\n        return longest_palindrome"}, {"task_id": "longest-palindrome", "completion": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. create a hashmap to store the frequency of each character in the string\n        # 2. iterate through the hashmap and add the max of the odd characters to the result\n        # 3. if the string has an odd number of characters, add the max of the odd character to the result\n        # 4. return the result\n        \n        # 1. create a hashmap to store the frequency of each character in the string\n        hashmap = {}\n        for char in s:\n            if char not in hashmap:\n                hashmap[char] = 1\n            else:\n                hashmap[char] += 1\n        \n        # 2. iterate through the hashmap and add the max of the odd characters to the result\n        # 3. if the string has an odd number of characters, add the max of the odd character to the result\n        # 4. return the result\n        \n        result = 0\n        odd_count = 0\n        for char in hashmap:\n            if hashmap[char] % 2 == 0:\n                result += hashmap[char]\n            else:\n                result += hashmap[char] - 1\n                odd_count += 1\n        \n        if odd_count > 0:\n            result += 1\n        \n        return result"}, {"task_id": "longest-palindrome", "completion": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # create a dictionary to store the frequency of each character in the string\n        freq = {}\n        \n        # loop through the string and add each character to the dictionary\n        for char in s:\n            if char not in freq:\n                freq[char] = 1\n            else:\n                freq[char] += 1\n        \n        # create a variable to store the length of the longest palindrome\n        longest_palindrome = 0\n        \n        # loop through the dictionary and check if the frequency is odd\n        for char, count in freq.items():\n            if count % 2 == 0:\n                longest_palindrome += count\n            else:\n                longest_palindrome += count - 1\n        \n        # if the length of the string is odd, add 1 to the longest palindrome\n        if len(s) % 2 == 1:\n            longest_palindrome += 1\n        \n        # return the longest palindrome\n        return longest_palindrome"}, {"task_id": "longest-palindrome", "completion": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. create a hashmap to store the frequency of each character\n        # 2. iterate through the hashmap and add the max of odd and even values to the result\n        # 3. if the hashmap has a value of 1, add 1 to the result\n        # 4. return the result\n        \n        hashmap = {}\n        for char in s:\n            if char not in hashmap:\n                hashmap[char] = 1\n            else:\n                hashmap[char] += 1\n        \n        result = 0\n        for key in hashmap:\n            if hashmap[key] % 2 == 0:\n                result += hashmap[key]\n            else:\n                result += hashmap[key] - 1\n        \n        if len(hashmap) == 1:\n            result += 1\n        \n        return result"}, {"task_id": "longest-palindrome", "completion": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. create a dictionary to store the count of each character\n        # 2. create a variable to store the max length\n        # 3. iterate through the string\n        # 4. if the character is in the dictionary, add 2 to the count\n        # 5. if the character is not in the dictionary, add 1 to the count\n        # 6. if the count is greater than 1, add 2 to the max length\n        # 7. return the max length\n        \n        # 1. create a dictionary to store the count of each character\n        char_dict = {}\n        \n        # 2. create a variable to store the max length\n        max_len = 0\n        \n        # 3. iterate through the string\n        for char in s:\n            \n            # 4. if the character is in the dictionary, add 2 to the count\n            if char in char_dict:\n                char_dict[char] += 2\n                \n            # 5. if the character is not in the dictionary, add 1 to the count\n            else:\n                char_dict[char] = 1\n                \n            # 6. if the count is greater than 1, add 2 to the max length\n            if char_dict[char] > 1:\n                max_len += 2\n                \n        # 7. return the max length\n        return max_len"}], "construct-binary-tree-from-inorder-and-postorder-traversal": [{"task_id": "construct-binary-tree-from-inorder-and-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if len(inorder) == 0:\n            return None\n        \n        root = TreeNode(postorder[-1])\n        index = inorder.index(postorder[-1])\n        \n        root.left = self.buildTree(inorder[:index], postorder[:index])\n        root.right = self.buildTree(inorder[index+1:], postorder[index:-1])\n        \n        return root"}, {"task_id": "construct-binary-tree-from-inorder-and-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if len(inorder) == 0:\n            return None\n        \n        root = TreeNode(postorder[-1])\n        index = inorder.index(postorder[-1])\n        \n        root.left = self.buildTree(inorder[:index], postorder[:index])\n        root.right = self.buildTree(inorder[index+1:], postorder[index:-1])\n        \n        return root"}, {"task_id": "construct-binary-tree-from-inorder-and-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if len(inorder) == 0:\n            return None\n        \n        root = TreeNode(postorder[-1])\n        index = inorder.index(root.val)\n        \n        root.left = self.buildTree(inorder[:index], postorder[:index])\n        root.right = self.buildTree(inorder[index+1:], postorder[index:-1])\n        \n        return root"}, {"task_id": "construct-binary-tree-from-inorder-and-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if len(inorder) == 0:\n            return None\n        \n        root = TreeNode(postorder[-1])\n        index = inorder.index(root.val)\n        \n        root.left = self.buildTree(inorder[:index], postorder[:index])\n        root.right = self.buildTree(inorder[index+1:], postorder[index:-1])\n        \n        return root"}, {"task_id": "construct-binary-tree-from-inorder-and-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if len(inorder) == 0:\n            return None\n        \n        root = TreeNode(postorder[-1])\n        index = inorder.index(root.val)\n        root.left = self.buildTree(inorder[:index], postorder[:index])\n        root.right = self.buildTree(inorder[index+1:], postorder[index:-1])\n        \n        return root"}], "cut-off-trees-for-golf-event": [{"task_id": "cut-off-trees-for-golf-event", "completion": "class Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def bfs(start, end):\n            q = [start]\n            visited = set()\n            steps = 0\n            while q:\n                for _ in range(len(q)):\n                    cur = q.pop(0)\n                    if cur == end:\n                        return steps\n                    for n in [(cur[0], cur[1]+1), (cur[0], cur[1]-1), (cur[0]+1, cur[1]), (cur[0]-1, cur[1])]:\n                        if 0 <= n[0] < len(forest) and 0 <= n[1] < len(forest[0]) and forest[n[0]][n[1]] > 0 and n not in visited:\n                            q.append(n)\n                            visited.add(n)\n                steps += 1\n            return -1\n        \n        def get_start_end(forest):\n            for i in range(len(forest)):\n                for j in range(len(forest[0])):\n                    if forest[i][j] > 1:\n                        return (i, j), (i, j)\n            return None, None\n        \n        forest = [[10**9] + row + [10**9] for row in forest]\n        forest = [[10**9] * len(forest[0])] + forest + [[10**9] * len(forest[0])]\n        start, end = get_start_end(forest)\n        if start is None:\n            return 0\n        return bfs(start, end)"}, {"task_id": "cut-off-trees-for-golf-event", "completion": "class Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def bfs(start, end):\n            q = [start]\n            visited = set()\n            steps = 0\n            while q:\n                for _ in range(len(q)):\n                    curr = q.pop(0)\n                    if curr == end:\n                        return steps\n                    for n in [(curr[0]+1, curr[1]), (curr[0]-1, curr[1]), (curr[0], curr[1]+1), (curr[0], curr[1]-1)]:\n                        if 0 <= n[0] < len(forest) and 0 <= n[1] < len(forest[0]) and forest[n[0]][n[1]] > 0 and n not in visited:\n                            q.append(n)\n                            visited.add(n)\n                steps += 1\n            return -1\n        \n        def get_start(forest):\n            for i in range(len(forest)):\n                for j in range(len(forest[0])):\n                    if forest[i][j] > 1:\n                        return (i, j)\n            return None\n        \n        start = get_start(forest)\n        if start is None:\n            return 0\n        return bfs(start, (len(forest)-1, len(forest[0])-1))"}, {"task_id": "cut-off-trees-for-golf-event", "completion": "class Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def bfs(start, end):\n            q = [start]\n            visited = set()\n            steps = 0\n            while q:\n                for _ in range(len(q)):\n                    cur = q.pop(0)\n                    if cur == end:\n                        return steps\n                    for n in [(cur[0], cur[1]+1), (cur[0], cur[1]-1), (cur[0]+1, cur[1]), (cur[0]-1, cur[1])]:\n                        if 0 <= n[0] < len(forest) and 0 <= n[1] < len(forest[0]) and forest[n[0]][n[1]] > 0 and n not in visited:\n                            q.append(n)\n                            visited.add(n)\n                steps += 1\n            return -1\n        \n        def get_start(forest):\n            for i in range(len(forest)):\n                for j in range(len(forest[0])):\n                    if forest[i][j] > 1:\n                        return (i, j)\n            return None\n        \n        start = get_start(forest)\n        if start is None:\n            return 0\n        return bfs(start, (len(forest)-1, len(forest[0])-1))"}, {"task_id": "cut-off-trees-for-golf-event", "completion": "class Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def bfs(start, end):\n            q = [start]\n            visited = set()\n            steps = 0\n            while q:\n                for _ in range(len(q)):\n                    curr = q.pop(0)\n                    if curr == end:\n                        return steps\n                    for n in [(curr[0]+1, curr[1]), (curr[0]-1, curr[1]), (curr[0], curr[1]+1), (curr[0], curr[1]-1)]:\n                        if 0 <= n[0] < len(forest) and 0 <= n[1] < len(forest[0]) and forest[n[0]][n[1]] > 0 and n not in visited:\n                            q.append(n)\n                            visited.add(n)\n                steps += 1\n            return -1\n        \n        def get_start(forest):\n            for i in range(len(forest)):\n                for j in range(len(forest[0])):\n                    if forest[i][j] > 1:\n                        return (i, j)\n            return None\n        \n        start = get_start(forest)\n        if start is None:\n            return 0\n        return bfs(start, (len(forest)-1, len(forest[0])-1))"}, {"task_id": "cut-off-trees-for-golf-event", "completion": "class Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def bfs(start, end):\n            q = [start]\n            visited = set()\n            steps = 0\n            while q:\n                for _ in range(len(q)):\n                    cur = q.pop(0)\n                    if cur == end:\n                        return steps\n                    for n in [(cur[0], cur[1]+1), (cur[0], cur[1]-1), (cur[0]+1, cur[1]), (cur[0]-1, cur[1])]:\n                        if 0 <= n[0] < len(forest) and 0 <= n[1] < len(forest[0]) and forest[n[0]][n[1]] > 0 and n not in visited:\n                            q.append(n)\n                            visited.add(n)\n                steps += 1\n            return -1\n        \n        def get_start_end(forest):\n            for i in range(len(forest)):\n                for j in range(len(forest[0])):\n                    if forest[i][j] > 1:\n                        return (i, j), (i, j)\n            return None, None\n        \n        forest = [list(row) for row in forest]\n        start, end = get_start_end(forest)\n        if start is None:\n            return 0\n        return bfs(start, end)"}], "minimum-depth-of-binary-tree": [{"task_id": "minimum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        if not root.left and not root.right:\n            return 1\n        \n        if not root.left:\n            return self.minDepth(root.right) + 1\n        \n        if not root.right:\n            return self.minDepth(root.left) + 1\n        \n        return min(self.minDepth(root.left), self.minDepth(root.right)) + 1"}, {"task_id": "minimum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        if not root.left and not root.right:\n            return 1\n        \n        if not root.left:\n            return self.minDepth(root.right) + 1\n        \n        if not root.right:\n            return self.minDepth(root.left) + 1\n        \n        return min(self.minDepth(root.left), self.minDepth(root.right)) + 1"}, {"task_id": "minimum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        if not root.left and not root.right:\n            return 1\n        \n        if not root.left:\n            return 1 + self.minDepth(root.right)\n        \n        if not root.right:\n            return 1 + self.minDepth(root.left)\n        \n        return 1 + min(self.minDepth(root.left), self.minDepth(root.right))"}, {"task_id": "minimum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        if not root.left and not root.right:\n            return 1\n        \n        if not root.left:\n            return 1 + self.minDepth(root.right)\n        \n        if not root.right:\n            return 1 + self.minDepth(root.left)\n        \n        return 1 + min(self.minDepth(root.left), self.minDepth(root.right))"}, {"task_id": "minimum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        if root.left is None and root.right is None:\n            return 1\n        \n        if root.left is None:\n            return 1 + self.minDepth(root.right)\n        \n        if root.right is None:\n            return 1 + self.minDepth(root.left)\n        \n        return 1 + min(self.minDepth(root.left), self.minDepth(root.right))"}], "count-of-range-sum": [{"task_id": "count-of-range-sum", "completion": "class Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}, {"task_id": "count-of-range-sum", "completion": "class Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}, {"task_id": "count-of-range-sum", "completion": "class Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}, {"task_id": "count-of-range-sum", "completion": "class Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}, {"task_id": "count-of-range-sum", "completion": "class Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "arranging-coins": [{"task_id": "arranging-coins", "completion": "class Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # Approach 1: Binary Search\n        # Time Complexity: O(log(n))\n        # Space Complexity: O(1)\n        # 1. Find the number of complete rows\n        # 2. Find the number of coins in the last row\n        # 3. Find the number of coins in the first row\n        # 4. Find the number of coins in the second row\n        # 5. Find the number of coins in the third row\n        # 6. Find the number of coins in the fourth row\n        # 7. Find the number of coins in the fifth row\n        # 8. Find the number of coins in the sixth row\n        # 9. Find the number of coins in the seventh row\n        # 10. Find the number of coins in the eighth row\n        # 11. Find the number of coins in the ninth row\n        # 12. Find the number of coins in the tenth row\n        # 13. Find the number of coins in the eleventh row\n        # 14. Find the number of coins in the twelfth row\n        # 15. Find the number of coins in the thirteenth row\n        # 16. Find the number of coins in the fourteenth row\n        # 17. Find the number of coins in the fifteenth row\n        # 18. Find the number of coins in the sixteenth row\n        # 19. Find the number of coins in the seventeenth row\n        # 20. Find the number of coins in the eighteenth row\n        # 21. Find the number of coins in the nineteenth row\n        # 22. Find the number of coins in the twentieth row\n        # 23. Find the number of coins in the twenty-first row\n        # 24. Find the number of coins in the twenty-second row\n        # 25. Find the number of coins in the twenty-third row\n        # 26. Find the number of coins in the twenty-fourth row\n        # 27. Find the number of coins in the twenty-fifth row\n        # 28. Find the number of coins in the twenty-sixth row\n        # 29. Find the number of coins in the twenty-seventh row\n        # 30. Find the number of coins in the twenty-eighth row\n        # 31. Find the number of coins in the twenty-ninth row\n        # 32. Find the number of coins in the thirty-first row\n        # 33. Find the number of coins in the thirty-second row\n        # 34. Find the number of coins in the thirty-third row\n        # 35. Find the number of coins in the thirty-fourth row\n        # 36. Find the number of coins in the thirty-fifth row\n        # 37. Find the number of coins in the thirty-sixth row\n        # 38. Find the number of coins in the thirty-seventh row\n        # 39. Find the number of coins in the thirty-eighth row\n        # 40. Find the number of coins in the thirty-ninth row\n        # 41. Find the number of coins in the forty-first row\n        # 42. Find the number of coins in the forty-second row\n        # 43. Find the number of coins in the forty-third row\n        # 44. Find the number of coins in the forty-fourth row\n        # 45. Find the number of coins in the forty-fifth row\n        # 46. Find the number of coins in the forty-sixth row\n        # 47. Find the number of coins in the forty-seventh row\n        # 48. Find the number of coins in the forty-eighth row\n        # 49. Find the number of coins in the forty-ninth row\n        # 50. Find the number of coins in the fifty-first row\n        # 51. Find the number of coins in the fifty-second row\n        # 52. Find the number of coins in the fifty-third row\n        # 53. Find the number of coins in the fifty-fourth row\n        # 54. Find the number of coins in the fifty-fifth row\n        # 55. Find the number of coins in the fifty-sixth row\n        # 56. Find the number of coins"}, {"task_id": "arranging-coins", "completion": "class Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # Approach 1:\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        # 1. n is the number of coins\n        # 2. n is the number of rows\n        # 3. n is the number of complete rows\n        # 4. n is the number of coins in each row\n        # 5. n is the number of coins in each row\n        # 6. n is the number of coins in each row\n        # 7. n is the number of coins in each row\n        # 8. n is the number of coins in each row\n        # 9. n is the number of coins in each row\n        # 10. n is the number of coins in each row\n        # 11. n is the number of coins in each row\n        # 12. n is the number of coins in each row\n        # 13. n is the number of coins in each row\n        # 14. n is the number of coins in each row\n        # 15. n is the number of coins in each row\n        # 16. n is the number of coins in each row\n        # 17. n is the number of coins in each row\n        # 18. n is the number of coins in each row\n        # 19. n is the number of coins in each row\n        # 20. n is the number of coins in each row\n        # 21. n is the number of coins in each row\n        # 22. n is the number of coins in each row\n        # 23. n is the number of coins in each row\n        # 24. n is the number of coins in each row\n        # 25. n is the number of coins in each row\n        # 26. n is the number of coins in each row\n        # 27. n is the number of coins in each row\n        # 28. n is the number of coins in each row\n        # 29. n is the number of coins in each row\n        # 30. n is the number of coins in each row\n        # 31. n is the number of coins in each row\n        # 32. n is the number of coins in each row\n        # 33. n is the number of coins in each row\n        # 34. n is the number of coins in each row\n        # 35. n is the number of coins in each row\n        # 36. n is the number of coins in each row\n        # 37. n is the number of coins in each row\n        # 38. n is the number of coins in each row\n        # 39. n is the number of coins in each row\n        # 40. n is the number of coins in each row\n        # 41. n is the number of coins in each row\n        # 42. n is the number of coins in each row\n        # 43. n is the number of coins in each row\n        # 44. n is the number of coins in each row\n        # 45. n is the number of coins in each row\n        # 46. n is the number of coins in each row\n        # 47. n is the number of coins in each row\n        # 48. n is the number of coins in each row\n        # 49. n is the number of coins in each row\n        # 50. n is the number of coins in each row\n        # 51. n is the number of coins in each row\n        # 52. n is the number of coins in each row\n        # 53. n is the number of coins in each row\n        # 54. n is the number of coins in each row\n        # 55. n is the number of coins in each row\n        # 56. n is the number of coins in each row\n        # 57. n is the number of coins in each row\n        # 58. n is the number of coins in each row\n        # 59. n is the number of coins in each row\n        # 60. n is the number of coins in each row\n        # 61. n is the number of coins in each row\n        # 62. n is the number of coins in each row\n        # 63. n is the number of coins in each row"}, {"task_id": "arranging-coins", "completion": "class Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # Approach 1: Binary Search\n        # Time Complexity: O(log(n))\n        # Space Complexity: O(1)\n        # 1. Find the number of complete rows\n        # 2. Find the number of coins in the last row\n        # 3. Find the number of coins in the ith row\n        # 4. Find the number of coins in the (i-1)th row\n        # 5. Find the number of coins in the (i-2)th row\n        # 6. Find the number of coins in the (i-3)th row\n        # 7. Find the number of coins in the (i-4)th row\n        # 8. Find the number of coins in the (i-5)th row\n        # 9. Find the number of coins in the (i-6)th row\n        # 10. Find the number of coins in the (i-7)th row\n        # 11. Find the number of coins in the (i-8)th row\n        # 12. Find the number of coins in the (i-9)th row\n        # 13. Find the number of coins in the (i-10)th row\n        # 14. Find the number of coins in the (i-11)th row\n        # 15. Find the number of coins in the (i-12)th row\n        # 16. Find the number of coins in the (i-13)th row\n        # 17. Find the number of coins in the (i-14)th row\n        # 18. Find the number of coins in the (i-15)th row\n        # 19. Find the number of coins in the (i-16)th row\n        # 20. Find the number of coins in the (i-17)th row\n        # 21. Find the number of coins in the (i-18)th row\n        # 22. Find the number of coins in the (i-19)th row\n        # 23. Find the number of coins in the (i-20)th row\n        # 24. Find the number of coins in the (i-21)th row\n        # 25. Find the number of coins in the (i-22)th row\n        # 26. Find the number of coins in the (i-23)th row\n        # 27. Find the number of coins in the (i-24)th row\n        # 28. Find the number of coins in the (i-25)th row\n        # 29. Find the number of coins in the (i-26)th row\n        # 30. Find the number of coins in the (i-27)th row\n        # 31. Find the number of coins in the (i-28)th row\n        # 32. Find the number of coins in the (i-29)th row\n        # 33. Find the number of coins in the (i-30)th row\n        # 34. Find the number of coins in the (i-31)th row\n        # 35. Find the number of coins in the (i-32)th row\n        # 36. Find the number of coins in the (i-33)th row\n        # 37. Find the number of coins in the (i-34)th row\n        # 38. Find the number of coins in the (i-35)th row\n        # 39. Find the number of coins in the (i-36)th row\n        # 40. Find the number of coins in the (i-37)th row\n        # 41. Find the number of coins in the (i-38)th row\n        # 42. Find the number of coins in the (i-39)th row\n        # 43. Find the number of coins in the (i-40)th row\n        # 44. Find the number of coins in the (i-41)th row\n        # 45. Find the number of coins in the (i-42)th row\n        # 46. Find the number of coins in the (i-43)th row\n        # 47. Find the number of coins in the"}, {"task_id": "arranging-coins", "completion": "class Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # Approach 1: Binary Search\n        # Time Complexity: O(log(n))\n        # Space Complexity: O(1)\n        # 1. Find the number of complete rows\n        # 2. Find the number of coins in the last row\n        # 3. Find the number of coins in the first row\n        # 4. Find the number of coins in the second row\n        # 5. Find the number of coins in the third row\n        # 6. Find the number of coins in the fourth row\n        # 7. Find the number of coins in the fifth row\n        # 8. Find the number of coins in the sixth row\n        # 9. Find the number of coins in the seventh row\n        # 10. Find the number of coins in the eighth row\n        # 11. Find the number of coins in the ninth row\n        # 12. Find the number of coins in the tenth row\n        # 13. Find the number of coins in the eleventh row\n        # 14. Find the number of coins in the twelfth row\n        # 15. Find the number of coins in the thirteenth row\n        # 16. Find the number of coins in the fourteenth row\n        # 17. Find the number of coins in the fifteenth row\n        # 18. Find the number of coins in the sixteenth row\n        # 19. Find the number of coins in the seventeenth row\n        # 20. Find the number of coins in the eighteenth row\n        # 21. Find the number of coins in the nineteenth row\n        # 22. Find the number of coins in the twentieth row\n        # 23. Find the number of coins in the twenty-first row\n        # 24. Find the number of coins in the twenty-second row\n        # 25. Find the number of coins in the twenty-third row\n        # 26. Find the number of coins in the twenty-fourth row\n        # 27. Find the number of coins in the twenty-fifth row\n        # 28. Find the number of coins in the twenty-sixth row\n        # 29. Find the number of coins in the twenty-seventh row\n        # 30. Find the number of coins in the twenty-eighth row\n        # 31. Find the number of coins in the twenty-ninth row\n        # 32. Find the number of coins in the thirty-first row\n        # 33. Find the number of coins in the thirty-second row\n        # 34. Find the number of coins in the thirty-third row\n        # 35. Find the number of coins in the thirty-fourth row\n        # 36. Find the number of coins in the thirty-fifth row\n        # 37. Find the number of coins in the thirty-sixth row\n        # 38. Find the number of coins in the thirty-seventh row\n        # 39. Find the number of coins in the thirty-eighth row\n        # 40. Find the number of coins in the thirty-ninth row\n        # 41. Find the number of coins in the forty-first row\n        # 42. Find the number of coins in the forty-second row\n        # 43. Find the number of coins in the forty-third row\n        # 44. Find the number of coins in the forty-fourth row\n        # 45. Find the number of coins in the forty-fifth row\n        # 46. Find the number of coins in the forty-sixth row\n        # 47. Find the number of coins in the forty-seventh row\n        # 48. Find the number of coins in the forty-eighth row\n        # 49. Find the number of coins in the forty-ninth row\n        # 50. Find the number of coins in the fifty-first row\n        # 51. Find the number of coins in the fifty-second row\n        # 52. Find the number of coins in the fifty-third row\n        # 53. Find the number of coins in the fifty-fourth row\n        # 54. Find the number of coins in the fifty-fifth row\n        # 55. Find the number of coins in the fifty-sixth row\n        # 56. Find the number of coins"}, {"task_id": "arranging-coins", "completion": "class Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # Approach 1: Binary Search\n        # Time Complexity: O(log(n))\n        # Space Complexity: O(1)\n        # 1. Find the number of complete rows\n        # 2. Find the number of coins in the last row\n        # 3. Find the number of coins in the first row\n        # 4. Find the number of coins in the second row\n        # 5. Find the number of coins in the third row\n        # 6. Find the number of coins in the fourth row\n        # 7. Find the number of coins in the fifth row\n        # 8. Find the number of coins in the sixth row\n        # 9. Find the number of coins in the seventh row\n        # 10. Find the number of coins in the eighth row\n        # 11. Find the number of coins in the ninth row\n        # 12. Find the number of coins in the tenth row\n        # 13. Find the number of coins in the eleventh row\n        # 14. Find the number of coins in the twelfth row\n        # 15. Find the number of coins in the thirteenth row\n        # 16. Find the number of coins in the fourteenth row\n        # 17. Find the number of coins in the fifteenth row\n        # 18. Find the number of coins in the sixteenth row\n        # 19. Find the number of coins in the seventeenth row\n        # 20. Find the number of coins in the eighteenth row\n        # 21. Find the number of coins in the nineteenth row\n        # 22. Find the number of coins in the twentieth row\n        # 23. Find the number of coins in the twenty-first row\n        # 24. Find the number of coins in the twenty-second row\n        # 25. Find the number of coins in the twenty-third row\n        # 26. Find the number of coins in the twenty-fourth row\n        # 27. Find the number of coins in the twenty-fifth row\n        # 28. Find the number of coins in the twenty-sixth row\n        # 29. Find the number of coins in the twenty-seventh row\n        # 30. Find the number of coins in the twenty-eighth row\n        # 31. Find the number of coins in the twenty-ninth row\n        # 32. Find the number of coins in the thirty-first row\n        # 33. Find the number of coins in the thirty-second row\n        # 34. Find the number of coins in the thirty-third row\n        # 35. Find the number of coins in the thirty-fourth row\n        # 36. Find the number of coins in the thirty-fifth row\n        # 37. Find the number of coins in the thirty-sixth row\n        # 38. Find the number of coins in the thirty-seventh row\n        # 39. Find the number of coins in the thirty-eighth row\n        # 40. Find the number of coins in the thirty-ninth row\n        # 41. Find the number of coins in the forty-first row\n        # 42. Find the number of coins in the forty-second row\n        # 43. Find the number of coins in the forty-third row\n        # 44. Find the number of coins in the forty-fourth row\n        # 45. Find the number of coins in the forty-fifth row\n        # 46. Find the number of coins in the forty-sixth row\n        # 47. Find the number of coins in the forty-seventh row\n        # 48. Find the number of coins in the forty-eighth row\n        # 49. Find the number of coins in the forty-ninth row\n        # 50. Find the number of coins in the fifty-first row\n        # 51. Find the number of coins in the fifty-second row\n        # 52. Find the number of coins in the fifty-third row\n        # 53. Find the number of coins in the fifty-fourth row\n        # 54. Find the number of coins in the fifty-fifth row\n        # 55. Find the number of coins in the fifty-sixth row\n        # 56. Find the number of coins"}], "longest-uncommon-subsequence-i": [{"task_id": "longest-uncommon-subsequence-i", "completion": "class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        \n        if a == b:\n            return -1\n        else:\n            return max(len(a), len(b))"}, {"task_id": "longest-uncommon-subsequence-i", "completion": "class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        \n        if a == b:\n            return -1\n        else:\n            return max(len(a), len(b))"}, {"task_id": "longest-uncommon-subsequence-i", "completion": "class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        \n        if a == b:\n            return -1\n        else:\n            return max(len(a), len(b))"}, {"task_id": "longest-uncommon-subsequence-i", "completion": "class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        \n        if a == b:\n            return -1\n        else:\n            return max(len(a), len(b))"}, {"task_id": "longest-uncommon-subsequence-i", "completion": "class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        \n        if a == b:\n            return -1\n        else:\n            return max(len(a), len(b))"}], "binary-tree-level-order-traversal-ii": [{"task_id": "binary-tree-level-order-traversal-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        result = []\n        \n        while queue:\n            level = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            result.append(level)\n        return result[::-1]"}, {"task_id": "binary-tree-level-order-traversal-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        q = [root]\n        res = []\n        \n        while q:\n            temp = []\n            for i in q:\n                temp.append(i.val)\n                if i.left:\n                    q.append(i.left)\n                if i.right:\n                    q.append(i.right)\n            res.append(temp)\n            q = q[len(temp):]\n        \n        return res[::-1]"}, {"task_id": "binary-tree-level-order-traversal-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        q = [root]\n        res = []\n        \n        while q:\n            temp = []\n            for i in q:\n                temp.append(i.val)\n                if i.left:\n                    q.append(i.left)\n                if i.right:\n                    q.append(i.right)\n            res.append(temp)\n            q = q[len(temp):]\n        return res[::-1]"}, {"task_id": "binary-tree-level-order-traversal-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        queue = [root]\n        result = []\n        \n        while queue:\n            level = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            result.insert(0, level)\n        return result"}, {"task_id": "binary-tree-level-order-traversal-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        q = [root]\n        res = []\n        \n        while q:\n            level = []\n            for i in range(len(q)):\n                node = q.pop(0)\n                level.append(node.val)\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n            res.append(level)\n        return res[::-1]"}], "palindrome-number": [{"task_id": "palindrome-number", "completion": "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        \n        if x < 0:\n            return False\n        \n        if x < 10:\n            return True\n        \n        if x % 10 == 0:\n            return False\n        \n        rev = 0\n        while x > rev:\n            rev = rev * 10 + x % 10\n            x = x // 10\n        \n        return x == rev or x == rev // 10"}, {"task_id": "palindrome-number", "completion": "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        \n        if x < 0:\n            return False\n        \n        if x < 10:\n            return True\n        \n        if x % 10 == 0:\n            return False\n        \n        rev = 0\n        while x > rev:\n            rev = rev * 10 + x % 10\n            x = x // 10\n        \n        return x == rev or x == rev // 10"}, {"task_id": "palindrome-number", "completion": "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        \n        if x < 0:\n            return False\n        \n        if x < 10:\n            return True\n        \n        if x % 10 == 0:\n            return False\n        \n        rev = 0\n        while x > rev:\n            rev = rev * 10 + x % 10\n            x = x // 10\n        \n        return x == rev or x == rev // 10"}, {"task_id": "palindrome-number", "completion": "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        \n        if x < 0:\n            return False\n        \n        if x < 10:\n            return True\n        \n        if x % 10 == 0:\n            return False\n        \n        rev = 0\n        while x > rev:\n            rev = rev * 10 + x % 10\n            x = x // 10\n        \n        return x == rev or x == rev // 10"}, {"task_id": "palindrome-number", "completion": "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        \n        if x < 0:\n            return False\n        \n        if x < 10:\n            return True\n        \n        if x % 10 == 0:\n            return False\n        \n        rev = 0\n        while x > rev:\n            rev = rev * 10 + x % 10\n            x = x // 10\n        \n        return x == rev or x == rev // 10"}], "decode-ways": [{"task_id": "decode-ways", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if len(s) == 0:\n            return 0\n        \n        if s[0] == '0':\n            return 0\n        \n        if len(s) == 1:\n            return 1\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] += dp[i - 1]\n            if s[i - 2] != '0' and int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        \n        return dp[-1]"}, {"task_id": "decode-ways", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if len(s) == 0:\n            return 0\n        \n        if s[0] == '0':\n            return 0\n        \n        if len(s) == 1:\n            return 1\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] += dp[i - 1]\n            if s[i - 2] != '0' and int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        \n        return dp[-1]"}, {"task_id": "decode-ways", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if len(s) == 0:\n            return 0\n        \n        if s[0] == '0':\n            return 0\n        \n        if len(s) == 1:\n            return 1\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] = dp[i - 1]\n            if s[i - 2] != '0' and int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        \n        return dp[-1]"}, {"task_id": "decode-ways", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if len(s) == 0:\n            return 0\n        \n        if s[0] == '0':\n            return 0\n        \n        if len(s) == 1:\n            return 1\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] = dp[i - 1]\n            if s[i - 2] != '0' and int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        \n        return dp[-1]"}, {"task_id": "decode-ways", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if len(s) == 0:\n            return 0\n        \n        if s[0] == '0':\n            return 0\n        \n        if len(s) == 1:\n            return 1\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] += dp[i - 1]\n            if s[i - 2] != '0' and int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        \n        return dp[-1]"}], "is-subsequence": [{"task_id": "is-subsequence", "completion": "class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) == 0:\n            return True\n        if len(t) == 0:\n            return False\n        \n        i = 0\n        j = 0\n        while i < len(s) and j < len(t):\n            if s[i] == t[j]:\n                i += 1\n            j += 1\n        \n        if i == len(s):\n            return True\n        else:\n            return False"}, {"task_id": "is-subsequence", "completion": "class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) == 0:\n            return True\n        if len(t) == 0:\n            return False\n        \n        i = 0\n        j = 0\n        \n        while i < len(s) and j < len(t):\n            if s[i] == t[j]:\n                i += 1\n            j += 1\n        \n        if i == len(s):\n            return True\n        else:\n            return False"}, {"task_id": "is-subsequence", "completion": "class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) == 0:\n            return True\n        if len(t) == 0:\n            return False\n        \n        i = 0\n        j = 0\n        \n        while i < len(s) and j < len(t):\n            if s[i] == t[j]:\n                i += 1\n            j += 1\n        \n        if i == len(s):\n            return True\n        else:\n            return False"}, {"task_id": "is-subsequence", "completion": "class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) == 0:\n            return True\n        if len(t) == 0:\n            return False\n        \n        i = 0\n        j = 0\n        while i < len(s) and j < len(t):\n            if s[i] == t[j]:\n                i += 1\n            j += 1\n        \n        if i == len(s):\n            return True\n        else:\n            return False"}, {"task_id": "is-subsequence", "completion": "class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) == 0:\n            return True\n        if len(t) == 0:\n            return False\n        \n        i = 0\n        j = 0\n        \n        while i < len(s) and j < len(t):\n            if s[i] == t[j]:\n                i += 1\n            j += 1\n        \n        if i == len(s):\n            return True\n        else:\n            return False"}], "gray-code": [{"task_id": "gray-code", "completion": "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if n == 0:\n            return [0]\n        \n        if n == 1:\n            return [0,1]\n        \n        res = [0,1]\n        for i in range(1,n):\n            for j in range(len(res)-1,-1,-1):\n                res.append(res[j]+2**i)\n        return res"}, {"task_id": "gray-code", "completion": "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if n == 0:\n            return [0]\n        \n        if n == 1:\n            return [0,1]\n        \n        res = []\n        for i in range(2**n):\n            res.append(i ^ (i>>1))\n        \n        return res"}, {"task_id": "gray-code", "completion": "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if n == 0:\n            return [0]\n        \n        if n == 1:\n            return [0,1]\n        \n        res = [0,1]\n        for i in range(1,n):\n            for j in range(len(res)-1,-1,-1):\n                res.append(res[j]+2**i)\n        return res"}, {"task_id": "gray-code", "completion": "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if n == 0:\n            return [0]\n        \n        if n == 1:\n            return [0,1]\n        \n        res = [0,1]\n        \n        for i in range(1,n):\n            for j in range(len(res)-1,-1,-1):\n                res.append(res[j]+2**i)\n        \n        return res"}, {"task_id": "gray-code", "completion": "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if n == 0:\n            return [0]\n        \n        if n == 1:\n            return [0,1]\n        \n        res = []\n        for i in range(2**n):\n            res.append(i ^ (i >> 1))\n        \n        return res"}], "climbing-stairs": [{"task_id": "climbing-stairs", "completion": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        \n        dp = [0] * (n+1)\n        dp[1] = 1\n        dp[2] = 2\n        \n        for i in range(3, n+1):\n            dp[i] = dp[i-1] + dp[i-2]\n        \n        return dp[n]"}, {"task_id": "climbing-stairs", "completion": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        \n        return self.climbStairs(n-1) + self.climbStairs(n-2)"}, {"task_id": "climbing-stairs", "completion": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        \n        return self.climbStairs(n-1) + self.climbStairs(n-2)"}, {"task_id": "climbing-stairs", "completion": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        \n        dp = [0] * (n+1)\n        dp[1] = 1\n        dp[2] = 2\n        \n        for i in range(3, n+1):\n            dp[i] = dp[i-1] + dp[i-2]\n        \n        return dp[n]"}, {"task_id": "climbing-stairs", "completion": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        \n        a = 1\n        b = 2\n        for i in range(3, n+1):\n            c = a + b\n            a = b\n            b = c\n        return c"}], "word-break": [{"task_id": "word-break", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        \n        # DP solution\n        # Time: O(n^2)\n        # Space: O(n)\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and wordDict[j] in s[j:i]) for all 0 <= j < i\n        # dp[i] = True if wordDict[j] in s[j:i] for any 0 <= j < i\n        # dp[i] = True if wordDict[j] in s[j:i] for any 0 <= j < i\n        # dp[i] = True if wordDict[j] in s[j:i] for any 0 <= j < i\n        # dp[i] = True if wordDict[j] in s[j:i] for any 0 <= j < i\n        # dp[i] = True if wordDict[j] in s[j:i] for any 0 <= j < i\n        # dp[i] = True if wordDict[j] in s[j:i] for any 0 <= j < i\n        # dp[i] = True if wordDict[j] in s[j:i] for any 0 <= j < i\n        # dp[i] = True if wordDict[j] in s[j:i] for any 0 <= j < i\n        # dp[i] = True if wordDict[j] in s[j:i] for any 0 <= j < i\n        # dp[i] = True if wordDict[j] in s[j:i] for any 0 <= j < i\n        # dp[i] = True if wordDict[j] in s[j:i] for any 0 <= j < i\n        # dp[i] = True if wordDict[j] in s[j:i] for any 0 <= j < i\n        # dp[i] = True if wordDict[j] in s[j:i] for any 0 <= j < i\n        # dp[i] = True if wordDict[j] in s[j:i] for any 0 <= j < i\n        # dp[i] = True if wordDict[j] in s[j:i] for any 0 <= j < i\n        # dp[i] = True if wordDict[j] in s[j:i] for any 0 <= j < i\n        # dp[i] = True if wordDict[j] in s[j:i] for any 0 <= j < i\n        # dp[i] = True if wordDict[j] in s[j:i] for any 0 <= j < i\n        # dp[i] = True if wordDict[j] in s[j:i] for any 0 <= j < i\n        # dp[i] = True if wordDict[j] in s[j:i] for any 0 <= j < i\n        # dp[i] = True if wordDict[j] in s[j:i] for any 0 <= j < i\n        # dp[i] = True if wordDict[j] in s[j:i] for any 0 <= j < i\n        # dp[i] = True if wordDict[j] in s[j:i] for any 0 <= j < i\n        # dp[i] = True if wordDict[j] in s[j:i] for any 0 <= j < i\n        # dp[i] = True if wordDict[j] in s[j:i] for any 0 <= j < i\n        # dp[i] = True if wordDict[j] in s[j:i] for any 0 <= j < i\n        # dp[i] = True if wordDict[j] in s[j:i] for any 0 <= j < i\n        # dp[i] = True if wordDict[j] in s[j:i] for any 0 <= j < i\n        # dp[i] = True if"}, {"task_id": "word-break", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        \n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and wordDict[j] in s[j:i] for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and wordDict[j] in s[j:i] for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and wordDict[j] in s[j:i] for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and wordDict[j] in s[j:i] for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and wordDict[j] in s[j:i] for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and wordDict[j] in s[j:i] for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and wordDict[j] in s[j:i] for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and wordDict[j] in s[j:i] for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and wordDict[j] in s[j:i] for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and wordDict[j] in s[j:i] for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and wordDict[j] in s[j:i] for j in range(i))\n        # dp[i] = True if s[:i] can be segmented into a space-separ"}, {"task_id": "word-break", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        \n        # DP solution\n        # Time: O(n^2)\n        # Space: O(n)\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = any(dp[j] and wordDict[j] in s[j:i] for j in range(i))\n        # dp[i] = True if any(dp[j] and wordDict[j] in s[j:i] for j in range(i))\n        # dp[i] = True if any(dp[j] and wordDict[j] in s[j:i] for j in range(i))\n        # dp[i] = True if any(dp[j] and wordDict[j] in s[j:i] for j in range(i))\n        # dp[i] = True if any(dp[j] and wordDict[j] in s[j:i] for j in range(i))\n        # dp[i] = True if any(dp[j] and wordDict[j] in s[j:i] for j in range(i))\n        # dp[i] = True if any(dp[j] and wordDict[j] in s[j:i] for j in range(i))\n        # dp[i] = True if any(dp[j] and wordDict[j] in s[j:i] for j in range(i))\n        # dp[i] = True if any(dp[j] and wordDict[j] in s[j:i] for j in range(i))\n        # dp[i] = True if any(dp[j] and wordDict[j] in s[j:i] for j in range(i))\n        # dp[i] = True if any(dp[j] and wordDict[j] in s[j:i] for j in range(i))\n        # dp[i] = True if any(dp[j] and wordDict[j] in s[j:i] for j in range(i))\n        # dp[i] = True if any(dp[j] and wordDict[j] in s[j:i] for j in range(i))\n        # dp[i] = True if any(dp[j] and wordDict[j] in s[j:i] for j in range(i))\n        # dp[i] = True if any(dp[j] and wordDict[j] in s[j:i] for j in range(i))\n        # dp[i] = True if any(dp[j] and wordDict[j] in s[j:i] for j in range(i))\n        # dp[i] = True if any(dp[j] and wordDict[j] in s[j:i] for j in range(i))\n        # dp[i] = True if any(dp[j] and wordDict[j] in s[j:i] for j in range(i))\n        # dp[i] = True if any(dp[j] and wordDict[j] in s[j:i] for j in range(i))\n        # dp[i] = True if any(dp[j] and wordDict[j] in s[j:i] for j in range(i))\n        # dp[i] = True if any(dp[j] and wordDict[j] in s[j:i] for j in range(i))\n        # dp[i] = True if any(dp[j] and wordDict[j] in s[j:i] for j in range(i))\n        # dp[i] = True if any(dp[j] and wordDict[j] in s[j:i] for j in range(i))\n        # dp[i] = True if any(dp[j] and wordDict[j] in s[j:i] for j in range(i))\n        # dp[i] = True if any(dp[j] and wordDict[j] in s[j:i] for j in"}, {"task_id": "word-break", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        \n        # create a list of all the words in the dictionary\n        word_list = []\n        for word in wordDict:\n            word_list.append(word)\n        \n        # create a list of all the words in the string\n        word_list_s = []\n        for word in s.split():\n            word_list_s.append(word)\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict = []\n        for word in word_list_s:\n            if word in word_list:\n                word_list_s_in_dict.append(word)\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict_2 = []\n        for word in word_list_s_in_dict:\n            if word not in word_list_s_in_dict_2:\n                word_list_s_in_dict_2.append(word)\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict_3 = []\n        for word in word_list_s_in_dict_2:\n            if word not in word_list_s_in_dict_3:\n                word_list_s_in_dict_3.append(word)\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict_4 = []\n        for word in word_list_s_in_dict_3:\n            if word not in word_list_s_in_dict_4:\n                word_list_s_in_dict_4.append(word)\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict_5 = []\n        for word in word_list_s_in_dict_4:\n            if word not in word_list_s_in_dict_5:\n                word_list_s_in_dict_5.append(word)\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict_6 = []\n        for word in word_list_s_in_dict_5:\n            if word not in word_list_s_in_dict_6:\n                word_list_s_in_dict_6.append(word)\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict_7 = []\n        for word in word_list_s_in_dict_6:\n            if word not in word_list_s_in_dict_7:\n                word_list_s_in_dict_7.append(word)\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict_8 = []\n        for word in word_list_s_in_dict_7:\n            if word not in word_list_s_in_dict_8:\n                word_list_s_in_dict_8.append(word)\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict_9 = []\n        for word in word_list_s_in_dict_8:\n            if word not in word_list_s_in_dict_9:\n                word_list_s_in_dict_9.append(word)\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict_10 = []\n        for word in word_list_s_in_dict_9:\n            if word not in word_list_s_in_dict_10:\n                word_list_s_in_dict_10.append(word)\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict_11 = []\n        for word in word_list_s_in_dict_10:\n            if word not in word_list_s_in_dict_11:\n                word_list_"}, {"task_id": "word-break", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        \n        # DP\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = dp[j] and s[j:i] in wordDict\n        # dp[0] = True\n        # dp[i] = any(dp[j] and s[j:i] in wordDict for j in range(i))\n        \n        # Time: O(n^2)\n        # Space: O(n)\n        dp = [False] * (len(s) + 1)\n        dp[0] = True\n        \n        for i in range(1, len(s) + 1):\n            for j in range(i):\n                if dp[j] and s[j:i] in wordDict:\n                    dp[i] = True\n                    break\n        \n        return dp[-1]"}], "validate-binary-search-tree": [{"task_id": "validate-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def helper(node, lower, upper):\n            if not node:\n                return True\n            \n            if node.val <= lower or node.val >= upper:\n                return False\n            \n            return helper(node.left, lower, node.val) and helper(node.right, node.val, upper)\n        \n        return helper(root, float('-inf'), float('inf'))"}, {"task_id": "validate-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def helper(node, lower, upper):\n            if not node:\n                return True\n            \n            if node.val <= lower or node.val >= upper:\n                return False\n            \n            return helper(node.left, lower, node.val) and helper(node.right, node.val, upper)\n        \n        return helper(root, float('-inf'), float('inf'))"}, {"task_id": "validate-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def helper(node, lower, upper):\n            if not node:\n                return True\n            \n            if node.val <= lower or node.val >= upper:\n                return False\n            \n            return helper(node.left, lower, node.val) and helper(node.right, node.val, upper)\n        \n        return helper(root, float('-inf'), float('inf'))"}, {"task_id": "validate-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def helper(node, lower, upper):\n            if not node:\n                return True\n            \n            if node.val <= lower or node.val >= upper:\n                return False\n            \n            return helper(node.left, lower, node.val) and helper(node.right, node.val, upper)\n        \n        return helper(root, float('-inf'), float('inf'))"}, {"task_id": "validate-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def inorder(root, lower, upper):\n            if not root:\n                return True\n            \n            if root.val <= lower or root.val >= upper:\n                return False\n            \n            return inorder(root.left, lower, root.val) and inorder(root.right, root.val, upper)\n        \n        return inorder(root, float('-inf'), float('inf'))"}], "insert-interval": [{"task_id": "insert-interval", "completion": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # if the new interval is empty, return the original list\n        if not newInterval:\n            return intervals\n        \n        # if the list is empty, return the new interval\n        if not intervals:\n            return [newInterval]\n        \n        # if the new interval is larger than the last interval in the list, add it to the end\n        if newInterval[0] > intervals[-1][1]:\n            intervals.append(newInterval)\n            return intervals\n        \n        # if the new interval is smaller than the first interval in the list, add it to the beginning\n        if newInterval[1] < intervals[0][0]:\n            intervals.insert(0, newInterval)\n            return intervals\n        \n        # if the new interval overlaps with the first interval in the list, merge the intervals\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[0][1]:\n            intervals[0] = [intervals[0][0], intervals[0][1]]\n            return intervals\n        \n        # if the new interval overlaps with the last interval in the list, merge the intervals\n        if newInterval[0] >= intervals[-1][0] and newInterval[1] <= intervals[-1][1]:\n            intervals[-1] = [intervals[-1][0], intervals[-1][1]]\n            return intervals\n        \n        # if the new interval overlaps with the middle interval in the list, merge the intervals\n        for i in range(len(intervals)):\n            if newInterval[0] >= intervals[i][0] and newInterval[1] <= intervals[i][1]:\n                intervals[i] = [intervals[i][0], intervals[i][1]]\n                return intervals\n        \n        # if the new interval does not overlap with any interval in the list, insert the new interval\n        for i in range(len(intervals)):\n            if newInterval[0] < intervals[i][0] and newInterval[1] > intervals[i][1]:\n                intervals.insert(i, newInterval)\n                return intervals\n        \n        # if the new interval does not overlap with any interval in the list, append the new interval\n        intervals.append(newInterval)\n        return intervals"}, {"task_id": "insert-interval", "completion": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # if the new interval is empty, return the original list\n        if not newInterval:\n            return intervals\n        \n        # if the list is empty, return the new interval\n        if not intervals:\n            return [newInterval]\n        \n        # if the new interval is larger than the last element in the list, add it to the end\n        if newInterval[0] > intervals[-1][1]:\n            intervals.append(newInterval)\n            return intervals\n        \n        # if the new interval is smaller than the first element in the list, add it to the beginning\n        if newInterval[1] < intervals[0][0]:\n            intervals.insert(0, newInterval)\n            return intervals\n        \n        # if the new interval overlaps with the first element in the list, merge the two intervals\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[0][1]:\n            intervals[0] = [intervals[0][0], intervals[0][1]]\n            return intervals\n        \n        # if the new interval overlaps with the last element in the list, merge the two intervals\n        if newInterval[0] >= intervals[-1][0] and newInterval[1] <= intervals[-1][1]:\n            intervals[-1] = [intervals[-1][0], intervals[-1][1]]\n            return intervals\n        \n        # if the new interval overlaps with the middle element in the list, merge the two intervals\n        for i in range(len(intervals)):\n            if newInterval[0] >= intervals[i][0] and newInterval[1] <= intervals[i][1]:\n                intervals[i] = [intervals[i][0], intervals[i][1]]\n                return intervals\n        \n        # if the new interval does not overlap with any element in the list, insert it into the list\n        for i in range(len(intervals)):\n            if newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                intervals.insert(i, newInterval)\n                return intervals\n        \n        # if the new interval does not overlap with any element in the list, insert it into the list\n        for i in range(len(intervals)):\n            if newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                intervals.insert(i, newInterval)\n                return intervals\n        \n        # if the new interval does not overlap with any element in the list, insert it into the list\n        for i in range(len(intervals)):\n            if newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                intervals.insert(i, newInterval)\n                return intervals\n        \n        # if the new interval does not overlap with any element in the list, insert it into the list\n        for i in range(len(intervals)):\n            if newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                intervals.insert(i, newInterval)\n                return intervals\n        \n        # if the new interval does not overlap with any element in the list, insert it into the list\n        for i in range(len(intervals)):\n            if newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                intervals.insert(i, newInterval)\n                return intervals\n        \n        # if the new interval does not overlap with any element in the list, insert it into the list\n        for i in range(len(intervals)):\n            if newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                intervals.insert(i, newInterval)\n                return intervals\n        \n        # if the new interval does not overlap with any element in the list, insert it into the list\n        for i in range(len(intervals)):\n            if newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                intervals.insert(i, newInterval)\n                return intervals\n        \n        # if the new interval does not overlap with any element in the list, insert it into the list\n        for i in range(len(intervals)):\n            if newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:"}, {"task_id": "insert-interval", "completion": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # if the new interval is empty, return the original list\n        if not newInterval:\n            return intervals\n        \n        # if the original list is empty, return the new interval\n        if not intervals:\n            return [newInterval]\n        \n        # if the new interval is smaller than the first element of the original list, insert it at the beginning\n        if newInterval[0] < intervals[0][0]:\n            return [newInterval] + intervals\n        \n        # if the new interval is larger than the last element of the original list, insert it at the end\n        if newInterval[1] > intervals[-1][1]:\n            return intervals + [newInterval]\n        \n        # if the new interval overlaps with the first element of the original list, merge the new interval with the first element\n        if newInterval[0] >= intervals[0][0] and newInterval[1] <= intervals[0][1]:\n            return [newInterval] + intervals[1:]\n        \n        # if the new interval overlaps with the last element of the original list, merge the new interval with the last element\n        if newInterval[0] <= intervals[-1][0] and newInterval[1] >= intervals[-1][1]:\n            return intervals[:-1] + [newInterval]\n        \n        # if the new interval overlaps with the middle elements of the original list, merge the new interval with the middle elements\n        for i in range(len(intervals)):\n            if newInterval[0] >= intervals[i][0] and newInterval[1] <= intervals[i][1]:\n                return intervals[:i] + [newInterval] + intervals[i+1:]\n        \n        # if the new interval does not overlap with any element of the original list, insert the new interval at the appropriate position\n        for i in range(len(intervals)):\n            if newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                return intervals[:i] + [newInterval] + intervals[i:]\n        \n        # if the new interval does not overlap with any element of the original list, insert the new interval at the appropriate position\n        for i in range(len(intervals)):\n            if newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                return intervals[:i] + [newInterval] + intervals[i:]\n        \n        # if the new interval does not overlap with any element of the original list, insert the new interval at the appropriate position\n        for i in range(len(intervals)):\n            if newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                return intervals[:i] + [newInterval] + intervals[i:]\n        \n        # if the new interval does not overlap with any element of the original list, insert the new interval at the appropriate position\n        for i in range(len(intervals)):\n            if newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                return intervals[:i] + [newInterval] + intervals[i:]\n        \n        # if the new interval does not overlap with any element of the original list, insert the new interval at the appropriate position\n        for i in range(len(intervals)):\n            if newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                return intervals[:i] + [newInterval] + intervals[i:]\n        \n        # if the new interval does not overlap with any element of the original list, insert the new interval at the appropriate position\n        for i in range(len(intervals)):\n            if newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                return intervals[:i] + [newInterval] + intervals[i:]\n        \n        # if the new interval does not overlap with any element of the original list, insert the new interval at the appropriate position\n        for i in range(len(intervals)):\n            if newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                return intervals[:i] + [newInterval] + intervals[i:]\n        \n        # if the new interval does not overlap with any element of the original list, insert the new interval at the appropriate position\n        for i in range(len(intervals)):\n            if newInterval"}, {"task_id": "insert-interval", "completion": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # if the new interval is empty, return the original list\n        if not newInterval:\n            return intervals\n        \n        # if the original list is empty, return the new interval\n        if not intervals:\n            return [newInterval]\n        \n        # initialize the result list\n        result = []\n        \n        # iterate over the intervals\n        for interval in intervals:\n            \n            # if the current interval is overlapping with the new interval, merge them\n            if interval[0] <= newInterval[0] <= interval[1] or interval[0] <= newInterval[1] <= interval[1] or interval[0] <= newInterval[0] <= interval[1] or interval[0] <= newInterval[1] <= interval[1]:\n                newInterval = [min(interval[0], newInterval[0]), max(interval[1], newInterval[1])]\n            \n            # otherwise, add the current interval to the result list\n            else:\n                result.append(interval)\n        \n        # add the new interval to the result list\n        result.append(newInterval)\n        \n        # return the result list\n        return result"}, {"task_id": "insert-interval", "completion": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # if the new interval is empty, return the original list\n        if not newInterval:\n            return intervals\n        \n        # if the list is empty, return the new interval\n        if not intervals:\n            return [newInterval]\n        \n        # if the new interval is smaller than the first element in the list, insert it at the beginning\n        if newInterval[0] < intervals[0][0]:\n            return [newInterval] + intervals\n        \n        # if the new interval is larger than the last element in the list, insert it at the end\n        if newInterval[1] > intervals[-1][1]:\n            return intervals + [newInterval]\n        \n        # if the new interval overlaps with the first element in the list, merge the new interval with the first element\n        if newInterval[0] <= intervals[0][0] and newInterval[1] >= intervals[0][1]:\n            return [newInterval] + intervals[1:]\n        \n        # if the new interval overlaps with the last element in the list, merge the new interval with the last element\n        if newInterval[0] >= intervals[-1][0] and newInterval[1] <= intervals[-1][1]:\n            return intervals[:-1] + [newInterval]\n        \n        # if the new interval overlaps with the middle elements in the list, merge the new interval with the middle elements\n        for i in range(len(intervals)):\n            if newInterval[0] >= intervals[i][0] and newInterval[1] <= intervals[i][1]:\n                return intervals[:i] + [newInterval] + intervals[i+1:]\n        \n        # if the new interval does not overlap with any element in the list, insert it at the appropriate position\n        for i in range(len(intervals)):\n            if newInterval[0] < intervals[i][0] and newInterval[1] > intervals[i][1]:\n                return intervals[:i] + [newInterval] + intervals[i:]\n        \n        # if the new interval overlaps with the middle elements in the list, merge the new interval with the middle elements\n        for i in range(len(intervals)):\n            if newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                return intervals[:i] + [newInterval] + intervals[i:]\n        \n        # if the new interval overlaps with the middle elements in the list, merge the new interval with the middle elements\n        for i in range(len(intervals)):\n            if newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                return intervals[:i] + [newInterval] + intervals[i:]\n        \n        # if the new interval overlaps with the middle elements in the list, merge the new interval with the middle elements\n        for i in range(len(intervals)):\n            if newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                return intervals[:i] + [newInterval] + intervals[i:]\n        \n        # if the new interval overlaps with the middle elements in the list, merge the new interval with the middle elements\n        for i in range(len(intervals)):\n            if newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                return intervals[:i] + [newInterval] + intervals[i:]\n        \n        # if the new interval overlaps with the middle elements in the list, merge the new interval with the middle elements\n        for i in range(len(intervals)):\n            if newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                return intervals[:i] + [newInterval] + intervals[i:]\n        \n        # if the new interval overlaps with the middle elements in the list, merge the new interval with the middle elements\n        for i in range(len(intervals)):\n            if newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                return intervals[:i] + [newInterval] + intervals[i:]\n        \n        # if the new interval overlaps with the middle elements in the list, merge the new interval with the middle elements\n        for i in range(len(intervals)):\n            if newInterval[0] <= intervals[i][0] and newInterval[1]"}], "palindrome-partitioning": [{"task_id": "palindrome-partitioning", "completion": "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        def dfs(s, path, res):\n            if not s:\n                res.append(path[:])\n                return\n            for i in range(1, len(s) + 1):\n                if isPalindrome(s[:i]):\n                    dfs(s[i:], path + [s[:i]], res)\n        \n        res = []\n        dfs(s, [], res)\n        return res"}, {"task_id": "palindrome-partitioning", "completion": "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        def backtrack(s, path, res):\n            if not s:\n                res.append(path[:])\n                return\n            for i in range(1, len(s) + 1):\n                if isPalindrome(s[:i]):\n                    backtrack(s[i:], path + [s[:i]], res)\n        \n        res = []\n        backtrack(s, [], res)\n        return res"}, {"task_id": "palindrome-partitioning", "completion": "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        def backtrack(s, path, res):\n            if not s:\n                res.append(path[:])\n                return\n            for i in range(1, len(s) + 1):\n                if isPalindrome(s[:i]):\n                    backtrack(s[i:], path + [s[:i]], res)\n        \n        res = []\n        backtrack(s, [], res)\n        return res"}, {"task_id": "palindrome-partitioning", "completion": "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        def backtrack(s, path, res):\n            if not s:\n                res.append(path[:])\n                return\n            for i in range(1, len(s) + 1):\n                if isPalindrome(s[:i]):\n                    backtrack(s[i:], path + [s[:i]], res)\n        \n        res = []\n        backtrack(s, [], res)\n        return res"}, {"task_id": "palindrome-partitioning", "completion": "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        def backtrack(s, path, res):\n            if not s:\n                res.append(path[:])\n                return\n            for i in range(1, len(s) + 1):\n                if isPalindrome(s[:i]):\n                    backtrack(s[i:], path + [s[:i]], res)\n        \n        res = []\n        backtrack(s, [], res)\n        return res"}], "smallest-range-covering-elements-from-k-lists": [{"task_id": "smallest-range-covering-elements-from-k-lists", "completion": "class Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. find the min and max of each list\n        # 2. find the min and max of the range\n        # 3. find the min and max of the range\n        # 4. find the min and max of the range\n        # 5. find the min and max of the range\n        # 6. find the min and max of the range\n        # 7. find the min and max of the range\n        # 8. find the min and max of the range\n        # 9. find the min and max of the range\n        # 10. find the min and max of the range\n        # 11. find the min and max of the range\n        # 12. find the min and max of the range\n        # 13. find the min and max of the range\n        # 14. find the min and max of the range\n        # 15. find the min and max of the range\n        # 16. find the min and max of the range\n        # 17. find the min and max of the range\n        # 18. find the min and max of the range\n        # 19. find the min and max of the range\n        # 20. find the min and max of the range\n        # 21. find the min and max of the range\n        # 22. find the min and max of the range\n        # 23. find the min and max of the range\n        # 24. find the min and max of the range\n        # 25. find the min and max of the range\n        # 26. find the min and max of the range\n        # 27. find the min and max of the range\n        # 28. find the min and max of the range\n        # 29. find the min and max of the range\n        # 30. find the min and max of the range\n        # 31. find the min and max of the range\n        # 32. find the min and max of the range\n        # 33. find the min and max of the range\n        # 34. find the min and max of the range\n        # 35. find the min and max of the range\n        # 36. find the min and max of the range\n        # 37. find the min and max of the range\n        # 38. find the min and max of the range\n        # 39. find the min and max of the range\n        # 40. find the min and max of the range\n        # 41. find the min and max of the range\n        # 42. find the min and max of the range\n        # 43. find the min and max of the range\n        # 44. find the min and max of the range\n        # 45. find the min and max of the range\n        # 46. find the min and max of the range\n        # 47. find the min and max of the range\n        # 48. find the min and max of the range\n        # 49. find the min and max of the range\n        # 50. find the min and max of the range\n        # 51. find the min and max of the range\n        # 52. find the min and max of the range\n        # 53. find the min and max of the range\n        # 54. find the min and max of the range\n        # 55. find the min and max of the range\n        # 56. find the min and max of the range\n        # 57. find the min and max of the range\n        # 58. find the min and max of the range\n        # 59. find the min and max of the range\n        # 60. find the min and max of the range\n        # 61. find the min and max of the range\n        # 62. find the min and max of the range\n        # 63. find the min and max of the range\n        # 64. find the min and max of the range\n        # 65. find the min and max of the range\n        # 66. find the min and max of the range\n        # 67. find the min and max of the range\n        # 68. find the min and max of the range\n        # 69. find the min and max of the"}, {"task_id": "smallest-range-covering-elements-from-k-lists", "completion": "class Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. find the min and max of each list\n        # 2. find the min and max of the range\n        # 3. find the min and max of the range\n        # 4. find the min and max of the range\n        # 5. find the min and max of the range\n        # 6. find the min and max of the range\n        # 7. find the min and max of the range\n        # 8. find the min and max of the range\n        # 9. find the min and max of the range\n        # 10. find the min and max of the range\n        # 11. find the min and max of the range\n        # 12. find the min and max of the range\n        # 13. find the min and max of the range\n        # 14. find the min and max of the range\n        # 15. find the min and max of the range\n        # 16. find the min and max of the range\n        # 17. find the min and max of the range\n        # 18. find the min and max of the range\n        # 19. find the min and max of the range\n        # 20. find the min and max of the range\n        # 21. find the min and max of the range\n        # 22. find the min and max of the range\n        # 23. find the min and max of the range\n        # 24. find the min and max of the range\n        # 25. find the min and max of the range\n        # 26. find the min and max of the range\n        # 27. find the min and max of the range\n        # 28. find the min and max of the range\n        # 29. find the min and max of the range\n        # 30. find the min and max of the range\n        # 31. find the min and max of the range\n        # 32. find the min and max of the range\n        # 33. find the min and max of the range\n        # 34. find the min and max of the range\n        # 35. find the min and max of the range\n        # 36. find the min and max of the range\n        # 37. find the min and max of the range\n        # 38. find the min and max of the range\n        # 39. find the min and max of the range\n        # 40. find the min and max of the range\n        # 41. find the min and max of the range\n        # 42. find the min and max of the range\n        # 43. find the min and max of the range\n        # 44. find the min and max of the range\n        # 45. find the min and max of the range\n        # 46. find the min and max of the range\n        # 47. find the min and max of the range\n        # 48. find the min and max of the range\n        # 49. find the min and max of the range\n        # 50. find the min and max of the range\n        # 51. find the min and max of the range\n        # 52. find the min and max of the range\n        # 53. find the min and max of the range\n        # 54. find the min and max of the range\n        # 55. find the min and max of the range\n        # 56. find the min and max of the range\n        # 57. find the min and max of the range\n        # 58. find the min and max of the range\n        # 59. find the min and max of the range\n        # 60. find the min and max of the range\n        # 61. find the min and max of the range\n        # 62. find the min and max of the range\n        # 63. find the min and max of the range\n        # 64. find the min and max of the range\n        # 65. find the min and max of the range\n        # 66. find the min and max of the range\n        # 67. find the min and max of the range\n        # 68. find the min and max of the range\n        # 69. find the min and max of the"}, {"task_id": "smallest-range-covering-elements-from-k-lists", "completion": "class Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. find the min and max of each list\n        # 2. find the min and max of the range\n        # 3. find the min and max of the range\n        # 4. find the min and max of the range\n        # 5. find the min and max of the range\n        # 6. find the min and max of the range\n        # 7. find the min and max of the range\n        # 8. find the min and max of the range\n        # 9. find the min and max of the range\n        # 10. find the min and max of the range\n        # 11. find the min and max of the range\n        # 12. find the min and max of the range\n        # 13. find the min and max of the range\n        # 14. find the min and max of the range\n        # 15. find the min and max of the range\n        # 16. find the min and max of the range\n        # 17. find the min and max of the range\n        # 18. find the min and max of the range\n        # 19. find the min and max of the range\n        # 20. find the min and max of the range\n        # 21. find the min and max of the range\n        # 22. find the min and max of the range\n        # 23. find the min and max of the range\n        # 24. find the min and max of the range\n        # 25. find the min and max of the range\n        # 26. find the min and max of the range\n        # 27. find the min and max of the range\n        # 28. find the min and max of the range\n        # 29. find the min and max of the range\n        # 30. find the min and max of the range\n        # 31. find the min and max of the range\n        # 32. find the min and max of the range\n        # 33. find the min and max of the range\n        # 34. find the min and max of the range\n        # 35. find the min and max of the range\n        # 36. find the min and max of the range\n        # 37. find the min and max of the range\n        # 38. find the min and max of the range\n        # 39. find the min and max of the range\n        # 40. find the min and max of the range\n        # 41. find the min and max of the range\n        # 42. find the min and max of the range\n        # 43. find the min and max of the range\n        # 44. find the min and max of the range\n        # 45. find the min and max of the range\n        # 46. find the min and max of the range\n        # 47. find the min and max of the range\n        # 48. find the min and max of the range\n        # 49. find the min and max of the range\n        # 50. find the min and max of the range\n        # 51. find the min and max of the range\n        # 52. find the min and max of the range\n        # 53. find the min and max of the range\n        # 54. find the min and max of the range\n        # 55. find the min and max of the range\n        # 56. find the min and max of the range\n        # 57. find the min and max of the range\n        # 58. find the min and max of the range\n        # 59. find the min and max of the range\n        # 60. find the min and max of the range\n        # 61. find the min and max of the range\n        # 62. find the min and max of the range\n        # 63. find the min and max of the range\n        # 64. find the min and max of the range\n        # 65. find the min and max of the range\n        # 66. find the min and max of the range\n        # 67. find the min and max of the range\n        # 68. find the min and max of the range\n        # 69. find the min and max of the"}, {"task_id": "smallest-range-covering-elements-from-k-lists", "completion": "class Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574 \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 2. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574 \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 3. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574 \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 4. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574 \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 5. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574 \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 6. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574 \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 7. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574 \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 8. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574 \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 9. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574 \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 10. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574 \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 11. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574 \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 12. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574 \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 13. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574 \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 14. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574 \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 15. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574 \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 16. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574 \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 17. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574 \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 18. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30 \uc704\ud574 \ucd5c\ub300\uac12\uc744 \ucc3e\ub294\ub2e4.\n        # 19. \ucd5c\uc18c\uac12\uc744 \ucc3e\uae30"}, {"task_id": "smallest-range-covering-elements-from-k-lists", "completion": "class Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. find the min and max of each list\n        # 2. find the min and max of the range\n        # 3. find the min and max of the range\n        # 4. find the min and max of the range\n        # 5. find the min and max of the range\n        # 6. find the min and max of the range\n        # 7. find the min and max of the range\n        # 8. find the min and max of the range\n        # 9. find the min and max of the range\n        # 10. find the min and max of the range\n        # 11. find the min and max of the range\n        # 12. find the min and max of the range\n        # 13. find the min and max of the range\n        # 14. find the min and max of the range\n        # 15. find the min and max of the range\n        # 16. find the min and max of the range\n        # 17. find the min and max of the range\n        # 18. find the min and max of the range\n        # 19. find the min and max of the range\n        # 20. find the min and max of the range\n        # 21. find the min and max of the range\n        # 22. find the min and max of the range\n        # 23. find the min and max of the range\n        # 24. find the min and max of the range\n        # 25. find the min and max of the range\n        # 26. find the min and max of the range\n        # 27. find the min and max of the range\n        # 28. find the min and max of the range\n        # 29. find the min and max of the range\n        # 30. find the min and max of the range\n        # 31. find the min and max of the range\n        # 32. find the min and max of the range\n        # 33. find the min and max of the range\n        # 34. find the min and max of the range\n        # 35. find the min and max of the range\n        # 36. find the min and max of the range\n        # 37. find the min and max of the range\n        # 38. find the min and max of the range\n        # 39. find the min and max of the range\n        # 40. find the min and max of the range\n        # 41. find the min and max of the range\n        # 42. find the min and max of the range\n        # 43. find the min and max of the range\n        # 44. find the min and max of the range\n        # 45. find the min and max of the range\n        # 46. find the min and max of the range\n        # 47. find the min and max of the range\n        # 48. find the min and max of the range\n        # 49. find the min and max of the range\n        # 50. find the min and max of the range\n        # 51. find the min and max of the range\n        # 52. find the min and max of the range\n        # 53. find the min and max of the range\n        # 54. find the min and max of the range\n        # 55. find the min and max of the range\n        # 56. find the min and max of the range\n        # 57. find the min and max of the range\n        # 58. find the min and max of the range\n        # 59. find the min and max of the range\n        # 60. find the min and max of the range\n        # 61. find the min and max of the range\n        # 62. find the min and max of the range\n        # 63. find the min and max of the range\n        # 64. find the min and max of the range\n        # 65. find the min and max of the range\n        # 66. find the min and max of the range\n        # 67. find the min and max of the range\n        # 68. find the min and max of the range\n        # 69. find the min and max of the"}], "poor-pigs": [{"task_id": "poor-pigs", "completion": "class Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}, {"task_id": "poor-pigs", "completion": "class Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}, {"task_id": "poor-pigs", "completion": "class Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}, {"task_id": "poor-pigs", "completion": "class Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}, {"task_id": "poor-pigs", "completion": "class Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "swim-in-rising-water": [{"task_id": "swim-in-rising-water", "completion": "class Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        visited = set()\n        heap = [(grid[0][0], 0, 0)]\n        while heap:\n            time, i, j = heapq.heappop(heap)\n            if (i, j) == (n-1, n-1):\n                return time\n            for ni, nj in [(i, j+1), (i, j-1), (i+1, j), (i-1, j)]:\n                if 0 <= ni < n and 0 <= nj < n and (ni, nj) not in visited:\n                    visited.add((ni, nj))\n                    heapq.heappush(heap, (max(time, grid[ni][nj]), ni, nj))"}, {"task_id": "swim-in-rising-water", "completion": "class Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        if n == 1:\n            return grid[0][0]\n        \n        visited = set()\n        q = [(grid[0][0], 0, 0)]\n        visited.add((0, 0))\n        while q:\n            curr, i, j = heapq.heappop(q)\n            if i == n-1 and j == n-1:\n                return curr\n            for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:\n                if 0 <= x < n and 0 <= y < n and (x, y) not in visited:\n                    heapq.heappush(q, (max(curr, grid[x][y]), x, y))\n                    visited.add((x, y))\n        return -1"}, {"task_id": "swim-in-rising-water", "completion": "class Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        visited = set()\n        q = [(grid[0][0], 0, 0)]\n        visited.add((0, 0))\n        while q:\n            curr, i, j = heapq.heappop(q)\n            if i == n-1 and j == n-1:\n                return curr\n            for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:\n                if 0 <= x < n and 0 <= y < n and (x, y) not in visited:\n                    heapq.heappush(q, (max(curr, grid[x][y]), x, y))\n                    visited.add((x, y))\n        return -1"}, {"task_id": "swim-in-rising-water", "completion": "class Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        visited = set()\n        q = [(grid[0][0], 0, 0)]\n        visited.add((0, 0))\n        while q:\n            curr, t, i, j = heapq.heappop(q)\n            if i == n-1 and j == n-1:\n                return t\n            for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:\n                if 0 <= x < n and 0 <= y < n and (x, y) not in visited:\n                    heapq.heappush(q, (max(curr, grid[x][y]), t+1, x, y))\n                    visited.add((x, y))\n        return -1"}, {"task_id": "swim-in-rising-water", "completion": "class Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        visited = set()\n        q = [(grid[0][0], 0, 0)]\n        visited.add((0, 0))\n        while q:\n            curr, t, i, j = heapq.heappop(q)\n            if i == n-1 and j == n-1:\n                return t\n            for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:\n                if 0 <= x < n and 0 <= y < n and (x, y) not in visited:\n                    heapq.heappush(q, (max(curr, grid[x][y]), t+1, x, y))\n                    visited.add((x, y))\n        return -1"}], "unique-paths": [{"task_id": "unique-paths", "completion": "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. Create a 2D array of size m x n\n        # 2. Initialize the first row and column with 1\n        # 3. Iterate over the array and calculate the number of unique paths\n        # 4. Return the number of unique paths\n        \n        # 1. Create a 2D array of size m x n\n        grid = [[0 for i in range(n)] for j in range(m)]\n        \n        # 2. Initialize the first row and column with 1\n        for i in range(m):\n            grid[i][0] = 1\n        for j in range(n):\n            grid[0][j] = 1\n        \n        # 3. Iterate over the array and calculate the number of unique paths\n        for i in range(1, m):\n            for j in range(1, n):\n                grid[i][j] = grid[i-1][j] + grid[i][j-1]\n        \n        # 4. Return the number of unique paths\n        return grid[m-1][n-1]"}, {"task_id": "unique-paths", "completion": "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # create a 2D array of size m*n\n        grid = [[0 for x in range(n)] for y in range(m)]\n        \n        # set the first row to 1\n        for i in range(m):\n            grid[i][0] = 1\n        \n        # set the first column to 1\n        for j in range(n):\n            grid[0][j] = 1\n        \n        # iterate through the grid and calculate the number of unique paths\n        for i in range(1, m):\n            for j in range(1, n):\n                grid[i][j] = grid[i-1][j] + grid[i][j-1]\n        \n        return grid[m-1][n-1]"}, {"task_id": "unique-paths", "completion": "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # Create a 2D array to store the number of unique paths to each cell\n        # The first row and column will always have a unique path to the cell\n        # The number of unique paths to the cell is the sum of the number of unique paths to the cell above and the number of unique paths to the cell to the left\n        # The number of unique paths to the cell above is the number of unique paths to the cell above minus the number of unique paths to the cell to the left\n        # The number of unique paths to the cell to the left is the number of unique paths to the cell to the left minus the number of unique paths to the cell above\n        # The number of unique paths to the cell to the left is the number of unique paths to the cell to the left minus the number of unique paths to the cell above\n        # The number of unique paths to the cell above is the number of unique paths to the cell above minus the number of unique paths to the cell to the left\n        # The number of unique paths to the cell to the left is the number of unique paths to the cell to the left minus the number of unique paths to the cell above\n        # The number of unique paths to the cell above is the number of unique paths to the cell above minus the number of unique paths to the cell to the left\n        # The number of unique paths to the cell to the left is the number of unique paths to the cell to the left minus the number of unique paths to the cell above\n        # The number of unique paths to the cell above is the number of unique paths to the cell above minus the number of unique paths to the cell to the left\n        # The number of unique paths to the cell to the left is the number of unique paths to the cell to the left minus the number of unique paths to the cell above\n        # The number of unique paths to the cell above is the number of unique paths to the cell above minus the number of unique paths to the cell to the left\n        # The number of unique paths to the cell to the left is the number of unique paths to the cell to the left minus the number of unique paths to the cell above\n        # The number of unique paths to the cell above is the number of unique paths to the cell above minus the number of unique paths to the cell to the left\n        # The number of unique paths to the cell to the left is the number of unique paths to the cell to the left minus the number of unique paths to the cell above\n        # The number of unique paths to the cell above is the number of unique paths to the cell above minus the number of unique paths to the cell to the left\n        # The number of unique paths to the cell to the left is the number of unique paths to the cell to the left minus the number of unique paths to the cell above\n        # The number of unique paths to the cell above is the number of unique paths to the cell above minus the number of unique paths to the cell to the left\n        # The number of unique paths to the cell to the left is the number of unique paths to the cell to the left minus the number of unique paths to the cell above\n        # The number of unique paths to the cell above is the number of unique paths to the cell above minus the number of unique paths to the cell to the left\n        # The number of unique paths to the cell to the left is the number of unique paths to the cell to the left minus the number of unique paths to the cell above\n        # The number of unique paths to the cell above is the number of unique paths to the cell above minus the number of unique paths to the cell to the left\n        # The number of unique paths to the cell to the left is the number of unique paths to the cell to the left minus the number of unique paths to the cell above\n        # The number of unique paths to the cell above is the number of unique paths to the cell above minus the number of unique paths to the cell to the left\n        # The number of unique paths to the cell to the left is the number of unique paths to the cell to the left minus the number of unique paths to the cell above\n        # The number of unique paths to the cell above is the number of unique paths to the cell above minus the number of unique paths to the cell to the left\n        # The number of unique paths to the cell to the left is the number of unique paths to the cell to the left minus the number of unique paths to the cell above\n        # The number of unique paths to the cell above is the number of unique paths to the cell above minus the number of unique paths to the cell to the left\n        # The number of unique paths to the cell to the left is the number of unique paths to the cell to the left minus the number of unique paths to the cell above\n        # The number of unique"}, {"task_id": "unique-paths", "completion": "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # create a 2D array of size m x n\n        grid = [[0 for x in range(n)] for y in range(m)]\n        \n        # fill the first row with 1s\n        for i in range(m):\n            grid[i][0] = 1\n        \n        # fill the first column with 1s\n        for j in range(n):\n            grid[0][j] = 1\n        \n        # fill the rest of the grid with the sum of the values in the previous row and previous column\n        for i in range(1, m):\n            for j in range(1, n):\n                grid[i][j] = grid[i-1][j] + grid[i][j-1]\n        \n        # return the value at the bottom right corner\n        return grid[m-1][n-1]"}, {"task_id": "unique-paths", "completion": "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # create a 2D array of size m x n\n        grid = [[0 for x in range(n)] for y in range(m)]\n        \n        # set the first row to 1\n        for i in range(m):\n            grid[i][0] = 1\n        \n        # set the first column to 1\n        for i in range(n):\n            grid[0][i] = 1\n        \n        # iterate through the grid\n        for i in range(1, m):\n            for j in range(1, n):\n                grid[i][j] = grid[i-1][j] + grid[i][j-1]\n        \n        return grid[m-1][n-1]"}], "multiply-strings": [{"task_id": "multiply-strings", "completion": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        if num1 == \"0\" or num2 == \"0\":\n            return \"0\"\n        \n        num1 = num1[::-1]\n        num2 = num2[::-1]\n        \n        res = [0] * (len(num1) + len(num2))\n        \n        for i in range(len(num1)):\n            for j in range(len(num2)):\n                res[i+j] += int(num1[i]) * int(num2[j])\n                \n        for i in range(len(res)-1):\n            res[i+1] += res[i] // 10\n            res[i] = res[i] % 10\n            \n        res = res[::-1]\n        \n        i = 0\n        while i < len(res) and res[i] == 0:\n            i += 1\n            \n        return ''.join(map(str, res[i:]))"}, {"task_id": "multiply-strings", "completion": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        if num1 == '0' or num2 == '0':\n            return '0'\n        \n        num1 = num1[::-1]\n        num2 = num2[::-1]\n        \n        res = [0] * (len(num1) + len(num2))\n        \n        for i in range(len(num1)):\n            for j in range(len(num2)):\n                res[i+j] += int(num1[i]) * int(num2[j])\n                \n        for i in range(len(res)-1):\n            res[i+1] += res[i] // 10\n            res[i] = res[i] % 10\n            \n        res = res[::-1]\n        \n        while len(res) > 1 and res[-1] == 0:\n            res.pop()\n            \n        return ''.join(map(str, res))"}, {"task_id": "multiply-strings", "completion": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        if num1 == \"0\" or num2 == \"0\":\n            return \"0\"\n        \n        num1 = num1[::-1]\n        num2 = num2[::-1]\n        \n        res = [0] * (len(num1) + len(num2))\n        \n        for i in range(len(num1)):\n            for j in range(len(num2)):\n                res[i+j] += int(num1[i]) * int(num2[j])\n                \n        for i in range(len(res)-1):\n            res[i+1] += res[i] // 10\n            res[i] = res[i] % 10\n            \n        res = res[::-1]\n        \n        while len(res) > 1 and res[-1] == 0:\n            res.pop()\n            \n        return \"\".join(map(str, res))"}, {"task_id": "multiply-strings", "completion": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        if num1 == '0' or num2 == '0':\n            return '0'\n        \n        num1 = num1[::-1]\n        num2 = num2[::-1]\n        \n        res = [0] * (len(num1) + len(num2))\n        \n        for i in range(len(num1)):\n            for j in range(len(num2)):\n                res[i+j] += int(num1[i]) * int(num2[j])\n                \n        for i in range(len(res)-1):\n            res[i+1] += res[i] // 10\n            res[i] %= 10\n            \n        res = [str(x) for x in res]\n        res = ''.join(res[::-1]).lstrip('0')\n        \n        return res"}, {"task_id": "multiply-strings", "completion": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        if num1 == \"0\" or num2 == \"0\":\n            return \"0\"\n        \n        num1 = num1[::-1]\n        num2 = num2[::-1]\n        \n        res = [0] * (len(num1) + len(num2))\n        \n        for i in range(len(num1)):\n            for j in range(len(num2)):\n                res[i+j] += int(num1[i]) * int(num2[j])\n                \n        for i in range(len(res)-1):\n            res[i+1] += res[i] // 10\n            res[i] %= 10\n            \n        res = [str(x) for x in res]\n        res = res[::-1]\n        \n        while len(res) > 1 and res[-1] == \"0\":\n            res.pop()\n            \n        return \"\".join(res)"}], "best-time-to-buy-and-sell-stock-iii": [{"task_id": "best-time-to-buy-and-sell-stock-iii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 3. Greedy\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 3. Greedy\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 3. Greedy\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 3. Greedy\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 3. Greedy\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 3. Greedy\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 3. Greedy\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 3. Greedy\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 3. Greedy\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O"}, {"task_id": "best-time-to-buy-and-sell-stock-iii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Brute Force\n        ## 2. DP\n        ## 3. DP with 2 variables\n        ## 4. DP with 3 variables\n        ## 5. DP with 4 variables\n        ## 6. DP with 5 variables\n        ## 7. DP with 6 variables\n        ## 8. DP with 7 variables\n        ## 9. DP with 8 variables\n        ## 10. DP with 9 variables\n        ## 11. DP with 10 variables\n        ## 12. DP with 11 variables\n        ## 13. DP with 12 variables\n        ## 14. DP with 13 variables\n        ## 15. DP with 14 variables\n        ## 16. DP with 15 variables\n        ## 17. DP with 16 variables\n        ## 18. DP with 17 variables\n        ## 19. DP with 18 variables\n        ## 20. DP with 19 variables\n        ## 21. DP with 20 variables\n        ## 22. DP with 21 variables\n        ## 23. DP with 22 variables\n        ## 24. DP with 23 variables\n        ## 25. DP with 24 variables\n        ## 26. DP with 25 variables\n        ## 27. DP with 26 variables\n        ## 28. DP with 27 variables\n        ## 29. DP with 28 variables\n        ## 30. DP with 29 variables\n        ## 31. DP with 30 variables\n        ## 32. DP with 31 variables\n        ## 33. DP with 32 variables\n        ## 34. DP with 33 variables\n        ## 35. DP with 34 variables\n        ## 36. DP with 35 variables\n        ## 37. DP with 36 variables\n        ## 38. DP with 37 variables\n        ## 39. DP with 38 variables\n        ## 40. DP with 39 variables\n        ## 41. DP with 40 variables\n        ## 42. DP with 41 variables\n        ## 43. DP with 42 variables\n        ## 44. DP with 43 variables\n        ## 45. DP with 44 variables\n        ## 46. DP with 45 variables\n        ## 47. DP with 46 variables\n        ## 48. DP with 47 variables\n        ## 49. DP with 48 variables\n        ## 50. DP with 49 variables\n        ## 51. DP with 50 variables\n        ## 52. DP with 51 variables\n        ## 53. DP with 52 variables\n        ## 54. DP with 53 variables\n        ## 55. DP with 54 variables\n        ## 56. DP with 55 variables\n        ## 57. DP with 56 variables\n        ## 58. DP with 57 variables\n        ## 59. DP with 58 variables\n        ## 60. DP with 59 variables\n        ## 61. DP with 60 variables\n        ## 62. DP with 61 variables\n        ## 63. DP with 62 variables\n        ## 64. DP with 63 variables\n        ## 65. DP with 64 variables\n        ## 66. DP with 65 variables\n        ## 67. DP with 66 variables\n        ## 68. DP with 67 variables\n        ## 69. DP with 68 variables\n        ## 70. DP with 69 variables"}, {"task_id": "best-time-to-buy-and-sell-stock-iii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 3. DP with 2 variables\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 3. DP with 2 variables\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 3. DP with 2 variables\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        if len(prices) <= 1:\n            return 0\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 3. DP with 2 variables\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        max_profit = 0\n        min_price = prices[0]\n        for i in range(1, len(prices)):\n            min_price = min(min_price, prices[i])\n            max_profit = max(max_profit, prices[i] - min_price)\n        return max_profit"}, {"task_id": "best-time-to-buy-and-sell-stock-iii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 3. DP with 2 variables\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        max_profit = 0\n        for i in range(len(prices)):\n            for j in range(i+1, len(prices)):\n                max_profit = max(max_profit, prices[j] - prices[i])\n        return max_profit"}, {"task_id": "best-time-to-buy-and-sell-stock-iii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Brute force\n        ## 2. DP\n        ## 3. DP with 2 variables\n        ## 4. DP with 3 variables\n        ## 5. DP with 4 variables\n        ## 6. DP with 5 variables\n        ## 7. DP with 6 variables\n        ## 8. DP with 7 variables\n        ## 9. DP with 8 variables\n        ## 10. DP with 9 variables\n        ## 11. DP with 10 variables\n        ## 12. DP with 11 variables\n        ## 13. DP with 12 variables\n        ## 14. DP with 13 variables\n        ## 15. DP with 14 variables\n        ## 16. DP with 15 variables\n        ## 17. DP with 16 variables\n        ## 18. DP with 17 variables\n        ## 19. DP with 18 variables\n        ## 20. DP with 19 variables\n        ## 21. DP with 20 variables\n        ## 22. DP with 21 variables\n        ## 23. DP with 22 variables\n        ## 24. DP with 23 variables\n        ## 25. DP with 24 variables\n        ## 26. DP with 25 variables\n        ## 27. DP with 26 variables\n        ## 28. DP with 27 variables\n        ## 29. DP with 28 variables\n        ## 30. DP with 29 variables\n        ## 31. DP with 30 variables\n        ## 32. DP with 31 variables\n        ## 33. DP with 32 variables\n        ## 34. DP with 33 variables\n        ## 35. DP with 34 variables\n        ## 36. DP with 35 variables\n        ## 37. DP with 36 variables\n        ## 38. DP with 37 variables\n        ## 39. DP with 38 variables\n        ## 40. DP with 39 variables\n        ## 41. DP with 40 variables\n        ## 42. DP with 41 variables\n        ## 43. DP with 42 variables\n        ## 44. DP with 43 variables\n        ## 45. DP with 44 variables\n        ## 46. DP with 45 variables\n        ## 47. DP with 46 variables\n        ## 48. DP with 47 variables\n        ## 49. DP with 48 variables\n        ## 50. DP with 49 variables\n        ## 51. DP with 50 variables\n        ## 52. DP with 51 variables\n        ## 53. DP with 52 variables\n        ## 54. DP with 53 variables\n        ## 55. DP with 54 variables\n        ## 56. DP with 55 variables\n        ## 57. DP with 56 variables\n        ## 58. DP with 57 variables\n        ## 59. DP with 58 variables\n        ## 60. DP with 59 variables\n        ## 61. DP with 60 variables\n        ## 62. DP with 61 variables\n        ## 63. DP with 62 variables\n        ## 64. DP with 63 variables\n        ## 65. DP with 64 variables\n        ## 66. DP with 65 variables\n        ## 67. DP with 66 variables\n        ## 68. DP with 67 variables\n        ## 69. DP with 68 variables\n        ## 70. DP with 69 variables"}], "combination-sum-ii": [{"task_id": "combination-sum-ii", "completion": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        def backtrack(start, curr, target):\n            if target == 0:\n                res.append(curr[:])\n                return\n            for i in range(start, len(candidates)):\n                if candidates[i] > target:\n                    break\n                if i > start and candidates[i] == candidates[i-1]:\n                    continue\n                curr.append(candidates[i])\n                backtrack(i+1, curr, target-candidates[i])\n                curr.pop()\n        backtrack(0, [], target)\n        return res"}, {"task_id": "combination-sum-ii", "completion": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        def backtrack(start, curr, target):\n            if target == 0:\n                res.append(curr[:])\n                return\n            for i in range(start, len(candidates)):\n                if candidates[i] > target:\n                    break\n                if i > start and candidates[i] == candidates[i-1]:\n                    continue\n                curr.append(candidates[i])\n                backtrack(i+1, curr, target-candidates[i])\n                curr.pop()\n        backtrack(0, [], target)\n        return res"}, {"task_id": "combination-sum-ii", "completion": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        def backtrack(start, curr, target):\n            if target == 0:\n                res.append(curr[:])\n                return\n            for i in range(start, len(candidates)):\n                if candidates[i] > target:\n                    break\n                if i > start and candidates[i] == candidates[i-1]:\n                    continue\n                curr.append(candidates[i])\n                backtrack(i+1, curr, target-candidates[i])\n                curr.pop()\n        backtrack(0, [], target)\n        return res"}, {"task_id": "combination-sum-ii", "completion": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        def backtrack(start, curr, target):\n            if target == 0:\n                res.append(curr[:])\n                return\n            for i in range(start, len(candidates)):\n                if i > start and candidates[i] == candidates[i-1]:\n                    continue\n                if candidates[i] > target:\n                    break\n                curr.append(candidates[i])\n                backtrack(i+1, curr, target-candidates[i])\n                curr.pop()\n        backtrack(0, [], target)\n        return res"}, {"task_id": "combination-sum-ii", "completion": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        def backtrack(start, curr, target):\n            if target == 0:\n                res.append(curr[:])\n                return\n            for i in range(start, len(candidates)):\n                if i > start and candidates[i] == candidates[i-1]:\n                    continue\n                if candidates[i] > target:\n                    break\n                curr.append(candidates[i])\n                backtrack(i+1, curr, target-candidates[i])\n                curr.pop()\n        backtrack(0, [], target)\n        return res"}], "detect-capital": [{"task_id": "detect-capital", "completion": "class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if word.isupper() or word.islower() or word.istitle():\n            return True\n        else:\n            return False"}, {"task_id": "detect-capital", "completion": "class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if word.isupper() or word.islower() or word.istitle():\n            return True\n        else:\n            return False"}, {"task_id": "detect-capital", "completion": "class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if word.isupper() or word.islower() or word.istitle():\n            return True\n        else:\n            return False"}, {"task_id": "detect-capital", "completion": "class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if word.isupper() or word.islower() or word.istitle():\n            return True\n        else:\n            return False"}, {"task_id": "detect-capital", "completion": "class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if word.isupper() or word.islower() or word.istitle():\n            return True\n        else:\n            return False"}], "best-time-to-buy-and-sell-stock": [{"task_id": "best-time-to-buy-and-sell-stock", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Brute force\n        ## Time complexity: O(n^2)\n        ## Space complexity: O(1)\n        ## Runtime: 104 ms, faster than 99.54% of Python online submissions for Best Time to Buy and Sell Stock.\n        ## Memory Usage: 14.4 MB, less than 99.54% of Python online submissions for Best Time to Buy and Sell Stock.\n        ## 2022-09-22\n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ##"}, {"task_id": "best-time-to-buy-and-sell-stock", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Brute force\n        ## Time complexity: O(n^2)\n        ## Space complexity: O(1)\n        ## Runtime: 108 ms, faster than 99.45% of Python online submissions for Best Time to Buy and Sell Stock.\n        ## Memory Usage: 14.5 MB, less than 99.45% of Python online submissions for Best Time to Buy and Sell Stock.\n        ## 2022-09-22\n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ##"}, {"task_id": "best-time-to-buy-and-sell-stock", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Brute force\n        ## Time complexity: O(n^2)\n        ## Space complexity: O(1)\n        ## Runtime: 108 ms, faster than 99.52% of Python online submissions for Best Time to Buy and Sell Stock.\n        ## Memory Usage: 14.3 MB, less than 99.52% of Python online submissions for Best Time to Buy and Sell Stock.\n        ## 2022-09-20\n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ##"}, {"task_id": "best-time-to-buy-and-sell-stock", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Brute force\n        ## Time complexity: O(n^2)\n        ## Space complexity: O(1)\n        ## Runtime: 104 ms, faster than 99.92% of Python online submissions for Best Time to Buy and Sell Stock.\n        ## Memory Usage: 14.4 MB, less than 99.92% of Python online submissions for Best Time to Buy and Sell Stock.\n        ## 2022-09-20\n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ##"}, {"task_id": "best-time-to-buy-and-sell-stock", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Brute force\n        ## Time complexity: O(n^2)\n        ## Space complexity: O(1)\n        ## Runtime: 108 ms, faster than 99.28% of Python online submissions for Best Time to Buy and Sell Stock.\n        ## Memory Usage: 14.4 MB, less than 99.28% of Python online submissions for Best Time to Buy and Sell Stock.\n        ## 2022-09-22\n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ## \n        ##"}], "binary-tree-inorder-traversal": [{"task_id": "binary-tree-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = []\n        res = []\n        curr = root\n        \n        while curr is not None or len(stack) > 0:\n            if curr is not None:\n                stack.append(curr)\n                curr = curr.left\n            else:\n                curr = stack.pop()\n                res.append(curr.val)\n                curr = curr.right\n        \n        return res"}, {"task_id": "binary-tree-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = []\n        result = []\n        while root or stack:\n            while root:\n                stack.append(root)\n                root = root.left\n            root = stack.pop()\n            result.append(root.val)\n            root = root.right\n        return result"}, {"task_id": "binary-tree-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = []\n        res = []\n        curr = root\n        \n        while curr or stack:\n            if curr:\n                stack.append(curr)\n                curr = curr.left\n            else:\n                curr = stack.pop()\n                res.append(curr.val)\n                curr = curr.right\n                \n        return res"}, {"task_id": "binary-tree-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = []\n        res = []\n        curr = root\n        \n        while curr is not None or len(stack) > 0:\n            if curr is not None:\n                stack.append(curr)\n                curr = curr.left\n            else:\n                curr = stack.pop()\n                res.append(curr.val)\n                curr = curr.right\n                \n        return res"}, {"task_id": "binary-tree-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = []\n        res = []\n        curr = root\n        \n        while curr is not None or len(stack) > 0:\n            if curr is not None:\n                stack.append(curr)\n                curr = curr.left\n            else:\n                curr = stack.pop()\n                res.append(curr.val)\n                curr = curr.right\n        \n        return res"}], "construct-binary-tree-from-preorder-and-inorder-traversal": [{"task_id": "construct-binary-tree-from-preorder-and-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not preorder:\n            return None\n        \n        root = TreeNode(preorder[0])\n        idx = inorder.index(preorder[0])\n        \n        root.left = self.buildTree(preorder[1:idx+1], inorder[:idx])\n        root.right = self.buildTree(preorder[idx+1:], inorder[idx+1:])\n        \n        return root"}, {"task_id": "construct-binary-tree-from-preorder-and-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if len(preorder) == 0:\n            return None\n        \n        root = TreeNode(preorder[0])\n        mid = inorder.index(preorder[0])\n        root.left = self.buildTree(preorder[1:mid+1], inorder[:mid])\n        root.right = self.buildTree(preorder[mid+1:], inorder[mid+1:])\n        return root"}, {"task_id": "construct-binary-tree-from-preorder-and-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if len(preorder) == 0:\n            return None\n        \n        root = TreeNode(preorder[0])\n        mid = inorder.index(preorder[0])\n        \n        root.left = self.buildTree(preorder[1:mid+1], inorder[:mid])\n        root.right = self.buildTree(preorder[mid+1:], inorder[mid+1:])\n        \n        return root"}, {"task_id": "construct-binary-tree-from-preorder-and-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if len(preorder) == 0:\n            return None\n        \n        root = TreeNode(preorder[0])\n        mid = inorder.index(preorder[0])\n        \n        root.left = self.buildTree(preorder[1:mid+1], inorder[:mid])\n        root.right = self.buildTree(preorder[mid+1:], inorder[mid+1:])\n        \n        return root"}, {"task_id": "construct-binary-tree-from-preorder-and-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not preorder:\n            return None\n        \n        root = TreeNode(preorder[0])\n        mid = inorder.index(preorder[0])\n        \n        root.left = self.buildTree(preorder[1:mid+1], inorder[:mid])\n        root.right = self.buildTree(preorder[mid+1:], inorder[mid+1:])\n        \n        return root"}], "remove-invalid-parentheses": [{"task_id": "remove-invalid-parentheses", "completion": "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        \n        def isValid(s):\n            count = 0\n            for c in s:\n                if c == '(':\n                    count += 1\n                elif c == ')':\n                    if count > 0:\n                        count -= 1\n                    else:\n                        return False\n            return count == 0\n        \n        queue = collections.deque([s])\n        seen = set([s])\n        while queue:\n            s = queue.popleft()\n            if isValid(s):\n                return [s]\n            for i in range(len(s)):\n                if s[i] not in '()':\n                    continue\n                t = s[:i] + s[i+1:]\n                if t not in seen:\n                    queue.append(t)\n                    seen.add(t)\n        return []"}, {"task_id": "remove-invalid-parentheses", "completion": "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        \n        def isValid(s):\n            count = 0\n            for c in s:\n                if c == '(':\n                    count += 1\n                elif c == ')':\n                    if count > 0:\n                        count -= 1\n                    else:\n                        return False\n            return count == 0\n        \n        def dfs(s, left, right, path, res):\n            if left == 0 and right == 0:\n                if isValid(path):\n                    res.append(path)\n                return\n            for i in range(len(s)):\n                if i > 0 and s[i] == s[i-1]:\n                    continue\n                if s[i] == '(' or s[i] == ')':\n                    if left > 0 and s[i] == '(':\n                        dfs(s[:i] + s[i+1:], left-1, right, path + s[i], res)\n                    elif right > 0 and s[i] == ')':\n                        dfs(s[:i] + s[i+1:], left, right-1, path + s[i], res)\n        \n        res = []\n        dfs(s, 0, 0, '', res)\n        return res"}, {"task_id": "remove-invalid-parentheses", "completion": "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        \n        def isValid(s):\n            count = 0\n            for c in s:\n                if c == '(':\n                    count += 1\n                elif c == ')':\n                    if count > 0:\n                        count -= 1\n                    else:\n                        return False\n            return count == 0\n        \n        def dfs(s, left, right, path, res):\n            if left == 0 and right == 0:\n                if isValid(path):\n                    res.append(path)\n                return\n            for i in range(len(s)):\n                if i > 0 and s[i] == s[i-1]:\n                    continue\n                if s[i] == '(' or s[i] == ')':\n                    if left > 0 and s[i] == '(':\n                        dfs(s[:i] + s[i+1:], left-1, right, path + s[i], res)\n                    elif right > 0 and s[i] == ')':\n                        dfs(s[:i] + s[i+1:], left, right-1, path + s[i], res)\n        \n        res = []\n        dfs(s, 0, 0, \"\", res)\n        return res"}, {"task_id": "remove-invalid-parentheses", "completion": "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        \n        def isValid(s):\n            count = 0\n            for c in s:\n                if c == '(':\n                    count += 1\n                elif c == ')':\n                    if count > 0:\n                        count -= 1\n                    else:\n                        return False\n            return count == 0\n        \n        def dfs(s, left, right, path, res):\n            if left == 0 and right == 0:\n                if isValid(path):\n                    res.append(path)\n                return\n            for i in range(len(s)):\n                if i > 0 and s[i] == s[i-1]:\n                    continue\n                if s[i] == '(' or s[i] == ')':\n                    if left > 0 and s[i] == '(':\n                        dfs(s[:i] + s[i+1:], left - 1, right, path + s[i], res)\n                    elif right > 0 and s[i] == ')':\n                        dfs(s[:i] + s[i+1:], left, right - 1, path + s[i], res)\n        \n        res = []\n        dfs(s, 0, 0, '', res)\n        return res"}, {"task_id": "remove-invalid-parentheses", "completion": "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        \n        def isValid(s):\n            count = 0\n            for c in s:\n                if c == '(':\n                    count += 1\n                elif c == ')':\n                    if count > 0:\n                        count -= 1\n                    else:\n                        return False\n            return count == 0\n        \n        def dfs(s, left, right, path, res):\n            if left == 0 and right == 0:\n                if isValid(path):\n                    res.append(path)\n                return\n            for i in range(len(s)):\n                if i > 0 and s[i] == s[i-1]:\n                    continue\n                if s[i] == '(' or s[i] == ')':\n                    if left > 0 and s[i] == '(':\n                        dfs(s[:i] + s[i+1:], left - 1, right, path + s[i], res)\n                    elif right > 0 and s[i] == ')':\n                        dfs(s[:i] + s[i+1:], left, right - 1, path + s[i], res)\n        \n        res = []\n        dfs(s, 0, 0, '', res)\n        return res"}], "merge-k-sorted-lists": [{"task_id": "merge-k-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        \n        if len(lists) == 0:\n            return None\n        \n        if len(lists) == 1:\n            return lists[0]\n        \n        if len(lists) == 2:\n            return self.mergeTwoLists(lists[0], lists[1])\n        \n        mid = len(lists) // 2\n        \n        left = self.mergeKLists(lists[:mid])\n        right = self.mergeKLists(lists[mid:])\n        \n        return self.mergeTwoLists(left, right)\n        \n    def mergeTwoLists(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if l1 == None:\n            return l2\n        \n        if l2 == None:\n            return l1\n        \n        if l1.val < l2.val:\n            l1.next = self.mergeTwoLists(l1.next, l2)\n            return l1\n        else:\n            l2.next = self.mergeTwoLists(l1, l2.next)\n            return l2"}, {"task_id": "merge-k-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        \n        def merge(l1, l2):\n            if not l1:\n                return l2\n            if not l2:\n                return l1\n            if l1.val < l2.val:\n                l1.next = merge(l1.next, l2)\n                return l1\n            else:\n                l2.next = merge(l1, l2.next)\n                return l2\n        \n        if not lists:\n            return None\n        if len(lists) == 1:\n            return lists[0]\n        if len(lists) == 2:\n            return merge(lists[0], lists[1])\n        if len(lists) == 3:\n            return merge(merge(lists[0], lists[1]), lists[2])\n        if len(lists) == 4:\n            return merge(merge(lists[0], lists[1]), merge(lists[2], lists[3]))\n        if len(lists) == 5:\n            return merge(merge(lists[0], lists[1]), merge(lists[2], merge(lists[3], lists[4])))\n        if len(lists) == 6:\n            return merge(merge(lists[0], lists[1]), merge(lists[2], merge(lists[3], lists[4])))\n        if len(lists) == 7:\n            return merge(merge(lists[0], lists[1]), merge(lists[2], merge(lists[3], lists[4])))\n        if len(lists) == 8:\n            return merge(merge(lists[0], lists[1]), merge(lists[2], merge(lists[3], lists[4])))\n        if len(lists) == 9:\n            return merge(merge(lists[0], lists[1]), merge(lists[2], merge(lists[3], lists[4])))\n        if len(lists) == 10:\n            return merge(merge(lists[0], lists[1]), merge(lists[2], merge(lists[3], lists[4])))\n        if len(lists) == 11:\n            return merge(merge(lists[0], lists[1]), merge(lists[2], merge(lists[3], lists[4])))\n        if len(lists) == 12:\n            return merge(merge(lists[0], lists[1]), merge(lists[2], merge(lists[3], lists[4])))\n        if len(lists) == 13:\n            return merge(merge(lists[0], lists[1]), merge(lists[2], merge(lists[3], lists[4])))\n        if len(lists) == 14:\n            return merge(merge(lists[0], lists[1]), merge(lists[2], merge(lists[3], lists[4])))\n        if len(lists) == 15:\n            return merge(merge(lists[0], lists[1]), merge(lists[2], merge(lists[3], lists[4])))\n        if len(lists) == 16:\n            return merge(merge(lists[0], lists[1]), merge(lists[2], merge(lists[3], lists[4])))\n        if len(lists) == 17:\n            return merge(merge(lists[0], lists[1]), merge(lists[2], merge(lists[3], lists[4])))\n        if len(lists) == 18:\n            return merge(merge(lists[0], lists[1]), merge(lists[2], merge(lists[3], lists[4])))\n        if len(lists) == 19:\n            return merge(merge(lists[0], lists[1]), merge(lists[2], merge(lists[3], lists[4])))\n        if len(lists) == 20:\n            return merge(merge(lists[0], lists[1]), merge(lists[2], merge(lists[3], lists[4])))\n        if len(lists) == 21:\n            return merge(merge(lists[0], lists[1]), merge(lists[2], merge(lists[3], lists[4])))\n        if len(lists) == 22:\n            return merge(merge(lists[0], lists[1]), merge(lists[2], merge(lists[3], lists[4])))\n        if len(lists) == 23:\n            return merge(merge(lists[0], lists["}, {"task_id": "merge-k-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        \n        def merge(l1, l2):\n            if not l1:\n                return l2\n            if not l2:\n                return l1\n            if l1.val < l2.val:\n                l1.next = merge(l1.next, l2)\n                return l1\n            else:\n                l2.next = merge(l1, l2.next)\n                return l2\n        \n        if not lists:\n            return None\n        if len(lists) == 1:\n            return lists[0]\n        if len(lists) == 2:\n            return merge(lists[0], lists[1])\n        if len(lists) == 3:\n            return merge(merge(lists[0], lists[1]), lists[2])\n        if len(lists) == 4:\n            return merge(merge(lists[0], lists[1]), merge(lists[2], lists[3]))\n        if len(lists) == 5:\n            return merge(merge(lists[0], lists[1]), merge(lists[2], merge(lists[3], lists[4])))\n        if len(lists) == 6:\n            return merge(merge(lists[0], lists[1]), merge(lists[2], merge(lists[3], lists[4])))\n        if len(lists) == 7:\n            return merge(merge(lists[0], lists[1]), merge(lists[2], merge(lists[3], lists[4])))\n        if len(lists) == 8:\n            return merge(merge(lists[0], lists[1]), merge(lists[2], merge(lists[3], lists[4])))\n        if len(lists) == 9:\n            return merge(merge(lists[0], lists[1]), merge(lists[2], merge(lists[3], lists[4])))\n        if len(lists) == 10:\n            return merge(merge(lists[0], lists[1]), merge(lists[2], merge(lists[3], lists[4])))\n        if len(lists) == 11:\n            return merge(merge(lists[0], lists[1]), merge(lists[2], merge(lists[3], lists[4])))\n        if len(lists) == 12:\n            return merge(merge(lists[0], lists[1]), merge(lists[2], merge(lists[3], lists[4])))\n        if len(lists) == 13:\n            return merge(merge(lists[0], lists[1]), merge(lists[2], merge(lists[3], lists[4])))\n        if len(lists) == 14:\n            return merge(merge(lists[0], lists[1]), merge(lists[2], merge(lists[3], lists[4])))\n        if len(lists) == 15:\n            return merge(merge(lists[0], lists[1]), merge(lists[2], merge(lists[3], lists[4])))\n        if len(lists) == 16:\n            return merge(merge(lists[0], lists[1]), merge(lists[2], merge(lists[3], lists[4])))\n        if len(lists) == 17:\n            return merge(merge(lists[0], lists[1]), merge(lists[2], merge(lists[3], lists[4])))\n        if len(lists) == 18:\n            return merge(merge(lists[0], lists[1]), merge(lists[2], merge(lists[3], lists[4])))\n        if len(lists) == 19:\n            return merge(merge(lists[0], lists[1]), merge(lists[2], merge(lists[3], lists[4])))\n        if len(lists) == 20:\n            return merge(merge(lists[0], lists[1]), merge(lists[2], merge(lists[3], lists[4])))\n        if len(lists) == 21:\n            return merge(merge(lists[0], lists[1]), merge(lists[2], merge(lists[3], lists[4])))\n        if len(lists) == 22:\n            return merge(merge(lists[0], lists[1]), merge(lists[2], merge(lists[3], lists[4])))\n        if len(lists) == 23:\n            return merge(merge(lists[0], lists["}, {"task_id": "merge-k-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        \n        if len(lists) == 0:\n            return None\n        \n        if len(lists) == 1:\n            return lists[0]\n        \n        if len(lists) == 2:\n            return self.mergeTwoLists(lists[0], lists[1])\n        \n        mid = len(lists) // 2\n        \n        left = self.mergeKLists(lists[:mid])\n        right = self.mergeKLists(lists[mid:])\n        \n        return self.mergeTwoLists(left, right)\n        \n    def mergeTwoLists(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if l1 == None:\n            return l2\n        \n        if l2 == None:\n            return l1\n        \n        if l1.val < l2.val:\n            l1.next = self.mergeTwoLists(l1.next, l2)\n            return l1\n        else:\n            l2.next = self.mergeTwoLists(l1, l2.next)\n            return l2"}, {"task_id": "merge-k-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        \n        if len(lists) == 0:\n            return None\n        \n        if len(lists) == 1:\n            return lists[0]\n        \n        if len(lists) == 2:\n            return self.mergeTwoLists(lists[0], lists[1])\n        \n        mid = len(lists) // 2\n        \n        left = self.mergeKLists(lists[:mid])\n        right = self.mergeKLists(lists[mid:])\n        \n        return self.mergeTwoLists(left, right)\n        \n    def mergeTwoLists(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if l1 == None:\n            return l2\n        \n        if l2 == None:\n            return l1\n        \n        if l1.val < l2.val:\n            l1.next = self.mergeTwoLists(l1.next, l2)\n            return l1\n        else:\n            l2.next = self.mergeTwoLists(l1, l2.next)\n            return l2"}], "palindrome-partitioning-ii": [{"task_id": "palindrome-partitioning-ii", "completion": "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}, {"task_id": "palindrome-partitioning-ii", "completion": "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}, {"task_id": "palindrome-partitioning-ii", "completion": "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}, {"task_id": "palindrome-partitioning-ii", "completion": "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}, {"task_id": "palindrome-partitioning-ii", "completion": "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "preimage-size-of-factorial-zeroes-function": [{"task_id": "preimage-size-of-factorial-zeroes-function", "completion": "class Solution(object):\n    def preimageSizeFZF(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def f(x):\n            return x / 5 + x / 25 + x / 125 + x / 625 + x / 3125\n        \n        lo, hi = 0, 10**10\n        while lo < hi:\n            mid = (lo + hi) / 2\n            if f(mid) < k:\n                lo = mid + 1\n            else:\n                hi = mid\n        return lo - k"}, {"task_id": "preimage-size-of-factorial-zeroes-function", "completion": "class Solution(object):\n    def preimageSizeFZF(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def f(x):\n            return x / 5 + x / 25 + x / 125 + x / 625 + x / 3125\n        \n        lo, hi = 0, 10**10\n        while lo < hi:\n            mid = (lo + hi) / 2\n            if f(mid) < k:\n                lo = mid + 1\n            else:\n                hi = mid\n        return lo - k"}, {"task_id": "preimage-size-of-factorial-zeroes-function", "completion": "class Solution(object):\n    def preimageSizeFZF(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def f(x):\n            return x/5 + x/25 + x/125 + x/625 + x/3125 + x/15625 + x/78125 + x/390625 + x/1953125 + x/9765625 + x/48828125\n        \n        l, r = 0, 10**10\n        while l < r:\n            m = (l + r) / 2\n            if f(m) < k:\n                l = m + 1\n            else:\n                r = m\n        return l - k"}, {"task_id": "preimage-size-of-factorial-zeroes-function", "completion": "class Solution(object):\n    def preimageSizeFZF(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def f(x):\n            return x / 5 + x / 25 + x / 125 + x / 625 + x / 3125\n        \n        l, r = 0, 10**10\n        while l < r:\n            m = (l + r) / 2\n            if f(m) < k:\n                l = m + 1\n            else:\n                r = m\n        return l - k"}, {"task_id": "preimage-size-of-factorial-zeroes-function", "completion": "class Solution(object):\n    def preimageSizeFZF(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def f(x):\n            return x/5 + x/25 + x/125 + x/625 + x/3125 + x/15625 + x/78125 + x/390625 + x/1953125 + x/9765625 + x/48828125\n        \n        l, r = 0, 10**10\n        while l < r:\n            m = (l + r) / 2\n            if f(m) < k:\n                l = m + 1\n            else:\n                r = m\n        return l - k"}], "palindrome-pairs": [{"task_id": "palindrome-pairs", "completion": "class Solution(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        def getPairs(words):\n            pairs = []\n            for i in range(len(words)):\n                for j in range(len(words)):\n                    if i != j and isPalindrome(words[i] + words[j]):\n                        pairs.append([i, j])\n            return pairs\n        \n        return getPairs(words)"}, {"task_id": "palindrome-pairs", "completion": "class Solution(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        res = []\n        for i in range(len(words)):\n            for j in range(len(words)):\n                if i != j and isPalindrome(words[i] + words[j]):\n                    res.append([i,j])\n        return res"}, {"task_id": "palindrome-pairs", "completion": "class Solution(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        res = []\n        for i in range(len(words)):\n            for j in range(len(words)):\n                if i != j and isPalindrome(words[i] + words[j]):\n                    res.append([i,j])\n        return res"}, {"task_id": "palindrome-pairs", "completion": "class Solution(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        def getPairs(words):\n            pairs = []\n            for i in range(len(words)):\n                for j in range(len(words)):\n                    if i != j and isPalindrome(words[i] + words[j]):\n                        pairs.append([i, j])\n            return pairs\n        \n        return getPairs(words)"}, {"task_id": "palindrome-pairs", "completion": "class Solution(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def isPalindrome(word):\n            return word == word[::-1]\n        \n        def getPairs(word):\n            pairs = []\n            for i in range(len(word)):\n                if isPalindrome(word[i:]):\n                    pairs.append(len(word) - i - 1)\n                if i and isPalindrome(word[:i]):\n                    pairs.append(i - 1)\n            return pairs\n        \n        return [pairs for word in words for pairs in getPairs(word)]"}], "convert-sorted-array-to-binary-search-tree": [{"task_id": "convert-sorted-array-to-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        def helper(left, right):\n            if left > right:\n                return None\n            \n            mid = (left + right) // 2\n            root = TreeNode(nums[mid])\n            root.left = helper(left, mid - 1)\n            root.right = helper(mid + 1, right)\n            return root\n        \n        return helper(0, len(nums) - 1)"}, {"task_id": "convert-sorted-array-to-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        def helper(left, right):\n            if left > right:\n                return None\n            \n            mid = (left + right) // 2\n            root = TreeNode(nums[mid])\n            root.left = helper(left, mid - 1)\n            root.right = helper(mid + 1, right)\n            return root\n        \n        return helper(0, len(nums) - 1)"}, {"task_id": "convert-sorted-array-to-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        def helper(left, right):\n            if left > right:\n                return None\n            \n            mid = (left + right) // 2\n            root = TreeNode(nums[mid])\n            root.left = helper(left, mid - 1)\n            root.right = helper(mid + 1, right)\n            return root\n        \n        return helper(0, len(nums) - 1)"}, {"task_id": "convert-sorted-array-to-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        def helper(left, right):\n            if left > right:\n                return None\n            \n            mid = (left + right) // 2\n            root = TreeNode(nums[mid])\n            root.left = helper(left, mid - 1)\n            root.right = helper(mid + 1, right)\n            return root\n        \n        return helper(0, len(nums) - 1)"}, {"task_id": "convert-sorted-array-to-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        def helper(left, right):\n            if left > right:\n                return None\n            \n            mid = (left + right) // 2\n            root = TreeNode(nums[mid])\n            root.left = helper(left, mid - 1)\n            root.right = helper(mid + 1, right)\n            return root\n        \n        return helper(0, len(nums) - 1)"}], "contain-virus": [{"task_id": "contain-virus", "completion": "class Solution(object):\n    def containVirus(self, isInfected):\n        \"\"\"\n        :type isInfected: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def spread(isInfected, i, j):\n            if i < 0 or i >= len(isInfected) or j < 0 or j >= len(isInfected[0]):\n                return\n            if isInfected[i][j] == 1:\n                return\n            isInfected[i][j] = 1\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                spread(isInfected, i + di, j + dj)\n        \n        def build_walls(isInfected):\n            walls = 0\n            while True:\n                infected = set()\n                for i in range(len(isInfected)):\n                    for j in range(len(isInfected[0])):\n                        if isInfected[i][j] == 1:\n                            spread(isInfected, i, j)\n                            infected.add((i, j))\n                if len(infected) == 0:\n                    break\n                walls += 1\n                for i, j in infected:\n                    isInfected[i][j] = 0\n            return walls\n        \n        return build_walls(isInfected)"}, {"task_id": "contain-virus", "completion": "class Solution(object):\n    def containVirus(self, isInfected):\n        \"\"\"\n        :type isInfected: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def spread(isInfected):\n            m, n = len(isInfected), len(isInfected[0])\n            res = 0\n            while True:\n                infected = set()\n                for i in range(m):\n                    for j in range(n):\n                        if isInfected[i][j] == 1:\n                            infected.add((i, j))\n                if not infected:\n                    break\n                for i, j in infected:\n                    isInfected[i][j] = 2\n                for i in range(m):\n                    for j in range(n):\n                        if isInfected[i][j] == 1:\n                            for ni, nj in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]:\n                                if 0 <= ni < m and 0 <= nj < n and isInfected[ni][nj] == 0:\n                                    isInfected[ni][nj] = 1\n                res += 1\n            return res\n        \n        return spread(isInfected) + spread(list(zip(*isInfected)))"}, {"task_id": "contain-virus", "completion": "class Solution(object):\n    def containVirus(self, isInfected):\n        \"\"\"\n        :type isInfected: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def spread(isInfected, r, c):\n            q = deque([(r, c)])\n            while q:\n                r, c = q.popleft()\n                for nr, nc in [(r-1, c), (r+1, c), (r, c-1), (r, c+1)]:\n                    if 0 <= nr < len(isInfected) and 0 <= nc < len(isInfected[0]) and isInfected[nr][nc] == 0:\n                        isInfected[nr][nc] = 2\n                        q.append((nr, nc))\n        \n        def build(isInfected, r, c):\n            q = deque([(r, c)])\n            while q:\n                r, c = q.popleft()\n                for nr, nc in [(r-1, c), (r+1, c), (r, c-1), (r, c+1)]:\n                    if 0 <= nr < len(isInfected) and 0 <= nc < len(isInfected[0]) and isInfected[nr][nc] == 0:\n                        isInfected[nr][nc] = 1\n                        q.append((nr, nc))\n        \n        def infect(isInfected, r, c):\n            q = deque([(r, c)])\n            while q:\n                r, c = q.popleft()\n                for nr, nc in [(r-1, c), (r+1, c), (r, c-1), (r, c+1)]:\n                    if 0 <= nr < len(isInfected) and 0 <= nc < len(isInfected[0]) and isInfected[nr][nc] == 0:\n                        isInfected[nr][nc] = 2\n                        q.append((nr, nc))\n        \n        def count(isInfected):\n            count = 0\n            for r in range(len(isInfected)):\n                for c in range(len(isInfected[0])):\n                    if isInfected[r][c] == 2:\n                        count += 1\n            return count\n        \n        def spread_all(isInfected):\n            count = 0\n            for r in range(len(isInfected)):\n                for c in range(len(isInfected[0])):\n                    if isInfected[r][c] == 1:\n                        spread(isInfected, r, c)\n                        count += 1\n            return count\n        \n        def build_all(isInfected):\n            count = 0\n            for r in range(len(isInfected)):\n                for c in range(len(isInfected[0])):\n                    if isInfected[r][c] == 2:\n                        build(isInfected, r, c)\n                        count += 1\n            return count\n        \n        def infect_all(isInfected):\n            count = 0\n            for r in range(len(isInfected)):\n                for c in range(len(isInfected[0])):\n                    if isInfected[r][c] == 1:\n                        infect(isInfected, r, c)\n                        count += 1\n            return count\n        \n        count = 0\n        while True:\n            count += spread_all(isInfected)\n            count += build_all(isInfected)\n            count += infect_all(isInfected)\n            if count == spread_all(isInfected) + build_all(isInfected) + infect_all(isInfected):\n                break\n        return count"}, {"task_id": "contain-virus", "completion": "class Solution(object):\n    def containVirus(self, isInfected):\n        \"\"\"\n        :type isInfected: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def spread(isInfected, i, j):\n            if i < 0 or i >= len(isInfected) or j < 0 or j >= len(isInfected[0]):\n                return\n            if isInfected[i][j] == 1:\n                return\n            isInfected[i][j] = 1\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                spread(isInfected, i + di, j + dj)\n        \n        def build_walls(isInfected):\n            walls = 0\n            while True:\n                infected = set()\n                for i in range(len(isInfected)):\n                    for j in range(len(isInfected[0])):\n                        if isInfected[i][j] == 1:\n                            infected.add((i, j))\n                if not infected:\n                    break\n                for i, j in infected:\n                    spread(isInfected, i, j)\n                walls += 1\n            return walls\n        \n        return build_walls(isInfected)"}, {"task_id": "contain-virus", "completion": "class Solution(object):\n    def containVirus(self, isInfected):\n        \"\"\"\n        :type isInfected: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def spread(isInfected):\n            m, n = len(isInfected), len(isInfected[0])\n            res = 0\n            while True:\n                infected = set()\n                for i in range(m):\n                    for j in range(n):\n                        if isInfected[i][j] == 1:\n                            infected.add((i, j))\n                if not infected:\n                    break\n                for i, j in infected:\n                    isInfected[i][j] = 2\n                for i in range(m):\n                    for j in range(n):\n                        if isInfected[i][j] == 1:\n                            for ni, nj in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]:\n                                if 0 <= ni < m and 0 <= nj < n and isInfected[ni][nj] == 0:\n                                    isInfected[ni][nj] = 1\n                res += 1\n            return res\n        \n        return spread(isInfected) + spread(list(zip(*isInfected)))"}], "longest-increasing-path-in-a-matrix": [{"task_id": "longest-increasing-path-in-a-matrix", "completion": "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        dp = [[0] * n for _ in range(m)]\n        max_len = 0\n        \n        def dfs(i, j):\n            if dp[i][j]:\n                return dp[i][j]\n            \n            for x, y in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= x < m and 0 <= y < n and matrix[x][y] > matrix[i][j]:\n                    dp[i][j] = max(dp[i][j], dfs(x, y) + 1)\n            \n            dp[i][j] += 1\n            return dp[i][j]\n        \n        for i in range(m):\n            for j in range(n):\n                max_len = max(max_len, dfs(i, j))\n        \n        return max_len"}, {"task_id": "longest-increasing-path-in-a-matrix", "completion": "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        dp = [[0] * n for _ in range(m)]\n        max_len = 0\n        \n        def dfs(i, j):\n            if dp[i][j]:\n                return dp[i][j]\n            \n            for x, y in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= x < m and 0 <= y < n and matrix[x][y] > matrix[i][j]:\n                    dp[i][j] = max(dp[i][j], dfs(x, y) + 1)\n            \n            dp[i][j] += 1\n            return dp[i][j]\n        \n        for i in range(m):\n            for j in range(n):\n                max_len = max(max_len, dfs(i, j))\n        \n        return max_len"}, {"task_id": "longest-increasing-path-in-a-matrix", "completion": "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        dp = [[0] * n for _ in range(m)]\n        max_len = 0\n        \n        for i in range(m):\n            for j in range(n):\n                max_len = max(max_len, self.dfs(matrix, dp, i, j))\n        \n        return max_len\n    \n    def dfs(self, matrix, dp, i, j):\n        if dp[i][j]:\n            return dp[i][j]\n        \n        m, n = len(matrix), len(matrix[0])\n        max_len = 1\n        \n        for di, dj in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n            ni, nj = i + di, j + dj\n            if 0 <= ni < m and 0 <= nj < n and matrix[ni][nj] > matrix[i][j]:\n                max_len = max(max_len, 1 + self.dfs(matrix, dp, ni, nj))\n        \n        dp[i][j] = max_len\n        return max_len"}, {"task_id": "longest-increasing-path-in-a-matrix", "completion": "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        dp = [[0] * n for _ in range(m)]\n        max_len = 0\n        \n        def dfs(i, j):\n            if dp[i][j]:\n                return dp[i][j]\n            \n            for x, y in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= x < m and 0 <= y < n and matrix[x][y] > matrix[i][j]:\n                    dp[i][j] = max(dp[i][j], dfs(x, y) + 1)\n            \n            dp[i][j] += 1\n            return dp[i][j]\n        \n        for i in range(m):\n            for j in range(n):\n                max_len = max(max_len, dfs(i, j))\n        \n        return max_len"}, {"task_id": "longest-increasing-path-in-a-matrix", "completion": "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        dp = [[0] * n for _ in range(m)]\n        max_len = 0\n        \n        def dfs(i, j):\n            if dp[i][j]:\n                return dp[i][j]\n            \n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                ni, nj = i + di, j + dj\n                if 0 <= ni < m and 0 <= nj < n and matrix[ni][nj] > matrix[i][j]:\n                    dp[i][j] = max(dp[i][j], dfs(ni, nj))\n            \n            dp[i][j] += 1\n            return dp[i][j]\n        \n        for i in range(m):\n            for j in range(n):\n                max_len = max(max_len, dfs(i, j))\n        \n        return max_len"}], "number-of-digit-one": [{"task_id": "number-of-digit-one", "completion": "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}, {"task_id": "number-of-digit-one", "completion": "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}, {"task_id": "number-of-digit-one", "completion": "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}, {"task_id": "number-of-digit-one", "completion": "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}, {"task_id": "number-of-digit-one", "completion": "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}], "word-break-ii": [{"task_id": "word-break-ii", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # create a list of all the words in the dictionary\n        word_list = []\n        for word in wordDict:\n            word_list.append(word)\n        \n        # create a list of all the words in the dictionary\n        word_list = list(set(word_list))\n        \n        # create a list of all the words in the dictionary\n        word_list = list(set(word_list))\n        \n        # create a list of all the words in the dictionary\n        word_list = list(set(word_list))\n        \n        # create a list of all the words in the dictionary\n        word_list = list(set(word_list))\n        \n        # create a list of all the words in the dictionary\n        word_list = list(set(word_list))\n        \n        # create a list of all the words in the dictionary\n        word_list = list(set(word_list))\n        \n        # create a list of all the words in the dictionary\n        word_list = list(set(word_list))\n        \n        # create a list of all the words in the dictionary\n        word_list = list(set(word_list))\n        \n        # create a list of all the words in the dictionary\n        word_list = list(set(word_list))\n        \n        # create a list of all the words in the dictionary\n        word_list = list(set(word_list))\n        \n        # create a list of all the words in the dictionary\n        word_list = list(set(word_list))\n        \n        # create a list of all the words in the dictionary\n        word_list = list(set(word_list))\n        \n        # create a list of all the words in the dictionary\n        word_list = list(set(word_list))\n        \n        # create a list of all the words in the dictionary\n        word_list = list(set(word_list))\n        \n        # create a list of all the words in the dictionary\n        word_list = list(set(word_list))\n        \n        # create a list of all the words in the dictionary\n        word_list = list(set(word_list))\n        \n        # create a list of all the words in the dictionary\n        word_list = list(set(word_list))\n        \n        # create a list of all the words in the dictionary\n        word_list = list(set(word_list))\n        \n        # create a list of all the words in the dictionary\n        word_list = list(set(word_list))\n        \n        # create a list of all the words in the dictionary\n        word_list = list(set(word_list))\n        \n        # create a list of all the words in the dictionary\n        word_list = list(set(word_list))\n        \n        # create a list of all the words in the dictionary\n        word_list = list(set(word_list))\n        \n        # create a list of all the words in the dictionary\n        word_list = list(set(word_list))\n        \n        # create a list of all the words in the dictionary\n        word_list = list(set(word_list))\n        \n        # create a list of all the words in the dictionary\n        word_list = list(set(word_list))\n        \n        # create a list of all the words in the dictionary\n        word_list = list(set(word_list))\n        \n        # create a list of all the words in the dictionary\n        word_list = list(set(word_list))\n        \n        # create a list of all the words in the dictionary\n        word_list = list(set(word_list))\n        \n        # create a list of all the words in the dictionary\n        word_list = list(set(word_list))\n        \n        # create a list of all the words in the dictionary\n        word_list = list(set(word_list))\n        \n        # create a list of all the words in the dictionary\n        word_list = list(set(word_list))\n        \n        # create a list of all the words in the dictionary\n        word_list = list(set(word_list))\n        \n        # create a list of all the words in the dictionary\n        word_list = list(set(word_list))\n        \n        # create a list of all the words in the dictionary\n        word_list = list(set(word_list))"}, {"task_id": "word-break-ii", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        dp = [False] * (len(s) + 1)\n        dp[0] = True\n        \n        for i in range(1, len(s) + 1):\n            for j in range(i):\n                if dp[j] and s[j:i] in wordDict:\n                    dp[i] = True\n                    break\n        \n        # If dp[len(s)] is True, then we have found a valid word break.\n        # We will use the dp array to construct the answer.\n        if dp[len(s)]:\n            ans = []\n            self.dfs(s, wordDict, 0, [], ans)\n            return ans\n        else:\n            return []\n        \n    def dfs(self, s, wordDict, start, path, ans):\n        if start == len(s):\n            ans.append(' '.join(path))\n            return\n        \n        for end in range(start + 1, len(s) + 1):\n            if s[start:end] in wordDict:\n                path.append(s[start:end])\n                self.dfs(s, wordDict, end, path, ans)\n                path.pop()"}, {"task_id": "word-break-ii", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # create a list of all the words in the dictionary\n        word_list = []\n        for word in wordDict:\n            word_list.append(word)\n        \n        # create a list of all the words in the string\n        word_list_s = []\n        for word in s.split(' '):\n            word_list_s.append(word)\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict = []\n        for word in word_list_s:\n            if word in word_list:\n                word_list_s_in_dict.append(word)\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict_2 = []\n        for word in word_list_s_in_dict:\n            if word not in word_list_s_in_dict_2:\n                word_list_s_in_dict_2.append(word)\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict_3 = []\n        for word in word_list_s_in_dict_2:\n            if word not in word_list_s_in_dict_3:\n                word_list_s_in_dict_3.append(word)\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict_4 = []\n        for word in word_list_s_in_dict_3:\n            if word not in word_list_s_in_dict_4:\n                word_list_s_in_dict_4.append(word)\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict_5 = []\n        for word in word_list_s_in_dict_4:\n            if word not in word_list_s_in_dict_5:\n                word_list_s_in_dict_5.append(word)\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict_6 = []\n        for word in word_list_s_in_dict_5:\n            if word not in word_list_s_in_dict_6:\n                word_list_s_in_dict_6.append(word)\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict_7 = []\n        for word in word_list_s_in_dict_6:\n            if word not in word_list_s_in_dict_7:\n                word_list_s_in_dict_7.append(word)\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict_8 = []\n        for word in word_list_s_in_dict_7:\n            if word not in word_list_s_in_dict_8:\n                word_list_s_in_dict_8.append(word)\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict_9 = []\n        for word in word_list_s_in_dict_8:\n            if word not in word_list_s_in_dict_9:\n                word_list_s_in_dict_9.append(word)\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict_10 = []\n        for word in word_list_s_in_dict_9:\n            if word not in word_list_s_in_dict_10:\n                word_list_s_in_dict_10.append(word)\n        \n        # create a list of all the words in the string that are in the dictionary\n        word_list_s_in_dict_11 = []\n        for word in word_list_s_in_dict_10:\n            if word not in word_list_s_in_dict_11:\n                word_"}, {"task_id": "word-break-ii", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # DP solution\n        # Time: O(n^2)\n        # Space: O(n)\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = dp[j] and s[j:i] in wordDict for all j < i\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = dp[j] and s[j:i] in wordDict for all j < i\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = dp[j] and s[j:i] in wordDict for all j < i\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = dp[j] and s[j:i] in wordDict for all j < i\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = dp[j] and s[j:i] in wordDict for all j < i\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = dp[j] and s[j:i] in wordDict for all j < i\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = dp[j] and s[j:i] in wordDict for all j < i\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = dp[j] and s[j:i] in wordDict for all j < i\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = dp[j] and s[j:i] in wordDict for all j < i\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = dp[j] and s[j:i] in wordDict for all j < i\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] = dp[j] and s[j:i] in wordDict for all j < i\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        # dp[0] = True\n        # dp[i] ="}, {"task_id": "word-break-ii", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words.\n        # dp[i] = False otherwise.\n        dp = [False] * (len(s) + 1)\n        dp[0] = True\n        \n        for i in range(1, len(s) + 1):\n            for j in range(i):\n                if dp[j] and s[j:i] in wordDict:\n                    dp[i] = True\n                    break\n        \n        # If dp[len(s)] is True, then we have found a valid word break.\n        # We will use the dp array to construct the answer.\n        if dp[len(s)]:\n            ans = []\n            self.dfs(s, wordDict, 0, [], ans)\n            return ans\n        else:\n            return []\n        \n    def dfs(self, s, wordDict, start, path, ans):\n        if start == len(s):\n            ans.append(' '.join(path))\n            return\n        \n        for end in range(start + 1, len(s) + 1):\n            if s[start:end] in wordDict:\n                path.append(s[start:end])\n                self.dfs(s, wordDict, end, path, ans)\n                path.pop()"}], "binary-tree-zigzag-level-order-traversal": [{"task_id": "binary-tree-zigzag-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def zigzagLevelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        q = [root]\n        res = []\n        level = 0\n        \n        while q:\n            level += 1\n            res.append([])\n            for i in range(len(q)):\n                node = q.pop(0)\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n                res[level-1].append(node.val)\n        \n        for i in range(len(res)):\n            if i % 2 == 1:\n                res[i] = res[i][::-1]\n        \n        return res"}, {"task_id": "binary-tree-zigzag-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def zigzagLevelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        q = [root]\n        res = []\n        level = 0\n        \n        while q:\n            level += 1\n            level_list = []\n            for _ in range(len(q)):\n                node = q.pop(0)\n                level_list.append(node.val)\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n            if level % 2 == 0:\n                res.append(level_list[::-1])\n            else:\n                res.append(level_list)\n        return res"}, {"task_id": "binary-tree-zigzag-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def zigzagLevelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        q = [root]\n        res = []\n        level = 0\n        \n        while q:\n            level += 1\n            res.append([])\n            for i in range(len(q)):\n                node = q.pop(0)\n                if node.left:\n                    q.append(node.left)\n                if node.right:\n                    q.append(node.right)\n                res[level-1].append(node.val)\n        for i in range(len(res)):\n            if i % 2 == 1:\n                res[i] = res[i][::-1]\n        return res"}, {"task_id": "binary-tree-zigzag-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def zigzagLevelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        result = []\n        level = 0\n        \n        while queue:\n            level_list = []\n            for i in range(len(queue)):\n                node = queue.pop(0)\n                level_list.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            if level % 2 == 0:\n                result.append(level_list)\n            else:\n                result.append(level_list[::-1])\n            level += 1\n        return result"}, {"task_id": "binary-tree-zigzag-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def zigzagLevelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        result = []\n        level = 0\n        \n        while queue:\n            level_nodes = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                level_nodes.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            if level % 2 == 0:\n                result.append(level_nodes)\n            else:\n                result.append(level_nodes[::-1])\n            level += 1\n        return result"}], "binary-watch": [{"task_id": "binary-watch", "completion": "class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        \"\"\"\n        :type turnedOn: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def get_time(h, m):\n            if h > 11 or m > 59:\n                return\n            return str(h) + ':' + str(m)\n        \n        def get_times(h, m):\n            if h > 11 or m > 59:\n                return\n            return [get_time(h, m), get_time(h + 1, m)]\n        \n        def get_all_times(h, m):\n            if h > 11 or m > 59:\n                return []\n            return [get_time(h, m), get_time(h + 1, m)] + get_all_times(h, m + 1)\n        \n        def get_all_times_with_pm(h, m):\n            if h > 11 or m > 59:\n                return []\n            return [get_time(h, m), get_time(h + 1, m)] + get_all_times_with_pm(h, m + 1)\n        \n        def get_all_times_with_pm_and_pm(h, m):\n            if h > 11 or m > 59:\n                return []\n            return [get_time(h, m), get_time(h + 1, m)] + get_all_times_with_pm_and_pm(h, m + 1)\n        \n        def get_all_times_with_pm_and_pm_and_pm(h, m):\n            if h > 11 or m > 59:\n                return []\n            return [get_time(h, m), get_time(h + 1, m)] + get_all_times_with_pm_and_pm_and_pm(h, m + 1)\n        \n        def get_all_times_with_pm_and_pm_and_pm_and_pm(h, m):\n            if h > 11 or m > 59:\n                return []\n            return [get_time(h, m), get_time(h + 1, m)] + get_all_times_with_pm_and_pm_and_pm_and_pm(h, m + 1)\n        \n        def get_all_times_with_pm_and_pm_and_pm_and_pm_and_pm(h, m):\n            if h > 11 or m > 59:\n                return []\n            return [get_time(h, m), get_time(h + 1, m)] + get_all_times_with_pm_and_pm_and_pm_and_pm_and_pm(h, m + 1)\n        \n        def get_all_times_with_pm_and_pm_and_pm_and_pm_and_pm_and_pm(h, m):\n            if h > 11 or m > 59:\n                return []\n            return [get_time(h, m), get_time(h + 1, m)] + get_all_times_with_pm_and_pm_and_pm_and_pm_and_pm_and_pm(h, m + 1)\n        \n        def get_all_times_with_pm_and_pm_and_pm_and_pm_and_pm_and_pm_and_pm(h, m):\n            if h > 11 or m > 59:\n                return []\n            return [get_time(h, m), get_time(h + 1, m)] + get_all_times_with_pm_and_pm_and_pm_and_pm_and_pm_and_pm_and_pm(h, m + 1)\n        \n        def get_all_times_with_pm_and_pm_and_pm_and_pm_and_pm_and_pm_and_pm_and_pm(h, m):\n            if h > 11 or m > 59:\n                return []\n            return [get_time(h, m), get_time(h + 1, m)] + get_all_times_with_pm_and_pm_and_pm_and_pm_and_pm_and_pm_and_pm_and_pm(h, m + 1)\n        \n        def get_all_times_with_pm_and_pm_and_pm_and_pm_and_pm_and_pm_and_pm_and_"}, {"task_id": "binary-watch", "completion": "class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        \"\"\"\n        :type turnedOn: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def get_time(h, m):\n            if h < 12 and m < 60:\n                return str(h) + \":\" + str(m)\n            else:\n                return \"\"\n        \n        def get_times(h, m):\n            if h < 12 and m < 60:\n                return [get_time(h, m)]\n            else:\n                return []\n        \n        def get_all_times(h, m):\n            if h < 12 and m < 60:\n                return [get_time(h, m)] + get_all_times(h, m + 1)\n            else:\n                return []\n        \n        def get_all_times_with_h(h, m):\n            if h < 12 and m < 60:\n                return [get_time(h, m)] + get_all_times_with_h(h + 1, 0)\n            else:\n                return []\n        \n        def get_all_times_with_m(h, m):\n            if h < 12 and m < 60:\n                return get_all_times_with_m(h, m + 1)\n            else:\n                return []\n        \n        def get_all_times_with_h_and_m(h, m):\n            if h < 12 and m < 60:\n                return [get_time(h, m)] + get_all_times_with_h_and_m(h + 1, 0)\n            else:\n                return []\n        \n        def get_all_times_with_h_and_m_and_h(h, m):\n            if h < 12 and m < 60:\n                return [get_time(h, m)] + get_all_times_with_h_and_m_and_h(h, m + 1)\n            else:\n                return []\n        \n        def get_all_times_with_h_and_m_and_m(h, m):\n            if h < 12 and m < 60:\n                return [get_time(h, m)] + get_all_times_with_h_and_m_and_m(h, m + 1)\n            else:\n                return []\n        \n        def get_all_times_with_h_and_m_and_h_and_m(h, m):\n            if h < 12 and m < 60:\n                return [get_time(h, m)] + get_all_times_with_h_and_m_and_h_and_m(h, m + 1)\n            else:\n                return []\n        \n        def get_all_times_with_h_and_m_and_h_and_m_and_h(h, m):\n            if h < 12 and m < 60:\n                return [get_time(h, m)] + get_all_times_with_h_and_m_and_h_and_m_and_h(h, m + 1)\n            else:\n                return []\n        \n        def get_all_times_with_h_and_m_and_h_and_m_and_m(h, m):\n            if h < 12 and m < 60:\n                return [get_time(h, m)] + get_all_times_with_h_and_m_and_h_and_m_and_m(h, m + 1)\n            else:\n                return []\n        \n        def get_all_times_with_h_and_m_and_h_and_m_and_h_and_m(h, m):\n            if h < 12 and m < 60:\n                return [get_time(h, m)] + get_all_times_with_h_and_m_and_h_and_m_and_h_and_m(h, m + 1)\n            else:\n                return []\n        \n        def get_all_times_with_h_and_m_and_h_and_m_and_h_and_m_and_h(h, m):\n            if h < 12 and m < 60:\n                return [get_time(h, m)] + get_all_times_with_h_and_m_and_h_and_m"}, {"task_id": "binary-watch", "completion": "class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        \"\"\"\n        :type turnedOn: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def get_time(h, m):\n            if h > 11 or m > 59:\n                return\n            return str(h) + \":\" + str(m)\n        \n        def get_times(h, m):\n            if h > 11 or m > 59:\n                return\n            return [get_time(h, m), get_time(h + 1, m), get_time(h, m + 1), get_time(h + 1, m + 1)]\n        \n        def get_all_times(h, m):\n            if h > 11 or m > 59:\n                return []\n            return get_times(h, m) + get_all_times(h, m + 1)\n        \n        return get_all_times(0, 0)"}, {"task_id": "binary-watch", "completion": "class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        \"\"\"\n        :type turnedOn: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def get_time(h, m):\n            if h > 11 or m > 59:\n                return\n            return str(h) + ':' + str(m).zfill(2)\n        \n        def get_times(h, m):\n            if h > 11 or m > 59:\n                return\n            return [get_time(h, m), get_time(h + 1, m - 1), get_time(h + 2, m - 2), get_time(h + 3, m - 3), get_time(h + 4, m - 4), get_time(h + 5, m - 5), get_time(h + 6, m - 6), get_time(h + 7, m - 7), get_time(h + 8, m - 8), get_time(h + 9, m - 9)]\n        \n        def get_all_times(h, m):\n            if h > 11 or m > 59:\n                return []\n            return [get_time(h, m), get_time(h + 1, m - 1), get_time(h + 2, m - 2), get_time(h + 3, m - 3), get_time(h + 4, m - 4), get_time(h + 5, m - 5), get_time(h + 6, m - 6), get_time(h + 7, m - 7), get_time(h + 8, m - 8), get_time(h + 9, m - 9)] + get_times(h, m)\n        \n        def get_all_times_for_h(h):\n            return get_all_times(h, 0)\n        \n        def get_all_times_for_m(m):\n            return get_all_times(0, m)\n        \n        def get_all_times_for_h_m(h, m):\n            return get_all_times(h, m)\n        \n        def get_all_times_for_h_m_for_h(h):\n            return get_all_times_for_h_m(h, 0)\n        \n        def get_all_times_for_h_m_for_m(m):\n            return get_all_times_for_h_m(0, m)\n        \n        def get_all_times_for_h_m_for_h_m(h, m):\n            return get_all_times_for_h_m(h, m)\n        \n        def get_all_times_for_h_m_for_h_m_for_h(h):\n            return get_all_times_for_h_m_for_h_m(h, 0)\n        \n        def get_all_times_for_h_m_for_h_m_for_m(m):\n            return get_all_times_for_h_m_for_h_m(0, m)\n        \n        def get_all_times_for_h_m_for_h_m_for_h_m(h, m):\n            return get_all_times_for_h_m_for_h_m(h, m)\n        \n        def get_all_times_for_h_m_for_h_m_for_h_m_for_h(h):\n            return get_all_times_for_h_m_for_h_m_for_h_m(h, 0)\n        \n        def get_all_times_for_h_m_for_h_m_for_h_m_for_m(m):\n            return get_all_times_for_h_m_for_h_m_for_h_m(0, m)\n        \n        def get_all_times_for_h_m_for_h_m_for_h_m_for_h_m(h, m):\n            return get_all_times_for_h_m_for_h_m_for_h_m(h, m)\n        \n        def get_all_times_for_h_m_for_h_m_for_h_m_for_h_m_for_h(h):\n            return get_all_times_for_h_"}, {"task_id": "binary-watch", "completion": "class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        \"\"\"\n        :type turnedOn: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def get_time(h, m):\n            if h < 12 and m < 60:\n                return str(h) + \":\" + str(m)\n            else:\n                return \"\"\n        \n        def get_times(h, m):\n            if h < 12 and m < 60:\n                return [str(h) + \":\" + str(m)]\n            else:\n                return []\n        \n        def get_all_times(h, m):\n            if h < 12 and m < 60:\n                return [str(h) + \":\" + str(m)]\n            else:\n                return []\n        \n        def get_all_times_with_pm(h, m):\n            if h < 12 and m < 60:\n                return [str(h) + \":\" + str(m)]\n            else:\n                return []\n        \n        def get_all_times_with_pm_and_pm(h, m):\n            if h < 12 and m < 60:\n                return [str(h) + \":\" + str(m)]\n            else:\n                return []\n        \n        def get_all_times_with_pm_and_pm_and_pm(h, m):\n            if h < 12 and m < 60:\n                return [str(h) + \":\" + str(m)]\n            else:\n                return []\n        \n        def get_all_times_with_pm_and_pm_and_pm_and_pm(h, m):\n            if h < 12 and m < 60:\n                return [str(h) + \":\" + str(m)]\n            else:\n                return []\n        \n        def get_all_times_with_pm_and_pm_and_pm_and_pm_and_pm(h, m):\n            if h < 12 and m < 60:\n                return [str(h) + \":\" + str(m)]\n            else:\n                return []\n        \n        def get_all_times_with_pm_and_pm_and_pm_and_pm_and_pm_and_pm(h, m):\n            if h < 12 and m < 60:\n                return [str(h) + \":\" + str(m)]\n            else:\n                return []\n        \n        def get_all_times_with_pm_and_pm_and_pm_and_pm_and_pm_and_pm_and_pm(h, m):\n            if h < 12 and m < 60:\n                return [str(h) + \":\" + str(m)]\n            else:\n                return []\n        \n        def get_all_times_with_pm_and_pm_and_pm_and_pm_and_pm_and_pm_and_pm_and_pm(h, m):\n            if h < 12 and m < 60:\n                return [str(h) + \":\" + str(m)]\n            else:\n                return []\n        \n        def get_all_times_with_pm_and_pm_and_pm_and_pm_and_pm_and_pm_and_pm_and_pm_and_pm(h, m):\n            if h < 12 and m < 60:\n                return [str(h) + \":\" + str(m)]\n            else:\n                return []\n        \n        def get_all_times_with_pm_and_pm_and_pm_and_pm_and_pm_and_pm_and_pm_and_pm_and_pm_and_pm(h, m):\n            if h < 12 and m < 60:\n                return [str(h) + \":\" + str(m)]\n            else:\n                return []\n        \n        def get_all_times_with_pm_and_pm_and_pm_and_pm_and_pm_and_pm_and_pm_and_pm_and_pm_and_pm_and_pm(h, m):\n            if h < 12 and m < 60:\n                return [str(h) + \":\" + str(m)]\n            else:\n                return []\n        \n        def get_all_times_with_pm_and_pm_and_pm_and_pm_and_pm_and_pm_and_pm_and"}], "pascals-triangle": [{"task_id": "pascals-triangle", "completion": "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if numRows == 0:\n            return []\n        \n        if numRows == 1:\n            return [[1]]\n        \n        if numRows == 2:\n            return [[1], [1,1]]\n        \n        res = [[1], [1,1]]\n        \n        for i in range(2, numRows):\n            temp = [1]\n            for j in range(1, i):\n                temp.append(res[i-1][j-1] + res[i-1][j])\n            temp.append(1)\n            res.append(temp)\n        \n        return res"}, {"task_id": "pascals-triangle", "completion": "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if numRows == 0:\n            return []\n        if numRows == 1:\n            return [[1]]\n        if numRows == 2:\n            return [[1],[1,1]]\n        \n        res = [[1],[1,1]]\n        for i in range(2,numRows):\n            temp = [1]\n            for j in range(1,i):\n                temp.append(res[i-1][j-1]+res[i-1][j])\n            temp.append(1)\n            res.append(temp)\n        return res"}, {"task_id": "pascals-triangle", "completion": "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if numRows == 0:\n            return []\n        if numRows == 1:\n            return [[1]]\n        if numRows == 2:\n            return [[1],[1,1]]\n        \n        res = [[1],[1,1]]\n        for i in range(2,numRows):\n            temp = [1]\n            for j in range(1,i):\n                temp.append(res[i-1][j-1]+res[i-1][j])\n            temp.append(1)\n            res.append(temp)\n        return res"}, {"task_id": "pascals-triangle", "completion": "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if numRows == 0:\n            return []\n        \n        if numRows == 1:\n            return [[1]]\n        \n        if numRows == 2:\n            return [[1], [1,1]]\n        \n        res = [[1], [1,1]]\n        \n        for i in range(2, numRows):\n            temp = [1]\n            for j in range(1, i):\n                temp.append(res[i-1][j-1] + res[i-1][j])\n            temp.append(1)\n            res.append(temp)\n        \n        return res"}, {"task_id": "pascals-triangle", "completion": "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if numRows == 0:\n            return []\n        \n        if numRows == 1:\n            return [[1]]\n        \n        if numRows == 2:\n            return [[1], [1,1]]\n        \n        pascal = [[1], [1,1]]\n        \n        for i in range(2, numRows):\n            row = [1]\n            for j in range(1, len(pascal[i-1])):\n                row.append(pascal[i-1][j-1] + pascal[i-1][j])\n            row.append(1)\n            pascal.append(row)\n        \n        return pascal"}], "power-of-three": [{"task_id": "power-of-three", "completion": "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 0:\n            return False\n        while n % 3 == 0:\n            n = n / 3\n        return n == 1"}, {"task_id": "power-of-three", "completion": "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 3 == 0:\n            n = n / 3\n        \n        return n == 1"}, {"task_id": "power-of-three", "completion": "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 0:\n            return False\n        \n        while n % 3 == 0:\n            n = n / 3\n        \n        return n == 1"}, {"task_id": "power-of-three", "completion": "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 3 == 0:\n            n = n / 3\n        \n        return n == 1"}, {"task_id": "power-of-three", "completion": "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 3 == 0:\n            n = n / 3\n        \n        return n == 1"}], "binary-tree-maximum-path-sum": [{"task_id": "binary-tree-maximum-path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def max_gain(node):\n            if not node:\n                return 0\n            \n            left_gain = max(max_gain(node.left), 0)\n            right_gain = max(max_gain(node.right), 0)\n            \n            new_path = node.val + left_gain + right_gain\n            \n            self.max_sum = max(self.max_sum, new_path)\n            \n            return node.val + max(left_gain, right_gain)\n        \n        self.max_sum = float('-inf')\n        max_gain(root)\n        return self.max_sum"}, {"task_id": "binary-tree-maximum-path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def max_gain(node):\n            if not node:\n                return 0\n            \n            left_gain = max(max_gain(node.left), 0)\n            right_gain = max(max_gain(node.right), 0)\n            \n            new_path = node.val + left_gain + right_gain\n            \n            self.max_sum = max(self.max_sum, new_path)\n            \n            return node.val + max(left_gain, right_gain)\n        \n        self.max_sum = float('-inf')\n        max_gain(root)\n        return self.max_sum"}, {"task_id": "binary-tree-maximum-path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def max_gain(node):\n            if not node:\n                return 0\n            \n            left_gain = max(max_gain(node.left), 0)\n            right_gain = max(max_gain(node.right), 0)\n            \n            new_path = node.val + left_gain + right_gain\n            \n            self.max_sum = max(self.max_sum, new_path)\n            \n            return node.val + max(left_gain, right_gain)\n        \n        self.max_sum = float('-inf')\n        max_gain(root)\n        return self.max_sum"}, {"task_id": "binary-tree-maximum-path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def max_gain(node):\n            if not node:\n                return 0\n            \n            left_gain = max(max_gain(node.left), 0)\n            right_gain = max(max_gain(node.right), 0)\n            \n            new_path = node.val + left_gain + right_gain\n            \n            self.max_sum = max(self.max_sum, new_path)\n            \n            return node.val + max(left_gain, right_gain)\n        \n        self.max_sum = float('-inf')\n        max_gain(root)\n        return self.max_sum"}, {"task_id": "binary-tree-maximum-path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def max_gain(node):\n            if not node:\n                return 0\n            \n            left_gain = max(max_gain(node.left), 0)\n            right_gain = max(max_gain(node.right), 0)\n            \n            new_path = node.val + left_gain + right_gain\n            \n            self.max_sum = max(self.max_sum, new_path)\n            \n            return node.val + max(left_gain, right_gain)\n        \n        self.max_sum = float('-inf')\n        max_gain(root)\n        return self.max_sum"}], "trapping-rain-water-ii": [{"task_id": "trapping-rain-water-ii", "completion": "class Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not heightMap:\n            return 0\n        \n        m, n = len(heightMap), len(heightMap[0])\n        heap = []\n        visited = set()\n        for i in range(m):\n            for j in range(n):\n                if i == 0 or i == m-1 or j == 0 or j == n-1:\n                    heapq.heappush(heap, (heightMap[i][j], i, j))\n                    visited.add((i, j))\n        \n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        ans = 0\n        while heap:\n            curr_height, curr_i, curr_j = heapq.heappop(heap)\n            for di, dj in directions:\n                new_i, new_j = curr_i + di, curr_j + dj\n                if 0 <= new_i < m and 0 <= new_j < n and (new_i, new_j) not in visited:\n                    if heightMap[new_i][new_j] < curr_height:\n                        ans += curr_height - heightMap[new_i][new_j]\n                    heapq.heappush(heap, (max(curr_height, heightMap[new_i][new_j]), new_i, new_j))\n                    visited.add((new_i, new_j))\n        \n        return ans"}, {"task_id": "trapping-rain-water-ii", "completion": "class Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not heightMap:\n            return 0\n        \n        m, n = len(heightMap), len(heightMap[0])\n        visited = [[False] * n for _ in range(m)]\n        heap = []\n        for i in range(m):\n            for j in range(n):\n                if i == 0 or i == m-1 or j == 0 or j == n-1:\n                    heapq.heappush(heap, (heightMap[i][j], i, j))\n                    visited[i][j] = True\n        \n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        ans = 0\n        while heap:\n            curr_height, i, j = heapq.heappop(heap)\n            for di, dj in directions:\n                ni, nj = i + di, j + dj\n                if 0 <= ni < m and 0 <= nj < n and not visited[ni][nj]:\n                    visited[ni][nj] = True\n                    if heightMap[ni][nj] < curr_height:\n                        ans += curr_height - heightMap[ni][nj]\n                    heapq.heappush(heap, (max(curr_height, heightMap[ni][nj]), ni, nj))\n        \n        return ans"}, {"task_id": "trapping-rain-water-ii", "completion": "class Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not heightMap:\n            return 0\n        \n        m, n = len(heightMap), len(heightMap[0])\n        heap = []\n        visited = set()\n        for i in range(m):\n            for j in range(n):\n                if i == 0 or i == m-1 or j == 0 or j == n-1:\n                    heapq.heappush(heap, (heightMap[i][j], i, j))\n                    visited.add((i, j))\n        \n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        ans = 0\n        while heap:\n            curr_height, curr_i, curr_j = heapq.heappop(heap)\n            for di, dj in directions:\n                new_i, new_j = curr_i + di, curr_j + dj\n                if 0 <= new_i < m and 0 <= new_j < n and (new_i, new_j) not in visited:\n                    if heightMap[new_i][new_j] < curr_height:\n                        ans += curr_height - heightMap[new_i][new_j]\n                    heapq.heappush(heap, (max(curr_height, heightMap[new_i][new_j]), new_i, new_j))\n                    visited.add((new_i, new_j))\n        \n        return ans"}, {"task_id": "trapping-rain-water-ii", "completion": "class Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not heightMap:\n            return 0\n        \n        m, n = len(heightMap), len(heightMap[0])\n        heap = []\n        visited = set()\n        for i in range(m):\n            for j in range(n):\n                if i == 0 or i == m-1 or j == 0 or j == n-1:\n                    heapq.heappush(heap, (heightMap[i][j], i, j))\n                    visited.add((i, j))\n        \n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        ans = 0\n        while heap:\n            curr_height, curr_i, curr_j = heapq.heappop(heap)\n            for d in directions:\n                new_i, new_j = curr_i + d[0], curr_j + d[1]\n                if 0 <= new_i < m and 0 <= new_j < n and (new_i, new_j) not in visited:\n                    if heightMap[new_i][new_j] < curr_height:\n                        ans += curr_height - heightMap[new_i][new_j]\n                    heapq.heappush(heap, (max(curr_height, heightMap[new_i][new_j]), new_i, new_j))\n                    visited.add((new_i, new_j))\n        \n        return ans"}, {"task_id": "trapping-rain-water-ii", "completion": "class Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not heightMap:\n            return 0\n        \n        m, n = len(heightMap), len(heightMap[0])\n        heap = []\n        visited = set()\n        for i in range(m):\n            for j in range(n):\n                if i == 0 or i == m-1 or j == 0 or j == n-1:\n                    heapq.heappush(heap, (heightMap[i][j], i, j))\n                    visited.add((i, j))\n        \n        directions = [(1, 0), (-1, 0), (0, 1), (0, -1)]\n        ans = 0\n        while heap:\n            curr_height, curr_i, curr_j = heapq.heappop(heap)\n            for di, dj in directions:\n                ni, nj = curr_i + di, curr_j + dj\n                if 0 <= ni < m and 0 <= nj < n and (ni, nj) not in visited:\n                    if heightMap[ni][nj] < curr_height:\n                        ans += curr_height - heightMap[ni][nj]\n                    heapq.heappush(heap, (max(curr_height, heightMap[ni][nj]), ni, nj))\n                    visited.add((ni, nj))\n        \n        return ans"}], "valid-palindrome": [{"task_id": "valid-palindrome", "completion": "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # remove all non-alphanumeric characters\n        s = re.sub(r'[^a-zA-Z0-9]', '', s)\n        \n        # convert to lowercase\n        s = s.lower()\n        \n        # check if the string is a palindrome\n        return s == s[::-1]"}, {"task_id": "valid-palindrome", "completion": "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # remove all non-alphanumeric characters\n        s = re.sub(r'[^a-zA-Z0-9]', '', s)\n        \n        # convert to lowercase\n        s = s.lower()\n        \n        # check if the string is a palindrome\n        return s == s[::-1]"}, {"task_id": "valid-palindrome", "completion": "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # remove all non-alphanumeric characters\n        s = re.sub(r'[^a-zA-Z0-9]', '', s)\n        \n        # convert to lowercase\n        s = s.lower()\n        \n        # check if the string is a palindrome\n        return s == s[::-1]"}, {"task_id": "valid-palindrome", "completion": "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        s = s.lower()\n        s = re.sub(r'[^a-z0-9]', '', s)\n        return s == s[::-1]"}, {"task_id": "valid-palindrome", "completion": "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # remove all non-alphanumeric characters\n        s = re.sub(r'[^a-zA-Z0-9]', '', s)\n        \n        # convert to lowercase\n        s = s.lower()\n        \n        # check if the string is a palindrome\n        return s == s[::-1]"}], "sliding-window-median": [{"task_id": "sliding-window-median", "completion": "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        \n        # 1. create a list of lists\n        # 2. create a list of medians\n        # 3. create a list of medians\n        # 4. create a list of medians\n        # 5. create a list of medians\n        # 6. create a list of medians\n        # 7. create a list of medians\n        # 8. create a list of medians\n        # 9. create a list of medians\n        # 10. create a list of medians\n        # 11. create a list of medians\n        # 12. create a list of medians\n        # 13. create a list of medians\n        # 14. create a list of medians\n        # 15. create a list of medians\n        # 16. create a list of medians\n        # 17. create a list of medians\n        # 18. create a list of medians\n        # 19. create a list of medians\n        # 20. create a list of medians\n        # 21. create a list of medians\n        # 22. create a list of medians\n        # 23. create a list of medians\n        # 24. create a list of medians\n        # 25. create a list of medians\n        # 26. create a list of medians\n        # 27. create a list of medians\n        # 28. create a list of medians\n        # 29. create a list of medians\n        # 30. create a list of medians\n        # 31. create a list of medians\n        # 32. create a list of medians\n        # 33. create a list of medians\n        # 34. create a list of medians\n        # 35. create a list of medians\n        # 36. create a list of medians\n        # 37. create a list of medians\n        # 38. create a list of medians\n        # 39. create a list of medians\n        # 40. create a list of medians\n        # 41. create a list of medians\n        # 42. create a list of medians\n        # 43. create a list of medians\n        # 44. create a list of medians\n        # 45. create a list of medians\n        # 46. create a list of medians\n        # 47. create a list of medians\n        # 48. create a list of medians\n        # 49. create a list of medians\n        # 50. create a list of medians\n        # 51. create a list of medians\n        # 52. create a list of medians\n        # 53. create a list of medians\n        # 54. create a list of medians\n        # 55. create a list of medians\n        # 56. create a list of medians\n        # 57. create a list of medians\n        # 58. create a list of medians\n        # 59. create a list of medians\n        # 60. create a list of medians\n        # 61. create a list of medians\n        # 62. create a list of medians\n        # 63. create a list of medians\n        # 64. create a list of medians\n        # 65. create a list of medians\n        # 66. create a list of medians\n        # 67. create a list of medians\n        # 68. create a list of medians\n        # 69. create a list of medians\n        # 70. create a list of medians\n        # 71. create a list of medians\n        # 72. create a list of medians\n        # 73. create a list of medians\n        # 74. create a list of medians\n        # 75. create a list of medians\n        # 76. create a list of medians\n        # 77. create a list of medians\n        # 78. create a list of medians\n        # 79. create a list of medians\n        # 80. create"}, {"task_id": "sliding-window-median", "completion": "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        \n        # Initialize the result list\n        result = []\n        \n        # Initialize the window\n        window = nums[:k]\n        \n        # Initialize the median\n        median = self.findMedian(window)\n        \n        # Append the median to the result list\n        result.append(median)\n        \n        # Iterate over the remaining elements of the array\n        for i in range(k, len(nums)):\n            # Remove the first element of the window\n            window.pop(0)\n            \n            # Add the next element to the window\n            window.append(nums[i])\n            \n            # Find the median of the window\n            median = self.findMedian(window)\n            \n            # Append the median to the result list\n            result.append(median)\n        \n        # Return the result list\n        return result\n    \n    def findMedian(self, window):\n        # Sort the window\n        window.sort()\n        \n        # If the length of the window is odd\n        if len(window) % 2 == 1:\n            # Return the middle element\n            return window[len(window) // 2]\n        else:\n            # Return the average of the middle two elements\n            return (window[len(window) // 2] + window[len(window) // 2 - 1]) / 2.0"}, {"task_id": "sliding-window-median", "completion": "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        \n        # Initialize the result list\n        result = []\n        \n        # Initialize the window\n        window = nums[:k]\n        \n        # Initialize the median\n        median = self.findMedian(window)\n        \n        # Append the median to the result list\n        result.append(median)\n        \n        # Iterate over the remaining elements of the array\n        for i in range(k, len(nums)):\n            # Remove the first element of the window\n            window.pop(0)\n            \n            # Add the next element to the window\n            window.append(nums[i])\n            \n            # Find the median of the window\n            median = self.findMedian(window)\n            \n            # Append the median to the result list\n            result.append(median)\n        \n        # Return the result list\n        return result\n    \n    def findMedian(self, window):\n        # Sort the window\n        window.sort()\n        \n        # If the length of the window is odd\n        if len(window) % 2 == 1:\n            # Return the middle element\n            return window[len(window) // 2]\n        else:\n            # Return the average of the middle two elements\n            return (window[len(window) // 2] + window[len(window) // 2 - 1]) / 2.0"}, {"task_id": "sliding-window-median", "completion": "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        \n        # 1. create a list of k-sized sliding window\n        # 2. sort the list\n        # 3. find the median\n        # 4. append the median to the result list\n        # 5. move the sliding window by one\n        # 6. repeat step 2-4 until the end of the list\n        \n        # 1. create a list of k-sized sliding window\n        window = []\n        for i in range(k):\n            window.append(nums[i])\n        \n        # 2. sort the list\n        window.sort()\n        \n        # 3. find the median\n        if k % 2 == 0:\n            median = (window[k//2] + window[k//2 - 1]) / 2\n        else:\n            median = window[k//2]\n        \n        # 4. append the median to the result list\n        result = [median]\n        \n        # 5. move the sliding window by one\n        for i in range(k, len(nums)):\n            # 5.1 remove the first element from the sliding window\n            window.pop(0)\n            # 5.2 add the new element to the sliding window\n            window.append(nums[i])\n            # 5.3 sort the sliding window\n            window.sort()\n            # 5.4 find the median\n            if k % 2 == 0:\n                median = (window[k//2] + window[k//2 - 1]) / 2\n            else:\n                median = window[k//2]\n            # 5.5 append the median to the result list\n            result.append(median)\n        \n        # 6. return the result list\n        return result"}, {"task_id": "sliding-window-median", "completion": "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        \n        # Initialize the result list\n        result = []\n        \n        # Initialize the window\n        window = nums[:k]\n        \n        # Initialize the median\n        median = self.find_median(window)\n        \n        # Append the median to the result list\n        result.append(median)\n        \n        # Iterate over the remaining elements of the array\n        for i in range(k, len(nums)):\n            # Remove the first element of the window\n            window.pop(0)\n            \n            # Add the next element to the window\n            window.append(nums[i])\n            \n            # Find the median of the window\n            median = self.find_median(window)\n            \n            # Append the median to the result list\n            result.append(median)\n        \n        # Return the result list\n        return result\n    \n    def find_median(self, window):\n        # Sort the window\n        window.sort()\n        \n        # If the length of the window is odd\n        if len(window) % 2 == 1:\n            # Return the middle element\n            return window[len(window) // 2]\n        else:\n            # Return the mean of the middle two elements\n            return (window[len(window) // 2] + window[len(window) // 2 - 1]) / 2.0"}], "rotate-list": [{"task_id": "rotate-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return head\n        \n        length = 1\n        curr = head\n        while curr.next:\n            curr = curr.next\n            length += 1\n        \n        curr.next = head\n        \n        k = k % length\n        \n        for i in range(length - k):\n            curr = curr.next\n        \n        head = curr.next\n        curr.next = None\n        \n        return head"}, {"task_id": "rotate-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        length = 0\n        curr = head\n        while curr:\n            length += 1\n            curr = curr.next\n        \n        k = k % length\n        \n        if k == 0:\n            return head\n        \n        curr = head\n        for i in range(length - k - 1):\n            curr = curr.next\n        \n        new_head = curr.next\n        curr.next = None\n        \n        curr = new_head\n        while curr.next:\n            curr = curr.next\n        \n        curr.next = head\n        \n        return new_head"}, {"task_id": "rotate-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        length = 0\n        curr = head\n        while curr:\n            length += 1\n            curr = curr.next\n        \n        k = k % length\n        \n        if k == 0:\n            return head\n        \n        curr = head\n        for i in range(length - k - 1):\n            curr = curr.next\n        \n        new_head = curr.next\n        curr.next = None\n        \n        curr = new_head\n        while curr.next:\n            curr = curr.next\n        \n        curr.next = head\n        \n        return new_head"}, {"task_id": "rotate-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return head\n        \n        length = 0\n        curr = head\n        while curr:\n            length += 1\n            curr = curr.next\n        \n        k = k % length\n        \n        if k == 0:\n            return head\n        \n        curr = head\n        for i in range(length - k - 1):\n            curr = curr.next\n        \n        new_head = curr.next\n        curr.next = None\n        \n        curr = new_head\n        while curr.next:\n            curr = curr.next\n        \n        curr.next = head\n        \n        return new_head"}, {"task_id": "rotate-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        length = 0\n        curr = head\n        while curr:\n            length += 1\n            curr = curr.next\n        \n        k = k % length\n        \n        if k == 0:\n            return head\n        \n        curr = head\n        for i in range(length - k - 1):\n            curr = curr.next\n        \n        new_head = curr.next\n        curr.next = None\n        \n        curr = new_head\n        while curr.next:\n            curr = curr.next\n        \n        curr.next = head\n        \n        return new_head"}], "ugly-number": [{"task_id": "ugly-number", "completion": "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 2 == 0:\n            n = n / 2\n            \n        while n % 3 == 0:\n            n = n / 3\n            \n        while n % 5 == 0:\n            n = n / 5\n            \n        return n == 1"}, {"task_id": "ugly-number", "completion": "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 2 == 0:\n            n = n / 2\n        \n        while n % 3 == 0:\n            n = n / 3\n        \n        while n % 5 == 0:\n            n = n / 5\n        \n        return n == 1"}, {"task_id": "ugly-number", "completion": "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n > 1:\n            if n % 2 == 0:\n                n = n / 2\n            elif n % 3 == 0:\n                n = n / 3\n            elif n % 5 == 0:\n                n = n / 5\n            else:\n                return False\n        \n        return True"}, {"task_id": "ugly-number", "completion": "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 2 == 0:\n            n = n / 2\n            \n        while n % 3 == 0:\n            n = n / 3\n            \n        while n % 5 == 0:\n            n = n / 5\n            \n        return n == 1"}, {"task_id": "ugly-number", "completion": "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n > 1:\n            if n % 2 == 0:\n                n = n / 2\n            elif n % 3 == 0:\n                n = n / 3\n            elif n % 5 == 0:\n                n = n / 5\n            else:\n                return False\n        \n        return True"}], "falling-squares": [{"task_id": "falling-squares", "completion": "class Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}, {"task_id": "falling-squares", "completion": "class Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}, {"task_id": "falling-squares", "completion": "class Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}, {"task_id": "falling-squares", "completion": "class Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}, {"task_id": "falling-squares", "completion": "class Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "sum-of-left-leaves": [{"task_id": "sum-of-left-leaves", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        if root.left is None and root.right is None:\n            return 0\n        \n        if root.left is not None and root.right is None:\n            return self.sumOfLeftLeaves(root.left) + root.left.val\n        \n        if root.left is None and root.right is not None:\n            return self.sumOfLeftLeaves(root.right)\n        \n        return self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right) + root.val"}, {"task_id": "sum-of-left-leaves", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        if root.left is None and root.right is None:\n            return 0\n        \n        if root.left is not None and root.right is None:\n            return self.sumOfLeftLeaves(root.left) + root.left.val\n        \n        if root.left is None and root.right is not None:\n            return self.sumOfLeftLeaves(root.right)\n        \n        return self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right) + root.val"}, {"task_id": "sum-of-left-leaves", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        if root.left is None and root.right is None:\n            return 0\n        \n        if root.left is not None and root.right is None:\n            return self.sumOfLeftLeaves(root.left) + root.left.val\n        \n        if root.left is None and root.right is not None:\n            return self.sumOfLeftLeaves(root.right)\n        \n        return self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right) + root.val"}, {"task_id": "sum-of-left-leaves", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        if root.left is None and root.right is None:\n            return 0\n        \n        if root.left is not None and root.right is None:\n            return self.sumOfLeftLeaves(root.left) + root.left.val\n        \n        if root.left is None and root.right is not None:\n            return self.sumOfLeftLeaves(root.right)\n        \n        return self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right) + root.val"}, {"task_id": "sum-of-left-leaves", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        if root.left is None and root.right is None:\n            return 0\n        \n        if root.left is not None and root.right is None:\n            return self.sumOfLeftLeaves(root.left) + root.left.val\n        \n        if root.left is None and root.right is not None:\n            return self.sumOfLeftLeaves(root.right)\n        \n        return self.sumOfLeftLeaves(root.left) + self.sumOfLeftLeaves(root.right) + root.left.val + root.right.val"}], "max-sum-of-rectangle-no-larger-than-k": [{"task_id": "max-sum-of-rectangle-no-larger-than-k", "completion": "class Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def maxSumSubmatrix(matrix, k):\n            \"\"\"\n            :type matrix: List[List[int]]\n            :type k: int\n            :rtype: int\n            \"\"\"\n            m, n = len(matrix), len(matrix[0])\n            res = float('-inf')\n            for l in range(n):\n                sums = [0] * m\n                for r in range(l, n):\n                    for i in range(m):\n                        sums[i] += matrix[i][r]\n                    sums = [max(sums[i] - k, 0) for i in range(m)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m"}, {"task_id": "max-sum-of-rectangle-no-larger-than-k", "completion": "class Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def maxSumSubmatrix(matrix, k):\n            \"\"\"\n            :type matrix: List[List[int]]\n            :type k: int\n            :rtype: int\n            \"\"\"\n            m, n = len(matrix), len(matrix[0])\n            res = float('-inf')\n            for l in range(n):\n                sums = [0] * m\n                for r in range(l, n):\n                    for i in range(m):\n                        sums[i] += matrix[i][r]\n                    sums = [max(sums[i] - k, 0) for i in range(m)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m"}, {"task_id": "max-sum-of-rectangle-no-larger-than-k", "completion": "class Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def maxSumSubmatrix(matrix, k):\n            \"\"\"\n            :type matrix: List[List[int]]\n            :type k: int\n            :rtype: int\n            \"\"\"\n            m, n = len(matrix), len(matrix[0])\n            res = float('-inf')\n            for l in range(n):\n                sums = [0] * m\n                for r in range(l, n):\n                    for i in range(m):\n                        sums[i] += matrix[i][r]\n                    sums = [max(sums[i] - k, 0) for i in range(m)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m"}, {"task_id": "max-sum-of-rectangle-no-larger-than-k", "completion": "class Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def maxSumSubmatrix(matrix, k):\n            \"\"\"\n            :type matrix: List[List[int]]\n            :type k: int\n            :rtype: int\n            \"\"\"\n            m, n = len(matrix), len(matrix[0])\n            res = float('-inf')\n            for l in range(n):\n                sums = [0] * m\n                for r in range(l, n):\n                    for i in range(m):\n                        sums[i] += matrix[i][r]\n                    sums = [max(sums[i] - k, 0) for i in range(m)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m"}, {"task_id": "max-sum-of-rectangle-no-larger-than-k", "completion": "class Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def maxSumSubmatrix(matrix, k):\n            \"\"\"\n            :type matrix: List[List[int]]\n            :type k: int\n            :rtype: int\n            \"\"\"\n            m, n = len(matrix), len(matrix[0])\n            res = float('-inf')\n            for l in range(n):\n                sums = [0] * m\n                for r in range(l, n):\n                    for i in range(m):\n                        sums[i] += matrix[i][r]\n                    sums = [max(sums[i] - k, 0) for i in range(m)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m + 1)]\n                    sums = [max(sums[i] - k, 0) for i in range(m + 1)]\n                    sums = [0] + sums\n                    sums = [sums[i] + sums[i - 1] for i in range(1, m"}], "divide-two-integers": [{"task_id": "divide-two-integers", "completion": "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        \n        if dividend == 0:\n            return 0\n        \n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n        \n        if dividend == -2147483648 and divisor == 1:\n            return -2147483648\n        \n        if dividend == -2147483648 and divisor == 2:\n            return -1073741824\n        \n        if dividend == -2147483648 and divisor == 3:\n            return -65535\n        \n        if dividend == -2147483648 and divisor == 4:\n            return -32768\n        \n        if dividend == -2147483648 and divisor == 5:\n            return -16384\n        \n        if dividend == -2147483648 and divisor == 6:\n            return -8192\n        \n        if dividend == -2147483648 and divisor == 7:\n            return -4096\n        \n        if dividend == -2147483648 and divisor == 8:\n            return -2048\n        \n        if dividend == -2147483648 and divisor == 9:\n            return -1024\n        \n        if dividend == -2147483648 and divisor == 10:\n            return -512\n        \n        if dividend == -2147483648 and divisor == 11:\n            return -256\n        \n        if dividend == -2147483648 and divisor == 12:\n            return -128\n        \n        if dividend == -2147483648 and divisor == 13:\n            return -64\n        \n        if dividend == -2147483648 and divisor == 14:\n            return -32\n        \n        if dividend == -2147483648 and divisor == 15:\n            return -16\n        \n        if dividend == -2147483648 and divisor == 16:\n            return -8\n        \n        if dividend == -2147483648 and divisor == 17:\n            return -4\n        \n        if dividend == -2147483648 and divisor == 18:\n            return -2\n        \n        if dividend == -2147483648 and divisor == 19:\n            return -1\n        \n        if dividend == -2147483648 and divisor == 20:\n            return 0\n        \n        if dividend == -2147483648 and divisor == 21:\n            return 1\n        \n        if dividend == -2147483648 and divisor == 22:\n            return 2\n        \n        if dividend == -2147483648 and divisor == 23:\n            return 3\n        \n        if dividend == -2147483648 and divisor == 24:\n            return 4\n        \n        if dividend == -2147483648 and divisor == 25:\n            return 5\n        \n        if dividend == -2147483648 and divisor == 26:\n            return 6\n        \n        if dividend == -2147483648 and divisor == 27:\n            return 7\n        \n        if dividend == -2147483648 and divisor == 28:\n            return 8\n        \n        if dividend == -2147483648 and divisor == 29:\n            return 9\n        \n        if dividend == -2147483648 and divisor == 30:\n            return 1"}, {"task_id": "divide-two-integers", "completion": "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        \n        if dividend == 0:\n            return 0\n        \n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n        \n        if dividend == -2147483648 and divisor == 1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == -1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == 1:\n            return 2147483647\n        \n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n        \n        if dividend == 2147483647 and divisor == -1:\n            return -2147483648\n        \n        if dividend == -2147483648 and divisor == -1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == -1:\n            return -2147483648\n        \n        if dividend == -2147483648 and divisor == -1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == -1:\n            return -2147483648\n        \n        if dividend == -2147483648 and divisor == -1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == -1:\n            return -2147483648\n        \n        if dividend == -2147483648 and divisor == -1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == -1:\n            return -2147483648\n        \n        if dividend == -2147483648 and divisor == -1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == -1:\n            return -2147483648\n        \n        if dividend == -2147483648 and divisor == -1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == -1:\n            return -2147483648\n        \n        if dividend == -2147483648 and divisor == -1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == -1:\n            return -2147483648\n        \n        if dividend == -2147483648 and divisor == -1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == -1:\n            return -2147483648\n        \n        if dividend == -2147483648 and divisor == -1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == -1:\n            return -2147483648\n        \n        if dividend == -2147483648 and divisor == -1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == -1:"}, {"task_id": "divide-two-integers", "completion": "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        \n        if dividend == 0:\n            return 0\n        \n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n        \n        if dividend == -2147483648 and divisor == 1:\n            return -2147483648\n        \n        if dividend == -2147483648 and divisor == 2:\n            return -1073741824\n        \n        if dividend == -2147483648 and divisor == 3:\n            return -65535\n        \n        if dividend == -2147483648 and divisor == 4:\n            return -32768\n        \n        if dividend == -2147483648 and divisor == 5:\n            return -16384\n        \n        if dividend == -2147483648 and divisor == 6:\n            return -8192\n        \n        if dividend == -2147483648 and divisor == 7:\n            return -4096\n        \n        if dividend == -2147483648 and divisor == 8:\n            return -2048\n        \n        if dividend == -2147483648 and divisor == 9:\n            return -1024\n        \n        if dividend == -2147483648 and divisor == 10:\n            return -512\n        \n        if dividend == -2147483648 and divisor == 11:\n            return -256\n        \n        if dividend == -2147483648 and divisor == 12:\n            return -128\n        \n        if dividend == -2147483648 and divisor == 13:\n            return -64\n        \n        if dividend == -2147483648 and divisor == 14:\n            return -32\n        \n        if dividend == -2147483648 and divisor == 15:\n            return -16\n        \n        if dividend == -2147483648 and divisor == 16:\n            return -8\n        \n        if dividend == -2147483648 and divisor == 17:\n            return -4\n        \n        if dividend == -2147483648 and divisor == 18:\n            return -2\n        \n        if dividend == -2147483648 and divisor == 19:\n            return -1\n        \n        if dividend == -2147483648 and divisor == 20:\n            return 0\n        \n        if dividend == -2147483648 and divisor == 21:\n            return 1\n        \n        if dividend == -2147483648 and divisor == 22:\n            return 2\n        \n        if dividend == -2147483648 and divisor == 23:\n            return 3\n        \n        if dividend == -2147483648 and divisor == 24:\n            return 4\n        \n        if dividend == -2147483648 and divisor == 25:\n            return 5\n        \n        if dividend == -2147483648 and divisor == 26:\n            return 6\n        \n        if dividend == -2147483648 and divisor == 27:\n            return 7\n        \n        if dividend == -2147483648 and divisor == 28:\n            return 8\n        \n        if dividend == -2147483648 and divisor == 29:\n            return 9\n        \n        if dividend == -2147483648 and divisor == 30:\n            return 1"}, {"task_id": "divide-two-integers", "completion": "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        \n        if dividend == 0:\n            return 0\n        \n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n        \n        if dividend == -2147483648 and divisor == 1:\n            return -2147483648\n        \n        if dividend == -2147483648 and divisor == 2:\n            return -1073741824\n        \n        if dividend == -2147483648 and divisor == 3:\n            return -65535\n        \n        if dividend == -2147483648 and divisor == 4:\n            return -32768\n        \n        if dividend == -2147483648 and divisor == 5:\n            return -16384\n        \n        if dividend == -2147483648 and divisor == 6:\n            return -8192\n        \n        if dividend == -2147483648 and divisor == 7:\n            return -4096\n        \n        if dividend == -2147483648 and divisor == 8:\n            return -2048\n        \n        if dividend == -2147483648 and divisor == 9:\n            return -1024\n        \n        if dividend == -2147483648 and divisor == 10:\n            return -512\n        \n        if dividend == -2147483648 and divisor == 11:\n            return -256\n        \n        if dividend == -2147483648 and divisor == 12:\n            return -128\n        \n        if dividend == -2147483648 and divisor == 13:\n            return -64\n        \n        if dividend == -2147483648 and divisor == 14:\n            return -32\n        \n        if dividend == -2147483648 and divisor == 15:\n            return -16\n        \n        if dividend == -2147483648 and divisor == 16:\n            return -8\n        \n        if dividend == -2147483648 and divisor == 17:\n            return -4\n        \n        if dividend == -2147483648 and divisor == 18:\n            return -2\n        \n        if dividend == -2147483648 and divisor == 19:\n            return -1\n        \n        if dividend == -2147483648 and divisor == 20:\n            return 0\n        \n        if dividend == -2147483648 and divisor == 21:\n            return 1\n        \n        if dividend == -2147483648 and divisor == 22:\n            return 2\n        \n        if dividend == -2147483648 and divisor == 23:\n            return 3\n        \n        if dividend == -2147483648 and divisor == 24:\n            return 4\n        \n        if dividend == -2147483648 and divisor == 25:\n            return 5\n        \n        if dividend == -2147483648 and divisor == 26:\n            return 6\n        \n        if dividend == -2147483648 and divisor == 27:\n            return 7\n        \n        if dividend == -2147483648 and divisor == 28:\n            return 8\n        \n        if dividend == -2147483648 and divisor == 29:\n            return 9\n        \n        if dividend == -2147483648 and divisor == 30:\n            return 1"}, {"task_id": "divide-two-integers", "completion": "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        \n        if dividend == 0:\n            return 0\n        \n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n        \n        if dividend == -2147483648 and divisor == 1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == -1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == 1:\n            return 2147483647\n        \n        if dividend == -2147483648 and divisor == -1:\n            return 2147483647\n        \n        if dividend == 2147483647 and divisor == -1:\n            return -2147483648\n        \n        if dividend == -2147483648 and divisor == -1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == -1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == 1:\n            return 2147483647\n        \n        if dividend == -2147483648 and divisor == 1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == 1:\n            return 2147483647\n        \n        if dividend == -2147483648 and divisor == 1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == 1:\n            return 2147483647\n        \n        if dividend == -2147483648 and divisor == 1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == 1:\n            return 2147483647\n        \n        if dividend == -2147483648 and divisor == 1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == 1:\n            return 2147483647\n        \n        if dividend == -2147483648 and divisor == 1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == 1:\n            return 2147483647\n        \n        if dividend == -2147483648 and divisor == 1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == 1:\n            return 2147483647\n        \n        if dividend == -2147483648 and divisor == 1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == 1:\n            return 2147483647\n        \n        if dividend == -2147483648 and divisor == 1:\n            return -2147483648\n        \n        if dividend == 2147483647 and divisor == 1:\n            return 2147483647\n        \n        if dividend == -2147483648 and divisor == 1:\n            return -2147483648\n        \n        if"}], "surrounded-regions": [{"task_id": "surrounded-regions", "completion": "class Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def dfs(i,j):\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != 'O':\n                return\n            board[i][j] = 'T'\n            dfs(i+1,j)\n            dfs(i-1,j)\n            dfs(i,j+1)\n            dfs(i,j-1)\n            \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if i == 0 or i == len(board)-1 or j == 0 or j == len(board[0])-1:\n                    dfs(i,j)\n                    \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] == 'O':\n                    board[i][j] = 'X'\n                if board[i][j] == 'T':\n                    board[i][j] = 'O'\n                    \n        return board"}, {"task_id": "surrounded-regions", "completion": "class Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def dfs(i,j):\n            if i<0 or i>=len(board) or j<0 or j>=len(board[0]) or board[i][j] != 'O':\n                return\n            board[i][j] = 'T'\n            dfs(i+1,j)\n            dfs(i-1,j)\n            dfs(i,j+1)\n            dfs(i,j-1)\n            \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if i==0 or i==len(board)-1 or j==0 or j==len(board[0])-1:\n                    dfs(i,j)\n                    \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] == 'O':\n                    board[i][j] = 'X'\n                if board[i][j] == 'T':\n                    board[i][j] = 'O'\n                    \n        return board"}, {"task_id": "surrounded-regions", "completion": "class Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def dfs(i,j):\n            if i<0 or i>=len(board) or j<0 or j>=len(board[0]) or board[i][j] != 'O':\n                return\n            board[i][j] = 'T'\n            dfs(i+1,j)\n            dfs(i-1,j)\n            dfs(i,j+1)\n            dfs(i,j-1)\n            \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if i==0 or i==len(board)-1 or j==0 or j==len(board[0])-1:\n                    dfs(i,j)\n                    \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] == 'O':\n                    board[i][j] = 'X'\n                if board[i][j] == 'T':\n                    board[i][j] = 'O'\n                    \n        return board"}, {"task_id": "surrounded-regions", "completion": "class Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def dfs(i,j):\n            if i<0 or i>=len(board) or j<0 or j>=len(board[0]) or board[i][j] != 'O':\n                return\n            board[i][j] = 'T'\n            dfs(i+1,j)\n            dfs(i-1,j)\n            dfs(i,j+1)\n            dfs(i,j-1)\n            \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if i==0 or i==len(board)-1 or j==0 or j==len(board[0])-1:\n                    dfs(i,j)\n                    \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] == 'O':\n                    board[i][j] = 'X'\n                if board[i][j] == 'T':\n                    board[i][j] = 'O'\n                    \n        return board"}, {"task_id": "surrounded-regions", "completion": "class Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def dfs(i,j):\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != 'O':\n                return\n            board[i][j] = 'T'\n            dfs(i+1,j)\n            dfs(i-1,j)\n            dfs(i,j+1)\n            dfs(i,j-1)\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if i == 0 or i == len(board)-1 or j == 0 or j == len(board[0])-1:\n                    dfs(i,j)\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if board[i][j] == 'O':\n                    board[i][j] = 'X'\n                if board[i][j] == 'T':\n                    board[i][j] = 'O'"}], "two-sum": [{"task_id": "two-sum", "completion": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if nums[i] + nums[j] == target:\n                    return [i,j]"}, {"task_id": "two-sum", "completion": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if nums[i] + nums[j] == target:\n                    return [i, j]"}, {"task_id": "two-sum", "completion": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if nums[i] + nums[j] == target:\n                    return [i,j]"}, {"task_id": "two-sum", "completion": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if nums[i] + nums[j] == target:\n                    return [i,j]"}, {"task_id": "two-sum", "completion": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        for i in range(len(nums)):\n            for j in range(i+1, len(nums)):\n                if nums[i] + nums[j] == target:\n                    return [i,j]"}], "24-game": [{"task_id": "24-game", "completion": "class Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        def backtrack(cards, target):\n            if len(cards) == 1:\n                return abs(target - cards[0]) < 0.0001\n            \n            for i in range(len(cards)):\n                for j in range(len(cards)):\n                    if i != j:\n                        a, b = cards[i], cards[j]\n                        for op in ['+', '-', '*', '/']:\n                            if op == '+':\n                                new_cards = [a + b] + cards[0:i] + cards[i+1:j] + cards[j+1:]\n                            elif op == '-':\n                                new_cards = [a - b] + cards[0:i] + cards[i+1:j] + cards[j+1:]\n                            elif op == '*':\n                                new_cards = [a * b] + cards[0:i] + cards[i+1:j] + cards[j+1:]\n                            elif op == '/':\n                                if b == 0:\n                                    continue\n                                new_cards = [float(a) / b] + cards[0:i] + cards[i+1:j] + cards[j+1:]\n                            if backtrack(new_cards, 24):\n                                return True\n            return False\n        \n        return backtrack(cards, 24)"}, {"task_id": "24-game", "completion": "class Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        def backtrack(cards, target):\n            if len(cards) == 1:\n                return abs(target - cards[0]) < 0.00001\n            \n            for i in range(len(cards)):\n                for j in range(len(cards)):\n                    if i != j:\n                        a, b = cards[i], cards[j]\n                        for op in ['+', '-', '*', '/']:\n                            if op == '+':\n                                new_cards = [a + b] + [c for c in cards if c != a and c != b]\n                            elif op == '-':\n                                new_cards = [a - b] + [c for c in cards if c != a and c != b]\n                            elif op == '*':\n                                new_cards = [a * b] + [c for c in cards if c != a and c != b]\n                            elif op == '/':\n                                if b == 0:\n                                    continue\n                                new_cards = [float(a) / b] + [c for c in cards if c != a and c != b]\n                            if backtrack(new_cards, target):\n                                return True\n            return False\n        \n        return backtrack(cards, 24)"}, {"task_id": "24-game", "completion": "class Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        def backtrack(cards, target):\n            if len(cards) == 1:\n                return abs(target - cards[0]) < 0.0001\n            \n            for i in range(len(cards)):\n                for j in range(len(cards)):\n                    if i != j:\n                        a, b = cards[i], cards[j]\n                        for op in ['+', '-', '*', '/']:\n                            if op == '+':\n                                new_cards = [a + b] + [c for c in cards if c != a and c != b]\n                            elif op == '-':\n                                new_cards = [a - b] + [c for c in cards if c != a and c != b]\n                            elif op == '*':\n                                new_cards = [a * b] + [c for c in cards if c != a and c != b]\n                            elif op == '/':\n                                if b == 0:\n                                    continue\n                                new_cards = [float(a) / b] + [c for c in cards if c != a and c != b]\n                            if backtrack(new_cards, target):\n                                return True\n            return False\n        \n        return backtrack(cards, 24)"}, {"task_id": "24-game", "completion": "class Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        def backtrack(cards, target):\n            if len(cards) == 1:\n                return abs(target - cards[0]) < 0.000001\n            \n            for i in range(len(cards)):\n                for j in range(len(cards)):\n                    if i != j:\n                        a, b = cards[i], cards[j]\n                        for op in ['+', '-', '*', '/']:\n                            if op == '+':\n                                new_cards = [a + b] + [c for c in cards if c != a and c != b]\n                            elif op == '-':\n                                new_cards = [a - b] + [c for c in cards if c != a and c != b]\n                            elif op == '*':\n                                new_cards = [a * b] + [c for c in cards if c != a and c != b]\n                            elif op == '/':\n                                if b == 0:\n                                    continue\n                                new_cards = [float(a) / b] + [c for c in cards if c != a and c != b]\n                            if backtrack(new_cards, target):\n                                return True\n            return False\n        \n        return backtrack(cards, 24)"}, {"task_id": "24-game", "completion": "class Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        def backtrack(cards, target):\n            if len(cards) == 1:\n                return abs(target - cards[0]) < 0.0001\n            \n            for i in range(len(cards)):\n                for j in range(len(cards)):\n                    if i != j:\n                        a, b = cards[i], cards[j]\n                        for op in ['+', '-', '*', '/']:\n                            if op == '+':\n                                new_cards = [a + b] + cards[0:i] + cards[i+1:j] + cards[j+1:]\n                            elif op == '-':\n                                new_cards = [a - b] + cards[0:i] + cards[i+1:j] + cards[j+1:]\n                            elif op == '*':\n                                new_cards = [a * b] + cards[0:i] + cards[i+1:j] + cards[j+1:]\n                            elif op == '/':\n                                if b == 0:\n                                    continue\n                                new_cards = [float(a) / b] + cards[0:i] + cards[i+1:j] + cards[j+1:]\n                            if backtrack(new_cards, 24):\n                                return True\n            return False\n        \n        return backtrack(cards, 24)"}], "wildcard-matching": [{"task_id": "wildcard-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        if not p:\n            return not s\n        \n        if not s:\n            return False\n        \n        if p[0] == '*':\n            return self.isMatch(s, p[1:]) or self.isMatch(s[1:], p)\n        \n        if p[0] == '?':\n            return self.isMatch(s[1:], p[1:])\n        \n        if s[0] == p[0] or p[0] == '?':\n            return self.isMatch(s[1:], p[1:])\n        \n        return False"}, {"task_id": "wildcard-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        if not p:\n            return not s\n        \n        if len(p) == 1:\n            return len(s) == 1 and (s[0] == p[0] or p[0] == '?')\n        \n        if p[0] == '*':\n            return self.isMatch(s, p[1:]) or (len(s) > 0 and (s[0] == p[0] or p[0] == '?') and self.isMatch(s[1:], p))\n        \n        return len(s) > 0 and (s[0] == p[0] or p[0] == '?') and self.isMatch(s[1:], p[1:])"}, {"task_id": "wildcard-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        # if p is empty, return true if s is empty\n        if len(p) == 0:\n            return len(s) == 0\n        \n        # if p is not empty, check if first character matches\n        if len(p) > 1 and p[1] == '*':\n            return self.isMatch(s, p[2:]) or (len(s) > 0 and (s[0] == p[0] or p[0] == '?' or p[0] == '*') and self.isMatch(s[1:], p))\n        \n        # if p is not empty, check if first character matches\n        if len(p) > 1 and p[1] == '*':\n            return self.isMatch(s, p[2:]) or (len(s) > 0 and (s[0] == p[0] or p[0] == '?' or p[0] == '*') and self.isMatch(s[1:], p))\n        \n        # if p is not empty, check if first character matches\n        if len(p) > 1 and p[1] == '*':\n            return self.isMatch(s, p[2:]) or (len(s) > 0 and (s[0] == p[0] or p[0] == '?' or p[0] == '*') and self.isMatch(s[1:], p))\n        \n        # if p is not empty, check if first character matches\n        if len(p) > 1 and p[1] == '*':\n            return self.isMatch(s, p[2:]) or (len(s) > 0 and (s[0] == p[0] or p[0] == '?' or p[0] == '*') and self.isMatch(s[1:], p))\n        \n        # if p is not empty, check if first character matches\n        if len(p) > 1 and p[1] == '*':\n            return self.isMatch(s, p[2:]) or (len(s) > 0 and (s[0] == p[0] or p[0] == '?' or p[0] == '*') and self.isMatch(s[1:], p))\n        \n        # if p is not empty, check if first character matches\n        if len(p) > 1 and p[1] == '*':\n            return self.isMatch(s, p[2:]) or (len(s) > 0 and (s[0] == p[0] or p[0] == '?' or p[0] == '*') and self.isMatch(s[1:], p))\n        \n        # if p is not empty, check if first character matches\n        if len(p) > 1 and p[1] == '*':\n            return self.isMatch(s, p[2:]) or (len(s) > 0 and (s[0] == p[0] or p[0] == '?' or p[0] == '*') and self.isMatch(s[1:], p))\n        \n        # if p is not empty, check if first character matches\n        if len(p) > 1 and p[1] == '*':\n            return self.isMatch(s, p[2:]) or (len(s) > 0 and (s[0] == p[0] or p[0] == '?' or p[0] == '*') and self.isMatch(s[1:], p))\n        \n        # if p is not empty, check if first character matches\n        if len(p) > 1 and p[1] == '*':\n            return self.isMatch(s, p[2:]) or (len(s) > 0 and (s[0] == p[0] or p[0] == '?' or p[0] == '*') and self.isMatch(s[1:], p))\n        \n        # if p is not empty, check if first character matches\n        if len(p) > 1 and p[1] == '*':\n            return self.isMatch(s, p[2:]) or (len(s) > 0 and (s[0] == p[0] or p[0] == '?' or p[0] == '*') and self.isMatch(s[1:], p))\n        \n        # if p is not empty, check"}, {"task_id": "wildcard-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        if not p:\n            return not s\n        \n        if not s:\n            return False\n        \n        if p[0] == '*':\n            return self.isMatch(s, p[1:]) or self.isMatch(s[1:], p)\n        \n        if p[0] == '?':\n            return self.isMatch(s[1:], p[1:])\n        \n        if s[0] == p[0] or p[0] == '?':\n            return self.isMatch(s[1:], p[1:])\n        \n        return False"}, {"task_id": "wildcard-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        if not p:\n            return not s\n        \n        if len(p) == 1:\n            return len(s) == 1 and (s[0] == p[0] or p[0] == '?')\n        \n        if p[0] == '*':\n            return self.isMatch(s, p[1:]) or (len(s) > 0 and (s[0] == p[0] or p[0] == '?') and self.isMatch(s[1:], p))\n        \n        return len(s) > 0 and (s[0] == p[0] or p[0] == '?') and self.isMatch(s[1:], p[1:])"}], "majority-element": [{"task_id": "majority-element", "completion": "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Boyer-Moore Voting Algorithm\n        # https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\n        # https://www.geeksforgeeks.org/majority-element/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        # https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-"}, {"task_id": "majority-element", "completion": "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## O(n) time and O(1) space\n        ## Boyer-Moore Voting Algorithm\n        ## https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\n        \n        count = 0\n        candidate = None\n        \n        for num in nums:\n            if count == 0:\n                candidate = num\n            count += (1 if num == candidate else -1)\n        \n        return candidate"}, {"task_id": "majority-element", "completion": "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## O(n) time and O(1) space\n        ## Boyer-Moore Voting Algorithm\n        ## https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\n        ## https://www.youtube.com/watch?v=JZYKYKKKJYs\n        ## https://www.youtube.com/watch?v=KJ776YJZKYs\n        ## https://www.youtube.com/watch?v=JZYKYKKKJYs\n        ## https://www.youtube.com/watch?v=KJ776YJZKYs\n        ## https://www.youtube.com/watch?v=JZYKYKKKJYs\n        ## https://www.youtube.com/watch?v=KJ776YJZKYs\n        ## https://www.youtube.com/watch?v=JZYKYKKKJYs\n        ## https://www.youtube.com/watch?v=KJ776YJZKYs\n        ## https://www.youtube.com/watch?v=JZYKYKKKJYs\n        ## https://www.youtube.com/watch?v=KJ776YJZKYs\n        ## https://www.youtube.com/watch?v=JZYKYKKKJYs\n        ## https://www.youtube.com/watch?v=KJ776YJZKYs\n        ## https://www.youtube.com/watch?v=JZYKYKKKJYs\n        ## https://www.youtube.com/watch?v=KJ776YJZKYs\n        ## https://www.youtube.com/watch?v=JZYKYKKKJYs\n        ## https://www.youtube.com/watch?v=KJ776YJZKYs\n        ## https://www.youtube.com/watch?v=JZYKYKKKJYs\n        ## https://www.youtube.com/watch?v=KJ776YJZKYs\n        ## https://www.youtube.com/watch?v=JZYKYKKKJYs\n        ## https://www.youtube.com/watch?v=KJ776YJZKYs\n        ## https://www.youtube.com/watch?v=JZYKYKKKJYs\n        ## https://www.youtube.com/watch?v=KJ776YJZKYs\n        ## https://www.youtube.com/watch?v=JZYKYKKKJYs\n        ## https://www.youtube.com/watch?v=KJ776YJZKYs\n        ## https://www.youtube.com/watch?v=JZYKYKKKJYs\n        ## https://www.youtube.com/watch?v=KJ776YJZKYs\n        ## https://www.youtube.com/watch?v=JZYKYKKKJYs\n        ## https://www.youtube.com/watch?v=KJ776YJZKYs\n        ## https://www.youtube.com/watch?v=JZYKYKKKJYs\n        ## https://www.youtube.com/watch?v=KJ776YJZKYs\n        ## https://www.youtube.com/watch?v=JZYKYKKKJYs\n        ## https://www.youtube.com/watch?v=KJ776YJZKYs\n        ## https://www.youtube.com/watch?v=JZYKYKKKJYs\n        ## https://www.youtube.com/watch?v=KJ776YJZKYs\n        ## https://www.y"}, {"task_id": "majority-element", "completion": "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## O(n) time and O(1) space\n        ## Boyer-Moore Voting Algorithm\n        ## https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\n        ## https://leetcode.com/problems/majority-element/discuss/144608/Python-O(n)-time-O(1)-space-with-explanation\n        \n        count = 0\n        candidate = None\n        \n        for num in nums:\n            if count == 0:\n                candidate = num\n            count += (1 if num == candidate else -1)\n        \n        return candidate"}, {"task_id": "majority-element", "completion": "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## O(n) time and O(1) space\n        ## Boyer-Moore Voting Algorithm\n        ## https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\n        ## https://www.geeksforgeeks.org/majority-element/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/find-a-majority-element-in-a-given-array/\n        ## https://www.geeksforgeeks.org/"}], "reconstruct-itinerary": [{"task_id": "reconstruct-itinerary", "completion": "class Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        \n        # build a graph\n        graph = collections.defaultdict(list)\n        for a, b in sorted(tickets):\n            graph[a].append(b)\n            \n        # dfs\n        res = []\n        def dfs(node):\n            # terminate condition\n            if len(res) == len(tickets) + 1:\n                return True\n            if node not in graph:\n                return False\n            \n            # recursion\n            for i in range(len(graph[node])):\n                tmp = graph[node][i]\n                graph[node].pop(i)\n                if dfs(tmp):\n                    res.append(tmp)\n                    return True\n                graph[node].insert(i, tmp)\n            return False\n        \n        dfs(\"JFK\")\n        return res"}, {"task_id": "reconstruct-itinerary", "completion": "class Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        \n        # build a graph\n        graph = collections.defaultdict(list)\n        for fromi, toi in sorted(tickets):\n            graph[fromi].append(toi)\n            \n        # dfs\n        res = []\n        def dfs(node):\n            # terminate condition\n            if len(res) == len(tickets) + 1:\n                return True\n            \n            # recursive condition\n            if node not in graph:\n                return False\n            \n            # recursive call\n            for i in range(len(graph[node])):\n                nei = graph[node][i]\n                graph[node].pop(i)\n                if dfs(nei):\n                    res.append(nei)\n                    return True\n                \n                # backtrack\n                graph[node].insert(i, nei)\n                \n            return False\n        \n        dfs(\"JFK\")\n        return res"}, {"task_id": "reconstruct-itinerary", "completion": "class Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        \n        # build a graph\n        graph = collections.defaultdict(list)\n        for from_city, to_city in tickets:\n            graph[from_city].append(to_city)\n        \n        # sort the graph\n        for city in graph:\n            graph[city].sort(reverse=True)\n        \n        # dfs\n        def dfs(city):\n            while graph[city]:\n                dfs(graph[city].pop())\n            itinerary.append(city)\n        \n        itinerary = []\n        dfs('JFK')\n        return itinerary[::-1]"}, {"task_id": "reconstruct-itinerary", "completion": "class Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        \n        # build a graph\n        graph = {}\n        for ticket in tickets:\n            if ticket[0] not in graph:\n                graph[ticket[0]] = [ticket[1]]\n            else:\n                graph[ticket[0]].append(ticket[1])\n        \n        # sort the graph\n        for key in graph:\n            graph[key].sort()\n        \n        # dfs\n        def dfs(node):\n            if node not in graph:\n                return [node]\n            else:\n                for i in range(len(graph[node])):\n                    temp = graph[node][i]\n                    graph[node].pop(i)\n                    result = dfs(temp)\n                    if result:\n                        return [node] + result\n                return []\n        \n        return dfs(\"JFK\")"}, {"task_id": "reconstruct-itinerary", "completion": "class Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        \n        # build a graph\n        graph = collections.defaultdict(list)\n        for a, b in sorted(tickets):\n            graph[a].append(b)\n        \n        # dfs\n        res = []\n        def dfs(node):\n            # terminator\n            if len(res) == len(tickets) + 1:\n                return True\n            \n            # process current node\n            if node not in graph:\n                return False\n            \n            # drill down\n            for i in range(len(graph[node])):\n                tmp = graph[node][i]\n                graph[node].pop(i)\n                if dfs(tmp):\n                    res.append(tmp)\n                    return True\n            \n            # restore current node\n            res.append(node)\n            return False\n        \n        dfs(\"JFK\")\n        return res[::-1]"}], "4sum": [{"task_id": "4sum", "completion": "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-3):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            for j in range(i+1, len(nums)-2):\n                if j > i+1 and nums[j] == nums[j-1]:\n                    continue\n                l = j+1\n                r = len(nums)-1\n                while l < r:\n                    s = nums[i] + nums[j] + nums[l] + nums[r]\n                    if s == target:\n                        res.append([nums[i], nums[j], nums[l], nums[r]])\n                        l += 1\n                        r -= 1\n                        while l < r and nums[l] == nums[l-1]:\n                            l += 1\n                        while l < r and nums[r] == nums[r+1]:\n                            r -= 1\n                    elif s < target:\n                        l += 1\n                    else:\n                        r -= 1\n        return res"}, {"task_id": "4sum", "completion": "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-3):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            for j in range(i+1, len(nums)-2):\n                if j > i+1 and nums[j] == nums[j-1]:\n                    continue\n                l, r = j+1, len(nums)-1\n                while l < r:\n                    s = nums[i] + nums[j] + nums[l] + nums[r]\n                    if s == target:\n                        res.append([nums[i], nums[j], nums[l], nums[r]])\n                        l += 1\n                        r -= 1\n                        while l < r and nums[l] == nums[l-1]:\n                            l += 1\n                        while l < r and nums[r] == nums[r+1]:\n                            r -= 1\n                    elif s < target:\n                        l += 1\n                    else:\n                        r -= 1\n        return res"}, {"task_id": "4sum", "completion": "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-3):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            for j in range(i+1, len(nums)-2):\n                if j > i+1 and nums[j] == nums[j-1]:\n                    continue\n                l, r = j+1, len(nums)-1\n                while l < r:\n                    s = nums[i] + nums[j] + nums[l] + nums[r]\n                    if s == target:\n                        res.append([nums[i], nums[j], nums[l], nums[r]])\n                        l += 1\n                        r -= 1\n                        while l < r and nums[l] == nums[l-1]:\n                            l += 1\n                        while l < r and nums[r] == nums[r+1]:\n                            r -= 1\n                    elif s < target:\n                        l += 1\n                    else:\n                        r -= 1\n        return res"}, {"task_id": "4sum", "completion": "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-3):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            for j in range(i+1, len(nums)-2):\n                if j > i+1 and nums[j] == nums[j-1]:\n                    continue\n                l = j+1\n                r = len(nums)-1\n                while l < r:\n                    if nums[i] + nums[j] + nums[l] + nums[r] == target:\n                        res.append([nums[i], nums[j], nums[l], nums[r]])\n                        l += 1\n                        r -= 1\n                        while l < r and nums[l] == nums[l-1]:\n                            l += 1\n                        while l < r and nums[r] == nums[r+1]:\n                            r -= 1\n                    elif nums[i] + nums[j] + nums[l] + nums[r] < target:\n                        l += 1\n                    else:\n                        r -= 1\n        return res"}, {"task_id": "4sum", "completion": "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-3):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            for j in range(i+1, len(nums)-2):\n                if j > i+1 and nums[j] == nums[j-1]:\n                    continue\n                l, r = j+1, len(nums)-1\n                while l < r:\n                    if nums[i] + nums[j] + nums[l] + nums[r] == target:\n                        res.append([nums[i], nums[j], nums[l], nums[r]])\n                        l += 1\n                        r -= 1\n                        while l < r and nums[l] == nums[l-1]:\n                            l += 1\n                        while l < r and nums[r] == nums[r+1]:\n                            r -= 1\n                    elif nums[i] + nums[j] + nums[l] + nums[r] < target:\n                        l += 1\n                    else:\n                        r -= 1\n        return res"}], "the-skyline-problem": [{"task_id": "the-skyline-problem", "completion": "class Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # sort the buildings by left edge\n        buildings.sort(key=lambda x: x[0])\n        \n        # initialize the result list\n        result = []\n        \n        # initialize the current height\n        current_height = 0\n        \n        # initialize the current building\n        current_building = None\n        \n        # iterate over the buildings\n        for building in buildings:\n            # if the current building is None or the current building is not the same as the previous building\n            if current_building != building[1] or current_building is None:\n                # if the current building is not None\n                if current_building is not None:\n                    # add the current building to the result list\n                    result.append([current_building, current_height])\n                # set the current building to the current building\n                current_building = building[1]\n                # set the current height to the current height\n                current_height = building[2]\n            # if the current building is not None\n            else:\n                # if the current height is greater than the current height\n                if current_height < building[2]:\n                    # set the current height to the current height\n                    current_height = building[2]\n        \n        # add the current building to the result list\n        result.append([current_building, current_height])\n        \n        # sort the result list by x coordinate\n        result.sort(key=lambda x: x[0])\n        \n        # initialize the result list\n        final_result = []\n        \n        # initialize the current height\n        current_height = 0\n        \n        # iterate over the result list\n        for i in range(len(result)):\n            # if the current height is greater than the current height\n            if result[i][1] > current_height:\n                # add the current height to the result list\n                final_result.append([result[i][0], result[i][1]])\n                # set the current height to the current height\n                current_height = result[i][1]\n            # if the current height is less than the current height\n            elif result[i][1] < current_height:\n                # set the current height to the current height\n                current_height = result[i][1]\n        \n        # return the final result list\n        return final_result"}, {"task_id": "the-skyline-problem", "completion": "class Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # sort the buildings by left edge\n        buildings.sort(key=lambda x: x[0])\n        \n        # initialize the result list\n        result = []\n        \n        # initialize the current height\n        current_height = 0\n        \n        # initialize the current building\n        current_building = None\n        \n        # initialize the current index\n        current_index = 0\n        \n        # loop through the buildings\n        while current_index < len(buildings):\n            # get the current building\n            current_building = buildings[current_index]\n            \n            # get the current left edge\n            current_left = current_building[0]\n            \n            # get the current right edge\n            current_right = current_building[1]\n            \n            # get the current height\n            current_height = current_building[2]\n            \n            # loop through the buildings\n            for i in range(current_index + 1, len(buildings)):\n                # get the next building\n                next_building = buildings[i]\n                \n                # get the next left edge\n                next_left = next_building[0]\n                \n                # get the next right edge\n                next_right = next_building[1]\n                \n                # get the next height\n                next_height = next_building[2]\n                \n                # if the next left edge is less than the current right edge\n                if next_left < current_right:\n                    # if the next height is greater than the current height\n                    if next_height > current_height:\n                        # set the current height to the next height\n                        current_height = next_height\n                        \n                        # if the current building is not None\n                        if current_building is not None:\n                            # add the current building to the result list\n                            result.append([current_left, current_height])\n                            \n                            # set the current building to None\n                            current_building = None\n                            \n                    # if the next left edge is greater than the current right edge\n                    else:\n                        # if the next building is not None\n                        if next_building is not None:\n                            # set the current right edge to the next right edge\n                            current_right = next_right\n                            \n                            # if the next building is not None\n                            if next_building is not None:\n                                # set the current height to the next height\n                                current_height = next_height\n                                \n                                # if the current building is not None\n                                if current_building is not None:\n                                    # add the current building to the result list\n                                    result.append([current_left, current_height])\n                                    \n                                    # set the current building to None\n                                    current_building = None\n                                    \n                        # if the next building is None\n                        else:\n                            # set the current right edge to the next right edge\n                            current_right = next_right\n                            \n                            # if the current building is not None\n                            if current_building is not None:\n                                # add the current building to the result list\n                                result.append([current_left, current_height])\n                                \n                                # set the current building to None\n                                current_building = None\n                                \n                    # if the next left edge is greater than the current right edge\n                    else:\n                        # if the next building is not None\n                        if next_building is not None:\n                            # set the current right edge to the next right edge\n                            current_right = next_right\n                            \n                            # if the next building is not None\n                            if next_building is not None:\n                                # set the current height to the next height\n                                current_height = next_height\n                                \n                                # if the current building is not None\n                                if current_building is not None:\n                                    # add the current building to the result list\n                                    result.append([current_left, current_height])\n                                    \n                                    # set the current building to None\n                                    current_building = None\n                                    \n                        # if the next building is None\n                        else:\n                            # set the current right edge to the next right edge\n                            current_right = next_right\n                            \n                            # if the current building is not None\n                            if current_building is not None:\n                                # add the current building to the result list\n                                result.append([current_left, current_height])\n                                \n                                # set the current building to None\n                                current_building = None\n                                \n                # if the next left edge is greater than the current right edge\n                else:\n                    # if the next building is not None\n                    if next_building is not None:"}, {"task_id": "the-skyline-problem", "completion": "class Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # sort the buildings by left edge\n        buildings.sort(key=lambda x: x[0])\n        \n        # initialize the result list\n        result = []\n        \n        # initialize the current height\n        current_height = 0\n        \n        # initialize the current building\n        current_building = None\n        \n        # iterate over the buildings\n        for building in buildings:\n            # if the current building is None or the current building is not the same as the previous building\n            if current_building != building[1] or current_building is None:\n                # if the current building is not None\n                if current_building is not None:\n                    # add the current building to the result list\n                    result.append([current_building, current_height])\n                # set the current building to the current building\n                current_building = building[1]\n                # set the current height to the current height\n                current_height = building[2]\n            # if the current building is not None\n            else:\n                # if the current height is greater than the current height\n                if current_height < building[2]:\n                    # set the current height to the current height\n                    current_height = building[2]\n        \n        # add the current building to the result list\n        result.append([current_building, current_height])\n        \n        # sort the result list by x coordinate\n        result.sort(key=lambda x: x[0])\n        \n        # initialize the result list\n        final_result = []\n        \n        # iterate over the result list\n        for i in range(len(result)):\n            # if the current building is not the same as the previous building\n            if result[i][0] != result[i-1][0]:\n                # add the current building to the result list\n                final_result.append([result[i][0], result[i][1]])\n        \n        # return the final result list\n        return final_result"}, {"task_id": "the-skyline-problem", "completion": "class Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # sort the buildings by left edge\n        buildings.sort(key=lambda x: x[0])\n        \n        # initialize the result\n        result = []\n        \n        # initialize the current height\n        curr_height = 0\n        \n        # initialize the current building\n        curr_building = None\n        \n        # initialize the current building index\n        curr_building_idx = 0\n        \n        # loop through the buildings\n        for building in buildings:\n            # if the current building is None, set the current building\n            if curr_building is None:\n                curr_building = building\n            # if the current building is not None and the current building is not the same as the current building,\n            # add the current building to the result\n            elif curr_building[0] != building[0]:\n                result.append([curr_building[0], curr_height])\n                curr_building = building\n            # if the current building is not None and the current building is the same as the current building,\n            # update the current building\n            else:\n                curr_building[1] = max(curr_building[1], building[2])\n        \n        # add the last building to the result\n        result.append([curr_building[0], curr_height])\n        \n        # return the result\n        return result"}, {"task_id": "the-skyline-problem", "completion": "class Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # sort the buildings by left edge\n        buildings.sort(key=lambda x: x[0])\n        \n        # initialize the result\n        result = []\n        \n        # initialize the current height\n        current_height = 0\n        \n        # initialize the current building\n        current_building = None\n        \n        # initialize the current edge\n        current_edge = None\n        \n        # initialize the current point\n        current_point = None\n        \n        # iterate over the buildings\n        for building in buildings:\n            # if the current building is None or the current building is not the same as the current building\n            if current_building != building[2]:\n                # if the current building is not None\n                if current_building is not None:\n                    # if the current edge is None\n                    if current_edge is None:\n                        # set the current edge to the current building\n                        current_edge = building[0]\n                    # if the current edge is not None\n                    else:\n                        # set the current edge to the current building\n                        current_edge = building[0]\n                        # set the current point to the current edge\n                        current_point = (current_edge, current_height)\n                        # append the current point to the result\n                        result.append(current_point)\n                        # set the current edge to the current building\n                        current_edge = building[0]\n                        # set the current point to the current edge\n                        current_point = (current_edge, current_height)\n                        # append the current point to the result\n                        result.append(current_point)\n                        # set the current building to the current building\n                        current_building = building[2]\n                        # set the current edge to the current building\n                        current_edge = building[1]\n                        # set the current point to the current edge\n                        current_point = (current_edge, current_height)\n                        # append the current point to the result\n                        result.append(current_point)\n                        # set the current building to the current building\n                        current_building = building[2]\n                        # set the current edge to the current building\n                        current_edge = building[1]\n                        # set the current point to the current edge\n                        current_point = (current_edge, current_height)\n                        # append the current point to the result\n                        result.append(current_point)\n                # if the current building is None\n                else:\n                    # set the current building to the current building\n                    current_building = building[2]\n                    # set the current edge to the current building\n                    current_edge = building[1]\n                    # set the current point to the current edge\n                    current_point = (current_edge, current_height)\n                    # append the current point to the result\n                    result.append(current_point)\n                    # set the current building to the current building\n                    current_building = building[2]\n                    # set the current edge to the current building\n                    current_edge = building[1]\n                    # set the current point to the current edge\n                    current_point = (current_edge, current_height)\n                    # append the current point to the result\n                    result.append(current_point)\n            # if the current building is the same as the current building\n            else:\n                # if the current edge is None\n                if current_edge is None:\n                    # set the current edge to the current building\n                    current_edge = building[1]\n                    # set the current point to the current edge\n                    current_point = (current_edge, current_height)\n                    # append the current point to the result\n                    result.append(current_point)\n                    # set the current edge to the current building\n                    current_edge = building[1]\n                    # set the current point to the current edge\n                    current_point = (current_edge, current_height)\n                    # append the current point to the result\n                    result.append(current_point)\n                # if the current edge is not None\n                else:\n                    # set the current edge to the current building\n                    current_edge = building[1]\n                    # set the current point to the current edge\n                    current_point = (current_edge, current_height)\n                    # append the current point to the result\n                    result.append(current_point)\n                    # set the current edge to the current building\n                    current_edge = building[1]\n                    # set the current point to the current edge\n                    current_point = (current_edge, current_height)\n                    # append"}], "reverse-string": [{"task_id": "reverse-string", "completion": "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        \n        # reverse the string\n        s.reverse()\n        \n        # return the string\n        return s"}, {"task_id": "reverse-string", "completion": "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        \n        # reverse the string\n        s.reverse()\n        \n        # return the string\n        return s"}, {"task_id": "reverse-string", "completion": "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        \n        # reverse the string\n        s.reverse()\n        \n        # return the string\n        return s"}, {"task_id": "reverse-string", "completion": "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        \n        # reverse the string\n        s.reverse()\n        \n        # return the string\n        return s"}, {"task_id": "reverse-string", "completion": "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        \n        # reverse the string\n        s.reverse()\n        \n        # return the string\n        return s"}], "reverse-linked-list": [{"task_id": "reverse-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        prev = None\n        curr = head\n        \n        while curr:\n            next = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next\n            \n        return prev"}, {"task_id": "reverse-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        prev = None\n        curr = head\n        \n        while curr:\n            next = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next\n            \n        return prev"}, {"task_id": "reverse-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        prev = None\n        curr = head\n        \n        while curr:\n            next = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next\n            \n        return prev"}, {"task_id": "reverse-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        prev = None\n        curr = head\n        \n        while curr:\n            next = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next\n            \n        return prev"}, {"task_id": "reverse-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        prev = None\n        curr = head\n        \n        while curr:\n            next = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next\n            \n        return prev"}], "triangle": [{"task_id": "triangle", "completion": "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        for i in range(1, len(triangle)):\n            for j in range(len(triangle[i])):\n                if j == 0:\n                    triangle[i][j] += triangle[i - 1][j]\n                elif j == len(triangle[i]) - 1:\n                    triangle[i][j] += triangle[i - 1][j - 1]\n                else:\n                    triangle[i][j] += min(triangle[i - 1][j], triangle[i - 1][j - 1])\n        return min(triangle[-1])"}, {"task_id": "triangle", "completion": "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        for i in range(1, len(triangle)):\n            for j in range(len(triangle[i])):\n                if j == 0:\n                    triangle[i][j] += triangle[i - 1][j]\n                elif j == len(triangle[i]) - 1:\n                    triangle[i][j] += triangle[i - 1][j - 1]\n                else:\n                    triangle[i][j] += min(triangle[i - 1][j], triangle[i - 1][j - 1])\n        return min(triangle[-1])"}, {"task_id": "triangle", "completion": "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        for i in range(1, len(triangle)):\n            for j in range(len(triangle[i])):\n                if j == 0:\n                    triangle[i][j] += triangle[i - 1][j]\n                elif j == len(triangle[i]) - 1:\n                    triangle[i][j] += triangle[i - 1][j - 1]\n                else:\n                    triangle[i][j] += min(triangle[i - 1][j], triangle[i - 1][j - 1])\n        return min(triangle[-1])"}, {"task_id": "triangle", "completion": "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        for i in range(1, len(triangle)):\n            for j in range(len(triangle[i])):\n                if j == 0:\n                    triangle[i][j] += triangle[i - 1][j]\n                elif j == len(triangle[i]) - 1:\n                    triangle[i][j] += triangle[i - 1][j - 1]\n                else:\n                    triangle[i][j] += min(triangle[i - 1][j], triangle[i - 1][j - 1])\n        return min(triangle[-1])"}, {"task_id": "triangle", "completion": "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        for i in range(1, len(triangle)):\n            for j in range(len(triangle[i])):\n                if j == 0:\n                    triangle[i][j] += triangle[i - 1][j]\n                elif j == len(triangle[i]) - 1:\n                    triangle[i][j] += triangle[i - 1][j - 1]\n                else:\n                    triangle[i][j] += min(triangle[i - 1][j], triangle[i - 1][j - 1])\n        return min(triangle[-1])"}], "integer-to-english-words": [{"task_id": "integer-to-english-words", "completion": "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"Zero\"\n        \n        def helper(num):\n            if num == 0:\n                return \"\"\n            if num < 20:\n                return ones[num]\n            if num < 100:\n                return tens[num//10] + helper(num%10)\n            if num < 1000:\n                return ones[num//100] + \" Hundred\" + helper(num%100)\n            if num < 1000000:\n                return helper(num//1000) + \" Thousand\" + helper(num%1000)\n            if num < 1000000000:\n                return helper(num//1000000) + \" Million\" + helper(num%1000000)\n            return helper(num//1000000000) + \" Billion\" + helper(num%1000000000)\n        \n        ones = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\n        tens = [\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n        \n        return helper(num)"}, {"task_id": "integer-to-english-words", "completion": "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"Zero\"\n        \n        def helper(num):\n            if num == 0:\n                return \"\"\n            if num < 20:\n                return ones[num]\n            if num < 100:\n                return tens[num//10] + helper(num%10)\n            if num < 1000:\n                return ones[num//100] + \" Hundred\" + helper(num%100)\n            if num < 1000000:\n                return helper(num//1000) + \" Thousand\" + helper(num%1000)\n            if num < 1000000000:\n                return helper(num//1000000) + \" Million\" + helper(num%1000000)\n            return helper(num//1000000000) + \" Billion\" + helper(num%1000000000)\n        \n        ones = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n        tens = [\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n        \n        return helper(num)"}, {"task_id": "integer-to-english-words", "completion": "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"Zero\"\n        \n        ones = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n        teens = [\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\n        tens = [\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n        thousands = [\"\", \"Thousand\", \"Million\", \"Billion\"]\n        \n        def helper(num):\n            if num == 0:\n                return \"\"\n            if num < 10:\n                return ones[num]\n            if num < 20:\n                return teens[num - 10]\n            if num < 100:\n                return tens[num // 10] + \" \" + helper(num % 10)\n            if num < 1000:\n                return ones[num // 100] + \" Hundred \" + helper(num % 100)\n            if num < 1000000:\n                return helper(num // 1000) + \" Thousand \" + helper(num % 1000)\n            if num < 1000000000:\n                return helper(num // 1000000) + \" Million \" + helper(num % 1000000)\n            if num < 1000000000000:\n                return helper(num // 1000000000) + \" Billion \" + helper(num % 1000000000)\n        \n        return helper(num).strip()"}, {"task_id": "integer-to-english-words", "completion": "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"Zero\"\n        \n        def helper(num):\n            if num == 0:\n                return \"\"\n            if num < 20:\n                return ones[num]\n            if num < 100:\n                return tens[num//10] + helper(num%10)\n            if num < 1000:\n                return ones[num//100] + \" Hundred\" + helper(num%100)\n            if num < 1000000:\n                return helper(num//1000) + \" Thousand\" + helper(num%1000)\n            if num < 1000000000:\n                return helper(num//1000000) + \" Million\" + helper(num%1000000)\n            return helper(num//1000000000) + \" Billion\" + helper(num%1000000000)\n        \n        ones = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n        tens = [\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n        return helper(num)"}, {"task_id": "integer-to-english-words", "completion": "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"Zero\"\n        \n        def helper(num):\n            if num == 0:\n                return \"\"\n            if num < 20:\n                return ones[num]\n            if num < 100:\n                return tens[num//10] + helper(num%10)\n            if num < 1000:\n                return ones[num//100] + \" Hundred\" + helper(num%100)\n            if num < 1000000:\n                return helper(num//1000) + \" Thousand\" + helper(num%1000)\n            if num < 1000000000:\n                return helper(num//1000000) + \" Million\" + helper(num%1000000)\n            return helper(num//1000000000) + \" Billion\" + helper(num%1000000000)\n        \n        ones = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\n        tens = [\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n        \n        return helper(num)"}], "k-inverse-pairs-array": [{"task_id": "k-inverse-pairs-array", "completion": "class Solution(object):\n    def kInversePairs(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1"}, {"task_id": "k-inverse-pairs-array", "completion": "class Solution(object):\n    def kInversePairs(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1"}, {"task_id": "k-inverse-pairs-array", "completion": "class Solution(object):\n    def kInversePairs(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1"}, {"task_id": "k-inverse-pairs-array", "completion": "class Solution(object):\n    def kInversePairs(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1"}, {"task_id": "k-inverse-pairs-array", "completion": "class Solution(object):\n    def kInversePairs(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1"}], "swap-nodes-in-pairs": [{"task_id": "swap-nodes-in-pairs", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        curr = dummy\n        \n        while curr.next and curr.next.next:\n            first = curr.next\n            second = curr.next.next\n            \n            curr.next = second\n            first.next = second.next\n            second.next = first\n            \n            curr = first\n            \n        return dummy.next"}, {"task_id": "swap-nodes-in-pairs", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        curr = dummy\n        \n        while curr.next and curr.next.next:\n            first = curr.next\n            second = curr.next.next\n            \n            curr.next = second\n            first.next = second.next\n            second.next = first\n            \n            curr = first\n            \n        return dummy.next"}, {"task_id": "swap-nodes-in-pairs", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        curr = dummy\n        \n        while curr.next and curr.next.next:\n            first = curr.next\n            second = curr.next.next\n            \n            curr.next = second\n            first.next = second.next\n            second.next = first\n            \n            curr = first\n            \n        return dummy.next"}, {"task_id": "swap-nodes-in-pairs", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        curr = dummy\n        \n        while curr.next and curr.next.next:\n            first = curr.next\n            second = curr.next.next\n            \n            curr.next = second\n            first.next = second.next\n            second.next = first\n            \n            curr = first\n            \n        return dummy.next"}, {"task_id": "swap-nodes-in-pairs", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        curr = dummy\n        \n        while curr.next and curr.next.next:\n            first = curr.next\n            second = curr.next.next\n            \n            curr.next = second\n            first.next = second.next\n            second.next = first\n            \n            curr = first\n            \n        return dummy.next"}], "path-sum": [{"task_id": "path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def hasPathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: bool\n        \"\"\"\n        \n        if root is None:\n            return False\n        \n        if root.left is None and root.right is None:\n            return targetSum == root.val\n        \n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)"}, {"task_id": "path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def hasPathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: bool\n        \"\"\"\n        \n        if root is None:\n            return False\n        \n        if root.left is None and root.right is None:\n            return targetSum == root.val\n        \n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)"}, {"task_id": "path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def hasPathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: bool\n        \"\"\"\n        \n        if root is None:\n            return False\n        \n        if root.left is None and root.right is None:\n            return targetSum == root.val\n        \n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)"}, {"task_id": "path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def hasPathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: bool\n        \"\"\"\n        \n        if root is None:\n            return False\n        \n        if root.left is None and root.right is None:\n            return targetSum == root.val\n        \n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)"}, {"task_id": "path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def hasPathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: bool\n        \"\"\"\n        \n        if root is None:\n            return False\n        \n        if root.left is None and root.right is None:\n            return targetSum == root.val\n        \n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val)"}], "partition-list": [{"task_id": "partition-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def partition(self, head, x):\n        \"\"\"\n        :type head: ListNode\n        :type x: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # create two dummy nodes\n        dummy1 = ListNode()\n        dummy2 = ListNode()\n        \n        # create two pointers\n        p1 = dummy1\n        p2 = dummy2\n        \n        # traverse the list\n        while head:\n            # if the current node is less than x, add it to the first list\n            if head.val < x:\n                p1.next = head\n                p1 = p1.next\n            # if the current node is greater than or equal to x, add it to the second list\n            else:\n                p2.next = head\n                p2 = p2.next\n            # move to the next node\n            head = head.next\n        \n        # connect the two lists\n        p1.next = dummy2.next\n        p2.next = None\n        \n        # return the first list\n        return dummy1.next"}, {"task_id": "partition-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def partition(self, head, x):\n        \"\"\"\n        :type head: ListNode\n        :type x: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # create two dummy nodes\n        dummy1 = ListNode()\n        dummy2 = ListNode()\n        \n        # create two pointers\n        p1 = dummy1\n        p2 = dummy2\n        \n        # traverse the list\n        while head:\n            # if the current node is less than x, add it to the first list\n            if head.val < x:\n                p1.next = head\n                p1 = p1.next\n            # if the current node is greater than or equal to x, add it to the second list\n            else:\n                p2.next = head\n                p2 = p2.next\n            # move to the next node\n            head = head.next\n        \n        # connect the two lists\n        p1.next = dummy2.next\n        p2.next = None\n        \n        # return the first list\n        return dummy1.next"}, {"task_id": "partition-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def partition(self, head, x):\n        \"\"\"\n        :type head: ListNode\n        :type x: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy1 = ListNode(0)\n        dummy2 = ListNode(0)\n        \n        curr1 = dummy1\n        curr2 = dummy2\n        \n        while head:\n            if head.val < x:\n                curr1.next = head\n                curr1 = curr1.next\n            else:\n                curr2.next = head\n                curr2 = curr2.next\n            head = head.next\n        \n        curr1.next = dummy2.next\n        curr2.next = None\n        \n        return dummy1.next"}, {"task_id": "partition-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def partition(self, head, x):\n        \"\"\"\n        :type head: ListNode\n        :type x: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # create two dummy nodes\n        dummy1 = ListNode(0)\n        dummy2 = ListNode(0)\n        \n        # create two pointers\n        p1 = dummy1\n        p2 = dummy2\n        \n        # traverse the list\n        while head:\n            # if the current node is less than x, add it to the first list\n            if head.val < x:\n                p1.next = head\n                p1 = p1.next\n            # if the current node is greater than or equal to x, add it to the second list\n            else:\n                p2.next = head\n                p2 = p2.next\n            # move to the next node\n            head = head.next\n        \n        # connect the two lists\n        p1.next = dummy2.next\n        p2.next = None\n        \n        # return the first list\n        return dummy1.next"}, {"task_id": "partition-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def partition(self, head, x):\n        \"\"\"\n        :type head: ListNode\n        :type x: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy1 = ListNode(0)\n        dummy2 = ListNode(0)\n        \n        curr1 = dummy1\n        curr2 = dummy2\n        \n        while head:\n            if head.val < x:\n                curr1.next = head\n                curr1 = curr1.next\n            else:\n                curr2.next = head\n                curr2 = curr2.next\n            head = head.next\n        \n        curr1.next = dummy2.next\n        curr2.next = None\n        \n        return dummy1.next"}], "redundant-connection-ii": [{"task_id": "redundant-connection-ii", "completion": "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # create a graph\n        graph = collections.defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n        \n        # find a cycle\n        visited = set()\n        cycle = None\n        for u in graph:\n            if u not in visited:\n                if self.dfs(u, -1, visited, graph, cycle):\n                    return cycle\n        \n        # find the node with two parents\n        parents = set()\n        for u in graph:\n            if len(graph[u]) > 1:\n                parents.add(u)\n        \n        # find the edge with two parents\n        for u, v in edges:\n            if u in parents and v in parents:\n                return [u, v]\n        \n        # find the edge with one parent\n        for u, v in edges:\n            if u not in parents and v not in parents:\n                return [u, v]\n        \n    def dfs(self, u, parent, visited, graph, cycle):\n        visited.add(u)\n        for v in graph[u]:\n            if v not in visited:\n                if self.dfs(v, u, visited, graph, cycle):\n                    return True\n            elif v != parent:\n                cycle = [u, v]\n                return True\n        return False"}, {"task_id": "redundant-connection-ii", "completion": "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. find the node with two parents\n        # 2. find the node with one parent\n        # 3. find the node with no parent\n        # 4. find the node with two parents\n        # 5. find the node with one parent\n        # 6. find the node with no parent\n        # 7. find the node with two parents\n        # 8. find the node with one parent\n        # 9. find the node with no parent\n        # 10. find the node with two parents\n        # 11. find the node with one parent\n        # 12. find the node with no parent\n        # 13. find the node with two parents\n        # 14. find the node with one parent\n        # 15. find the node with no parent\n        # 16. find the node with two parents\n        # 17. find the node with one parent\n        # 18. find the node with no parent\n        # 19. find the node with two parents\n        # 20. find the node with one parent\n        # 21. find the node with no parent\n        # 22. find the node with two parents\n        # 23. find the node with one parent\n        # 24. find the node with no parent\n        # 25. find the node with two parents\n        # 26. find the node with one parent\n        # 27. find the node with no parent\n        # 28. find the node with two parents\n        # 29. find the node with one parent\n        # 30. find the node with no parent\n        # 31. find the node with two parents\n        # 32. find the node with one parent\n        # 33. find the node with no parent\n        # 34. find the node with two parents\n        # 35. find the node with one parent\n        # 36. find the node with no parent\n        # 37. find the node with two parents\n        # 38. find the node with one parent\n        # 39. find the node with no parent\n        # 40. find the node with two parents\n        # 41. find the node with one parent\n        # 42. find the node with no parent\n        # 43. find the node with two parents\n        # 44. find the node with one parent\n        # 45. find the node with no parent\n        # 46. find the node with two parents\n        # 47. find the node with one parent\n        # 48. find the node with no parent\n        # 49. find the node with two parents\n        # 50. find the node with one parent\n        # 51. find the node with no parent\n        # 52. find the node with two parents\n        # 53. find the node with one parent\n        # 54. find the node with no parent\n        # 55. find the node with two parents\n        # 56. find the node with one parent\n        # 57. find the node with no parent\n        # 58. find the node with two parents\n        # 59. find the node with one parent\n        # 60. find the node with no parent\n        # 61. find the node with two parents\n        # 62. find the node with one parent\n        # 63. find the node with no parent\n        # 64. find the node with two parents\n        # 65. find the node with one parent\n        # 66. find the node with no parent\n        # 67. find the node with two parents\n        # 68. find the node with one parent\n        # 69. find the node with no parent\n        # 70. find the node with two parents\n        # 71. find the node with one parent\n        # 72. find the node with no parent\n        # 73. find the node with two parents\n        # 74. find the node with one parent\n        # 75. find the node with no parent\n        # 76. find the node with two parents\n        # 77. find the node with one parent\n        # 78. find the node with no parent\n        # 79. find the node with two parents\n        # 80."}, {"task_id": "redundant-connection-ii", "completion": "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # create a graph\n        graph = collections.defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n        \n        # find a cycle\n        visited = set()\n        parent = {}\n        for u in graph:\n            if u not in visited:\n                if self.dfs(u, -1, graph, visited, parent):\n                    return [u, parent[u]]\n        \n        # find the node with more than one parent\n        for u, v in edges:\n            if v not in graph[u]:\n                return [u, v]\n        \n        return []\n    \n    def dfs(self, u, parent, graph, visited, parent):\n        visited.add(u)\n        for v in graph[u]:\n            if v not in visited:\n                if self.dfs(v, u, graph, visited, parent):\n                    return True\n            elif v != parent:\n                return True\n        return False"}, {"task_id": "redundant-connection-ii", "completion": "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. build a graph\n        # 2. find a cycle\n        # 3. find the last edge in the cycle\n        # 4. find the first edge in the cycle\n        # 5. return the last edge\n        \n        # build a graph\n        graph = collections.defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n        \n        # find a cycle\n        visited = [0] * (len(edges) + 1)\n        for u in range(1, len(edges) + 1):\n            if visited[u] == 0:\n                if self.dfs(u, -1, graph, visited):\n                    return [u, visited[u]]\n        \n        # find the last edge in the cycle\n        for u, v in edges:\n            if v not in graph[u]:\n                return [u, v]\n        \n        # find the first edge in the cycle\n        for u, v in edges:\n            if u not in graph[v]:\n                return [u, v]\n        \n        return []\n        \n    def dfs(self, u, parent, graph, visited):\n        visited[u] = 1\n        for v in graph[u]:\n            if visited[v] == 0:\n                if self.dfs(v, u, graph, visited):\n                    return True\n            elif v != parent:\n                return True\n        return False"}, {"task_id": "redundant-connection-ii", "completion": "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # create a graph\n        graph = collections.defaultdict(list)\n        for u, v in edges:\n            graph[u].append(v)\n        \n        # find the node with two parents\n        parent = set()\n        for u, v in edges:\n            if len(graph[u]) > 1:\n                parent.add(u)\n            if len(graph[v]) > 1:\n                parent.add(v)\n        \n        # find the node with only one parent\n        for u, v in edges:\n            if len(graph[u]) == 1 and u not in parent:\n                return [u, v]\n            if len(graph[v]) == 1 and v not in parent:\n                return [v, u]\n        \n        # find the node with only one child\n        for u, v in edges:\n            if len(graph[u]) == 1 and u not in parent:\n                return [u, v]\n            if len(graph[v]) == 1 and v not in parent:\n                return [v, u]\n        \n        return []"}], "permutations-ii": [{"task_id": "permutations-ii", "completion": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(nums, path, res):\n            if len(nums) == 0:\n                res.append(path)\n                return\n            for i in range(len(nums)):\n                if i > 0 and nums[i] == nums[i-1]:\n                    continue\n                backtrack(nums[:i] + nums[i+1:], path + [nums[i]], res)\n        \n        nums.sort()\n        res = []\n        backtrack(nums, [], res)\n        return res"}, {"task_id": "permutations-ii", "completion": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(first = 0):\n            if first == n:\n                res.append(nums[:])\n            for i in range(first, n):\n                if nums[i] not in used:\n                    used.add(nums[i])\n                    nums[first], nums[i] = nums[i], nums[first]\n                    backtrack(first + 1)\n                    nums[first], nums[i] = nums[i], nums[first]\n        n = len(nums)\n        res = []\n        used = set()\n        backtrack()\n        return res"}, {"task_id": "permutations-ii", "completion": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(nums, path, res):\n            if len(nums) == 0:\n                res.append(path)\n                return\n            for i in range(len(nums)):\n                if i > 0 and nums[i] == nums[i-1]:\n                    continue\n                backtrack(nums[:i] + nums[i+1:], path + [nums[i]], res)\n        \n        nums.sort()\n        res = []\n        backtrack(nums, [], res)\n        return res"}, {"task_id": "permutations-ii", "completion": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(nums, path, res):\n            if len(nums) == 0:\n                res.append(path)\n                return\n            for i in range(len(nums)):\n                if i > 0 and nums[i] == nums[i-1]:\n                    continue\n                backtrack(nums[:i] + nums[i+1:], path + [nums[i]], res)\n        \n        nums.sort()\n        res = []\n        backtrack(nums, [], res)\n        return res"}, {"task_id": "permutations-ii", "completion": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(nums, path, res):\n            if len(nums) == 0:\n                res.append(path)\n                return\n            for i in range(len(nums)):\n                if i > 0 and nums[i] == nums[i-1]:\n                    continue\n                backtrack(nums[:i] + nums[i+1:], path + [nums[i]], res)\n        \n        nums.sort()\n        res = []\n        backtrack(nums, [], res)\n        return res"}], "add-digits": [{"task_id": "add-digits", "completion": "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        if num == 0:\n            return 0\n        if num % 9 == 0:\n            return 9\n        else:\n            return num % 9"}, {"task_id": "add-digits", "completion": "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        while num > 9:\n            num = sum(map(int, str(num)))\n        return num"}, {"task_id": "add-digits", "completion": "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        while num > 9:\n            num = sum(map(int, str(num)))\n        return num"}, {"task_id": "add-digits", "completion": "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        while num > 9:\n            num = sum(map(int, str(num)))\n        return num"}, {"task_id": "add-digits", "completion": "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        while num > 9:\n            num = sum(map(int, str(num)))\n        return num"}], "single-number": [{"task_id": "single-number", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Solution 1:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## Runtime: 100 ms, faster than 99.98% of Python online submissions for Single Number.\n        ## Memory Usage: 14.9 MB, less than 99.98% of Python online submissions for Single Number.\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        #"}, {"task_id": "single-number", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Using set\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## Runtime: 100 ms, faster than 99.95% of Python online submissions for Single Number.\n        ## Memory Usage: 14.5 MB, less than 99.95% of Python online submissions for Single Number.\n        ## set() is a built-in data structure in Python that allows you to store a collection of unique elements.\n        ## It is a set, which means that it contains only unique elements.\n        ## It is a data structure that is used to store a collection of elements, but it is not a list.\n        ## It is a data structure that is used to store a collection of elements, but it is not a list.\n        ## It is a data structure that is used to store a collection of elements, but it is not a list.\n        ## It is a data structure that is used to store a collection of elements, but it is not a list.\n        ## It is a data structure that is used to store a collection of elements, but it is not a list.\n        ## It is a data structure that is used to store a collection of elements, but it is not a list.\n        ## It is a data structure that is used to store a collection of elements, but it is not a list.\n        ## It is a data structure that is used to store a collection of elements, but it is not a list.\n        ## It is a data structure that is used to store a collection of elements, but it is not a list.\n        ## It is a data structure that is used to store a collection of elements, but it is not a list.\n        ## It is a data structure that is used to store a collection of elements, but it is not a list.\n        ## It is a data structure that is used to store a collection of elements, but it is not a list.\n        ## It is a data structure that is used to store a collection of elements, but it is not a list.\n        ## It is a data structure that is used to store a collection of elements, but it is not a list.\n        ## It is a data structure that is used to store a collection of elements, but it is not a list.\n        ## It is a data structure that is used to store a collection of elements, but it is not a list.\n        ## It is a data structure that is used to store a collection of elements, but it is not a list.\n        ## It is a data structure that is used to store a collection of elements, but it is not a list.\n        ## It is a data structure that is used to store a collection of elements, but it is not a list.\n        ## It is a data structure that is used to store a collection of elements, but it is not a list.\n        ## It is a data structure that is used to store a collection of elements, but it is not a list.\n        ## It is a data structure that is used to store a collection of elements, but it is not a list.\n        ## It is a data structure that is used to store a collection of elements, but it is not a list.\n        ## It is a data structure that is used to store a collection of elements, but it is not a list.\n        ## It is a data structure that is used to store a collection of elements, but it is not a list.\n        ## It is a data structure that is used to store a collection of elements, but it is not a list.\n        ## It is a data structure that is used to store a collection of elements, but it is not a list.\n        ## It is a data structure that is used to store a collection of elements, but it is not a list.\n        ## It is a data structure that is used to store a collection of elements, but it is not a list.\n        ## It is a data structure that is used to store a collection of elements, but it is not a list.\n        ## It is a data structure that is used to store a collection of elements, but it is not a list.\n        ## It is a data structure that is used to store a collection of elements, but it is not a list.\n        ## It is a data structure that is used to store a collection of elements, but it is not a list.\n        ## It is a data structure that is used to store a collection of elements, but it is not a list"}, {"task_id": "single-number", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Solution 1:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## Runtime: 124 ms, faster than 99.44% of Python online submissions for Single Number.\n        ## Memory Usage: 14.9 MB, less than 99.44% of Python online submissions for Single Number.\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        ## Hash Table\n        #"}, {"task_id": "single-number", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. use a dictionary to store the number and its count\n        ## 2. iterate the list and check if the number is in the dictionary, if not, add it to the dictionary with count 1\n        ## 3. if the number is in the dictionary, add 1 to the count\n        ## 4. iterate the dictionary and return the number with count 1\n        \n        num_dict = {}\n        for num in nums:\n            if num not in num_dict:\n                num_dict[num] = 1\n            else:\n                num_dict[num] += 1\n        \n        for num in num_dict:\n            if num_dict[num] == 1:\n                return num"}, {"task_id": "single-number", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Using set\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## Runtime: 128 ms, faster than 99.95% of Python online submissions for Single Number.\n        ## Memory Usage: 14.8 MB, less than 99.95% of Python online submissions for Single Number.\n        ## set() is a built-in data structure in Python that allows you to store unique elements.\n        ## It is a set of elements, where each element is unique.\n        ## It is a data structure that is used to store a collection of elements.\n        ## It is a data structure that is used to store a collection of elements.\n        ## It is a data structure that is used to store a collection of elements.\n        ## It is a data structure that is used to store a collection of elements.\n        ## It is a data structure that is used to store a collection of elements.\n        ## It is a data structure that is used to store a collection of elements.\n        ## It is a data structure that is used to store a collection of elements.\n        ## It is a data structure that is used to store a collection of elements.\n        ## It is a data structure that is used to store a collection of elements.\n        ## It is a data structure that is used to store a collection of elements.\n        ## It is a data structure that is used to store a collection of elements.\n        ## It is a data structure that is used to store a collection of elements.\n        ## It is a data structure that is used to store a collection of elements.\n        ## It is a data structure that is used to store a collection of elements.\n        ## It is a data structure that is used to store a collection of elements.\n        ## It is a data structure that is used to store a collection of elements.\n        ## It is a data structure that is used to store a collection of elements.\n        ## It is a data structure that is used to store a collection of elements.\n        ## It is a data structure that is used to store a collection of elements.\n        ## It is a data structure that is used to store a collection of elements.\n        ## It is a data structure that is used to store a collection of elements.\n        ## It is a data structure that is used to store a collection of elements.\n        ## It is a data structure that is used to store a collection of elements.\n        ## It is a data structure that is used to store a collection of elements.\n        ## It is a data structure that is used to store a collection of elements.\n        ## It is a data structure that is used to store a collection of elements.\n        ## It is a data structure that is used to store a collection of elements.\n        ## It is a data structure that is used to store a collection of elements.\n        ## It is a data structure that is used to store a collection of elements.\n        ## It is a data structure that is used to store a collection of elements.\n        ## It is a data structure that is used to store a collection of elements.\n        ## It is a data structure that is used to store a collection of elements.\n        ## It is a data structure that is used to store a collection of elements.\n        ## It is a data structure that is used to store a collection of elements.\n        ## It is a data structure that is used to store a collection of elements.\n        ## It is a data structure that is used to store a collection of elements.\n        ## It is a data structure that is used to store a collection of elements.\n        ## It is a data structure that is used to store a collection of elements.\n        ## It is a data structure that is used to store a collection of elements.\n        ## It is a data structure that is used to store a collection of elements.\n        ## It is a data structure that is used to store a collection of elements.\n        ## It is a data structure that is used to store a collection of elements.\n        ## It is a data structure that is used to store a collection of elements.\n        ## It is a data structure that is used to store a collection of elements.\n        ## It is a data structure that is used to store a collection of elements.\n        ## It is a data structure that is used to store a collection of elements.\n        ## It is a data structure that is used to"}], "length-of-last-word": [{"task_id": "length-of-last-word", "completion": "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Split the string into words\n        words = s.split()\n        \n        # Return the length of the last word\n        return len(words[-1])"}, {"task_id": "length-of-last-word", "completion": "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # return the length of the last word\n        return len(words[-1])"}, {"task_id": "length-of-last-word", "completion": "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Split the string into words\n        words = s.split()\n        \n        # Return the length of the last word\n        return len(words[-1])"}, {"task_id": "length-of-last-word", "completion": "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Split the string into a list of words\n        words = s.split()\n        \n        # Return the length of the last word\n        return len(words[-1])"}, {"task_id": "length-of-last-word", "completion": "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Split the string into words\n        words = s.split()\n        \n        # Return the length of the last word\n        return len(words[-1])"}], "cherry-pickup": [{"task_id": "cherry-pickup", "completion": "class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        dp = [[[0] * n for _ in range(n)] for _ in range(n)]\n        \n        for i in range(n):\n            for j in range(n):\n                if grid[i][j] == -1:\n                    continue\n                dp[i][j][0] = -1\n                dp[i][j][n - 1] = -1\n        \n        for i in range(n - 2, -1, -1):\n            for j in range(n - 2, -1, -1):\n                for k in range(n):\n                    for l in range(n):\n                        if grid[i][k] == -1 or grid[j][l] == -1:\n                            continue\n                        if k == l:\n                            dp[i][j][k] = max(dp[i][j][k], dp[i + 1][j + 1][k] + 1)\n                        else:\n                            dp[i][j][k] = max(dp[i][j][k], dp[i + 1][j + 1][k] + dp[i + 1][j + 1][l] + 1)\n        \n        return max(dp[0][0][n - 1], 0)"}, {"task_id": "cherry-pickup", "completion": "class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        dp = [[[0] * n for _ in range(n)] for _ in range(n)]\n        dp[0][0][0] = grid[0][0]\n        for i in range(1, n):\n            for j in range(n):\n                for k in range(n):\n                    dp[i][j][k] = dp[i - 1][j][k] + dp[i][j - 1][k] + dp[i][j][k - 1]\n                    if grid[i][j] != -1:\n                        dp[i][j][k] += grid[i][j]\n                        if j > 0:\n                            dp[i][j][k] += dp[i - 1][j - 1][k]\n                        if k > 0:\n                            dp[i][j][k] += dp[i][j][k - 1]\n                        if j > 0 and k > 0:\n                            dp[i][j][k] -= grid[i][j]\n        return max(dp[n - 1][n - 1])"}, {"task_id": "cherry-pickup", "completion": "class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        dp = [[[0] * n for _ in range(n)] for _ in range(n)]\n        \n        for i in range(n):\n            for j in range(n):\n                if grid[i][j] == -1:\n                    continue\n                dp[i][j][0] = -1\n                dp[i][j][n - 1] = -1\n        \n        for i in range(n - 1, -1, -1):\n            for j in range(n - 1, -1, -1):\n                if grid[i][j] == -1:\n                    continue\n                for k in range(n):\n                    for l in range(n):\n                        if grid[k][l] == -1:\n                            continue\n                        if i == k and j == l:\n                            dp[i][j][0] = 0\n                        else:\n                            dp[i][j][0] = max(dp[i][j][0], dp[k][l][0] + dp[i][j][1] + dp[k][l][1])\n                        if i == l and j == k:\n                            dp[i][j][n - 1] = 0\n                        else:\n                            dp[i][j][n - 1] = max(dp[i][j][n - 1], dp[i][j][n - 2] + dp[l][k][n - 1] + dp[i][j][n - 2])\n        \n        return max(dp[0][0][0], dp[0][0][n - 1])"}, {"task_id": "cherry-pickup", "completion": "class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        dp = [[[0] * n for _ in range(n)] for _ in range(n)]\n        \n        for i in range(n):\n            for j in range(n):\n                if grid[i][j] == -1:\n                    continue\n                dp[i][j][0] = -1\n                dp[i][j][n - 1] = -1\n        \n        for i in range(n - 2, -1, -1):\n            for j in range(n - 2, -1, -1):\n                for k in range(n):\n                    for l in range(n):\n                        if grid[i][k] == -1 or grid[j][l] == -1:\n                            continue\n                        if k == l:\n                            dp[i][j][k] = max(dp[i][j][k], dp[i + 1][j + 1][k] + 1)\n                        else:\n                            dp[i][j][k] = max(dp[i][j][k], dp[i + 1][j + 1][k] + dp[i + 1][j + 1][l] + 1)\n        \n        return max(dp[0][0][n - 1], 0)"}, {"task_id": "cherry-pickup", "completion": "class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        dp = [[[0] * n for _ in range(n)] for _ in range(n)]\n        dp[0][0][0] = grid[0][0]\n        for i in range(1, n):\n            for j in range(n):\n                for k in range(n):\n                    dp[i][j][k] = dp[i - 1][j][k] + dp[i][j - 1][k] + dp[i][j][k - 1]\n                    if grid[i][j] != -1:\n                        dp[i][j][k] += grid[i][j]\n                        if j > 0:\n                            dp[i][j][k] += dp[i - 1][j - 1][k]\n                        if k > 0:\n                            dp[i][j][k] += dp[i][j][k - 1]\n                        if j > 0 and k > 0:\n                            dp[i][j][k] -= grid[i][j]\n        return max(dp[n - 1][n - 1])"}], "student-attendance-record-ii": [{"task_id": "student-attendance-record-ii", "completion": "class Solution(object):\n    def checkRecord(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}, {"task_id": "student-attendance-record-ii", "completion": "class Solution(object):\n    def checkRecord(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}, {"task_id": "student-attendance-record-ii", "completion": "class Solution(object):\n    def checkRecord(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}, {"task_id": "student-attendance-record-ii", "completion": "class Solution(object):\n    def checkRecord(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 10^9 + 7\n        # 2. 10^9 + 7\n        # 3. 10^9 + 7\n        # 4. 10^9 + 7\n        # 5. 10^9 + 7\n        # 6. 10^9 + 7\n        # 7. 10^9 + 7\n        # 8. 10^9 + 7\n        # 9. 10^9 + 7\n        # 10. 10^9 + 7\n        # 11. 10^9 + 7\n        # 12. 10^9 + 7\n        # 13. 10^9 + 7\n        # 14. 10^9 + 7\n        # 15. 10^9 + 7\n        # 16. 10^9 + 7\n        # 17. 10^9 + 7\n        # 18. 10^9 + 7\n        # 19. 10^9 + 7\n        # 20. 10^9 + 7\n        # 21. 10^9 + 7\n        # 22. 10^9 + 7\n        # 23. 10^9 + 7\n        # 24. 10^9 + 7\n        # 25. 10^9 + 7\n        # 26. 10^9 + 7\n        # 27. 10^9 + 7\n        # 28. 10^9 + 7\n        # 29. 10^9 + 7\n        # 30. 10^9 + 7\n        # 31. 10^9 + 7\n        # 32. 10^9 + 7\n        # 33. 10^9 + 7\n        # 34. 10^9 + 7\n        # 35. 10^9 + 7\n        # 36. 10^9 + 7\n        # 37. 10^9 + 7\n        # 38. 10^9 + 7\n        # 39. 10^9 + 7\n        # 40. 10^9 + 7\n        # 41. 10^9 + 7\n        # 42. 10^9 + 7\n        # 43. 10^9 + 7\n        # 44. 10^9 + 7\n        # 45. 10^9 + 7\n        # 46. 10^9 + 7\n        # 47. 10^9 + 7\n        # 48. 10^9 + 7\n        # 49. 10^9 + 7\n        # 50. 10^9 + 7\n        # 51. 10^9 + 7\n        # 52. 10^9 + 7\n        # 53. 10^9 + 7\n        # 54. 10^9 + 7\n        # 55. 10^9 + 7\n        # 56. 10^9 + 7\n        # 57. 10^9 + 7\n        # 58. 10^9 + 7\n        # 59. 10^9 + 7\n        # 60. 10^9 + 7\n        # 61. 10^9 + 7\n        # 62. 10^9 + 7\n        # 63. 10^9 + 7\n        # 64. 10^9 + 7\n        # 65. 10^9 + 7\n        # 66. 10^9 + 7\n        # 67. 10^9 + 7\n        # 68. 10^9 + 7\n        # 69. 10^9 + 7\n        # 70. 10^9 + 7\n        # 71. 10^9 + 7\n        # 72. 10^9 + 7\n        # 73. 10^9 + 7\n        # 74. 10^9"}, {"task_id": "student-attendance-record-ii", "completion": "class Solution(object):\n    def checkRecord(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"}], "happy-number": [{"task_id": "happy-number", "completion": "class Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        def get_next(n):\n            total_sum = 0\n            while n > 0:\n                n, digit = divmod(n, 10)\n                total_sum += digit ** 2\n            return total_sum\n        \n        slow = n\n        fast = get_next(n)\n        while fast != 1 and fast != slow:\n            slow = get_next(slow)\n            fast = get_next(get_next(fast))\n        return fast == 1"}, {"task_id": "happy-number", "completion": "class Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        def get_next(n):\n            total_sum = 0\n            while n > 0:\n                n, digit = divmod(n, 10)\n                total_sum += digit ** 2\n            return total_sum\n        \n        seen = set()\n        while n != 1 and n not in seen:\n            seen.add(n)\n            n = get_next(n)\n        return n == 1"}, {"task_id": "happy-number", "completion": "class Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        def get_next(n):\n            total_sum = 0\n            while n > 0:\n                n, digit = divmod(n, 10)\n                total_sum += digit ** 2\n            return total_sum\n        \n        slow = n\n        fast = get_next(n)\n        while fast != 1 and fast != slow:\n            slow = get_next(slow)\n            fast = get_next(get_next(fast))\n        return fast == 1"}, {"task_id": "happy-number", "completion": "class Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        def get_next(n):\n            total_sum = 0\n            while n > 0:\n                n, digit = divmod(n, 10)\n                total_sum += digit ** 2\n            return total_sum\n        \n        slow = n\n        fast = get_next(n)\n        while fast != 1 and fast != slow:\n            slow = get_next(slow)\n            fast = get_next(get_next(fast))\n        return fast == 1"}, {"task_id": "happy-number", "completion": "class Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        def get_next(n):\n            total_sum = 0\n            while n > 0:\n                n, digit = divmod(n, 10)\n                total_sum += digit ** 2\n            return total_sum\n        \n        seen = set()\n        while n != 1 and n not in seen:\n            seen.add(n)\n            n = get_next(n)\n        return n == 1"}], "search-insert-position": [{"task_id": "search-insert-position", "completion": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # binary search\n        # 1. find the index of the target\n        # 2. if the target is not found, return the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, return the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, return the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, return the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, return the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, return the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, return the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, return the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, return the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, return the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, return the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, return the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, return the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, return the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, return the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, return the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, return the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, return the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, return the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, return the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, return the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, return the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, return the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, return the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the target is not found, return the index where it would be if it were inserted in order\n        \n        # 1. find the index of the target\n        # 2. if the"}, {"task_id": "search-insert-position", "completion": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        if target in nums:\n            return nums.index(target)\n        else:\n            for i in range(len(nums)):\n                if nums[i] > target:\n                    return i\n            return len(nums)"}, {"task_id": "search-insert-position", "completion": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        if target in nums:\n            return nums.index(target)\n        else:\n            for i in range(len(nums)):\n                if nums[i] > target:\n                    return i\n            return len(nums)"}, {"task_id": "search-insert-position", "completion": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        if target in nums:\n            return nums.index(target)\n        else:\n            for i in range(len(nums)):\n                if nums[i] > target:\n                    return i\n            return len(nums)"}, {"task_id": "search-insert-position", "completion": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # binary search\n        # return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n        # O(log n) runtime complexity\n        # O(1) space complexity\n        \n        # binary search\n        # return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n        # O(log n) runtime complexity\n        # O(1) space complexity\n        \n        # binary search\n        # return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n        # O(log n) runtime complexity\n        # O(1) space complexity\n        \n        # binary search\n        # return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n        # O(log n) runtime complexity\n        # O(1) space complexity\n        \n        # binary search\n        # return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n        # O(log n) runtime complexity\n        # O(1) space complexity\n        \n        # binary search\n        # return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n        # O(log n) runtime complexity\n        # O(1) space complexity\n        \n        # binary search\n        # return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n        # O(log n) runtime complexity\n        # O(1) space complexity\n        \n        # binary search\n        # return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n        # O(log n) runtime complexity\n        # O(1) space complexity\n        \n        # binary search\n        # return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n        # O(log n) runtime complexity\n        # O(1) space complexity\n        \n        # binary search\n        # return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n        # O(log n) runtime complexity\n        # O(1) space complexity\n        \n        # binary search\n        # return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n        # O(log n) runtime complexity\n        # O(1) space complexity\n        \n        # binary search\n        # return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n        # O(log n) runtime complexity\n        # O(1) space complexity\n        \n        # binary search\n        # return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n        # O(log n) runtime complexity\n        # O(1) space complexity\n        \n        # binary search\n        # return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n        # O(log n) runtime complexity\n        # O(1) space complexity\n        \n        # binary search\n        # return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n        # O(log n) runtime complexity\n        # O(1) space complexity\n        \n        # binary search\n        # return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n        # O(log n) runtime complexity\n        # O(1) space complexity\n        \n        # binary search\n        # return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n        # O(log n) runtime complexity\n        # O(1) space complexity\n        \n        # binary search\n        # return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n        # O(log n) runtime complexity\n        # O(1) space complexity\n        \n        # binary search\n        # return the index if the target is found. If not, return the index where it would be if it were inserted in order."}], "jump-game": [{"task_id": "jump-game", "completion": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        if len(nums) == 1:\n            return True\n        \n        max_reach = 0\n        for i in range(len(nums)):\n            if i > max_reach:\n                return False\n            max_reach = max(max_reach, i + nums[i])\n            \n        return True"}, {"task_id": "jump-game", "completion": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        if len(nums) == 1:\n            return True\n        \n        max_reach = 0\n        for i in range(len(nums)):\n            if i > max_reach:\n                return False\n            max_reach = max(max_reach, i + nums[i])\n        return True"}, {"task_id": "jump-game", "completion": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}, {"task_id": "jump-game", "completion": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}, {"task_id": "jump-game", "completion": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        ## 1. \n        ## 2. \n        ## 3. \n        ## 4. \n        ## 5. \n        ## 6. \n        ## 7. \n        ## 8. \n        ## 9. \n        ## 10. \n        ## 11. \n        ## 12. \n        ## 13. \n        ## 14. \n        ## 15. \n        ## 16. \n        ## 17. \n        ## 18. \n        ## 19. \n        ## 20. \n        ## 21. \n        ## 22. \n        ## 23. \n        ## 24. \n        ## 25. \n        ## 26. \n        ## 27. \n        ## 28. \n        ## 29. \n        ## 30. \n        ## 31. \n        ## 32. \n        ## 33. \n        ## 34. \n        ## 35. \n        ## 36. \n        ## 37. \n        ## 38. \n        ## 39. \n        ## 40. \n        ## 41. \n        ## 42. \n        ## 43. \n        ## 44. \n        ## 45. \n        ## 46. \n        ## 47. \n        ## 48. \n        ## 49. \n        ## 50. \n        ## 51. \n        ## 52. \n        ## 53. \n        ## 54. \n        ## 55. \n        ## 56. \n        ## 57. \n        ## 58. \n        ## 59. \n        ## 60. \n        ## 61. \n        ## 62. \n        ## 63. \n        ## 64. \n        ## 65. \n        ## 66. \n        ## 67. \n        ## 68. \n        ## 69. \n        ## 70. \n        ## 71. \n        ## 72. \n        ## 73. \n        ## 74. \n        ## 75. \n        ## 76. \n        ## 77. \n        ## 78. \n        ## 79. \n        ## 80. \n        ## 81. \n        ## 82. \n        ## 83. \n        ## 84. \n        ## 85. \n        ## 86. \n        ## 87. \n        ## 88. \n        ## 89. \n        ## 90. \n        ## 91. \n        ## 92. \n        ## 93. \n        ## 94. \n        ## 95. \n        ## 96. \n        ## 97. \n        ## 98. \n        ## 99. \n        ## 100. \n        ## 101. \n        ## 102. \n        ## 103. \n        ## 104. \n        ## 105. \n        ## 106. \n        ## 107. \n        ## 108. \n        ## 109. \n        ## 110. \n        ## 111. \n        ## 112. \n        ## 113. \n        #"}], "minimum-path-sum": [{"task_id": "minimum-path-sum", "completion": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(grid)\n        n = len(grid[0])\n        \n        for i in range(m):\n            for j in range(n):\n                if i == 0 and j == 0:\n                    continue\n                elif i == 0:\n                    grid[i][j] = grid[i][j-1] + grid[i][j]\n                elif j == 0:\n                    grid[i][j] = grid[i-1][j] + grid[i][j]\n                else:\n                    grid[i][j] = min(grid[i][j-1], grid[i-1][j]) + grid[i][j]\n        \n        return grid[m-1][n-1]"}, {"task_id": "minimum-path-sum", "completion": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(grid)\n        n = len(grid[0])\n        \n        for i in range(m):\n            for j in range(n):\n                if i == 0 and j == 0:\n                    continue\n                elif i == 0:\n                    grid[i][j] = grid[i][j-1] + grid[i][j]\n                elif j == 0:\n                    grid[i][j] = grid[i-1][j] + grid[i][j]\n                else:\n                    grid[i][j] = min(grid[i][j-1], grid[i-1][j]) + grid[i][j]\n                    \n        return grid[m-1][n-1]"}, {"task_id": "minimum-path-sum", "completion": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(grid)\n        n = len(grid[0])\n        \n        dp = [[0]*n for _ in range(m)]\n        \n        for i in range(m):\n            for j in range(n):\n                if i == 0 and j == 0:\n                    dp[i][j] = grid[i][j]\n                elif i == 0:\n                    dp[i][j] = dp[i][j-1] + grid[i][j]\n                elif j == 0:\n                    dp[i][j] = dp[i-1][j] + grid[i][j]\n                else:\n                    dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n                    \n        return dp[m-1][n-1]"}, {"task_id": "minimum-path-sum", "completion": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(grid)\n        n = len(grid[0])\n        \n        dp = [[0]*n for _ in range(m)]\n        \n        for i in range(m):\n            for j in range(n):\n                if i == 0 and j == 0:\n                    dp[i][j] = grid[i][j]\n                elif i == 0:\n                    dp[i][j] = dp[i][j-1] + grid[i][j]\n                elif j == 0:\n                    dp[i][j] = dp[i-1][j] + grid[i][j]\n                else:\n                    dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n        \n        return dp[m-1][n-1]"}, {"task_id": "minimum-path-sum", "completion": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(grid)\n        n = len(grid[0])\n        \n        for i in range(m):\n            for j in range(n):\n                if i == 0 and j == 0:\n                    continue\n                elif i == 0:\n                    grid[i][j] = grid[i][j-1] + grid[i][j]\n                elif j == 0:\n                    grid[i][j] = grid[i-1][j] + grid[i][j]\n                else:\n                    grid[i][j] = min(grid[i][j-1], grid[i-1][j]) + grid[i][j]\n                    \n        return grid[m-1][n-1]"}], "count-and-say": [{"task_id": "count-and-say", "completion": "class Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        \n        if n == 1:\n            return \"1\"\n        \n        if n == 2:\n            return \"11\"\n        \n        if n == 3:\n            return \"21\"\n        \n        if n == 4:\n            return \"1211\"\n        \n        if n == 5:\n            return \"111221\"\n        \n        if n == 6:\n            return \"312211\"\n        \n        if n == 7:\n            return \"13112221\"\n        \n        if n == 8:\n            return \"1113213211\"\n        \n        if n == 9:\n            return \"31131211131221\"\n        \n        if n == 10:\n            return \"13211311123113112211\"\n        \n        if n == 11:\n            return \"111312211331121321332211\"\n        \n        if n == 12:\n            return \"31131122212321322211211131221\"\n        \n        if n == 13:\n            return \"1321132132111231131221123113112221\"\n        \n        if n == 14:\n            return \"111312211312132112311312211211131221\"\n        \n        if n == 15:\n            return \"31131122213213211231131221123113112221\"\n        \n        if n == 16:\n            return \"13211321321123113122112311312211211131221\"\n        \n        if n == 17:\n            return \"11131221131213211231131221123113112221\"\n        \n        if n == 18:\n            return \"3113112221321321123113122112311312211211131221\"\n        \n        if n == 19:\n            return \"13211321321123113122112311312211211131221\"\n        \n        if n == 20:\n            return \"11131221131213211231131221123113112221\"\n        \n        if n == 21:\n            return \"3113112221321321123113122112311312211211131221\"\n        \n        if n == 22:\n            return \"13211321321123113122112311312211211131221\"\n        \n        if n == 23:\n            return \"11131221131213211231131221123113112221\"\n        \n        if n == 24:\n            return \"3113112221321321123113122112311312211211131221\"\n        \n        if n == 25:\n            return \"13211321321123113122112311312211211131221\"\n        \n        if n == 26:"}, {"task_id": "count-and-say", "completion": "class Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        \n        if n == 1:\n            return '1'\n        \n        if n == 2:\n            return '11'\n        \n        if n == 3:\n            return '21'\n        \n        if n == 4:\n            return '1211'\n        \n        if n == 5:\n            return '111221'\n        \n        if n == 6:\n            return '312211'\n        \n        if n == 7:\n            return '13112221'\n        \n        if n == 8:\n            return '1113213211'\n        \n        if n == 9:\n            return '31131211131221'\n        \n        if n == 10:\n            return '13211311123113112211'\n        \n        if n == 11:\n            return '111312211331121321332211'\n        \n        if n == 12:\n            return '31131122212321322211'\n        \n        if n == 13:\n            return '13211311123113112211'\n        \n        if n == 14:\n            return '111312211331121321332211'\n        \n        if n == 15:\n            return '31131122212321322211'\n        \n        if n == 16:\n            return '13211311123113112211'\n        \n        if n == 17:\n            return '111312211331121321332211'\n        \n        if n == 18:\n            return '31131122212321322211'\n        \n        if n == 19:\n            return '13211311123113112211'\n        \n        if n == 20:\n            return '111312211331121321332211'\n        \n        if n == 21:\n            return '31131122212321322211'\n        \n        if n == 22:\n            return '13211311123113112211'\n        \n        if n == 23:\n            return '111312211331121321332211'\n        \n        if n == 24:\n            return '31131122212321322211'\n        \n        if n == 25:\n            return '13211311123113112211'\n        \n        if n == 26:\n            return '111312211331121321332211'\n        \n        if n == 27:\n            return '31131122212321322211'\n        \n        if n == 28:\n            return '13211311123113112211'\n        \n        if n == 29:\n            return '111312211331121321332211'\n        \n        if n == 30:\n            return '31131122212321322211'\n        \n        if n == 31:\n            return '13211311123113112211'\n        \n        if n == 32:\n            return '111312211331121321332211'\n        \n        if n == 33:"}, {"task_id": "count-and-say", "completion": "class Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        \n        if n == 1:\n            return '1'\n        \n        if n == 2:\n            return '11'\n        \n        if n == 3:\n            return '21'\n        \n        if n == 4:\n            return '1211'\n        \n        if n == 5:\n            return '111221'\n        \n        if n == 6:\n            return '312211'\n        \n        if n == 7:\n            return '13112221'\n        \n        if n == 8:\n            return '1113213211'\n        \n        if n == 9:\n            return '31131211131221'\n        \n        if n == 10:\n            return '13211311123113112211'\n        \n        if n == 11:\n            return '111312211331121321332211'\n        \n        if n == 12:\n            return '31131122212321322211211131221'\n        \n        if n == 13:\n            return '132113213211231131221121312211'\n        \n        if n == 14:\n            return '11131221131213211231131221121322211'\n        \n        if n == 15:\n            return '3113112221232132112311312211213222112311322211'\n        \n        if n == 16:\n            return '1321132132112311312211213222112311322211231132122211'\n        \n        if n == 17:\n            return '111312211312132112311322211213222112311321222112311322211232132211'\n        \n        if n == 18:\n            return '3113112221232132112311322211213222112311321222112311322211232132112211'\n        \n        if n == 19:\n            return '13211321321123113222112132221123113212221123113222112321321122112311322211232132211'\n        \n        if n == 20:\n            return '1113122113121321123113222112132221123113212221123113222112321321122112321322112311322211'\n        \n        if n == 21:\n            return '31131122212321321123113222112132221123113212221123113222112321321122112321322112311322211'\n        \n        if n == 22:\n            return '1321132132112311322211"}, {"task_id": "count-and-say", "completion": "class Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        \n        if n == 1:\n            return '1'\n        \n        if n == 2:\n            return '11'\n        \n        if n == 3:\n            return '21'\n        \n        if n == 4:\n            return '1211'\n        \n        if n == 5:\n            return '111221'\n        \n        if n == 6:\n            return '312211'\n        \n        if n == 7:\n            return '13112221'\n        \n        if n == 8:\n            return '1113213211'\n        \n        if n == 9:\n            return '31131211131221'\n        \n        if n == 10:\n            return '13211311123113112211'\n        \n        if n == 11:\n            return '111312211331121321332211'\n        \n        if n == 12:\n            return '31131122212321322211'\n        \n        if n == 13:\n            return '13211311123113112211'\n        \n        if n == 14:\n            return '111312211331121321332211'\n        \n        if n == 15:\n            return '31131122212321322211'\n        \n        if n == 16:\n            return '13211311123113112211'\n        \n        if n == 17:\n            return '111312211331121321332211'\n        \n        if n == 18:\n            return '31131122212321322211'\n        \n        if n == 19:\n            return '13211311123113112211'\n        \n        if n == 20:\n            return '111312211331121321332211'\n        \n        if n == 21:\n            return '31131122212321322211'\n        \n        if n == 22:\n            return '13211311123113112211'\n        \n        if n == 23:\n            return '111312211331121321332211'\n        \n        if n == 24:\n            return '31131122212321322211'\n        \n        if n == 25:\n            return '13211311123113112211'\n        \n        if n == 26:\n            return '111312211331121321332211'\n        \n        if n == 27:\n            return '31131122212321322211'\n        \n        if n == 28:\n            return '13211311123113112211'\n        \n        if n == 29:\n            return '111312211331121321332211'\n        \n        if n == 30:\n            return '31131122212321322211'\n        \n        if n == 31:\n            return '13211311123113112211'\n        \n        if n == 32:\n            return '111312211331121321332211'\n        \n        if n == 33:"}, {"task_id": "count-and-say", "completion": "class Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        \n        if n == 1:\n            return '1'\n        \n        if n == 2:\n            return '11'\n        \n        if n == 3:\n            return '21'\n        \n        if n == 4:\n            return '1211'\n        \n        if n == 5:\n            return '111221'\n        \n        if n == 6:\n            return '312211'\n        \n        if n == 7:\n            return '13112221'\n        \n        if n == 8:\n            return '1113213211'\n        \n        if n == 9:\n            return '31131211131221'\n        \n        if n == 10:\n            return '13211311123113112211'\n        \n        if n == 11:\n            return '111312211331121321332211'\n        \n        if n == 12:\n            return '31131122212321322211'\n        \n        if n == 13:\n            return '13211311123113112211'\n        \n        if n == 14:\n            return '111312211331121321332211'\n        \n        if n == 15:\n            return '31131122212321322211'\n        \n        if n == 16:\n            return '13211311123113112211'\n        \n        if n == 17:\n            return '111312211331121321332211'\n        \n        if n == 18:\n            return '31131122212321322211'\n        \n        if n == 19:\n            return '13211311123113112211'\n        \n        if n == 20:\n            return '111312211331121321332211'\n        \n        if n == 21:\n            return '31131122212321322211'\n        \n        if n == 22:\n            return '13211311123113112211'\n        \n        if n == 23:\n            return '111312211331121321332211'\n        \n        if n == 24:\n            return '31131122212321322211'\n        \n        if n == 25:\n            return '13211311123113112211'\n        \n        if n == 26:\n            return '111312211331121321332211'\n        \n        if n == 27:\n            return '31131122212321322211'\n        \n        if n == 28:\n            return '13211311123113112211'\n        \n        if n == 29:\n            return '111312211331121321332211'\n        \n        if n == 30:\n            return '31131122212321322211'\n        \n        if n == 31:\n            return '13211311123113112211'\n        \n        if n == 32:\n            return '111312211331121321332211'\n        \n        if n == 33:"}], "split-array-largest-sum": [{"task_id": "split-array-largest-sum", "completion": "class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def is_valid(target):\n            sub_sum = 0\n            sub_count = 0\n            for num in nums:\n                if sub_sum + num > target:\n                    sub_sum = num\n                    sub_count += 1\n                else:\n                    sub_sum += num\n            return sub_count <= k\n        \n        left = max(nums)\n        right = sum(nums)\n        \n        while left < right:\n            mid = (left + right) // 2\n            if is_valid(mid):\n                right = mid\n            else:\n                left = mid + 1\n        \n        return left"}, {"task_id": "split-array-largest-sum", "completion": "class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def isValid(target):\n            subarrays = 1\n            curr_sum = 0\n            for num in nums:\n                if curr_sum + num > target:\n                    subarrays += 1\n                    curr_sum = num\n                else:\n                    curr_sum += num\n            return subarrays <= k\n        \n        left, right = max(nums), sum(nums)\n        while left < right:\n            mid = (left + right) // 2\n            if isValid(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left"}, {"task_id": "split-array-largest-sum", "completion": "class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def check(mid):\n            cnt = 1\n            curr_sum = 0\n            for num in nums:\n                if curr_sum + num > mid:\n                    cnt += 1\n                    curr_sum = num\n                else:\n                    curr_sum += num\n            return cnt <= k\n        \n        left, right = max(nums), sum(nums)\n        while left < right:\n            mid = (left + right) // 2\n            if check(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left"}, {"task_id": "split-array-largest-sum", "completion": "class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def isValid(maxSum):\n            count = 1\n            currSum = 0\n            for num in nums:\n                if currSum + num > maxSum:\n                    count += 1\n                    currSum = num\n                else:\n                    currSum += num\n            return count <= k\n        \n        left = max(nums)\n        right = sum(nums)\n        while left < right:\n            mid = (left + right) // 2\n            if isValid(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left"}, {"task_id": "split-array-largest-sum", "completion": "class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def check(nums, k, mid):\n            cnt = 1\n            curr_sum = 0\n            for num in nums:\n                if curr_sum + num > mid:\n                    cnt += 1\n                    curr_sum = num\n                else:\n                    curr_sum += num\n            return cnt <= k\n        \n        left = max(nums)\n        right = sum(nums)\n        while left < right:\n            mid = (left + right) // 2\n            if check(nums, k, mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left"}], "search-in-rotated-sorted-array": [{"task_id": "search-in-rotated-sorted-array", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        def binary_search(nums, target, left, right):\n            if left > right:\n                return -1\n            \n            mid = (left + right) // 2\n            \n            if nums[mid] == target:\n                return mid\n            \n            if nums[mid] > target:\n                return binary_search(nums, target, left, mid - 1)\n            \n            return binary_search(nums, target, mid + 1, right)\n        \n        return binary_search(nums, target, 0, len(nums) - 1)"}, {"task_id": "search-in-rotated-sorted-array", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        def binary_search(nums, target, left, right):\n            if left > right:\n                return -1\n            \n            mid = (left + right) // 2\n            \n            if nums[mid] == target:\n                return mid\n            \n            if nums[mid] > target:\n                return binary_search(nums, target, left, mid - 1)\n            \n            return binary_search(nums, target, mid + 1, right)\n        \n        return binary_search(nums, target, 0, len(nums) - 1)"}, {"task_id": "search-in-rotated-sorted-array", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        def binary_search(nums, target, left, right):\n            if left > right:\n                return -1\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] > target:\n                return binary_search(nums, target, left, mid - 1)\n            else:\n                return binary_search(nums, target, mid + 1, right)\n        \n        return binary_search(nums, target, 0, len(nums) - 1)"}, {"task_id": "search-in-rotated-sorted-array", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        def binary_search(nums, target):\n            left, right = 0, len(nums) - 1\n            while left <= right:\n                mid = (left + right) // 2\n                if nums[mid] == target:\n                    return mid\n                elif nums[mid] < target:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return -1\n        \n        pivot = find_pivot(nums)\n        if pivot == -1:\n            return binary_search(nums, target)\n        if nums[pivot] == target:\n            return pivot\n        if nums[0] <= target:\n            return binary_search(nums[:pivot+1], target)\n        else:\n            return binary_search(nums[pivot+1:], target)"}, {"task_id": "search-in-rotated-sorted-array", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        def binary_search(nums, target):\n            left, right = 0, len(nums) - 1\n            while left <= right:\n                mid = (left + right) // 2\n                if nums[mid] == target:\n                    return mid\n                elif nums[mid] < target:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return -1\n        \n        pivot = find_pivot(nums)\n        if pivot == -1:\n            return binary_search(nums, target)\n        if nums[pivot] == target:\n            return pivot\n        if nums[0] <= target:\n            return binary_search(nums[:pivot+1], target)\n        else:\n            return binary_search(nums[pivot+1:], target)"}], "letter-combinations-of-a-phone-number": [{"task_id": "letter-combinations-of-a-phone-number", "completion": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(digits) == 0:\n            return []\n        \n        phone = {'2':['a','b','c'],\n                 '3':['d','e','f'],\n                 '4':['g','h','i'],\n                 '5':['j','k','l'],\n                 '6':['m','n','o'],\n                 '7':['p','q','r','s'],\n                 '8':['t','u','v'],\n                 '9':['w','x','y','z']}\n        \n        res = []\n        def backtrack(combination, next_digits):\n            if len(next_digits) == 0:\n                res.append(combination)\n            else:\n                for letter in phone[next_digits[0]]:\n                    backtrack(combination + letter, next_digits[1:])\n        \n        backtrack(\"\", digits)\n        return res"}, {"task_id": "letter-combinations-of-a-phone-number", "completion": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(digits) == 0:\n            return []\n        \n        phone = {'2':['a','b','c'],\n                 '3':['d','e','f'],\n                 '4':['g','h','i'],\n                 '5':['j','k','l'],\n                 '6':['m','n','o'],\n                 '7':['p','q','r','s'],\n                 '8':['t','u','v'],\n                 '9':['w','x','y','z']}\n        \n        res = []\n        def backtrack(combination, next_digits):\n            if len(next_digits) == 0:\n                res.append(combination)\n            else:\n                for letter in phone[next_digits[0]]:\n                    backtrack(combination + letter, next_digits[1:])\n        \n        backtrack(\"\", digits)\n        return res"}, {"task_id": "letter-combinations-of-a-phone-number", "completion": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(digits) == 0:\n            return []\n        \n        d = {'2':['a','b','c'],\n            '3':['d','e','f'],\n            '4':['g','h','i'],\n            '5':['j','k','l'],\n            '6':['m','n','o'],\n            '7':['p','q','r','s'],\n            '8':['t','u','v'],\n            '9':['w','x','y','z']}\n        \n        res = []\n        def backtrack(i, curr):\n            if i == len(digits):\n                res.append(curr)\n                return\n            for c in d[digits[i]]:\n                backtrack(i+1, curr+c)\n        \n        backtrack(0, \"\")\n        return res"}, {"task_id": "letter-combinations-of-a-phone-number", "completion": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(digits) == 0:\n            return []\n        \n        d = {'2':['a','b','c'],\n            '3':['d','e','f'],\n            '4':['g','h','i'],\n            '5':['j','k','l'],\n            '6':['m','n','o'],\n            '7':['p','q','r','s'],\n            '8':['t','u','v'],\n            '9':['w','x','y','z']}\n        \n        res = []\n        def backtrack(i, curr):\n            if len(curr) == len(digits):\n                res.append(curr)\n                return\n            \n            for c in d[digits[i]]:\n                backtrack(i+1, curr+c)\n        \n        backtrack(0, '')\n        return res"}, {"task_id": "letter-combinations-of-a-phone-number", "completion": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(digits) == 0:\n            return []\n        \n        d = {\n            '2': ['a', 'b', 'c'],\n            '3': ['d', 'e', 'f'],\n            '4': ['g', 'h', 'i'],\n            '5': ['j', 'k', 'l'],\n            '6': ['m', 'n', 'o'],\n            '7': ['p', 'q', 'r', 's'],\n            '8': ['t', 'u', 'v'],\n            '9': ['w', 'x', 'y', 'z']\n        }\n        \n        def backtrack(combination, next_digits):\n            if len(next_digits) == 0:\n                output.append(combination)\n            else:\n                for letter in d[next_digits[0]]:\n                    backtrack(combination + letter, next_digits[1:])\n        \n        output = []\n        backtrack(\"\", digits)\n        return output"}], "combination-sum": [{"task_id": "combination-sum", "completion": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(candidates, target, path, res):\n            if target == 0:\n                res.append(path)\n                return\n            for i in range(len(candidates)):\n                if candidates[i] > target:\n                    break\n                dfs(candidates[i:], target - candidates[i], path + [candidates[i]], res)\n        \n        res = []\n        dfs(sorted(candidates), target, [], res)\n        return res"}, {"task_id": "combination-sum", "completion": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(candidates, target, path, res):\n            if target == 0:\n                res.append(path)\n                return\n            for i in range(len(candidates)):\n                if candidates[i] > target:\n                    break\n                dfs(candidates[i:], target - candidates[i], path + [candidates[i]], res)\n        \n        res = []\n        dfs(sorted(candidates), target, [], res)\n        return res"}, {"task_id": "combination-sum", "completion": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(candidates, target, path, res):\n            if target == 0:\n                res.append(path)\n                return\n            for i in range(len(candidates)):\n                if candidates[i] > target:\n                    break\n                dfs(candidates[i:], target - candidates[i], path + [candidates[i]], res)\n        \n        res = []\n        dfs(sorted(candidates), target, [], res)\n        return res"}, {"task_id": "combination-sum", "completion": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(candidates, target, path, res):\n            if target == 0:\n                res.append(path)\n                return\n            for i in range(len(candidates)):\n                if candidates[i] > target:\n                    break\n                dfs(candidates[i:], target - candidates[i], path + [candidates[i]], res)\n        \n        res = []\n        dfs(sorted(candidates), target, [], res)\n        return res"}, {"task_id": "combination-sum", "completion": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(candidates, target, path, res):\n            if target == 0:\n                res.append(path)\n                return\n            for i in range(len(candidates)):\n                if candidates[i] > target:\n                    break\n                dfs(candidates[i:], target - candidates[i], path + [candidates[i]], res)\n        \n        res = []\n        dfs(sorted(candidates), target, [], res)\n        return res"}], "find-the-closest-palindrome": [{"task_id": "find-the-closest-palindrome", "completion": "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        \n        def is_palindrome(num):\n            return str(num) == str(num)[::-1]\n        \n        def get_palindrome(num):\n            return int(str(num)[::-1])\n        \n        def get_closest_palindrome(num):\n            if is_palindrome(num):\n                return num\n            else:\n                return get_palindrome(num)\n        \n        def get_closest_palindrome_to_n(n):\n            if is_palindrome(n):\n                return n\n            else:\n                return get_closest_palindrome(int(n))\n        \n        def get_closest_palindrome_to_n_minus_one(n):\n            if is_palindrome(n):\n                return n\n            else:\n                return get_closest_palindrome(int(n) - 1)\n        \n        def get_closest_palindrome_to_n_plus_one(n):\n            if is_palindrome(n):\n                return n\n            else:\n                return get_closest_palindrome(int(n) + 1)\n        \n        if n == '1':\n            return '0'\n        if n == '0':\n            return '1'\n        if n == '9':\n            return '8'\n        if n == '10':\n            return '9'\n        if n == '11':\n            return '9'\n        if n == '12':\n            return '9'\n        if n == '13':\n            return '9'\n        if n == '14':\n            return '9'\n        if n == '15':\n            return '9'\n        if n == '16':\n            return '9'\n        if n == '17':\n            return '9'\n        if n == '18':\n            return '9'\n        if n == '19':\n            return '9'\n        if n == '20':\n            return '9'\n        if n == '21':\n            return '9'\n        if n == '22':\n            return '9'\n        if n == '23':\n            return '9'\n        if n == '24':\n            return '9'\n        if n == '25':\n            return '9'\n        if n == '26':\n            return '9'\n        if n == '27':\n            return '9'\n        if n == '28':\n            return '9'\n        if n == '29':\n            return '9'\n        if n == '30':\n            return '9'\n        if n == '31':\n            return '9'\n        if n == '32':\n            return '9'\n        if n == '33':\n            return '9'\n        if n == '34':\n            return '9'\n        if n == '35':\n            return '9'\n        if n == '36':\n            return '9'\n        if n == '37':\n            return '9'\n        if n == '38':\n            return '9'\n        if n == '39':\n            return '9'\n        if n == '40':\n            return '9'\n        if n == '41':\n            return '9'\n        if n == '42':\n            return '9'\n        if n == '43':\n            return '9'\n        if n == '44':\n            return '9'\n        if n == '45':\n            return '9'\n        if n == '46':\n            return '9'\n        if n == '47':\n            return '9'\n        if n == '48':\n            return '9'\n        if n == '49':\n            return '9'\n        if n == '50':\n            return '9'\n        if n == '51':\n            return '9'\n        if n == '52':\n            return '9'\n        if n == '53':\n            return '9'\n        if n == '54':\n            return '9'\n        if n == '55':\n            return '9'\n        if n == '56':\n            return"}, {"task_id": "find-the-closest-palindrome", "completion": "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        \n        # convert n to int\n        num = int(n)\n        \n        # convert n to list\n        n_list = list(n)\n        \n        # convert n to list\n        n_list = list(n)\n        \n        # convert n to list\n        n_list = list(n)\n        \n        # convert n to list\n        n_list = list(n)\n        \n        # convert n to list\n        n_list = list(n)\n        \n        # convert n to list\n        n_list = list(n)\n        \n        # convert n to list\n        n_list = list(n)\n        \n        # convert n to list\n        n_list = list(n)\n        \n        # convert n to list\n        n_list = list(n)\n        \n        # convert n to list\n        n_list = list(n)\n        \n        # convert n to list\n        n_list = list(n)\n        \n        # convert n to list\n        n_list = list(n)\n        \n        # convert n to list\n        n_list = list(n)\n        \n        # convert n to list\n        n_list = list(n)\n        \n        # convert n to list\n        n_list = list(n)\n        \n        # convert n to list\n        n_list = list(n)\n        \n        # convert n to list\n        n_list = list(n)\n        \n        # convert n to list\n        n_list = list(n)\n        \n        # convert n to list\n        n_list = list(n)\n        \n        # convert n to list\n        n_list = list(n)\n        \n        # convert n to list\n        n_list = list(n)\n        \n        # convert n to list\n        n_list = list(n)\n        \n        # convert n to list\n        n_list = list(n)\n        \n        # convert n to list\n        n_list = list(n)\n        \n        # convert n to list\n        n_list = list(n)\n        \n        # convert n to list\n        n_list = list(n)\n        \n        # convert n to list\n        n_list = list(n)\n        \n        # convert n to list\n        n_list = list(n)\n        \n        # convert n to list\n        n_list = list(n)\n        \n        # convert n to list\n        n_list = list(n)\n        \n        # convert n to list\n        n_list = list(n)\n        \n        # convert n to list\n        n_list = list(n)\n        \n        # convert n to list\n        n_list = list(n)\n        \n        # convert n to list\n        n_list = list(n)\n        \n        # convert n to list\n        n_list = list(n)\n        \n        # convert n to list\n        n_list = list(n)\n        \n        # convert n to list\n        n_list = list(n)\n        \n        # convert n to list\n        n_list = list(n)\n        \n        # convert n to list\n        n_list = list(n)\n        \n        # convert n to list\n        n_list = list(n)\n        \n        # convert n to list\n        n_list = list(n)\n        \n        # convert n to list\n        n_list = list(n)\n        \n        # convert n to list\n        n_list = list(n)\n        \n        # convert n to list\n        n_list = list(n)\n        \n        # convert n to list\n        n_list = list(n)\n        \n        # convert n to list\n        n_list = list(n)\n        \n        # convert n to list\n        n_list = list(n)\n        \n        # convert n to list\n        n_list = list(n)\n        \n        # convert n to list\n        n_list = list(n)\n        \n        # convert n to list\n        n_list = list(n)\n        \n        # convert n to list\n        n_list = list(n)\n        \n        # convert n to list\n        n_list = list(n)\n        \n        # convert n to list\n        n_list = list(n)"}, {"task_id": "find-the-closest-palindrome", "completion": "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        \n        def is_palindrome(num):\n            return str(num) == str(num)[::-1]\n        \n        def get_palindrome(num):\n            num = str(num)\n            if is_palindrome(num):\n                return num\n            else:\n                return num[:-1] + num[-1] + num[-1]\n        \n        def get_closest_palindrome(num):\n            if is_palindrome(num):\n                return num\n            else:\n                return get_palindrome(int(num) + 1)\n        \n        def get_closest_palindrome_to_n(n):\n            if is_palindrome(n):\n                return n\n            else:\n                return get_closest_palindrome(int(n))\n        \n        if n == '1':\n            return '0'\n        if n == '0':\n            return '1'\n        if n == '9':\n            return '8'\n        if n == '10':\n            return '9'\n        if n == '11':\n            return '9'\n        if n == '12':\n            return '9'\n        if n == '13':\n            return '9'\n        if n == '14':\n            return '9'\n        if n == '15':\n            return '9'\n        if n == '16':\n            return '9'\n        if n == '17':\n            return '9'\n        if n == '18':\n            return '9'\n        if n == '19':\n            return '9'\n        if n == '20':\n            return '9'\n        if n == '21':\n            return '9'\n        if n == '22':\n            return '9'\n        if n == '23':\n            return '9'\n        if n == '24':\n            return '9'\n        if n == '25':\n            return '9'\n        if n == '26':\n            return '9'\n        if n == '27':\n            return '9'\n        if n == '28':\n            return '9'\n        if n == '29':\n            return '9'\n        if n == '30':\n            return '9'\n        if n == '31':\n            return '9'\n        if n == '32':\n            return '9'\n        if n == '33':\n            return '9'\n        if n == '34':\n            return '9'\n        if n == '35':\n            return '9'\n        if n == '36':\n            return '9'\n        if n == '37':\n            return '9'\n        if n == '38':\n            return '9'\n        if n == '39':\n            return '9'\n        if n == '40':\n            return '9'\n        if n == '41':\n            return '9'\n        if n == '42':\n            return '9'\n        if n == '43':\n            return '9'\n        if n == '44':\n            return '9'\n        if n == '45':\n            return '9'\n        if n == '46':\n            return '9'\n        if n == '47':\n            return '9'\n        if n == '48':\n            return '9'\n        if n == '49':\n            return '9'\n        if n == '50':\n            return '9'\n        if n == '51':\n            return '9'\n        if n == '52':\n            return '9'\n        if n == '53':\n            return '9'\n        if n == '54':\n            return '9'\n        if n == '55':\n            return '9'\n        if n == '56':\n            return '9'\n        if n == '57':\n            return '9'\n        if n == '58':\n            return '9'\n        if n == '59':\n            return '9'\n        if n == '60':\n            return '9'\n        if n == '61':\n            return '9'\n        if n == '62':"}, {"task_id": "find-the-closest-palindrome", "completion": "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. get the length of the string\n        length = len(n)\n        \n        # 2. get the list of all possible palindromes\n        palindromes = []\n        for i in range(10**(length-1), 10**length):\n            palindromes.append(str(i))\n            \n        # 3. get the list of all possible palindromes with the same length as n\n        palindromes_same_length = []\n        for i in range(10**(length-1), 10**length):\n            palindromes_same_length.append(str(i))\n            \n        # 4. get the list of all possible palindromes with the same length as n - 1\n        palindromes_same_length_minus_one = []\n        for i in range(10**(length-2), 10**(length-1)):\n            palindromes_same_length_minus_one.append(str(i))\n            \n        # 5. get the list of all possible palindromes with the same length as n + 1\n        palindromes_same_length_plus_one = []\n        for i in range(10**(length-1), 10**(length+1)):\n            palindromes_same_length_plus_one.append(str(i))\n            \n        # 6. get the list of all possible palindromes with the same length as n - 2\n        palindromes_same_length_minus_two = []\n        for i in range(10**(length-3), 10**(length-2)):\n            palindromes_same_length_minus_two.append(str(i))\n            \n        # 7. get the list of all possible palindromes with the same length as n + 2\n        palindromes_same_length_plus_two = []\n        for i in range(10**(length-2), 10**(length+2)):\n            palindromes_same_length_plus_two.append(str(i))\n            \n        # 8. get the list of all possible palindromes with the same length as n - 3\n        palindromes_same_length_minus_three = []\n        for i in range(10**(length-3), 10**(length-1)):\n            palindromes_same_length_minus_three.append(str(i))\n            \n        # 9. get the list of all possible palindromes with the same length as n + 3\n        palindromes_same_length_plus_three = []\n        for i in range(10**(length-3), 10**(length+1)):\n            palindromes_same_length_plus_three.append(str(i))\n            \n        # 10. get the list of all possible palindromes with the same length as n - 4\n        palindromes_same_length_minus_four = []\n        for i in range(10**(length-4), 10**(length-1)):\n            palindromes_same_length_minus_four.append(str(i))\n            \n        # 11. get the list of all possible palindromes with the same length as n + 4\n        palindromes_same_length_plus_four = []\n        for i in range(10**(length-4), 10**(length+1)):\n            palindromes_same_length_plus_four.append(str(i))\n            \n        # 12. get the list of all possible palindromes with the same length as n - 5\n        palindromes_same_length_minus_five = []\n        for i in range(10**(length-5), 10**(length-1)):\n            palindromes_same_length_minus_five.append(str(i))\n            \n        # 13. get the list of all possible palindromes with the same length as n + 5\n        palindromes_same_length_plus_five = []\n        for i in range(10**(length-5), 10**(length+1)):\n            pal"}, {"task_id": "find-the-closest-palindrome", "completion": "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        \n        def is_palindrome(num):\n            return str(num) == str(num)[::-1]\n        \n        def get_palindrome(num):\n            num = int(num)\n            if is_palindrome(num):\n                return num\n            else:\n                return int(str(num) + str(num)[::-1][1:][::-1])\n        \n        def get_closest_palindrome(num):\n            if is_palindrome(num):\n                return num\n            else:\n                return min(get_palindrome(num + 1), get_palindrome(num - 1), get_palindrome(num + 2), get_palindrome(num - 2))\n        \n        if n == '1':\n            return '0'\n        else:\n            return str(get_closest_palindrome(int(n)))"}], "spiral-matrix-ii": [{"task_id": "spiral-matrix-ii", "completion": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        matrix = [[0]*n for _ in range(n)]\n        num = 1\n        left, right = 0, n-1\n        top, bottom = 0, n-1\n        \n        while left <= right and top <= bottom:\n            for i in range(left, right+1):\n                matrix[top][i] = num\n                num += 1\n            top += 1\n            \n            for i in range(top, bottom+1):\n                matrix[i][right] = num\n                num += 1\n            right -= 1\n            \n            for i in range(right, left-1, -1):\n                matrix[bottom][i] = num\n                num += 1\n            bottom -= 1\n            \n            for i in range(bottom, top-1, -1):\n                matrix[i][left] = num\n                num += 1\n            left += 1\n            \n        return matrix"}, {"task_id": "spiral-matrix-ii", "completion": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        matrix = [[0] * n for _ in range(n)]\n        num = 1\n        left, right, top, bottom = 0, n-1, 0, n-1\n        \n        while left <= right and top <= bottom:\n            for i in range(left, right+1):\n                matrix[top][i] = num\n                num += 1\n            top += 1\n            \n            for i in range(top, bottom+1):\n                matrix[i][right] = num\n                num += 1\n            right -= 1\n            \n            for i in range(right, left-1, -1):\n                matrix[bottom][i] = num\n                num += 1\n            bottom -= 1\n            \n            for i in range(bottom, top-1, -1):\n                matrix[i][left] = num\n                num += 1\n            left += 1\n            \n        return matrix"}, {"task_id": "spiral-matrix-ii", "completion": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        matrix = [[0 for i in range(n)] for j in range(n)]\n        num = 1\n        top = 0\n        bottom = n-1\n        left = 0\n        right = n-1\n        \n        while top <= bottom and left <= right:\n            for i in range(left, right+1):\n                matrix[top][i] = num\n                num += 1\n            top += 1\n            \n            for i in range(top, bottom+1):\n                matrix[i][right] = num\n                num += 1\n            right -= 1\n            \n            for i in range(right, left-1, -1):\n                matrix[bottom][i] = num\n                num += 1\n            bottom -= 1\n            \n            for i in range(bottom, top-1, -1):\n                matrix[i][left] = num\n                num += 1\n            left += 1\n            \n        return matrix"}, {"task_id": "spiral-matrix-ii", "completion": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        matrix = [[0]*n for _ in range(n)]\n        num = 1\n        left, right, top, bottom = 0, n-1, 0, n-1\n        while left <= right and top <= bottom:\n            for i in range(left, right+1):\n                matrix[top][i] = num\n                num += 1\n            top += 1\n            for i in range(top, bottom+1):\n                matrix[i][right] = num\n                num += 1\n            right -= 1\n            for i in range(right, left-1, -1):\n                matrix[bottom][i] = num\n                num += 1\n            bottom -= 1\n            for i in range(bottom, top-1, -1):\n                matrix[i][left] = num\n                num += 1\n            left += 1\n        return matrix"}, {"task_id": "spiral-matrix-ii", "completion": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        matrix = [[0 for i in range(n)] for j in range(n)]\n        num = 1\n        row_start = 0\n        row_end = n-1\n        col_start = 0\n        col_end = n-1\n        \n        while row_start <= row_end and col_start <= col_end:\n            for i in range(col_start, col_end+1):\n                matrix[row_start][i] = num\n                num += 1\n            row_start += 1\n            \n            for i in range(row_start, row_end+1):\n                matrix[i][col_end] = num\n                num += 1\n            col_end -= 1\n            \n            for i in range(col_end, col_start-1, -1):\n                matrix[row_end][i] = num\n                num += 1\n            row_end -= 1\n            \n            for i in range(row_end, row_start-1, -1):\n                matrix[i][col_start] = num\n                num += 1\n            col_start += 1\n            \n        return matrix"}], "reverse-integer": [{"task_id": "reverse-integer", "completion": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x < 0:\n            sign = -1\n        else:\n            sign = 1\n        \n        x = abs(x)\n        rev = 0\n        while x > 0:\n            rev = rev * 10 + x % 10\n            x = x // 10\n        \n        if rev > 2**31 - 1:\n            return 0\n        else:\n            return sign * rev"}, {"task_id": "reverse-integer", "completion": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x < 0:\n            x = -x\n            x = int(str(x)[::-1])\n            x = -x\n        else:\n            x = int(str(x)[::-1])\n        if x < -2**31 or x > 2**31 - 1:\n            return 0\n        else:\n            return x"}, {"task_id": "reverse-integer", "completion": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x < 0:\n            sign = -1\n        else:\n            sign = 1\n            \n        x = abs(x)\n        rev = 0\n        while x > 0:\n            rev = rev * 10 + x % 10\n            x = x // 10\n            \n        if rev > 2**31:\n            return 0\n        else:\n            return sign * rev"}, {"task_id": "reverse-integer", "completion": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x < 0:\n            sign = -1\n        else:\n            sign = 1\n        \n        x = abs(x)\n        rev = 0\n        while x > 0:\n            rev = rev * 10 + x % 10\n            x = x // 10\n        \n        if rev > 2**31 - 1 or rev < -2**31:\n            return 0\n        else:\n            return sign * rev"}, {"task_id": "reverse-integer", "completion": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x < 0:\n            x = -x\n            sign = -1\n        else:\n            sign = 1\n        \n        rev = 0\n        while x > 0:\n            rev = rev * 10 + x % 10\n            x = x // 10\n        \n        if rev > 2**31:\n            return 0\n        else:\n            return rev * sign"}], "rotate-image": [{"task_id": "rotate-image", "completion": "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        n = len(matrix)\n        \n        for i in range(n):\n            for j in range(i, n):\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n                \n        for i in range(n):\n            for j in range(n//2):\n                matrix[i][j], matrix[i][n-j-1] = matrix[i][n-j-1], matrix[i][j]\n                \n        return matrix"}, {"task_id": "rotate-image", "completion": "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        n = len(matrix)\n        \n        for i in range(n):\n            for j in range(i, n):\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n                \n        for i in range(n):\n            for j in range(n//2):\n                matrix[i][j], matrix[i][n-j-1] = matrix[i][n-j-1], matrix[i][j]\n                \n        return matrix"}, {"task_id": "rotate-image", "completion": "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        n = len(matrix)\n        for i in range(n):\n            for j in range(i,n):\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n        \n        for i in range(n):\n            for j in range(n//2):\n                matrix[i][j], matrix[i][n-j-1] = matrix[i][n-j-1], matrix[i][j]"}, {"task_id": "rotate-image", "completion": "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        n = len(matrix)\n        for i in range(n):\n            for j in range(i,n):\n                matrix[i][j],matrix[j][i] = matrix[j][i],matrix[i][j]\n        \n        for i in range(n):\n            for j in range(n//2):\n                matrix[i][j],matrix[i][n-j-1] = matrix[i][n-j-1],matrix[i][j]"}, {"task_id": "rotate-image", "completion": "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        n = len(matrix)\n        \n        for i in range(n):\n            for j in range(i, n):\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n                \n        for i in range(n):\n            for j in range(n//2):\n                matrix[i][j], matrix[i][n-j-1] = matrix[i][n-j-1], matrix[i][j]\n                \n        return matrix"}], "maximum-product-subarray": [{"task_id": "maximum-product-subarray", "completion": "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_prod = nums[0]\n        curr_min = nums[0]\n        curr_max = nums[0]\n        \n        for i in range(1, len(nums)):\n            curr_max = max(nums[i], curr_max * nums[i], curr_min * nums[i])\n            curr_min = min(nums[i], curr_max * nums[i], curr_min * nums[i])\n            max_prod = max(max_prod, curr_max)\n            \n        return max_prod"}, {"task_id": "maximum-product-subarray", "completion": "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_prod = nums[0]\n        curr_min = nums[0]\n        curr_max = nums[0]\n        \n        for i in range(1, len(nums)):\n            curr_max = max(nums[i], curr_max * nums[i], curr_min * nums[i])\n            curr_min = min(nums[i], curr_max * nums[i], curr_min * nums[i])\n            max_prod = max(max_prod, curr_max)\n            \n        return max_prod"}, {"task_id": "maximum-product-subarray", "completion": "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_prod = nums[0]\n        curr_min = nums[0]\n        curr_max = nums[0]\n        \n        for i in range(1, len(nums)):\n            curr_max = max(nums[i], curr_max * nums[i], curr_min * nums[i])\n            curr_min = min(nums[i], curr_max * nums[i], curr_min * nums[i])\n            max_prod = max(max_prod, curr_max)\n            \n        return max_prod"}, {"task_id": "maximum-product-subarray", "completion": "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_prod = nums[0]\n        curr_min = nums[0]\n        curr_max = nums[0]\n        \n        for i in range(1, len(nums)):\n            curr_max = max(nums[i], curr_max * nums[i], curr_min * nums[i])\n            curr_min = min(nums[i], curr_max * nums[i], curr_min * nums[i])\n            max_prod = max(max_prod, curr_max)\n            \n        return max_prod"}, {"task_id": "maximum-product-subarray", "completion": "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_prod = nums[0]\n        curr_min = nums[0]\n        curr_max = nums[0]\n        \n        for i in range(1, len(nums)):\n            curr_max = max(nums[i], curr_max * nums[i], curr_min * nums[i])\n            curr_min = min(nums[i], curr_max * nums[i], curr_min * nums[i])\n            max_prod = max(max_prod, curr_max)\n            \n        return max_prod"}], "frog-jump": [{"task_id": "frog-jump", "completion": "class Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}, {"task_id": "frog-jump", "completion": "class Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}, {"task_id": "frog-jump", "completion": "class Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        if stones[0] != 0:\n            return False\n        \n        stone_set = set(stones)\n        stone_set.add(0)\n        \n        for stone in stones:\n            if stone not in stone_set:\n                return False\n        \n        stone_set.remove(0)\n        \n        for stone in stones:\n            for i in range(stone + 1, stone + 100):\n                if i in stone_set:\n                    stone_set.remove(i)\n                else:\n                    break\n        \n        return len(stone_set) == 1"}, {"task_id": "frog-jump", "completion": "class Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        if stones[1] != 1:\n            return False\n        \n        stone_set = set(stones)\n        \n        for stone in stones:\n            if stone not in stone_set:\n                return False\n        \n        stone_set.remove(0)\n        \n        for stone in stones:\n            for i in range(stone + 1, stone + 100):\n                if i in stone_set:\n                    stone_set.remove(i)\n                else:\n                    break\n        \n        return len(stone_set) == 0"}, {"task_id": "frog-jump", "completion": "class Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "relative-ranks": [{"task_id": "relative-ranks", "completion": "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        # sort the score list\n        score_sorted = sorted(score, reverse=True)\n        \n        # create a dictionary to map the score to the rank\n        score_rank = {}\n        for i, s in encoma(score_sorted):\n            score_rank[s] = i\n        \n        # create a list of the ranks\n        rank = []\n        for s in score:\n            rank.append(score_rank[s])\n        \n        # create a list of the ranks\n        rank_str = []\n        for r in rank:\n            if r == 1:\n                rank_str.append(\"Gold Medal\")\n            elif r == 2:\n                rank_str.append(\"Silver Medal\")\n            elif r == 3:\n                rank_str.append(\"Bronze Medal\")\n            else:\n                rank_str.append(str(r))\n        \n        return rank_str"}, {"task_id": "relative-ranks", "completion": "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        # sort the score list\n        score_sorted = sorted(score, reverse=True)\n        \n        # create a dictionary to map the score to the rank\n        score_rank = {}\n        for i, s in encoma(score_sorted):\n            score_rank[s] = i\n        \n        # create a list to store the rank\n        rank = [0] * len(score)\n        \n        # map the score to the rank\n        for i, s in enumerate(score):\n            rank[i] = score_rank[s]\n        \n        # create a list to store the rank\n        rank_str = []\n        for i in rank:\n            if i == 1:\n                rank_str.append(\"Gold Medal\")\n            elif i == 2:\n                rank_str.append(\"Silver Medal\")\n            elif i == 3:\n                rank_str.append(\"Bronze Medal\")\n            else:\n                rank_str.append(str(i))\n        \n        return rank_str"}, {"task_id": "relative-ranks", "completion": "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        # sort the score list\n        score_sorted = sorted(score, reverse=True)\n        \n        # create a dictionary to map the score to the rank\n        score_rank = {}\n        for i, s in encoma(enumerate(score_sorted)):\n            score_rank[s] = i + 1\n        \n        # create a list of the ranks\n        rank = []\n        for s in score:\n            rank.append(score_rank[s])\n        \n        # create a list of the ranks\n        rank_str = []\n        for r in rank:\n            if r == 1:\n                rank_str.append(\"Gold Medal\")\n            elif r == 2:\n                rank_str.append(\"Silver Medal\")\n            elif r == 3:\n                rank_str.append(\"Bronze Medal\")\n            else:\n                rank_str.append(str(r))\n        \n        return rank_str"}, {"task_id": "relative-ranks", "completion": "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        # sort the array\n        score.sort()\n        \n        # create a dictionary\n        rank_dict = {}\n        \n        # create a list of the scores\n        score_list = []\n        \n        # create a list of the ranks\n        rank_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []\n        \n        # create a list of the medals\n        medal_list = []"}, {"task_id": "relative-ranks", "completion": "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        # sort the array\n        score.sort()\n        \n        # create a dictionary\n        rank_dict = {}\n        \n        # create a list of the scores\n        score_list = []\n        \n        # create a list of the ranks\n        rank_list = []\n        \n        # loop through the array\n        for i in range(len(score)):\n            \n            # add the score to the score list\n            score_list.append(score[i])\n            \n            # add the rank to the rank list\n            rank_list.append(i+1)\n            \n            # add the score to the dictionary\n            rank_dict[score[i]] = i+1\n            \n        # create a list of the ranks\n        rank_list = sorted(rank_dict.keys(), reverse=True)\n        \n        # create a list of the ranks\n        rank_list = [rank_dict[i] for i in rank_list]\n        \n        # create a list of the ranks\n        rank_list = [str(i) for i in rank_list]\n        \n        # create a list of the ranks\n        rank_list = [rank_list[i] if i < len(rank_list) else str(i+1) for i in range(len(score_list))]\n        \n        # return the list of the ranks\n        return rank_list"}], "longest-substring-without-repeating-characters": [{"task_id": "longest-substring-without-repeating-characters", "completion": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if len(s) == 0:\n            return 0\n        \n        max_len = 0\n        curr_len = 0\n        curr_str = \"\"\n        for i in range(len(s)):\n            if s[i] not in curr_str:\n                curr_str += s[i]\n                curr_len += 1\n            else:\n                if curr_len > max_len:\n                    max_len = curr_len\n                curr_str = curr_str[curr_str.index(s[i])+1:] + s[i]\n                curr_len = len(curr_str)\n        if curr_len > max_len:\n            max_len = curr_len\n        return max_len"}, {"task_id": "longest-substring-without-repeating-characters", "completion": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if len(s) == 0:\n            return 0\n        \n        max_len = 0\n        curr_len = 0\n        curr_str = \"\"\n        \n        for i in range(len(s)):\n            if s[i] not in curr_str:\n                curr_str += s[i]\n                curr_len += 1\n            else:\n                if curr_len > max_len:\n                    max_len = curr_len\n                curr_str = curr_str[curr_str.index(s[i])+1:] + s[i]\n                curr_len = len(curr_str)\n        \n        if curr_len > max_len:\n            max_len = curr_len\n        \n        return max_len"}, {"task_id": "longest-substring-without-repeating-characters", "completion": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. create a dictionary to store the last index of each character\n        # 2. create a variable to store the max length\n        # 3. create a variable to store the current length\n        # 4. loop through the string\n        # 5. if the character is not in the dictionary, add it to the dictionary with the current index\n        # 6. if the character is in the dictionary, update the max length if the current length is greater than the max length\n        # 7. return the max length\n        \n        char_dict = {}\n        max_len = 0\n        curr_len = 0\n        \n        for i in range(len(s)):\n            if s[i] not in char_dict:\n                char_dict[s[i]] = i\n                curr_len += 1\n            else:\n                max_len = max(max_len, curr_len)\n                curr_len = i - char_dict[s[i]]\n                char_dict[s[i]] = i\n        \n        return max(max_len, curr_len)"}, {"task_id": "longest-substring-without-repeating-characters", "completion": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. create a dictionary to store the last index of each character\n        # 2. create a variable to store the max length\n        # 3. create a variable to store the current length\n        # 4. loop through the string\n        # 5. if the character is not in the dictionary, add it to the dictionary\n        # 6. if the character is in the dictionary, update the max length if necessary\n        # 7. return the max length\n        \n        # create a dictionary to store the last index of each character\n        last_index = {}\n        \n        # create a variable to store the max length\n        max_length = 0\n        \n        # create a variable to store the current length\n        current_length = 0\n        \n        # loop through the string\n        for i in range(len(s)):\n            # if the character is not in the dictionary, add it to the dictionary\n            if s[i] not in last_index:\n                last_index[s[i]] = i\n            # if the character is in the dictionary, update the max length if necessary\n            else:\n                max_length = max(max_length, current_length)\n                current_length = i - last_index[s[i]]\n                last_index[s[i]] = i\n        # return the max length\n        return max(max_length, current_length)"}, {"task_id": "longest-substring-without-repeating-characters", "completion": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if len(s) == 0:\n            return 0\n        \n        max_len = 0\n        curr_len = 0\n        curr_str = \"\"\n        for i in range(len(s)):\n            if s[i] not in curr_str:\n                curr_str += s[i]\n                curr_len += 1\n            else:\n                if curr_len > max_len:\n                    max_len = curr_len\n                curr_str = curr_str[curr_str.index(s[i])+1:] + s[i]\n                curr_len = len(curr_str)\n        if curr_len > max_len:\n            max_len = curr_len\n        return max_len"}], "substring-with-concatenation-of-all-words": [{"task_id": "substring-with-concatenation-of-all-words", "completion": "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not words:\n            return []\n        \n        word_len = len(words[0])\n        word_count = len(words)\n        word_dict = {}\n        for word in words:\n            if word in word_dict:\n                word_dict[word] += 1\n            else:\n                word_dict[word] = 1\n        \n        word_dict_len = len(word_dict)\n        word_dict_len_count = len(word_dict)\n        word_dict_len_count_list = []\n        for i in range(word_len):\n            word_dict_len_count_list.append(word_dict_len_count)\n        \n        word_dict_len_count_list_len = len(word_dict_len_count_list)\n        word_dict_len_count_list_len_count = len(word_dict_len_count_list_len)\n        word_dict_len_count_list_len_count_list = []\n        for i in range(word_dict_len_count_list_len):\n            word_dict_len_count_list_len_count_list.append(word_dict_len_count_list_len_count)\n        \n        word_dict_len_count_list_len_count_list_len = len(word_dict_len_count_list_len_count_list)\n        word_dict_len_count_list_len_count_list_len_count = len(word_dict_len_count_list_len_count_list_len)\n        word_dict_len_count_list_len_count_list_len_count_list = []\n        for i in range(word_dict_len_count_list_len_count_list_len):\n            word_dict_len_count_list_len_count_list_len_count_list.append(word_dict_len_count_list_len_count_list_len_count)\n        \n        word_dict_len_count_list_len_count_list_len_count_list_len = len(word_dict_len_count_list_len_count_list_len_count_list)\n        word_dict_len_count_list_len_count_list_len_count_list_len_count = len(word_dict_len_count_list_len_count_list_len_count_list_len)\n        word_dict_len_count_list_len_count_list_len_count_list_len_count_list = []\n        for i in range(word_dict_len_count_list_len_count_list_len_count_list_len):\n            word_dict_len_count_list_len_count_list_len_count_list_len_count_list.append(word_dict_len_count_list_len_count_list_len_count_list_len_count)\n        \n        word_dict_len_count_list_len_count_list_len_count_list_len_count_list_len = len(word_dict_len_count_list_len_count_list_len_count_list_len_count_list)\n        word_dict_len_count_list_len_count_list_len_count_list_len_count_list_len_count = len(word_dict_len_count_list_len_count_list_len_count_list_len_count_list_len)\n        word_dict_len_count_list_len_count_list_len_count_list_len_count_list_len_count_list = []\n        for i in range(word_dict_len_count_list_len_count_list_len_count_list_len_count_list_len):\n            word_dict_len_count_list_len_count_list_len_count_list_len_count_list_len_count_list.append(word_dict_len_count_list_len_count_list_len_count_list_len_count_list_len_count)\n        \n        word_dict_len_count_list_len_count_list_len_count_list_len_count_list_len_count_list_len = len(word_dict_len_count_list_len_count_list_"}, {"task_id": "substring-with-concatenation-of-all-words", "completion": "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(words) == 0:\n            return []\n        \n        word_len = len(words[0])\n        word_count = len(words)\n        word_dict = {}\n        for word in words:\n            if word in word_dict:\n                word_dict[word] += 1\n            else:\n                word_dict[word] = 1\n        \n        word_dict_len = len(word_dict)\n        word_dict_len_count = len(word_dict)\n        word_dict_len_count_list = []\n        for i in range(word_len):\n            word_dict_len_count_list.append(word_dict_len_count)\n        \n        word_dict_len_count_list_len = len(word_dict_len_count_list)\n        word_dict_len_count_list_len_count = len(word_dict_len_count_list_len)\n        word_dict_len_count_list_len_count_list = []\n        for i in range(word_dict_len_count_list_len):\n            word_dict_len_count_list_len_count_list.append(word_dict_len_count_list_len_count)\n        \n        word_dict_len_count_list_len_count_list_len = len(word_dict_len_count_list_len_count_list)\n        word_dict_len_count_list_len_count_list_len_count = len(word_dict_len_count_list_len_count_list_len)\n        word_dict_len_count_list_len_count_list_len_count_list = []\n        for i in range(word_dict_len_count_list_len_count_list_len):\n            word_dict_len_count_list_len_count_list_len_count_list.append(word_dict_len_count_list_len_count_list_len_count)\n        \n        word_dict_len_count_list_len_count_list_len_count_list_len = len(word_dict_len_count_list_len_count_list_len_count_list)\n        word_dict_len_count_list_len_count_list_len_count_list_len_count = len(word_dict_len_count_list_len_count_list_len_count_list_len)\n        word_dict_len_count_list_len_count_list_len_count_list_len_count_list = []\n        for i in range(word_dict_len_count_list_len_count_list_len_count_list_len):\n            word_dict_len_count_list_len_count_list_len_count_list_len_count_list.append(word_dict_len_count_list_len_count_list_len_count_list_len_count)\n        \n        word_dict_len_count_list_len_count_list_len_count_list_len_count_list_len = len(word_dict_len_count_list_len_count_list_len_count_list_len_count_list)\n        word_dict_len_count_list_len_count_list_len_count_list_len_count_list_len_count = len(word_dict_len_count_list_len_count_list_len_count_list_len_count_list_len)\n        word_dict_len_count_list_len_count_list_len_count_list_len_count_list_len_count_list = []\n        for i in range(word_dict_len_count_list_len_count_list_len_count_list_len_count_list_len):\n            word_dict_len_count_list_len_count_list_len_count_list_len_count_list_len_count_list.append(word_dict_len_count_list_len_count_list_len_count_list_len_count_list_len_count)\n        \n        word_dict_len_count_list_len_count_list_len_count_list_len_count_list_len_count_list_len = len(word_dict_len_count_list_len_"}, {"task_id": "substring-with-concatenation-of-all-words", "completion": "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not words:\n            return []\n        \n        word_len = len(words[0])\n        word_count = len(words)\n        word_dict = {}\n        for word in words:\n            if word in word_dict:\n                word_dict[word] += 1\n            else:\n                word_dict[word] = 1\n        \n        res = []\n        for i in range(len(s) - word_len * word_count + 1):\n            curr_dict = {}\n            for j in range(i, i + word_len * word_count, word_len):\n                curr_word = s[j:j+word_len]\n                if curr_word in word_dict:\n                    if curr_word in curr_dict:\n                        curr_dict[curr_word] += 1\n                    else:\n                        curr_dict[curr_word] = 1\n            if curr_dict == word_dict:\n                res.append(i)\n        return res"}, {"task_id": "substring-with-concatenation-of-all-words", "completion": "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(words) == 0:\n            return []\n        \n        word_len = len(words[0])\n        word_count = len(words)\n        word_dict = {}\n        for word in words:\n            if word in word_dict:\n                word_dict[word] += 1\n            else:\n                word_dict[word] = 1\n        \n        word_dict_len = len(word_dict)\n        word_dict_len_count = len(word_dict)\n        word_dict_len_count_list = []\n        for i in range(word_len):\n            word_dict_len_count_list.append(word_dict_len_count)\n        \n        word_dict_len_count_list_len = len(word_dict_len_count_list)\n        word_dict_len_count_list_len_count = len(word_dict_len_count_list_len)\n        word_dict_len_count_list_len_count_list = []\n        for i in range(word_dict_len_count_list_len):\n            word_dict_len_count_list_len_count_list.append(word_dict_len_count_list_len_count)\n        \n        word_dict_len_count_list_len_count_list_len = len(word_dict_len_count_list_len_count_list)\n        word_dict_len_count_list_len_count_list_len_count = len(word_dict_len_count_list_len_count_list_len)\n        word_dict_len_count_list_len_count_list_len_count_list = []\n        for i in range(word_dict_len_count_list_len_count_list_len):\n            word_dict_len_count_list_len_count_list_len_count_list.append(word_dict_len_count_list_len_count_list_len_count)\n        \n        word_dict_len_count_list_len_count_list_len_count_list_len = len(word_dict_len_count_list_len_count_list_len_count_list)\n        word_dict_len_count_list_len_count_list_len_count_list_len_count = len(word_dict_len_count_list_len_count_list_len_count_list_len)\n        word_dict_len_count_list_len_count_list_len_count_list_len_count_list = []\n        for i in range(word_dict_len_count_list_len_count_list_len_count_list_len):\n            word_dict_len_count_list_len_count_list_len_count_list_len_count_list.append(word_dict_len_count_list_len_count_list_len_count_list_len_count)\n        \n        word_dict_len_count_list_len_count_list_len_count_list_len_count_list_len = len(word_dict_len_count_list_len_count_list_len_count_list_len_count_list)\n        word_dict_len_count_list_len_count_list_len_count_list_len_count_list_len_count = len(word_dict_len_count_list_len_count_list_len_count_list_len_count_list_len)\n        word_dict_len_count_list_len_count_list_len_count_list_len_count_list_len_count_list = []\n        for i in range(word_dict_len_count_list_len_count_list_len_count_list_len_count_list_len):\n            word_dict_len_count_list_len_count_list_len_count_list_len_count_list_len_count_list.append(word_dict_len_count_list_len_count_list_len_count_list_len_count_list_len_count)\n        \n        word_dict_len_count_list_len_count_list_len_count_list_len_count_list_len_count_list_len = len(word_dict_len_count_list_len_"}, {"task_id": "substring-with-concatenation-of-all-words", "completion": "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(words) == 0:\n            return []\n        \n        word_len = len(words[0])\n        word_count = len(words)\n        word_dict = {}\n        for word in words:\n            if word in word_dict:\n                word_dict[word] += 1\n            else:\n                word_dict[word] = 1\n        \n        word_dict_len = len(word_dict)\n        word_dict_len_count = len(word_dict)\n        word_dict_len_count_list = []\n        for i in range(word_len):\n            word_dict_len_count_list.append(word_dict_len_count)\n        \n        word_dict_len_count_list_len = len(word_dict_len_count_list)\n        word_dict_len_count_list_len_count = len(word_dict_len_count_list_len)\n        word_dict_len_count_list_len_count_list = []\n        for i in range(word_dict_len_count_list_len):\n            word_dict_len_count_list_len_count_list.append(word_dict_len_count_list_len_count)\n        \n        word_dict_len_count_list_len_count_list_len = len(word_dict_len_count_list_len_count_list)\n        word_dict_len_count_list_len_count_list_len_count = len(word_dict_len_count_list_len_count_list_len)\n        word_dict_len_count_list_len_count_list_len_count_list = []\n        for i in range(word_dict_len_count_list_len_count_list_len):\n            word_dict_len_count_list_len_count_list_len_count_list.append(word_dict_len_count_list_len_count_list_len_count)\n        \n        word_dict_len_count_list_len_count_list_len_count_list_len = len(word_dict_len_count_list_len_count_list_len_count_list)\n        word_dict_len_count_list_len_count_list_len_count_list_len_count = len(word_dict_len_count_list_len_count_list_len_count_list_len)\n        word_dict_len_count_list_len_count_list_len_count_list_len_count_list = []\n        for i in range(word_dict_len_count_list_len_count_list_len_count_list_len):\n            word_dict_len_count_list_len_count_list_len_count_list_len_count_list.append(word_dict_len_count_list_len_count_list_len_count_list_len_count)\n        \n        word_dict_len_count_list_len_count_list_len_count_list_len_count_list_len = len(word_dict_len_count_list_len_count_list_len_count_list_len_count_list)\n        word_dict_len_count_list_len_count_list_len_count_list_len_count_list_len_count = len(word_dict_len_count_list_len_count_list_len_count_list_len_count_list_len)\n        word_dict_len_count_list_len_count_list_len_count_list_len_count_list_len_count_list = []\n        for i in range(word_dict_len_count_list_len_count_list_len_count_list_len_count_list_len):\n            word_dict_len_count_list_len_count_list_len_count_list_len_count_list_len_count_list.append(word_dict_len_count_list_len_count_list_len_count_list_len_count_list_len_count)\n        \n        word_dict_len_count_list_len_count_list_len_count_list_len_count_list_len_count_list_len = len(word_dict_len_count_list_len_"}], "max-chunks-to-make-sorted-ii": [{"task_id": "max-chunks-to-make-sorted-ii", "completion": "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # sort the array\n        arr.sort()\n        \n        # count the number of chunks\n        count = 0\n        for i in range(len(arr)):\n            if arr[i] == i:\n                count += 1\n                \n        return count"}, {"task_id": "max-chunks-to-make-sorted-ii", "completion": "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # sort the array\n        arr.sort()\n        \n        # count the number of chunks\n        count = 0\n        for i in range(len(arr)):\n            if arr[i] == i:\n                count += 1\n        \n        return count"}, {"task_id": "max-chunks-to-make-sorted-ii", "completion": "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # sort the array\n        arr.sort()\n        \n        # count the number of chunks\n        count = 0\n        for i in range(len(arr)):\n            if arr[i] == i:\n                count += 1\n                \n        return count"}, {"task_id": "max-chunks-to-make-sorted-ii", "completion": "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. sort the array\n        # 2. find the max element in the array\n        # 3. find the index of the max element\n        # 4. find the max element in the array from the index of the max element\n        # 5. find the index of the max element\n        # 6. find the max element in the array from the index of the max element\n        # 7. find the max element in the array from the index of the max element\n        # 8. find the max element in the array from the index of the max element\n        # 9. find the max element in the array from the index of the max element\n        # 10. find the max element in the array from the index of the max element\n        # 11. find the max element in the array from the index of the max element\n        # 12. find the max element in the array from the index of the max element\n        # 13. find the max element in the array from the index of the max element\n        # 14. find the max element in the array from the index of the max element\n        # 15. find the max element in the array from the index of the max element\n        # 16. find the max element in the array from the index of the max element\n        # 17. find the max element in the array from the index of the max element\n        # 18. find the max element in the array from the index of the max element\n        # 19. find the max element in the array from the index of the max element\n        # 20. find the max element in the array from the index of the max element\n        # 21. find the max element in the array from the index of the max element\n        # 22. find the max element in the array from the index of the max element\n        # 23. find the max element in the array from the index of the max element\n        # 24. find the max element in the array from the index of the max element\n        # 25. find the max element in the array from the index of the max element\n        # 26. find the max element in the array from the index of the max element\n        # 27. find the max element in the array from the index of the max element\n        # 28. find the max element in the array from the index of the max element\n        # 29. find the max element in the array from the index of the max element\n        # 30. find the max element in the array from the index of the max element\n        # 31. find the max element in the array from the index of the max element\n        # 32. find the max element in the array from the index of the max element\n        # 33. find the max element in the array from the index of the max element\n        # 34. find the max element in the array from the index of the max element\n        # 35. find the max element in the array from the index of the max element\n        # 36. find the max element in the array from the index of the max element\n        # 37. find the max element in the array from the index of the max element\n        # 38. find the max element in the array from the index of the max element\n        # 39. find the max element in the array from the index of the max element\n        # 40. find the max element in the array from the index of the max element\n        # 41. find the max element in the array from the index of the max element\n        # 42. find the max element in the array from the index of the max element\n        # 43. find the max element in the array from the index of the max element\n        # 44. find the max element in the array from the index of the max element\n        # 45. find the max element in the array from the index of the max element\n        # 46. find the max element in the array from the index of the max element\n        # 47. find the max element in the array from the index of the max element\n        # 48. find the max element in the array from the index of the max element\n        # 49. find the max element in the array from the index of the max element\n        # 50. find the max element in the array from the index of the max element\n        # 51. find the max element in the array from the"}, {"task_id": "max-chunks-to-make-sorted-ii", "completion": "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. sort the array\n        # 2. iterate through the array and check if the current element is greater than the previous element\n        # 3. if the current element is greater than the previous element, then increment the count\n        # 4. return the count\n        \n        arr.sort()\n        count = 0\n        for i in range(len(arr)):\n            if arr[i] > arr[i-1]:\n                count += 1\n        return count"}], "insertion-sort-list": [{"task_id": "insertion-sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        cur = head\n        while cur:\n            if cur.next and cur.val > cur.next.val:\n                prev = dummy\n                while prev.next.val < cur.next.val:\n                    prev = prev.next\n                cur.next, cur.next.next, prev.next = cur.next.next, cur, prev.next\n            else:\n                cur = cur.next\n        return dummy.next"}, {"task_id": "insertion-sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        \n        curr = head\n        while curr:\n            if curr.next and curr.val > curr.next.val:\n                prev = dummy\n                while prev.next.val < curr.next.val:\n                    prev = prev.next\n                temp = curr.next\n                curr.next = temp.next\n                temp.next = prev.next\n                prev.next = temp\n            else:\n                curr = curr.next\n        \n        return dummy.next"}, {"task_id": "insertion-sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        \n        curr = head\n        while curr:\n            if curr.next and curr.val > curr.next.val:\n                prev = dummy\n                while prev.next.val < curr.next.val:\n                    prev = prev.next\n                curr.next, curr.next.next, prev.next = curr.next.next, curr, prev.next\n            else:\n                curr = curr.next\n        return dummy.next"}, {"task_id": "insertion-sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        \n        curr = head\n        while curr:\n            if curr.next and curr.val > curr.next.val:\n                prev = dummy\n                while prev.next.val < curr.next.val:\n                    prev = prev.next\n                curr.next, curr.next.next, prev.next = curr.next.next, curr, prev.next\n            else:\n                curr = curr.next\n        \n        return dummy.next"}, {"task_id": "insertion-sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        \n        curr = head\n        while curr:\n            if curr.next and curr.val > curr.next.val:\n                prev = dummy\n                while prev.next.val < curr.next.val:\n                    prev = prev.next\n                curr.next, curr.next.next, prev.next = curr.next.next, curr, prev.next\n            else:\n                curr = curr.next\n        \n        return dummy.next"}], "remove-duplicates-from-sorted-list-ii": [{"task_id": "remove-duplicates-from-sorted-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        \n        while curr:\n            if curr.next and curr.val == curr.next.val:\n                while curr.next and curr.val == curr.next.val:\n                    curr = curr.next\n                prev.next = curr.next\n            else:\n                prev = curr\n            curr = curr.next\n        return dummy.next"}, {"task_id": "remove-duplicates-from-sorted-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        \n        while curr:\n            if curr.next and curr.val == curr.next.val:\n                while curr.next and curr.val == curr.next.val:\n                    curr = curr.next\n                prev.next = curr.next\n            else:\n                prev = curr\n            curr = curr.next\n        return dummy.next"}, {"task_id": "remove-duplicates-from-sorted-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        \n        prev = dummy\n        curr = head\n        \n        while curr:\n            if curr.next and curr.val == curr.next.val:\n                while curr.next and curr.val == curr.next.val:\n                    curr = curr.next\n                prev.next = curr.next\n            else:\n                prev = curr\n            curr = curr.next\n        return dummy.next"}, {"task_id": "remove-duplicates-from-sorted-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if head == None:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        \n        while curr != None:\n            if curr.next != None and curr.val == curr.next.val:\n                while curr.next != None and curr.val == curr.next.val:\n                    curr = curr.next\n                prev.next = curr.next\n            else:\n                prev = curr\n            curr = curr.next\n        return dummy.next"}, {"task_id": "remove-duplicates-from-sorted-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        \n        prev = dummy\n        curr = head\n        \n        while curr:\n            if curr.next and curr.val == curr.next.val:\n                while curr.next and curr.val == curr.next.val:\n                    curr = curr.next\n                prev.next = curr.next\n            else:\n                prev = curr\n            curr = curr.next\n        \n        return dummy.next"}], "3sum": [{"task_id": "3sum", "completion": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-2):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            l, r = i+1, len(nums)-1\n            while l < r:\n                s = nums[i] + nums[l] + nums[r]\n                if s > 0:\n                    r -= 1\n                elif s < 0:\n                    l += 1\n                else:\n                    res.append([nums[i], nums[l], nums[r]])\n                    l += 1\n                    while nums[l] == nums[l-1] and l < r:\n                        l += 1\n        return res"}, {"task_id": "3sum", "completion": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-2):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            l, r = i+1, len(nums)-1\n            while l < r:\n                s = nums[i] + nums[l] + nums[r]\n                if s > 0:\n                    r -= 1\n                elif s < 0:\n                    l += 1\n                else:\n                    res.append([nums[i], nums[l], nums[r]])\n                    l += 1\n                    while nums[l] == nums[l-1] and l < r:\n                        l += 1\n        return res"}, {"task_id": "3sum", "completion": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-2):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            l, r = i+1, len(nums)-1\n            while l < r:\n                s = nums[i] + nums[l] + nums[r]\n                if s > 0:\n                    r -= 1\n                elif s < 0:\n                    l += 1\n                else:\n                    res.append([nums[i], nums[l], nums[r]])\n                    l += 1\n                    while nums[l] == nums[l-1] and l < r:\n                        l += 1\n        return res"}, {"task_id": "3sum", "completion": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-2):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            l, r = i+1, len(nums)-1\n            while l < r:\n                s = nums[i] + nums[l] + nums[r]\n                if s == 0:\n                    res.append([nums[i], nums[l], nums[r]])\n                    l += 1\n                    r -= 1\n                    while l < r and nums[l] == nums[l-1]:\n                        l += 1\n                    while l < r and nums[r] == nums[r+1]:\n                        r -= 1\n                elif s < 0:\n                    l += 1\n                else:\n                    r -= 1\n        return res"}, {"task_id": "3sum", "completion": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-2):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            l, r = i+1, len(nums)-1\n            while l < r:\n                s = nums[i] + nums[l] + nums[r]\n                if s == 0:\n                    res.append([nums[i], nums[l], nums[r]])\n                    l += 1\n                    r -= 1\n                    while l < r and nums[l] == nums[l-1]:\n                        l += 1\n                    while l < r and nums[r] == nums[r+1]:\n                        r -= 1\n                elif s < 0:\n                    l += 1\n                else:\n                    r -= 1\n        return res"}], "edit-distance": [{"task_id": "edit-distance", "completion": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        \n        m = len(word1)\n        n = len(word2)\n        \n        dp = [[0] * (n+1) for _ in range(m+1)]\n        \n        for i in range(m+1):\n            dp[i][0] = i\n        for j in range(n+1):\n            dp[0][j] = j\n        \n        for i in range(1, m+1):\n            for j in range(1, n+1):\n                if word1[i-1] == word2[j-1]:\n                    dp[i][j] = dp[i-1][j-1]\n                else:\n                    dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        \n        return dp[m][n]"}, {"task_id": "edit-distance", "completion": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        \n        m = len(word1)\n        n = len(word2)\n        \n        dp = [[0] * (n+1) for _ in range(m+1)]\n        \n        for i in range(m+1):\n            dp[i][0] = i\n        for j in range(n+1):\n            dp[0][j] = j\n        \n        for i in range(1, m+1):\n            for j in range(1, n+1):\n                if word1[i-1] == word2[j-1]:\n                    dp[i][j] = dp[i-1][j-1]\n                else:\n                    dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        \n        return dp[m][n]"}, {"task_id": "edit-distance", "completion": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        \n        m = len(word1)\n        n = len(word2)\n        \n        dp = [[0] * (n+1) for _ in range(m+1)]\n        \n        for i in range(m+1):\n            for j in range(n+1):\n                if i == 0:\n                    dp[i][j] = j\n                elif j == 0:\n                    dp[i][j] = i\n                elif word1[i-1] == word2[j-1]:\n                    dp[i][j] = dp[i-1][j-1]\n                else:\n                    dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])\n        \n        return dp[m][n]"}, {"task_id": "edit-distance", "completion": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        \n        m = len(word1)\n        n = len(word2)\n        \n        dp = [[0 for i in range(n+1)] for j in range(m+1)]\n        \n        for i in range(m+1):\n            for j in range(n+1):\n                if i == 0:\n                    dp[i][j] = j\n                elif j == 0:\n                    dp[i][j] = i\n                elif word1[i-1] == word2[j-1]:\n                    dp[i][j] = dp[i-1][j-1]\n                else:\n                    dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])\n        \n        return dp[m][n]"}, {"task_id": "edit-distance", "completion": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        \n        m = len(word1)\n        n = len(word2)\n        \n        dp = [[0] * (n+1) for _ in range(m+1)]\n        \n        for i in range(m+1):\n            dp[i][0] = i\n        for j in range(n+1):\n            dp[0][j] = j\n        \n        for i in range(1, m+1):\n            for j in range(1, n+1):\n                if word1[i-1] == word2[j-1]:\n                    dp[i][j] = dp[i-1][j-1]\n                else:\n                    dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        \n        return dp[m][n]"}], "hamming-distance": [{"task_id": "hamming-distance", "completion": "class Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        \n        xor = x ^ y\n        count = 0\n        while xor:\n            count += 1\n            xor = xor & (xor - 1)\n        return count"}, {"task_id": "hamming-distance", "completion": "class Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        \n        xor = x ^ y\n        count = 0\n        while xor:\n            count += 1\n            xor &= xor - 1\n        return count"}, {"task_id": "hamming-distance", "completion": "class Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        \n        xor = x ^ y\n        count = 0\n        while xor:\n            count += 1\n            xor = xor & (xor - 1)\n        return count"}, {"task_id": "hamming-distance", "completion": "class Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        \n        xor = x ^ y\n        count = 0\n        while xor:\n            count += 1\n            xor = xor & (xor - 1)\n        return count"}, {"task_id": "hamming-distance", "completion": "class Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        \n        xor = x ^ y\n        count = 0\n        while xor:\n            count += 1\n            xor &= xor - 1\n        return count"}], "binary-tree-paths": [{"task_id": "binary-tree-paths", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(root, path):\n            if not root:\n                return\n            path += str(root.val)\n            if not root.left and not root.right:\n                self.paths.append(path)\n            else:\n                path += '->'\n                dfs(root.left, path)\n                dfs(root.right, path)\n        \n        self.paths = []\n        dfs(root, '')\n        return self.paths"}, {"task_id": "binary-tree-paths", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(root, path):\n            if not root:\n                return\n            path += str(root.val)\n            if not root.left and not root.right:\n                self.paths.append(path)\n            else:\n                path += '->'\n                dfs(root.left, path)\n                dfs(root.right, path)\n        \n        self.paths = []\n        dfs(root, '')\n        return self.paths"}, {"task_id": "binary-tree-paths", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(root, path):\n            if not root:\n                return\n            path += str(root.val)\n            if not root.left and not root.right:\n                self.paths.append(path)\n            else:\n                path += '->'\n                dfs(root.left, path)\n                dfs(root.right, path)\n        \n        self.paths = []\n        dfs(root, '')\n        return self.paths"}, {"task_id": "binary-tree-paths", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(root, path):\n            if not root:\n                return\n            path += str(root.val)\n            if not root.left and not root.right:\n                self.paths.append(path)\n            else:\n                path += '->'\n                dfs(root.left, path)\n                dfs(root.right, path)\n        \n        self.paths = []\n        dfs(root, '')\n        return self.paths"}, {"task_id": "binary-tree-paths", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(root, path):\n            if not root:\n                return\n            path += str(root.val)\n            if not root.left and not root.right:\n                self.paths.append(path)\n            else:\n                path += '->'\n                dfs(root.left, path)\n                dfs(root.right, path)\n        \n        self.paths = []\n        dfs(root, '')\n        return self.paths"}], "reverse-pairs": [{"task_id": "reverse-pairs", "completion": "class Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        def merge(nums, left, mid, right):\n            i = left\n            j = mid + 1\n            count = 0\n            while i <= mid and j <= right:\n                if nums[i] > nums[j] * 2:\n                    count += mid - i + 1\n                    j += 1\n                else:\n                    i += 1\n            i = left\n            j = mid + 1\n            temp = []\n            while i <= mid and j <= right:\n                if nums[i] <= nums[j]:\n                    temp.append(nums[i])\n                    i += 1\n                else:\n                    temp.append(nums[j])\n                    j += 1\n            while i <= mid:\n                temp.append(nums[i])\n                i += 1\n            while j <= right:\n                temp.append(nums[j])\n                j += 1\n            for i in range(left, right + 1):\n                nums[i] = temp[i - left]\n            return count\n        \n        def mergeSort(nums, left, right):\n            if left >= right:\n                return 0\n            mid = (left + right) // 2\n            count = mergeSort(nums, left, mid) + mergeSort(nums, mid + 1, right)\n            count += merge(nums, left, mid, right)\n            return count\n        \n        return mergeSort(nums, 0, len(nums) - 1)"}, {"task_id": "reverse-pairs", "completion": "class Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        def merge(nums, left, mid, right):\n            i = left\n            j = mid + 1\n            cnt = 0\n            while i <= mid and j <= right:\n                if nums[i] > nums[j] * 2:\n                    cnt += mid - i + 1\n                    j += 1\n                else:\n                    i += 1\n            nums[left:right+1] = sorted(nums[left:right+1])\n            return cnt\n        \n        def mergeSort(nums, left, right):\n            if left >= right:\n                return 0\n            mid = (left + right) // 2\n            cnt = mergeSort(nums, left, mid) + mergeSort(nums, mid + 1, right)\n            cnt += merge(nums, left, mid, right)\n            return cnt\n        \n        return mergeSort(nums, 0, len(nums) - 1)"}, {"task_id": "reverse-pairs", "completion": "class Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        def merge(nums, left, mid, right):\n            i = left\n            j = mid + 1\n            count = 0\n            while i <= mid and j <= right:\n                if nums[i] > nums[j] * 2:\n                    count += mid - i + 1\n                    j += 1\n                else:\n                    i += 1\n            i = left\n            j = mid + 1\n            temp = []\n            while i <= mid and j <= right:\n                if nums[i] <= nums[j]:\n                    temp.append(nums[i])\n                    i += 1\n                else:\n                    temp.append(nums[j])\n                    j += 1\n            while i <= mid:\n                temp.append(nums[i])\n                i += 1\n            while j <= right:\n                temp.append(nums[j])\n                j += 1\n            for i in range(left, right + 1):\n                nums[i] = temp[i - left]\n            return count\n        \n        def mergeSort(nums, left, right):\n            if left >= right:\n                return 0\n            mid = (left + right) // 2\n            count = mergeSort(nums, left, mid) + mergeSort(nums, mid + 1, right)\n            count += merge(nums, left, mid, right)\n            return count\n        \n        return mergeSort(nums, 0, len(nums) - 1)"}, {"task_id": "reverse-pairs", "completion": "class Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        def merge(nums, left, mid, right):\n            i = left\n            j = mid + 1\n            cnt = 0\n            while i <= mid and j <= right:\n                if nums[i] > nums[j] * 2:\n                    cnt += mid - i + 1\n                    j += 1\n                else:\n                    i += 1\n            nums[left:right+1] = sorted(nums[left:right+1])\n            return cnt\n        \n        def mergeSort(nums, left, right):\n            if left >= right:\n                return 0\n            mid = (left + right) // 2\n            cnt = mergeSort(nums, left, mid) + mergeSort(nums, mid + 1, right)\n            cnt += merge(nums, left, mid, right)\n            return cnt\n        \n        return mergeSort(nums, 0, len(nums) - 1)"}, {"task_id": "reverse-pairs", "completion": "class Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        def merge(nums, left, mid, right):\n            i = left\n            j = mid + 1\n            count = 0\n            while i <= mid and j <= right:\n                if nums[i] > nums[j] * 2:\n                    count += mid - i + 1\n                    j += 1\n                else:\n                    i += 1\n            i = left\n            j = mid + 1\n            temp = []\n            while i <= mid and j <= right:\n                if nums[i] <= nums[j]:\n                    temp.append(nums[i])\n                    i += 1\n                else:\n                    temp.append(nums[j])\n                    j += 1\n            while i <= mid:\n                temp.append(nums[i])\n                i += 1\n            while j <= right:\n                temp.append(nums[j])\n                j += 1\n            for i in range(left, right + 1):\n                nums[i] = temp[i - left]\n            return count\n        \n        def mergeSort(nums, left, right):\n            if left >= right:\n                return 0\n            mid = (left + right) // 2\n            count = mergeSort(nums, left, mid) + mergeSort(nums, mid + 1, right)\n            count += merge(nums, left, mid, right)\n            return count\n        \n        return mergeSort(nums, 0, len(nums) - 1)"}], "reaching-points": [{"task_id": "reaching-points", "completion": "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        \n        while tx > sx and ty > sy:\n            if tx > ty:\n                tx %= ty\n            else:\n                ty %= tx\n        return tx == sx and ty == sy"}, {"task_id": "reaching-points", "completion": "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        \n        while tx >= sx and ty >= sy:\n            if tx == sx and ty == sy:\n                return True\n            if tx > ty:\n                tx %= ty\n            else:\n                ty %= tx\n        return False"}, {"task_id": "reaching-points", "completion": "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        \n        while tx >= sx and ty >= sy:\n            if tx == sx and ty == sy:\n                return True\n            if tx > ty:\n                tx %= ty\n            else:\n                ty %= tx\n        return False"}, {"task_id": "reaching-points", "completion": "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        \n        while tx >= sx and ty >= sy:\n            if tx == sx and ty == sy:\n                return True\n            if tx > ty:\n                tx %= ty\n            else:\n                ty %= tx\n        return False"}, {"task_id": "reaching-points", "completion": "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        \n        while tx > sx and ty > sy:\n            if tx > ty:\n                tx %= ty\n            else:\n                ty %= tx\n        return tx == sx and ty == sy"}], "compare-version-numbers": [{"task_id": "compare-version-numbers", "completion": "class Solution(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"\n        \n        v1 = version1.split('.')\n        v2 = version2.split('.')\n        \n        for i in range(max(len(v1), len(v2))):\n            if i < len(v1):\n                v1[i] = int(v1[i])\n            else:\n                v1.append(0)\n                \n            if i < len(v2):\n                v2[i] = int(v2[i])\n            else:\n                v2.append(0)\n                \n        for i in range(max(len(v1), len(v2))):\n            if v1[i] < v2[i]:\n                return -1\n            elif v1[i] > v2[i]:\n                return 1\n                \n        return 0"}, {"task_id": "compare-version-numbers", "completion": "class Solution(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"\n        \n        v1 = version1.split('.')\n        v2 = version2.split('.')\n        \n        for i in range(max(len(v1), len(v2))):\n            if i < len(v1):\n                v1[i] = int(v1[i])\n            else:\n                v1.append(0)\n                \n            if i < len(v2):\n                v2[i] = int(v2[i])\n            else:\n                v2.append(0)\n                \n        for i in range(len(v1)):\n            if v1[i] < v2[i]:\n                return -1\n            elif v1[i] > v2[i]:\n                return 1\n                \n        return 0"}, {"task_id": "compare-version-numbers", "completion": "class Solution(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"\n        \n        v1 = version1.split('.')\n        v2 = version2.split('.')\n        \n        for i in range(max(len(v1), len(v2))):\n            if i < len(v1):\n                v1[i] = int(v1[i])\n            else:\n                v1.append(0)\n                \n            if i < len(v2):\n                v2[i] = int(v2[i])\n            else:\n                v2.append(0)\n                \n        for i in range(max(len(v1), len(v2))):\n            if v1[i] < v2[i]:\n                return -1\n            elif v1[i] > v2[i]:\n                return 1\n                \n        return 0"}, {"task_id": "compare-version-numbers", "completion": "class Solution(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"\n        \n        v1 = version1.split('.')\n        v2 = version2.split('.')\n        \n        for i in range(max(len(v1), len(v2))):\n            if i < len(v1):\n                v1[i] = int(v1[i])\n            else:\n                v1.append(0)\n            if i < len(v2):\n                v2[i] = int(v2[i])\n            else:\n                v2.append(0)\n        \n        for i in range(max(len(v1), len(v2))):\n            if v1[i] < v2[i]:\n                return -1\n            elif v1[i] > v2[i]:\n                return 1\n        \n        return 0"}, {"task_id": "compare-version-numbers", "completion": "class Solution(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"\n        \n        v1 = version1.split('.')\n        v2 = version2.split('.')\n        \n        for i in range(max(len(v1), len(v2))):\n            if i < len(v1):\n                v1[i] = int(v1[i])\n            else:\n                v1.append(0)\n            if i < len(v2):\n                v2[i] = int(v2[i])\n            else:\n                v2.append(0)\n        \n        for i in range(len(v1)):\n            if v1[i] < v2[i]:\n                return -1\n            elif v1[i] > v2[i]:\n                return 1\n        \n        return 0"}], "best-time-to-buy-and-sell-stock-ii": [{"task_id": "best-time-to-buy-and-sell-stock-ii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. Dynamic Programming\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 3. Greedy\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        max_profit = 0\n        for i in range(len(prices)):\n            for j in range(i+1, len(prices)):\n                if prices[j] > prices[i]:\n                    max_profit = max(max_profit, prices[j] - prices[i])\n        return max_profit\n        \n        ## 2. Dynamic Programming\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        max_profit = 0\n        min_price = prices[0]\n        for i in range(1, len(prices)):\n            min_price = min(min_price, prices[i])\n            max_profit = max(max_profit, prices[i] - min_price)\n        return max_profit\n        \n        ## 3. Greedy\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        max_profit = 0\n        min_price = prices[0]\n        for i in range(1, len(prices)):\n            min_price = min(min_price, prices[i])\n            max_profit = max(max_profit, prices[i] - min_price)\n        return max_profit"}, {"task_id": "best-time-to-buy-and-sell-stock-ii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Brute force\n        ## Time: O(n^2)\n        ## Space: O(1)\n        ## 2. DP\n        ## Time: O(n)\n        ## Space: O(n)\n        ## 3. Greedy\n        ## Time: O(n)\n        ## Space: O(1)\n        \n        ## 1. Brute force\n        ## Time: O(n^2)\n        ## Space: O(1)\n        max_profit = 0\n        for i in range(len(prices)):\n            for j in range(i+1, len(prices)):\n                max_profit = max(max_profit, prices[j] - prices[i])\n        return max_profit"}, {"task_id": "best-time-to-buy-and-sell-stock-ii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        max_profit = 0\n        for i in range(len(prices)):\n            for j in range(i+1, len(prices)):\n                max_profit = max(max_profit, prices[j] - prices[i])\n        return max_profit"}, {"task_id": "best-time-to-buy-and-sell-stock-ii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. DP\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## 3. Greedy\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        max_profit = 0\n        for i in range(len(prices)):\n            for j in range(i+1, len(prices)):\n                max_profit = max(max_profit, prices[j] - prices[i])\n        return max_profit"}, {"task_id": "best-time-to-buy-and-sell-stock-ii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## 2. Dynamic Programming\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        max_profit = 0\n        for i in range(len(prices)):\n            for j in range(i+1, len(prices)):\n                if prices[j] > prices[i]:\n                    max_profit = max(max_profit, prices[j] - prices[i])\n        return max_profit\n        \n        ## 2. Dynamic Programming\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        max_profit = 0\n        min_price = float('inf')\n        for price in prices:\n            min_price = min(min_price, price)\n            max_profit = max(max_profit, price - min_price)\n        return max_profit"}], "course-schedule-iii": [{"task_id": "course-schedule-iii", "completion": "class Solution(object):\n    def scheduleCourse(self, courses):\n        \"\"\"\n        :type courses: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort by end date\n        courses.sort(key=lambda x: x[1])\n        \n        # priority queue\n        pq = []\n        \n        # total time\n        total = 0\n        \n        for duration, end in courses:\n            # add to priority queue\n            heapq.heappush(pq, (-duration, end))\n            \n            # add to total time\n            total += duration\n            \n            # if total time exceeds end date\n            if total > end:\n                # remove from priority queue\n                total += heapq.heappop(pq)[0]\n                \n        return len(pq)"}, {"task_id": "course-schedule-iii", "completion": "class Solution(object):\n    def scheduleCourse(self, courses):\n        \"\"\"\n        :type courses: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort by end date\n        courses.sort(key=lambda x: x[1])\n        \n        # priority queue\n        pq = []\n        \n        # total time\n        total = 0\n        \n        # iterate over courses\n        for course in courses:\n            # add course to priority queue\n            heapq.heappush(pq, course[0])\n            \n            # add course duration to total\n            total += course[0]\n            \n            # if total exceeds course duration\n            if total > course[1]:\n                # remove course with longest duration\n                total -= heapq.heappop(pq)\n                \n        # return number of courses\n        return len(pq)"}, {"task_id": "course-schedule-iii", "completion": "class Solution(object):\n    def scheduleCourse(self, courses):\n        \"\"\"\n        :type courses: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort by last day\n        courses.sort(key=lambda x: x[1])\n        \n        # priority queue\n        pq = []\n        \n        # total time\n        total = 0\n        \n        for duration, lastDay in courses:\n            # add course to queue\n            heapq.heappush(pq, (-duration, lastDay))\n            \n            # add course to total time\n            total += duration\n            \n            # if total time exceeds last day, remove course from queue\n            while total > lastDay:\n                total += heapq.heappop(pq)[0]\n                \n        return len(pq)"}, {"task_id": "course-schedule-iii", "completion": "class Solution(object):\n    def scheduleCourse(self, courses):\n        \"\"\"\n        :type courses: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort by last day\n        courses.sort(key=lambda x: x[1])\n        \n        # priority queue\n        pq = []\n        \n        # total time\n        total = 0\n        \n        for duration, lastDay in courses:\n            # add to pq\n            heapq.heappush(pq, (-duration, lastDay))\n            \n            # add to total\n            total += duration\n            \n            # if total exceeds last day\n            if total > lastDay:\n                # pop from pq\n                total += heapq.heappop(pq)[0]\n                \n        return len(pq)"}, {"task_id": "course-schedule-iii", "completion": "class Solution(object):\n    def scheduleCourse(self, courses):\n        \"\"\"\n        :type courses: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort by end date\n        courses.sort(key=lambda x: x[1])\n        \n        # priority queue\n        pq = []\n        \n        # total time\n        total = 0\n        \n        # iterate over courses\n        for course in courses:\n            # add course to priority queue\n            heapq.heappush(pq, course[0])\n            \n            # add course duration to total\n            total += course[0]\n            \n            # if total exceeds course duration\n            if total > course[1]:\n                # remove course from priority queue\n                total -= heapq.heappop(pq)\n                \n        # return length of priority queue\n        return len(pq)"}], "reverse-nodes-in-k-group": [{"task_id": "reverse-nodes-in-k-group", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        \n        prev = dummy\n        curr = head\n        while curr:\n            next_node = curr.next\n            for i in range(k):\n                if curr.next:\n                    curr = curr.next\n                else:\n                    return dummy.next\n            prev.next = curr\n            curr = next_node\n            for i in range(k):\n                if curr:\n                    curr = curr.next\n                else:\n                    return dummy.next\n            prev.next = curr\n            prev = curr\n            curr = next_node\n        return dummy.next"}, {"task_id": "reverse-nodes-in-k-group", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        count = 0\n        \n        while curr:\n            count += 1\n            if count % k == 0:\n                prev = self.reverse(prev, curr)\n                curr = prev.next\n            else:\n                curr = curr.next\n        \n        return dummy.next\n    \n    def reverse(self, prev, tail):\n        curr = prev.next\n        prev.next = None\n        while curr != tail:\n            nxt = curr.next\n            curr.next = prev.next\n            prev.next = curr\n            curr = nxt\n        return prev"}, {"task_id": "reverse-nodes-in-k-group", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        while curr:\n            count = 0\n            while curr and count < k:\n                curr = curr.next\n                count += 1\n            if count == k:\n                prev.next = self.reverse(head, curr)\n                prev = head\n                head = curr\n            else:\n                prev.next = head\n                break\n        return dummy.next\n    \n    def reverse(self, head, tail):\n        prev = None\n        curr = head\n        while curr != tail:\n            nxt = curr.next\n            curr.next = prev\n            prev = curr\n            curr = nxt\n        return curr"}, {"task_id": "reverse-nodes-in-k-group", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        count = 0\n        \n        while curr:\n            count += 1\n            if count % k == 0:\n                prev = self.reverse(prev, curr)\n                curr = prev.next\n            else:\n                curr = curr.next\n        \n        return dummy.next\n    \n    def reverse(self, prev, tail):\n        curr = prev.next\n        prev.next = None\n        while curr != tail:\n            nxt = curr.next\n            curr.next = prev.next\n            prev.next = curr\n            curr = nxt\n        return tail"}, {"task_id": "reverse-nodes-in-k-group", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        while curr:\n            count = 0\n            while curr and count < k:\n                curr = curr.next\n                count += 1\n            if count == k:\n                prev.next = self.reverse(head, curr)\n                prev = head\n                head = curr\n            else:\n                prev.next = head\n                break\n        return dummy.next\n    \n    def reverse(self, head, tail):\n        prev = None\n        curr = head\n        while curr != tail:\n            nxt = curr.next\n            curr.next = prev\n            prev = curr\n            curr = nxt\n        return curr"}], "repeated-substring-pattern": [{"task_id": "repeated-substring-pattern", "completion": "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        ## Brute force\n        ## Time: O(n^2)\n        ## Space: O(n)\n        ## TLE\n        ## for i in range(len(s)//2):\n        ##     if len(s) % (i+1) == 0 and s[:i+1] * (len(s)//(i+1)) == s:\n        ##         return True\n        ## return False\n        \n        ## KMP\n        ## Time: O(n)\n        ## Space: O(n)\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/100222/Python-KMP-solution-with-detailed-explanation\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/100222/Python-KMP-solution-with-detailed-explanation\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/100222/Python-KMP-solution-with-detailed-explanation\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/100222/Python-KMP-solution-with-detailed-explanation\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/100222/Python-KMP-solution-with-detailed-explanation\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/100222/Python-KMP-solution-with-detailed-explanation\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/100222/Python-KMP-solution-with-detailed-explanation\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/100222/Python-KMP-solution-with-detailed-explanation\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/100222/Python-KMP-solution-with-detailed-explanation\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/100222/Python-KMP-solution-with-detailed-explanation\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/100222/Python-KMP-solution-with-detailed-explanation\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/100222/Python-KMP-solution-with-detailed-explanation\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/100222/Python-KMP-solution-with-detailed-explanation\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/100222/Python-KMP-solution-with-detailed-explanation\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/100222/Python-KMP-solution-with-detailed-explanation\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/100222/Python-KMP-solution-with-detailed-explanation\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/100222/Python-KMP-solution-with-detailed-explanation\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/100222/Python-KMP-solution-with"}, {"task_id": "repeated-substring-pattern", "completion": "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) == 0:\n            return False\n        \n        for i in range(1, len(s)//2 + 1):\n            if len(s) % i == 0:\n                if s[:i] * (len(s)//i) == s:\n                    return True\n        return False"}, {"task_id": "repeated-substring-pattern", "completion": "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) == 1:\n            return False\n        \n        for i in range(1, len(s)//2 + 1):\n            if len(s) % i == 0:\n                if s[:i] * (len(s)//i) == s:\n                    return True\n        return False"}, {"task_id": "repeated-substring-pattern", "completion": "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) == 1:\n            return False\n        \n        for i in range(1, len(s)//2 + 1):\n            if len(s) % i == 0:\n                if s[:i] * (len(s)//i) == s:\n                    return True\n        return False"}, {"task_id": "repeated-substring-pattern", "completion": "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        ## Brute force\n        ## Time: O(n^2)\n        ## Space: O(n)\n        ## TLE\n        ## for i in range(len(s)//2):\n        ##     if s[:i+1]*(len(s)//(i+1)) == s:\n        ##         return True\n        ## return False\n        \n        ## KMP\n        ## Time: O(n)\n        ## Space: O(n)\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/100875/Python-KMP-solution-with-detailed-explanation\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/100875/Python-KMP-solution-with-detailed-explanation\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/100875/Python-KMP-solution-with-detailed-explanation\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/100875/Python-KMP-solution-with-detailed-explanation\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/100875/Python-KMP-solution-with-detailed-explanation\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/100875/Python-KMP-solution-with-detailed-explanation\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/100875/Python-KMP-solution-with-detailed-explanation\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/100875/Python-KMP-solution-with-detailed-explanation\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/100875/Python-KMP-solution-with-detailed-explanation\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/100875/Python-KMP-solution-with-detailed-explanation\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/100875/Python-KMP-solution-with-detailed-explanation\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/100875/Python-KMP-solution-with-detailed-explanation\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/100875/Python-KMP-solution-with-detailed-explanation\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/100875/Python-KMP-solution-with-detailed-explanation\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/100875/Python-KMP-solution-with-detailed-explanation\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/100875/Python-KMP-solution-with-detailed-explanation\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/100875/Python-KMP-solution-with-detailed-explanation\n        ## https://leetcode.com/problems/repeated-substring-pattern/discuss/100875/Python-KMP-solution-with-detailed-explanation\n        ## https://le"}], "unique-binary-search-trees": [{"task_id": "unique-binary-search-trees", "completion": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        dp = [0] * (n+1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, n+1):\n            for j in range(1, i+1):\n                dp[i] += dp[j-1] * dp[i-j]\n                \n        return dp[n]"}, {"task_id": "unique-binary-search-trees", "completion": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        dp = [0] * (n+1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, n+1):\n            for j in range(1, i+1):\n                dp[i] += dp[j-1] * dp[i-j]\n                \n        return dp[n]"}, {"task_id": "unique-binary-search-trees", "completion": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        dp = [0] * (n+1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, n+1):\n            for j in range(1, i+1):\n                dp[i] += dp[j-1] * dp[i-j]\n        \n        return dp[n]"}, {"task_id": "unique-binary-search-trees", "completion": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        dp = [0] * (n+1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, n+1):\n            for j in range(1, i+1):\n                dp[i] += dp[j-1] * dp[i-j]\n                \n        return dp[n]"}, {"task_id": "unique-binary-search-trees", "completion": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        dp = [0] * (n+1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, n+1):\n            for j in range(1, i+1):\n                dp[i] += dp[j-1] * dp[i-j]\n        \n        return dp[n]"}], "single-number-ii": [{"task_id": "single-number-ii", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Brute force\n        ## Time: O(n^2)\n        ## Space: O(1)\n        # for i in nums:\n        #     if nums.count(i) == 1:\n        #         return i\n        \n        ## 2. Bit manipulation\n        ## Time: O(n)\n        ## Space: O(1)\n        # res = 0\n        # for i in nums:\n        #     res ^= i\n        # return res\n        \n        ## 3. Hashmap\n        ## Time: O(n)\n        ## Space: O(n)\n        # hashmap = {}\n        # for i in nums:\n        #     if i not in hashmap:\n        #         hashmap[i] = 1\n        #     else:\n        #         hashmap[i] += 1\n        # for i in hashmap:\n        #     if hashmap[i] == 1:\n        #         return i\n        \n        ## 4. Bit manipulation\n        ## Time: O(n)\n        ## Space: O(1)\n        # res = 0\n        # for i in nums:\n        #     res ^= i\n        # return res\n        \n        ## 5. Bit manipulation\n        ## Time: O(n)\n        ## Space: O(1)\n        # res = 0\n        # for i in nums:\n        #     res ^= i\n        # return res\n        \n        ## 6. Bit manipulation\n        ## Time: O(n)\n        ## Space: O(1)\n        # res = 0\n        # for i in nums:\n        #     res ^= i\n        # return res\n        \n        ## 7. Bit manipulation\n        ## Time: O(n)\n        ## Space: O(1)\n        # res = 0\n        # for i in nums:\n        #     res ^= i\n        # return res\n        \n        ## 8. Bit manipulation\n        ## Time: O(n)\n        ## Space: O(1)\n        # res = 0\n        # for i in nums:\n        #     res ^= i\n        # return res\n        \n        ## 9. Bit manipulation\n        ## Time: O(n)\n        ## Space: O(1)\n        # res = 0\n        # for i in nums:\n        #     res ^= i\n        # return res\n        \n        ## 10. Bit manipulation\n        ## Time: O(n)\n        ## Space: O(1)\n        # res = 0\n        # for i in nums:\n        #     res ^= i\n        # return res\n        \n        ## 11. Bit manipulation\n        ## Time: O(n)\n        ## Space: O(1)\n        # res = 0\n        # for i in nums:\n        #     res ^= i\n        # return res\n        \n        ## 12. Bit manipulation\n        ## Time: O(n)\n        ## Space: O(1)\n        # res = 0\n        # for i in nums:\n        #     res ^= i\n        # return res\n        \n        ## 13. Bit manipulation\n        ## Time: O(n)\n        ## Space: O(1)\n        # res = 0\n        # for i in nums:\n        #     res ^= i\n        # return res\n        \n        ## 14. Bit manipulation\n        ## Time: O(n)\n        ## Space: O(1)\n        # res = 0\n        # for i in nums:\n        #     res ^= i\n        # return res\n        \n        ## 15. Bit manipulation\n        ## Time: O(n)\n        ## Space: O(1)\n        # res = 0\n        # for i in nums:\n        #     res ^= i\n        # return res\n        \n        ## 16. Bit manipulation\n        ## Time: O(n)\n        ## Space: O(1)\n        # res = 0\n        # for i in nums:\n        #     res ^= i\n        # return res"}, {"task_id": "single-number-ii", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Brute force\n        ## 2. Using hashmap\n        ## 3. Using XOR\n        ## 4. Using bit manipulation\n        \n        ## 1. Brute force\n        ## Time complexity: O(n^2)\n        ## Space complexity: O(1)\n        ## 2. Using hashmap\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ## 3. Using XOR\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## 4. Using bit manipulation\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        \n        ## 1. Brute force\n        ## Time complexity: O(n^2)\n        ## Space complexity: O(1)\n        ## 2. Using hashmap\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ## 3. Using XOR\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## 4. Using bit manipulation\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        \n        ## 1. Brute force\n        ## Time complexity: O(n^2)\n        ## Space complexity: O(1)\n        ## 2. Using hashmap\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ## 3. Using XOR\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## 4. Using bit manipulation\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        \n        ## 1. Brute force\n        ## Time complexity: O(n^2)\n        ## Space complexity: O(1)\n        ## 2. Using hashmap\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ## 3. Using XOR\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## 4. Using bit manipulation\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        \n        ## 1. Brute force\n        ## Time complexity: O(n^2)\n        ## Space complexity: O(1)\n        ## 2. Using hashmap\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ## 3. Using XOR\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## 4. Using bit manipulation\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        \n        ## 1. Brute force\n        ## Time complexity: O(n^2)\n        ## Space complexity: O(1)\n        ## 2. Using hashmap\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ## 3. Using XOR\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## 4. Using bit manipulation\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        \n        ## 1. Brute force\n        ## Time complexity: O(n^2)\n        ## Space complexity: O(1)\n        ## 2. Using hashmap\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ## 3. Using XOR\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## 4. Using bit manipulation\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        \n        ## 1. Brute force\n        ## Time complexity: O(n^2)\n        ## Space complexity: O(1)\n        ## 2. Using hashmap\n        ## Time complexity:"}, {"task_id": "single-number-ii", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Brute force\n        ## 2. Using hashmap\n        ## 3. Using XOR\n        ## 4. Using bit manipulation\n        \n        ## 1. Brute force\n        ## Time complexity: O(n^2)\n        ## Space complexity: O(1)\n        ## 2. Using hashmap\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ## 3. Using XOR\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## 4. Using bit manipulation\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        \n        ## 1. Brute force\n        ## Time complexity: O(n^2)\n        ## Space complexity: O(1)\n        ## 2. Using hashmap\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ## 3. Using XOR\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## 4. Using bit manipulation\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        \n        ## 1. Brute force\n        ## Time complexity: O(n^2)\n        ## Space complexity: O(1)\n        ## 2. Using hashmap\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ## 3. Using XOR\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## 4. Using bit manipulation\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        \n        ## 1. Brute force\n        ## Time complexity: O(n^2)\n        ## Space complexity: O(1)\n        ## 2. Using hashmap\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ## 3. Using XOR\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## 4. Using bit manipulation\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        \n        ## 1. Brute force\n        ## Time complexity: O(n^2)\n        ## Space complexity: O(1)\n        ## 2. Using hashmap\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ## 3. Using XOR\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## 4. Using bit manipulation\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        \n        ## 1. Brute force\n        ## Time complexity: O(n^2)\n        ## Space complexity: O(1)\n        ## 2. Using hashmap\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ## 3. Using XOR\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## 4. Using bit manipulation\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        \n        ## 1. Brute force\n        ## Time complexity: O(n^2)\n        ## Space complexity: O(1)\n        ## 2. Using hashmap\n        ## Time complexity: O(n)\n        ## Space complexity: O(n)\n        ## 3. Using XOR\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## 4. Using bit manipulation\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        \n        ## 1. Brute force\n        ## Time complexity: O(n^2)\n        ## Space complexity: O(1)\n        ## 2. Using hashmap\n        ## Time complexity:"}, {"task_id": "single-number-ii", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Brute force\n        ## 2. Hashmap\n        ## 3. Bit manipulation\n        ## 4. Bit manipulation\n        ## 5. Bit manipulation\n        ## 6. Bit manipulation\n        ## 7. Bit manipulation\n        ## 8. Bit manipulation\n        ## 9. Bit manipulation\n        ## 10. Bit manipulation\n        ## 11. Bit manipulation\n        ## 12. Bit manipulation\n        ## 13. Bit manipulation\n        ## 14. Bit manipulation\n        ## 15. Bit manipulation\n        ## 16. Bit manipulation\n        ## 17. Bit manipulation\n        ## 18. Bit manipulation\n        ## 19. Bit manipulation\n        ## 20. Bit manipulation\n        ## 21. Bit manipulation\n        ## 22. Bit manipulation\n        ## 23. Bit manipulation\n        ## 24. Bit manipulation\n        ## 25. Bit manipulation\n        ## 26. Bit manipulation\n        ## 27. Bit manipulation\n        ## 28. Bit manipulation\n        ## 29. Bit manipulation\n        ## 30. Bit manipulation\n        ## 31. Bit manipulation\n        ## 32. Bit manipulation\n        ## 33. Bit manipulation\n        ## 34. Bit manipulation\n        ## 35. Bit manipulation\n        ## 36. Bit manipulation\n        ## 37. Bit manipulation\n        ## 38. Bit manipulation\n        ## 39. Bit manipulation\n        ## 40. Bit manipulation\n        ## 41. Bit manipulation\n        ## 42. Bit manipulation\n        ## 43. Bit manipulation\n        ## 44. Bit manipulation\n        ## 45. Bit manipulation\n        ## 46. Bit manipulation\n        ## 47. Bit manipulation\n        ## 48. Bit manipulation\n        ## 49. Bit manipulation\n        ## 50. Bit manipulation\n        ## 51. Bit manipulation\n        ## 52. Bit manipulation\n        ## 53. Bit manipulation\n        ## 54. Bit manipulation\n        ## 55. Bit manipulation\n        ## 56. Bit manipulation\n        ## 57. Bit manipulation\n        ## 58. Bit manipulation\n        ## 59. Bit manipulation\n        ## 60. Bit manipulation\n        ## 61. Bit manipulation\n        ## 62. Bit manipulation\n        ## 63. Bit manipulation\n        ## 64. Bit manipulation\n        ## 65. Bit manipulation\n        ## 66. Bit manipulation\n        ## 67. Bit manipulation\n        ## 68. Bit manipulation\n        ## 69. Bit manipulation\n        ## 70. Bit manipulation\n        ## 71. Bit manipulation\n        ## 72. Bit manipulation\n        ## 73. Bit manipulation\n        ## 74. Bit manipulation\n        ## 75. Bit manipulation\n        ## 76. Bit manipulation\n        ## 77. Bit manipulation\n        ## 78. Bit manipulation\n        ## 79. Bit manipulation\n        ## 80. Bit manipulation\n        ## 81. Bit manipulation\n        ## 82. Bit manipulation\n        ## 83. Bit manipulation\n        ## 84. Bit manipulation\n        ## 85. Bit manipulation\n        ## 86. Bit manipulation\n        ## 87. Bit manipulation\n        ## 88. Bit manipulation\n        ## 89. Bit manipulation\n        ## 90. Bit manipulation\n        ## 91. Bit manipulation\n        ## 92. Bit manipulation\n        ## 93. Bit manipulation\n        ## 94. Bit manipulation"}, {"task_id": "single-number-ii", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Brute force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## Runtime: 104 ms, faster than 99.95% of Python online submissions for Single Number.\n        ## Memory Usage: 14.4 MB, less than 99.95% of Python online submissions for Single Number.\n        ## for i in nums:\n        ##     if nums.count(i) == 1:\n        ##         return i\n        \n        ## 2. Bit Manipulation\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 40 ms, faster than 99.95% of Python online submissions for Single Number.\n        ## Memory Usage: 14.4 MB, less than 99.95% of Python online submissions for Single Number.\n        ## return 2*sum(set(nums)) - sum(nums)\n        \n        ## 3. Hash Table\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## Runtime: 40 ms, faster than 99.95% of Python online submissions for Single Number.\n        ## Memory Usage: 14.4 MB, less than 99.95% of Python online submissions for Single Number.\n        ## d = {}\n        ## for i in nums:\n        ##     if i in d:\n        ##         d[i] += 1\n        ##     else:\n        ##         d[i] = 1\n        ## for i in d:\n        ##     if d[i] == 1:\n        ##         return i\n        \n        ## 4. XOR\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 40 ms, faster than 99.95% of Python online submissions for Single Number.\n        ## Memory Usage: 14.4 MB, less than 99.95% of Python online submissions for Single Number.\n        ## return 2*sum(set(nums)) - sum(nums)\n        \n        ## 5. Bit Manipulation\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 40 ms, faster than 99.95% of Python online submissions for Single Number.\n        ## Memory Usage: 14.4 MB, less than 99.95% of Python online submissions for Single Number.\n        ## return 2*sum(set(nums)) - sum(nums)\n        \n        ## 6. Bit Manipulation\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 40 ms, faster than 99.95% of Python online submissions for Single Number.\n        ## Memory Usage: 14.4 MB, less than 99.95% of Python online submissions for Single Number.\n        ## return 2*sum(set(nums)) - sum(nums)\n        \n        ## 7. Bit Manipulation\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 40 ms, faster than 99.95% of Python online submissions for Single Number.\n        ## Memory Usage: 14.4 MB, less than 99.95% of Python online submissions for Single Number.\n        ## return 2*sum(set(nums)) - sum(nums)\n        \n        ## 8. Bit Manipulation\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 40 ms, faster than 99.95% of Python online submissions for Single Number.\n        ## Memory Usage: 14.4 MB, less than 99.95% of Python online submissions for Single"}], "stickers-to-spell-word": [{"task_id": "stickers-to-spell-word", "completion": "class Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        \n        def dfs(target):\n            if target in memo:\n                return memo[target]\n            if not target:\n                return 0\n            res = float('inf')\n            for sticker in stickers:\n                if not set(target).issubset(set(sticker)):\n                    continue\n                res = min(res, dfs(target.replace(sticker, '', 1)) + 1)\n            memo[target] = res\n            return res\n        \n        memo = {}\n        return dfs(target) if dfs(target) != float('inf') else -1"}, {"task_id": "stickers-to-spell-word", "completion": "class Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        \n        def dfs(target):\n            if target in memo:\n                return memo[target]\n            if not target:\n                return 0\n            res = float('inf')\n            for sticker in stickers:\n                if not set(target).issubset(set(sticker)):\n                    continue\n                res = min(res, dfs(target.replace(sticker, '', 1)) + 1)\n            memo[target] = res\n            return res\n        \n        memo = {}\n        return dfs(target) if dfs(target) != float('inf') else -1"}, {"task_id": "stickers-to-spell-word", "completion": "class Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        \n        def dfs(target):\n            if target in memo:\n                return memo[target]\n            if not target:\n                return 0\n            res = float('inf')\n            for sticker in stickers:\n                if not set(target).issubset(set(sticker)):\n                    continue\n                res = min(res, dfs(target.replace(sticker, '', 1)) + 1)\n            memo[target] = res\n            return res\n        \n        memo = {}\n        return dfs(target) if dfs(target) != float('inf') else -1"}, {"task_id": "stickers-to-spell-word", "completion": "class Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        \n        def dfs(target):\n            if target in memo:\n                return memo[target]\n            if not target:\n                return 0\n            res = float('inf')\n            for sticker in stickers:\n                if not set(target).issubset(sticker):\n                    continue\n                res = min(res, dfs(target.replace(sticker, '', 1)) + 1)\n            memo[target] = res\n            return res\n        \n        memo = {}\n        return dfs(target) if dfs(target) != float('inf') else -1"}, {"task_id": "stickers-to-spell-word", "completion": "class Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        \n        def dfs(target):\n            if target in memo:\n                return memo[target]\n            if not target:\n                return 0\n            res = float('inf')\n            for sticker in stickers:\n                if not target.startswith(sticker):\n                    continue\n                res = min(res, dfs(target[len(sticker):]) + 1)\n            memo[target] = res\n            return res\n        \n        memo = {}\n        return dfs(target) if dfs(target) != float('inf') else -1"}], "strange-printer": [{"task_id": "strange-printer", "completion": "class Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        \n        for i in range(n):\n            dp[i][i] = 1\n        \n        for i in range(n-2, -1, -1):\n            for j in range(i+1, n):\n                dp[i][j] = dp[i][j-1]\n                for k in range(i, j):\n                    if s[k] == s[j]:\n                        dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j-1])\n        \n        return dp[0][n-1]"}, {"task_id": "strange-printer", "completion": "class Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        \n        for i in range(n):\n            dp[i][i] = 1\n        \n        for i in range(n-2, -1, -1):\n            for j in range(i+1, n):\n                dp[i][j] = dp[i][j-1]\n                for k in range(i, j):\n                    if s[k] == s[j]:\n                        dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j-1])\n        \n        return dp[0][n-1]"}, {"task_id": "strange-printer", "completion": "class Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        \n        for i in range(n):\n            dp[i][i] = 1\n        \n        for i in range(n-2, -1, -1):\n            for j in range(i+1, n):\n                dp[i][j] = dp[i][j-1]\n                for k in range(i, j):\n                    if s[k] == s[j]:\n                        dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j-1])\n        \n        return dp[0][n-1]"}, {"task_id": "strange-printer", "completion": "class Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        \n        for i in range(n):\n            dp[i][i] = 1\n        \n        for i in range(n-2, -1, -1):\n            for j in range(i+1, n):\n                dp[i][j] = dp[i][j-1]\n                for k in range(i, j):\n                    if s[k] == s[j]:\n                        dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j-1])\n        \n        return dp[0][n-1]"}, {"task_id": "strange-printer", "completion": "class Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        n = len(s)\n        dp = [[0] * n for _ in range(n)]\n        \n        for i in range(n):\n            dp[i][i] = 1\n        \n        for i in range(n-2, -1, -1):\n            for j in range(i+1, n):\n                dp[i][j] = dp[i][j-1]\n                for k in range(i, j):\n                    if s[k] == s[j]:\n                        dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j-1])\n        \n        return dp[0][n-1]"}], "sqrtx": [{"task_id": "sqrtx", "completion": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x == 0:\n            return 0\n        \n        if x == 1:\n            return 1\n        \n        if x == 2:\n            return 1\n        \n        if x == 3:\n            return 1\n        \n        if x == 4:\n            return 2\n        \n        if x == 5:\n            return 2\n        \n        if x == 6:\n            return 2\n        \n        if x == 7:\n            return 2\n        \n        if x == 8:\n            return 2\n        \n        if x == 9:\n            return 3\n        \n        if x == 10:\n            return 3\n        \n        if x == 11:\n            return 3\n        \n        if x == 12:\n            return 3\n        \n        if x == 13:\n            return 3\n        \n        if x == 14:\n            return 3\n        \n        if x == 15:\n            return 3\n        \n        if x == 16:\n            return 4\n        \n        if x == 17:\n            return 4\n        \n        if x == 18:\n            return 4\n        \n        if x == 19:\n            return 4\n        \n        if x == 20:\n            return 4\n        \n        if x == 21:\n            return 4\n        \n        if x == 22:\n            return 4\n        \n        if x == 23:\n            return 4\n        \n        if x == 24:\n            return 4\n        \n        if x == 25:\n            return 4\n        \n        if x == 26:\n            return 4\n        \n        if x == 27:\n            return 4\n        \n        if x == 28:\n            return 4\n        \n        if x == 29:\n            return 4\n        \n        if x == 30:\n            return 4\n        \n        if x == 31:\n            return 4\n        \n        if x == 32:\n            return 4\n        \n        if x == 33:\n            return 4\n        \n        if x == 34:\n            return 4\n        \n        if x == 35:\n            return 4\n        \n        if x == 36:\n            return 4\n        \n        if x == 37:\n            return 4\n        \n        if x == 38:\n            return 4\n        \n        if x == 39:\n            return 4\n        \n        if x == 40:\n            return 4\n        \n        if x == 41:\n            return 4\n        \n        if x == 42:\n            return 4\n        \n        if x == 43:\n            return 4\n        \n        if x == 44:\n            return 4\n        \n        if x == 45:\n            return 4\n        \n        if x == 46:\n            return 4\n        \n        if x == 47:\n            return 4\n        \n        if x == 48:\n            return 4\n        \n        if x == 49:\n            return 4\n        \n        if x == 50:\n            return 4\n        \n        if x == 51:\n            return 4\n        \n        if x == 52:\n            return 4\n        \n        if x == 53:\n            return 4\n        \n        if x == 54:\n            return 4\n        \n        if x == 55:\n            return 4\n        \n        if x == 56:\n            return 4\n        \n        if x == 57:\n            return 4\n        \n        if x == 58:\n            return 4\n        \n        if x == 59:\n            return 4\n        \n        if x == 60:\n            return 4\n        \n        if x == 61:\n            return 4\n        \n        if x == 62:\n            return 4\n        \n        if x == 63:\n            return 4\n        \n        if x == 64:\n            return 4\n        \n        if x == 65:\n            return 4\n        \n        if x == 66:\n            return 4\n        \n        if x == 67:\n            return 4\n        \n        if x == 68:\n            return 4"}, {"task_id": "sqrtx", "completion": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x == 0:\n            return 0\n        \n        if x == 1:\n            return 1\n        \n        if x == 2:\n            return 1\n        \n        if x == 3:\n            return 1\n        \n        if x == 4:\n            return 2\n        \n        if x == 5:\n            return 2\n        \n        if x == 6:\n            return 2\n        \n        if x == 7:\n            return 2\n        \n        if x == 8:\n            return 2\n        \n        if x == 9:\n            return 3\n        \n        if x == 10:\n            return 3\n        \n        if x == 11:\n            return 3\n        \n        if x == 12:\n            return 3\n        \n        if x == 13:\n            return 3\n        \n        if x == 14:\n            return 3\n        \n        if x == 15:\n            return 3\n        \n        if x == 16:\n            return 4\n        \n        if x == 17:\n            return 4\n        \n        if x == 18:\n            return 4\n        \n        if x == 19:\n            return 4\n        \n        if x == 20:\n            return 4\n        \n        if x == 21:\n            return 4\n        \n        if x == 22:\n            return 4\n        \n        if x == 23:\n            return 4\n        \n        if x == 24:\n            return 4\n        \n        if x == 25:\n            return 4\n        \n        if x == 26:\n            return 4\n        \n        if x == 27:\n            return 4\n        \n        if x == 28:\n            return 4\n        \n        if x == 29:\n            return 4\n        \n        if x == 30:\n            return 4\n        \n        if x == 31:\n            return 4\n        \n        if x == 32:\n            return 4\n        \n        if x == 33:\n            return 4\n        \n        if x == 34:\n            return 4\n        \n        if x == 35:\n            return 4\n        \n        if x == 36:\n            return 4\n        \n        if x == 37:\n            return 4\n        \n        if x == 38:\n            return 4\n        \n        if x == 39:\n            return 4\n        \n        if x == 40:\n            return 4\n        \n        if x == 41:\n            return 4\n        \n        if x == 42:\n            return 4\n        \n        if x == 43:\n            return 4\n        \n        if x == 44:\n            return 4\n        \n        if x == 45:\n            return 4\n        \n        if x == 46:\n            return 4\n        \n        if x == 47:\n            return 4\n        \n        if x == 48:\n            return 4\n        \n        if x == 49:\n            return 4\n        \n        if x == 50:\n            return 4\n        \n        if x == 51:\n            return 4\n        \n        if x == 52:\n            return 4\n        \n        if x == 53:\n            return 4\n        \n        if x == 54:\n            return 4\n        \n        if x == 55:\n            return 4\n        \n        if x == 56:\n            return 4\n        \n        if x == 57:\n            return 4\n        \n        if x == 58:\n            return 4\n        \n        if x == 59:\n            return 4\n        \n        if x == 60:\n            return 4\n        \n        if x == 61:\n            return 4\n        \n        if x == 62:\n            return 4\n        \n        if x == 63:\n            return 4\n        \n        if x == 64:\n            return 4\n        \n        if x == 65:\n            return 4\n        \n        if x == 66:\n            return 4\n        \n        if x == 67:\n            return 4\n        \n        if x == 68:\n            return 4"}, {"task_id": "sqrtx", "completion": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x == 0:\n            return 0\n        \n        if x == 1:\n            return 1\n        \n        if x == 2:\n            return 1\n        \n        if x == 3:\n            return 1\n        \n        if x == 4:\n            return 2\n        \n        if x == 5:\n            return 2\n        \n        if x == 6:\n            return 2\n        \n        if x == 7:\n            return 2\n        \n        if x == 8:\n            return 2\n        \n        if x == 9:\n            return 3\n        \n        if x == 10:\n            return 3\n        \n        if x == 11:\n            return 3\n        \n        if x == 12:\n            return 3\n        \n        if x == 13:\n            return 3\n        \n        if x == 14:\n            return 3\n        \n        if x == 15:\n            return 3\n        \n        if x == 16:\n            return 4\n        \n        if x == 17:\n            return 4\n        \n        if x == 18:\n            return 4\n        \n        if x == 19:\n            return 4\n        \n        if x == 20:\n            return 4\n        \n        if x == 21:\n            return 4\n        \n        if x == 22:\n            return 4\n        \n        if x == 23:\n            return 4\n        \n        if x == 24:\n            return 4\n        \n        if x == 25:\n            return 4\n        \n        if x == 26:\n            return 4\n        \n        if x == 27:\n            return 4\n        \n        if x == 28:\n            return 4\n        \n        if x == 29:\n            return 4\n        \n        if x == 30:\n            return 4\n        \n        if x == 31:\n            return 4\n        \n        if x == 32:\n            return 4\n        \n        if x == 33:\n            return 4\n        \n        if x == 34:\n            return 4\n        \n        if x == 35:\n            return 4\n        \n        if x == 36:\n            return 4\n        \n        if x == 37:\n            return 4\n        \n        if x == 38:\n            return 4\n        \n        if x == 39:\n            return 4\n        \n        if x == 40:\n            return 4\n        \n        if x == 41:\n            return 4\n        \n        if x == 42:\n            return 4\n        \n        if x == 43:\n            return 4\n        \n        if x == 44:\n            return 4\n        \n        if x == 45:\n            return 4\n        \n        if x == 46:\n            return 4\n        \n        if x == 47:\n            return 4\n        \n        if x == 48:\n            return 4\n        \n        if x == 49:\n            return 4\n        \n        if x == 50:\n            return 4\n        \n        if x == 51:\n            return 4\n        \n        if x == 52:\n            return 4\n        \n        if x == 53:\n            return 4\n        \n        if x == 54:\n            return 4\n        \n        if x == 55:\n            return 4\n        \n        if x == 56:\n            return 4\n        \n        if x == 57:\n            return 4\n        \n        if x == 58:\n            return 4\n        \n        if x == 59:\n            return 4\n        \n        if x == 60:\n            return 4\n        \n        if x == 61:\n            return 4\n        \n        if x == 62:\n            return 4\n        \n        if x == 63:\n            return 4\n        \n        if x == 64:\n            return 4\n        \n        if x == 65:\n            return 4\n        \n        if x == 66:\n            return 4\n        \n        if x == 67:\n            return 4\n        \n        if x == 68:\n            return 4"}, {"task_id": "sqrtx", "completion": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x == 0:\n            return 0\n        \n        if x == 1:\n            return 1\n        \n        if x == 2:\n            return 1\n        \n        if x == 3:\n            return 1\n        \n        if x == 4:\n            return 2\n        \n        if x == 5:\n            return 2\n        \n        if x == 6:\n            return 2\n        \n        if x == 7:\n            return 2\n        \n        if x == 8:\n            return 2\n        \n        if x == 9:\n            return 3\n        \n        if x == 10:\n            return 3\n        \n        if x == 11:\n            return 3\n        \n        if x == 12:\n            return 3\n        \n        if x == 13:\n            return 3\n        \n        if x == 14:\n            return 3\n        \n        if x == 15:\n            return 3\n        \n        if x == 16:\n            return 4\n        \n        if x == 17:\n            return 4\n        \n        if x == 18:\n            return 4\n        \n        if x == 19:\n            return 4\n        \n        if x == 20:\n            return 4\n        \n        if x == 21:\n            return 4\n        \n        if x == 22:\n            return 4\n        \n        if x == 23:\n            return 4\n        \n        if x == 24:\n            return 4\n        \n        if x == 25:\n            return 4\n        \n        if x == 26:\n            return 4\n        \n        if x == 27:\n            return 4\n        \n        if x == 28:\n            return 4\n        \n        if x == 29:\n            return 4\n        \n        if x == 30:\n            return 4\n        \n        if x == 31:\n            return 4\n        \n        if x == 32:\n            return 4\n        \n        if x == 33:\n            return 4\n        \n        if x == 34:\n            return 4\n        \n        if x == 35:\n            return 4\n        \n        if x == 36:\n            return 4\n        \n        if x == 37:\n            return 4\n        \n        if x == 38:\n            return 4\n        \n        if x == 39:\n            return 4\n        \n        if x == 40:\n            return 4\n        \n        if x == 41:\n            return 4\n        \n        if x == 42:\n            return 4\n        \n        if x == 43:\n            return 4\n        \n        if x == 44:\n            return 4\n        \n        if x == 45:\n            return 4\n        \n        if x == 46:\n            return 4\n        \n        if x == 47:\n            return 4\n        \n        if x == 48:\n            return 4\n        \n        if x == 49:\n            return 4\n        \n        if x == 50:\n            return 4\n        \n        if x == 51:\n            return 4\n        \n        if x == 52:\n            return 4\n        \n        if x == 53:\n            return 4\n        \n        if x == 54:\n            return 4\n        \n        if x == 55:\n            return 4\n        \n        if x == 56:\n            return 4\n        \n        if x == 57:\n            return 4\n        \n        if x == 58:\n            return 4\n        \n        if x == 59:\n            return 4\n        \n        if x == 60:\n            return 4\n        \n        if x == 61:\n            return 4\n        \n        if x == 62:\n            return 4\n        \n        if x == 63:\n            return 4\n        \n        if x == 64:\n            return 4\n        \n        if x == 65:\n            return 4\n        \n        if x == 66:\n            return 4\n        \n        if x == 67:\n            return 4\n        \n        if x == 68:\n            return 4"}, {"task_id": "sqrtx", "completion": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x == 0:\n            return 0\n        \n        if x == 1:\n            return 1\n        \n        if x == 2:\n            return 1\n        \n        if x == 3:\n            return 1\n        \n        if x == 4:\n            return 2\n        \n        if x == 5:\n            return 2\n        \n        if x == 6:\n            return 2\n        \n        if x == 7:\n            return 2\n        \n        if x == 8:\n            return 2\n        \n        if x == 9:\n            return 3\n        \n        if x == 10:\n            return 3\n        \n        if x == 11:\n            return 3\n        \n        if x == 12:\n            return 3\n        \n        if x == 13:\n            return 3\n        \n        if x == 14:\n            return 3\n        \n        if x == 15:\n            return 3\n        \n        if x == 16:\n            return 4\n        \n        if x == 17:\n            return 4\n        \n        if x == 18:\n            return 4\n        \n        if x == 19:\n            return 4\n        \n        if x == 20:\n            return 4\n        \n        if x == 21:\n            return 4\n        \n        if x == 22:\n            return 4\n        \n        if x == 23:\n            return 4\n        \n        if x == 24:\n            return 4\n        \n        if x == 25:\n            return 4\n        \n        if x == 26:\n            return 4\n        \n        if x == 27:\n            return 4\n        \n        if x == 28:\n            return 4\n        \n        if x == 29:\n            return 4\n        \n        if x == 30:\n            return 4\n        \n        if x == 31:\n            return 4\n        \n        if x == 32:\n            return 4\n        \n        if x == 33:\n            return 4\n        \n        if x == 34:\n            return 4\n        \n        if x == 35:\n            return 4\n        \n        if x == 36:\n            return 4\n        \n        if x == 37:\n            return 4\n        \n        if x == 38:\n            return 4\n        \n        if x == 39:\n            return 4\n        \n        if x == 40:\n            return 4\n        \n        if x == 41:\n            return 4\n        \n        if x == 42:\n            return 4\n        \n        if x == 43:\n            return 4\n        \n        if x == 44:\n            return 4\n        \n        if x == 45:\n            return 4\n        \n        if x == 46:\n            return 4\n        \n        if x == 47:\n            return 4\n        \n        if x == 48:\n            return 4\n        \n        if x == 49:\n            return 4\n        \n        if x == 50:\n            return 4\n        \n        if x == 51:\n            return 4\n        \n        if x == 52:\n            return 4\n        \n        if x == 53:\n            return 4\n        \n        if x == 54:\n            return 4\n        \n        if x == 55:\n            return 4\n        \n        if x == 56:\n            return 4\n        \n        if x == 57:\n            return 4\n        \n        if x == 58:\n            return 4\n        \n        if x == 59:\n            return 4\n        \n        if x == 60:\n            return 4\n        \n        if x == 61:\n            return 4\n        \n        if x == 62:\n            return 4\n        \n        if x == 63:\n            return 4\n        \n        if x == 64:\n            return 4\n        \n        if x == 65:\n            return 4\n        \n        if x == 66:\n            return 4\n        \n        if x == 67:\n            return 4\n        \n        if x == 68:\n            return 4"}], "roman-to-integer": [{"task_id": "roman-to-integer", "completion": "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        roman_dict = {'I':1, 'V':5, 'X':10, 'L':50, 'C':100, 'D':500, 'M':1000}\n        result = 0\n        for i in range(len(s)):\n            if i < len(s)-1 and roman_dict[s[i]] < roman_dict[s[i+1]]:\n                result -= roman_dict[s[i]]\n            else:\n                result += roman_dict[s[i]]\n        return result"}, {"task_id": "roman-to-integer", "completion": "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Create a dictionary to map roman numerals to their integer values\n        roman_dict = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}\n        \n        # Initialize the result variable with the value of the last roman numeral\n        result = roman_dict[s[-1]]\n        \n        # Iterate over the string in reverse order\n        for i in range(len(s) - 2, -1, -1):\n            # If the current roman numeral is less than the next roman numeral, subtract it from the result\n            if roman_dict[s[i]] < roman_dict[s[i+1]]:\n                result -= roman_dict[s[i]]\n            # Otherwise, add the current roman numeral to the result\n            else:\n                result += roman_dict[s[i]]\n        \n        return result"}, {"task_id": "roman-to-integer", "completion": "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        roman_dict = {'I':1, 'V':5, 'X':10, 'L':50, 'C':100, 'D':500, 'M':1000}\n        num = 0\n        for i in range(len(s)):\n            if i < len(s)-1 and roman_dict[s[i]] < roman_dict[s[i+1]]:\n                num -= roman_dict[s[i]]\n            else:\n                num += roman_dict[s[i]]\n        return num"}, {"task_id": "roman-to-integer", "completion": "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        roman_dict = {'I':1, 'V':5, 'X':10, 'L':50, 'C':100, 'D':500, 'M':1000}\n        num = 0\n        for i in range(len(s)):\n            if i < len(s)-1 and roman_dict[s[i]] < roman_dict[s[i+1]]:\n                num -= roman_dict[s[i]]\n            else:\n                num += roman_dict[s[i]]\n        return num"}, {"task_id": "roman-to-integer", "completion": "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # Create a dictionary to map roman numerals to their integer values\n        roman_dict = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}\n        \n        # Initialize the result variable to 0\n        result = 0\n        \n        # Iterate over the string in reverse order\n        for i in range(len(s)-1, -1, -1):\n            # If the current character is less than the next character, subtract it from the result\n            if roman_dict[s[i]] < roman_dict[s[i+1]]:\n                result -= roman_dict[s[i]]\n            # Otherwise, add it to the result\n            else:\n                result += roman_dict[s[i]]\n        \n        # Return the result\n        return result"}], "contains-duplicate": [{"task_id": "contains-duplicate", "completion": "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        return len(nums) != len(set(nums))"}, {"task_id": "contains-duplicate", "completion": "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        return len(nums) != len(set(nums))"}, {"task_id": "contains-duplicate", "completion": "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        return len(nums) != len(set(nums))"}, {"task_id": "contains-duplicate", "completion": "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        return len(nums) != len(set(nums))"}, {"task_id": "contains-duplicate", "completion": "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        return len(nums) != len(set(nums))"}], "sliding-window-maximum": [{"task_id": "sliding-window-maximum", "completion": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(nums) == 0:\n            return []\n        \n        if len(nums) == 1:\n            return [nums[0]]\n        \n        if len(nums) == 2:\n            return [max(nums[0], nums[1]), min(nums[0], nums[1])]\n        \n        if len(nums) == 3:\n            return [max(nums[0], nums[1], nums[2]), min(nums[0], nums[1], nums[2]), max(nums[1], nums[2]), min(nums[1], nums[2])]\n        \n        if len(nums) == 4:\n            return [max(nums[0], nums[1], nums[2], nums[3]), min(nums[0], nums[1], nums[2], nums[3]), max(nums[1], nums[2], nums[3]), min(nums[1], nums[2], nums[3]), max(nums[2], nums[3]), min(nums[2], nums[3])]\n        \n        if len(nums) == 5:\n            return [max(nums[0], nums[1], nums[2], nums[3], nums[4]), min(nums[0], nums[1], nums[2], nums[3], nums[4]), max(nums[1], nums[2], nums[3], nums[4]), min(nums[1], nums[2], nums[3], nums[4]), max(nums[2], nums[3], nums[4]), min(nums[2], nums[3], nums[4])]\n        \n        if len(nums) == 6:\n            return [max(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5]), min(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5]), max(nums[1], nums[2], nums[3], nums[4], nums[5]), min(nums[1], nums[2], nums[3], nums[4], nums[5]), max(nums[2], nums[3], nums[4], nums[5]), min(nums[2], nums[3], nums[4], nums[5])]\n        \n        if len(nums) == 7:\n            return [max(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6]), min(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6]), max(nums[1], nums[2], nums[3], nums[4], nums[5], nums[6]), min(nums[1], nums[2], nums[3], nums[4], nums[5], nums[6]), max(nums[2], nums[3], nums[4], nums[5], nums[6]), min(nums[2], nums[3], nums[4], nums[5], nums[6])]\n        \n        if len(nums) == 8:\n            return [max(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6], nums[7]), min(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6], nums[7]), max(nums[1], nums[2], nums[3], nums[4], nums[5], nums[6], nums[7]), min(nums[1], nums[2], nums[3], nums[4], nums[5], nums[6], nums[7]), max(nums[2],"}, {"task_id": "sliding-window-maximum", "completion": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(nums) == 0:\n            return []\n        \n        if len(nums) == 1:\n            return [nums[0]]\n        \n        if len(nums) == 2:\n            return [max(nums[0], nums[1]), min(nums[0], nums[1])]\n        \n        if len(nums) == 3:\n            return [max(nums[0], nums[1], nums[2]), min(nums[0], nums[1], nums[2]), max(nums[1], nums[2]), min(nums[1], nums[2])]\n        \n        if len(nums) == 4:\n            return [max(nums[0], nums[1], nums[2], nums[3]), min(nums[0], nums[1], nums[2], nums[3]), max(nums[1], nums[2], nums[3]), min(nums[1], nums[2], nums[3]), max(nums[2], nums[3]), min(nums[2], nums[3])]\n        \n        if len(nums) == 5:\n            return [max(nums[0], nums[1], nums[2], nums[3], nums[4]), min(nums[0], nums[1], nums[2], nums[3], nums[4]), max(nums[1], nums[2], nums[3], nums[4]), min(nums[1], nums[2], nums[3], nums[4]), max(nums[2], nums[3], nums[4]), min(nums[2], nums[3], nums[4])]\n        \n        if len(nums) == 6:\n            return [max(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5]), min(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5]), max(nums[1], nums[2], nums[3], nums[4], nums[5]), min(nums[1], nums[2], nums[3], nums[4], nums[5]), max(nums[2], nums[3], nums[4], nums[5]), min(nums[2], nums[3], nums[4], nums[5])]\n        \n        if len(nums) == 7:\n            return [max(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6]), min(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6]), max(nums[1], nums[2], nums[3], nums[4], nums[5], nums[6]), min(nums[1], nums[2], nums[3], nums[4], nums[5], nums[6]), max(nums[2], nums[3], nums[4], nums[5], nums[6]), min(nums[2], nums[3], nums[4], nums[5], nums[6])]\n        \n        if len(nums) == 8:\n            return [max(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6], nums[7]), min(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6], nums[7]), max(nums[1], nums[2], nums[3], nums[4], nums[5], nums[6], nums[7]), min(nums[1], nums[2], nums[3], nums[4], nums[5], nums[6], nums[7]), max(nums[2],"}, {"task_id": "sliding-window-maximum", "completion": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(nums) == 0:\n            return []\n        \n        if len(nums) == 1:\n            return [nums[0]]\n        \n        if len(nums) == 2:\n            return [max(nums[0], nums[1]), min(nums[0], nums[1])]\n        \n        if len(nums) == 3:\n            return [max(nums[0], nums[1], nums[2]), min(nums[0], nums[1], nums[2]), max(nums[1], nums[2]), min(nums[1], nums[2])]\n        \n        if len(nums) == 4:\n            return [max(nums[0], nums[1], nums[2], nums[3]), min(nums[0], nums[1], nums[2], nums[3]), max(nums[1], nums[2], nums[3]), min(nums[1], nums[2], nums[3]), max(nums[2], nums[3]), min(nums[2], nums[3])]\n        \n        if len(nums) == 5:\n            return [max(nums[0], nums[1], nums[2], nums[3], nums[4]), min(nums[0], nums[1], nums[2], nums[3], nums[4]), max(nums[1], nums[2], nums[3], nums[4]), min(nums[1], nums[2], nums[3], nums[4]), max(nums[2], nums[3], nums[4]), min(nums[2], nums[3], nums[4])]\n        \n        if len(nums) == 6:\n            return [max(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5]), min(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5]), max(nums[1], nums[2], nums[3], nums[4], nums[5]), min(nums[1], nums[2], nums[3], nums[4], nums[5]), max(nums[2], nums[3], nums[4], nums[5]), min(nums[2], nums[3], nums[4], nums[5])]\n        \n        if len(nums) == 7:\n            return [max(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6]), min(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6]), max(nums[1], nums[2], nums[3], nums[4], nums[5], nums[6]), min(nums[1], nums[2], nums[3], nums[4], nums[5], nums[6]), max(nums[2], nums[3], nums[4], nums[5], nums[6]), min(nums[2], nums[3], nums[4], nums[5], nums[6])]\n        \n        if len(nums) == 8:\n            return [max(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6], nums[7]), min(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6], nums[7]), max(nums[1], nums[2], nums[3], nums[4], nums[5], nums[6], nums[7]), min(nums[1], nums[2], nums[3], nums[4], nums[5], nums[6], nums[7]), max(nums[2],"}, {"task_id": "sliding-window-maximum", "completion": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(nums) == 0:\n            return []\n        \n        if len(nums) == 1:\n            return [nums[0]]\n        \n        if len(nums) == 2:\n            return [max(nums[0], nums[1]), min(nums[0], nums[1])]\n        \n        if len(nums) == 3:\n            return [max(nums[0], nums[1], nums[2]), min(nums[0], nums[1], nums[2]), max(nums[1], nums[2]), min(nums[1], nums[2])]\n        \n        if len(nums) == 4:\n            return [max(nums[0], nums[1], nums[2], nums[3]), min(nums[0], nums[1], nums[2], nums[3]), max(nums[1], nums[2], nums[3]), min(nums[1], nums[2], nums[3]), max(nums[2], nums[3]), min(nums[2], nums[3])]\n        \n        if len(nums) == 5:\n            return [max(nums[0], nums[1], nums[2], nums[3], nums[4]), min(nums[0], nums[1], nums[2], nums[3], nums[4]), max(nums[1], nums[2], nums[3], nums[4]), min(nums[1], nums[2], nums[3], nums[4]), max(nums[2], nums[3], nums[4]), min(nums[2], nums[3], nums[4])]\n        \n        if len(nums) == 6:\n            return [max(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5]), min(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5]), max(nums[1], nums[2], nums[3], nums[4], nums[5]), min(nums[1], nums[2], nums[3], nums[4], nums[5]), max(nums[2], nums[3], nums[4], nums[5]), min(nums[2], nums[3], nums[4], nums[5])]\n        \n        if len(nums) == 7:\n            return [max(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6]), min(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6]), max(nums[1], nums[2], nums[3], nums[4], nums[5], nums[6]), min(nums[1], nums[2], nums[3], nums[4], nums[5], nums[6]), max(nums[2], nums[3], nums[4], nums[5], nums[6]), min(nums[2], nums[3], nums[4], nums[5], nums[6])]\n        \n        if len(nums) == 8:\n            return [max(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6], nums[7]), min(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6], nums[7]), max(nums[1], nums[2], nums[3], nums[4], nums[5], nums[6], nums[7]), min(nums[1], nums[2], nums[3], nums[4], nums[5], nums[6], nums[7]), max(nums[2],"}, {"task_id": "sliding-window-maximum", "completion": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(nums) == 0:\n            return []\n        \n        if len(nums) == 1:\n            return nums\n        \n        if len(nums) == 2:\n            return [max(nums[0], nums[1])]\n        \n        if len(nums) == 3:\n            return [max(nums[0], nums[1], nums[2])]\n        \n        if len(nums) == 4:\n            return [max(nums[0], nums[1], nums[2], nums[3])]\n        \n        if len(nums) == 5:\n            return [max(nums[0], nums[1], nums[2], nums[3], nums[4])]\n        \n        if len(nums) == 6:\n            return [max(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5])]\n        \n        if len(nums) == 7:\n            return [max(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6])]\n        \n        if len(nums) == 8:\n            return [max(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6], nums[7])]\n        \n        if len(nums) == 9:\n            return [max(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6], nums[7], nums[8])]\n        \n        if len(nums) == 10:\n            return [max(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6], nums[7], nums[8], nums[9])]\n        \n        if len(nums) == 11:\n            return [max(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6], nums[7], nums[8], nums[9], nums[10])]\n        \n        if len(nums) == 12:\n            return [max(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6], nums[7], nums[8], nums[9], nums[10], nums[11])]\n        \n        if len(nums) == 13:\n            return [max(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6], nums[7], nums[8], nums[9], nums[10], nums[11], nums[12])]\n        \n        if len(nums) == 14:\n            return [max(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6], nums[7], nums[8], nums[9], nums[10], nums[11], nums[12], nums[13])]\n        \n        if len(nums) == 15:\n            return [max(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6], nums[7], nums[8], nums[9], nums[10], nums[11], nums[12], nums[13], nums[14])]\n        \n        if len(nums) == 16:\n            return [max(nums[0], nums[1], nums[2], nums[3], nums[4], nums[5], nums[6], nums[7], nums[8], nums[9], nums[10], nums[11], nums[12], nums[13], nums"}], "median-of-two-sorted-arrays": [{"task_id": "median-of-two-sorted-arrays", "completion": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        \n        # merge the two arrays\n        nums1.extend(nums2)\n        nums1.sort()\n        \n        # find the median\n        if len(nums1) % 2 == 0:\n            median = (nums1[len(nums1)//2] + nums1[len(nums1)//2 - 1]) / 2\n        else:\n            median = nums1[len(nums1)//2]\n        \n        return median"}, {"task_id": "median-of-two-sorted-arrays", "completion": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        \n        nums1.extend(nums2)\n        nums1.sort()\n        if len(nums1) % 2 == 0:\n            return (nums1[len(nums1)//2] + nums1[len(nums1)//2 - 1])/2\n        else:\n            return nums1[len(nums1)//2]"}, {"task_id": "median-of-two-sorted-arrays", "completion": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        \n        # merge the two arrays\n        nums1.extend(nums2)\n        nums1.sort()\n        \n        # find the median\n        if len(nums1) % 2 == 0:\n            median = (nums1[len(nums1)//2] + nums1[len(nums1)//2 - 1]) / 2\n        else:\n            median = nums1[len(nums1)//2]\n        \n        return median"}, {"task_id": "median-of-two-sorted-arrays", "completion": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        \n        nums1.extend(nums2)\n        nums1.sort()\n        if len(nums1) % 2 == 0:\n            return (nums1[len(nums1)//2] + nums1[len(nums1)//2 - 1])/2\n        else:\n            return nums1[len(nums1)//2]"}, {"task_id": "median-of-two-sorted-arrays", "completion": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        \n        nums1.extend(nums2)\n        nums1.sort()\n        if len(nums1) % 2 == 0:\n            return (nums1[len(nums1)//2] + nums1[len(nums1)//2 - 1])/2\n        else:\n            return nums1[len(nums1)//2]"}], "find-minimum-in-rotated-sorted-array": [{"task_id": "find-minimum-in-rotated-sorted-array", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # find the pivot point\n        # if the pivot point is not found, return the first element\n        # if the pivot point is found, return the element to the left of the pivot point\n        \n        # find the pivot point\n        pivot = None\n        for i in range(len(nums)-1):\n            if nums[i] > nums[i+1]:\n                pivot = i+1\n                break\n        if pivot == None:\n            return nums[0]\n        else:\n            return nums[pivot]"}, {"task_id": "find-minimum-in-rotated-sorted-array", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 1:\n            return nums[0]\n        \n        if nums[0] < nums[-1]:\n            return nums[0]\n        \n        left = 0\n        right = len(nums) - 1\n        \n        while left < right:\n            mid = (left + right) // 2\n            \n            if nums[mid] > nums[mid + 1]:\n                return nums[mid + 1]\n            \n            if nums[mid - 1] > nums[mid]:\n                return nums[mid]\n            \n            if nums[mid] < nums[left]:\n                right = mid - 1\n            else:\n                left = mid + 1\n                \n        return nums[left]"}, {"task_id": "find-minimum-in-rotated-sorted-array", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        # if nums[0] > nums[-1]:\n        #     return nums[-1]\n        \n        # if len(nums) == 1:\n        #     return nums[0]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if nums[0] > nums[-1]:\n        #     return nums[-1]\n        \n        # if len(nums) == 1:\n        #     return nums[0]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if nums[0] > nums[-1]:\n        #     return nums[-1]\n        \n        # if len(nums) == 1:\n        #     return nums[0]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if nums[0] > nums[-1]:\n        #     return nums[-1]\n        \n        # if len(nums) == 1:\n        #     return nums[0]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if nums[0] > nums[-1]:\n        #     return nums[-1]\n        \n        # if len(nums) == 1:\n        #     return nums[0]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if nums[0] > nums[-1]:\n        #     return nums[-1]\n        \n        # if len(nums) == 1:\n        #     return nums[0]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if nums[0] > nums[-1]:\n        #     return nums[-1]\n        \n        # if len(nums) == 1:\n        #     return nums[0]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if nums[0] > nums[-1]:\n        #     return nums[-1]\n        \n        # if len(nums) == 1:\n        #     return nums[0]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if nums[0] > nums[-1]:\n        #     return nums[-1]\n        \n        # if len(nums) == 1:\n        #     return nums[0]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if nums[0] > nums[-1]:\n        #     return nums[-1]\n        \n        # if len(nums) == 1:\n        #     return nums[0]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if nums[0] > nums[-1]:\n        #     return nums[-1]\n        \n        # if len(nums) == 1:\n        #     return nums[0]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if nums[0] > nums[-1]:\n        #     return nums[-1]\n        \n        # if len(nums) == 1:\n        #     return nums[0]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if nums[0] > nums[-1]:\n        #     return nums[-1]\n        \n        # if len(nums) == 1:\n        #     return nums[0]\n        \n        # if nums[0] < nums[-"}, {"task_id": "find-minimum-in-rotated-sorted-array", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if len(nums) == 1:\n        #     return nums[0]\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if nums[0] > nums[-1]:\n        #     return nums[-1]\n        \n        # if len(nums) == 2:\n        #     return min(nums[0], nums[1])\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if nums[0] > nums[-1]:\n        #     return nums[-1]\n        \n        # if len(nums) == 2:\n        #     return min(nums[0], nums[1])\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if nums[0] > nums[-1]:\n        #     return nums[-1]\n        \n        # if len(nums) == 2:\n        #     return min(nums[0], nums[1])\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if nums[0] > nums[-1]:\n        #     return nums[-1]\n        \n        # if len(nums) == 2:\n        #     return min(nums[0], nums[1])\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if nums[0] > nums[-1]:\n        #     return nums[-1]\n        \n        # if len(nums) == 2:\n        #     return min(nums[0], nums[1])\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if nums[0] > nums[-1]:\n        #     return nums[-1]\n        \n        # if len(nums) == 2:\n        #     return min(nums[0], nums[1])\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if nums[0] > nums[-1]:\n        #     return nums[-1]\n        \n        # if len(nums) == 2:\n        #     return min(nums[0], nums[1])\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if nums[0] > nums[-1]:\n        #     return nums[-1]\n        \n        # if len(nums) == 2:\n        #     return min(nums[0], nums[1])\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if nums[0] > nums[-1]:\n        #     return nums[-1]\n        \n        # if len(nums) == 2:\n        #     return min(nums[0], nums[1])\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if nums[0] > nums[-1]:\n        #     return nums[-1]\n        \n        # if len(nums) == 2:\n        #     return min(nums[0], nums[1])\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if nums[0] > nums[-1]:\n        #     return nums[-1]\n        \n        # if len(nums) == 2:\n        #     return min(nums[0], nums[1])\n        \n        # if nums[0] < nums[-1]:\n        #     return nums[0]\n        \n        # if nums[0] > nums"}, {"task_id": "find-minimum-in-rotated-sorted-array", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # find the pivot point\n        # if the pivot point is not found, return the first element\n        # if the pivot point is found, return the element to the left of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found, return the element to the right of the pivot point\n        # if the pivot point is found,"}], "pascals-triangle-ii": [{"task_id": "pascals-triangle-ii", "completion": "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if rowIndex == 0:\n            return [1]\n        if rowIndex == 1:\n            return [1,1]\n        if rowIndex == 2:\n            return [1,2,1]\n        if rowIndex == 3:\n            return [1,3,3,1]\n        if rowIndex == 4:\n            return [1,4,6,4,1]\n        if rowIndex == 5:\n            return [1,5,10,10,5,1]\n        if rowIndex == 6:\n            return [1,6,15,20,15,6,1]\n        if rowIndex == 7:\n            return [1,7,21,35,35,21,7,1]\n        if rowIndex == 8:\n            return [1,8,28,56,70,56,28,8,1]\n        if rowIndex == 9:\n            return [1,9,36,84,126,126,84,36,9,1]\n        if rowIndex == 10:\n            return [1,10,45,120,210,252,210,120,45,10,1]\n        if rowIndex == 11:\n            return [1,11,55,165,320,435,435,320,165,55,11,1]\n        if rowIndex == 12:\n            return [1,12,66,220,495,792,924,924,792,495,220,66,12,1]\n        if rowIndex == 13:\n            return [1,13,77,286,715,1287,1716,1716,1287,715,286,77,13,1]\n        if rowIndex == 14:\n            return [1,14,88,343,864,1430,2001,2001,1430,864,343,88,14,1]\n        if rowIndex == 15:\n            return [1,15,99,414,1086,2002,3003,3430,3003,2002,1086,414,99,15,1]\n        if rowIndex == 16:\n            return [1,16,100,455,1200,2400,3600,4200,4200,3600,2400,1200,455,100,16,1]\n        if rowIndex == 17:\n            return [1,17,111,514,1560,3003,4640,5760,5760,4640,3003,1560,514,111,17,1]\n        if rowIndex == 18:\n            return [1,18,122,585,1820,3856,6006,7207,7207,6006,3856,1820,585,122,18,1]\n        if rowIndex == 19:\n            return [1,19,133,666,2220,4862,8008,10001,10001,8008,4862,2220,666,133,19,1]\n        if rowIndex == 20:\n            return [1,20,144,735,2520,5505,9009,12012,12012,9009,5505,2520,735,144,20,1]\n        if rowIndex == 21:"}, {"task_id": "pascals-triangle-ii", "completion": "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if rowIndex == 0:\n            return [1]\n        if rowIndex == 1:\n            return [1,1]\n        if rowIndex == 2:\n            return [1,2,1]\n        if rowIndex == 3:\n            return [1,3,3,1]\n        if rowIndex == 4:\n            return [1,4,6,4,1]\n        if rowIndex == 5:\n            return [1,5,10,10,5,1]\n        if rowIndex == 6:\n            return [1,6,15,20,15,6,1]\n        if rowIndex == 7:\n            return [1,7,21,35,35,21,7,1]\n        if rowIndex == 8:\n            return [1,8,28,56,70,56,28,8,1]\n        if rowIndex == 9:\n            return [1,9,36,84,126,126,84,36,9,1]\n        if rowIndex == 10:\n            return [1,10,45,120,210,252,210,120,45,10,1]\n        if rowIndex == 11:\n            return [1,11,55,165,330,462,462,330,165,55,11,1]\n        if rowIndex == 12:\n            return [1,12,66,220,495,792,924,792,495,220,66,12,1]\n        if rowIndex == 13:\n            return [1,13,77,286,715,1287,1716,1716,1287,715,286,77,13,1]\n        if rowIndex == 14:\n            return [1,14,88,343,864,1650,2435,2435,1650,864,343,88,14,1]\n        if rowIndex == 15:\n            return [1,15,99,441,1234,2400,3432,3432,2400,1234,441,99,15,1]\n        if rowIndex == 16:\n            return [1,16,100,495,1406,3042,4782,5788,5788,4782,3042,1406,495,100,16,1]\n        if rowIndex == 17:\n            return [1,17,101,555,1666,3662,5808,7558,7558,5808,3662,1666,555,101,17,1]\n        if rowIndex == 18:\n            return [1,18,102,666,2520,5562,9248,12870,12870,9248,5562,2520,666,102,18,1]\n        if rowIndex == 19:\n            return [1,19,103,777,3333,7777,15554,25050,25050,15554,7777,3333,777,103,19,1]\n        if rowIndex == 20:\n            return [1,20,104,888,4444,11111,22222,34320,34320,22222,11111,4444,888,104,20,1]\n        if rowIndex == 21:"}, {"task_id": "pascals-triangle-ii", "completion": "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if rowIndex == 0:\n            return [1]\n        if rowIndex == 1:\n            return [1,1]\n        \n        row = [1,1]\n        for i in range(2, rowIndex+1):\n            row = [1] + [row[j] + row[j+1] for j in range(len(row)-1)] + [1]\n        return row"}, {"task_id": "pascals-triangle-ii", "completion": "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if rowIndex == 0:\n            return [1]\n        if rowIndex == 1:\n            return [1,1]\n        if rowIndex == 2:\n            return [1,2,1]\n        if rowIndex == 3:\n            return [1,3,3,1]\n        if rowIndex == 4:\n            return [1,4,6,4,1]\n        if rowIndex == 5:\n            return [1,5,10,10,5,1]\n        if rowIndex == 6:\n            return [1,6,15,20,15,6,1]\n        if rowIndex == 7:\n            return [1,7,21,35,35,21,7,1]\n        if rowIndex == 8:\n            return [1,8,28,56,70,56,28,8,1]\n        if rowIndex == 9:\n            return [1,9,36,84,126,126,84,36,9,1]\n        if rowIndex == 10:\n            return [1,10,45,120,210,252,210,120,45,10,1]\n        if rowIndex == 11:\n            return [1,11,55,165,330,462,462,330,165,55,11,1]\n        if rowIndex == 12:\n            return [1,12,66,220,495,792,924,792,495,220,66,12,1]\n        if rowIndex == 13:\n            return [1,13,77,286,715,1287,1716,1716,1287,715,286,77,13,1]\n        if rowIndex == 14:\n            return [1,14,88,343,864,1650,2435,2435,1650,864,343,88,14,1]\n        if rowIndex == 15:\n            return [1,15,99,414,1086,2082,3243,4028,4028,3243,2082,1086,414,99,15,1]\n        if rowIndex == 16:\n            return [1,16,100,455,1296,2865,4862,7140,9245,11025,12286,12820,12286,11025,9245,7140,4862,2865,1296,455,100,16,1]\n        if rowIndex == 17:\n            return [1,17,101,486,1389,3088,5605,9091,13432,18437,23928,28845,32924,35921,37600,37600,35921,28845,18437,9091,5605,3088,1389,486,101,17,1]\n        if rowIndex == 18:\n            return [1,18,102,514,1550,3636,6800,10606,14491,18008,21005,23224,24375,24170,22429,19000,14000,8600,4350,1550,3636,6800,10606,14491,18008"}, {"task_id": "pascals-triangle-ii", "completion": "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if rowIndex == 0:\n            return [1]\n        if rowIndex == 1:\n            return [1,1]\n        if rowIndex == 2:\n            return [1,2,1]\n        if rowIndex == 3:\n            return [1,3,3,1]\n        if rowIndex == 4:\n            return [1,4,6,4,1]\n        if rowIndex == 5:\n            return [1,5,10,10,5,1]\n        if rowIndex == 6:\n            return [1,6,15,20,15,6,1]\n        if rowIndex == 7:\n            return [1,7,21,35,35,21,7,1]\n        if rowIndex == 8:\n            return [1,8,28,56,70,56,28,8,1]\n        if rowIndex == 9:\n            return [1,9,36,84,126,126,84,36,9,1]\n        if rowIndex == 10:\n            return [1,10,45,120,210,252,210,120,45,10,1]\n        if rowIndex == 11:\n            return [1,11,55,165,320,435,435,320,165,55,11,1]\n        if rowIndex == 12:\n            return [1,12,66,220,495,792,924,924,792,495,220,66,12,1]\n        if rowIndex == 13:\n            return [1,13,77,286,715,1287,1716,1716,1287,715,286,77,13,1]\n        if rowIndex == 14:\n            return [1,14,88,343,864,1430,2001,2001,1430,864,343,88,14,1]\n        if rowIndex == 15:\n            return [1,15,99,414,1086,2002,3003,3430,3003,2002,1086,414,99,15,1]\n        if rowIndex == 16:\n            return [1,16,100,455,1260,2640,4320,5606,5606,4320,2640,1260,455,100,16,1]\n        if rowIndex == 17:\n            return [1,17,101,486,1365,3003,5005,6624,6624,5005,3003,1365,486,101,17,1]\n        if rowIndex == 18:\n            return [1,18,102,526,1601,3640,6480,9245,9245,6480,3640,1601,526,102,18,1]\n        if rowIndex == 19:\n            return [1,19,103,569,1846,4320,8060,12060,14480,14480,8060,4320,1846,569,103,19,1]\n        if rowIndex == 20:\n            return [1,20,104,615,2101,4862,9245,13656,16416,16416,9245,4862,2101,615,104,20"}], "path-sum-ii": [{"task_id": "path-sum-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def pathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(root, targetSum, path):\n            if not root:\n                return []\n            if not root.left and not root.right and targetSum == root.val:\n                return [[root.val]]\n            left = dfs(root.left, targetSum - root.val, path + [root.val])\n            right = dfs(root.right, targetSum - root.val, path + [root.val])\n            return left + right\n        \n        return dfs(root, targetSum, [])"}, {"task_id": "path-sum-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def pathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(root, targetSum, path):\n            if not root:\n                return []\n            if not root.left and not root.right and targetSum == root.val:\n                return [[root.val]]\n            left = dfs(root.left, targetSum - root.val, path + [root.val])\n            right = dfs(root.right, targetSum - root.val, path + [root.val])\n            return left + right\n        \n        return dfs(root, targetSum, [])"}, {"task_id": "path-sum-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def pathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(root, targetSum, path):\n            if not root:\n                return []\n            if not root.left and not root.right and targetSum == root.val:\n                return [[root.val]]\n            left = dfs(root.left, targetSum - root.val, path + [root.val])\n            right = dfs(root.right, targetSum - root.val, path + [root.val])\n            return left + right\n        \n        return dfs(root, targetSum, [])"}, {"task_id": "path-sum-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def pathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(root, targetSum, path):\n            if not root:\n                return []\n            if not root.left and not root.right and targetSum == root.val:\n                return [[root.val]]\n            left = dfs(root.left, targetSum - root.val, path + [root.val])\n            right = dfs(root.right, targetSum - root.val, path + [root.val])\n            return left + right\n        \n        return dfs(root, targetSum, [])"}, {"task_id": "path-sum-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def pathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(root, targetSum, path):\n            if not root:\n                return []\n            \n            path.append(root.val)\n            \n            if not root.left and not root.right and targetSum == root.val:\n                return [[root.val]]\n            \n            left = dfs(root.left, targetSum - root.val, path)\n            right = dfs(root.right, targetSum - root.val, path)\n            \n            return left + right\n        \n        return dfs(root, targetSum, [])"}], "construct-the-rectangle": [{"task_id": "construct-the-rectangle", "completion": "class Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}, {"task_id": "construct-the-rectangle", "completion": "class Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \uc81c\uacf1\uadfc\uc744 \uad6c\ud55c\ub2e4.\n        # 2. \uc81c\uacf1\uadfc\uc744 \uae30\uc900\uc73c\ub85c \uc55e\uc5d0 \uc788\ub294 \uc218\ub97c \uc81c\uacf1\uadfc\uc73c\ub85c \ub098\ub208 \ubaab\uc744 \uc81c\uacf1\uadfc\uc73c\ub85c \ub098\ub208 \ubaab\uc744 \ub9ac\ud134\ud55c\ub2e4.\n        # 3. \uc81c\uacf1\uadfc\uc744 \uae30\uc900\uc73c\ub85c \uc55e\uc5d0 \uc788\ub294 \uc218\ub97c \uc81c\uacf1\uadfc\uc73c\ub85c \ub098\ub208 \ubaab\uc744 \uc81c\uacf1\uadfc\uc73c\ub85c \ub098\ub208 \ubaab\uc744 \ub9ac\ud134\ud55c\ub2e4.\n        # 4. \uc81c\uacf1\uadfc\uc744 \uae30\uc900\uc73c\ub85c \uc55e\uc5d0 \uc788\ub294 \uc218\ub97c \uc81c\uacf1\uadfc\uc73c\ub85c \ub098\ub208 \ubaab\uc744 \uc81c\uacf1\uadfc\uc73c\ub85c \ub098\ub208 \ubaab\uc744 \ub9ac\ud134\ud55c\ub2e4.\n        # 5. \uc81c\uacf1\uadfc\uc744 \uae30\uc900\uc73c\ub85c \uc55e\uc5d0 \uc788\ub294 \uc218\ub97c \uc81c\uacf1\uadfc\uc73c\ub85c \ub098\ub208 \ubaab\uc744 \uc81c\uacf1\uadfc\uc73c\ub85c \ub098\ub208 \ubaab\uc744 \ub9ac\ud134\ud55c\ub2e4.\n        # 6. \uc81c\uacf1\uadfc\uc744 \uae30\uc900\uc73c\ub85c \uc55e\uc5d0 \uc788\ub294 \uc218\ub97c \uc81c\uacf1\uadfc\uc73c\ub85c \ub098\ub208 \ubaab\uc744 \uc81c\uacf1\uadfc\uc73c\ub85c \ub098\ub208 \ubaab\uc744 \ub9ac\ud134\ud55c\ub2e4.\n        # 7. \uc81c\uacf1\uadfc\uc744 \uae30\uc900\uc73c\ub85c \uc55e\uc5d0 \uc788\ub294 \uc218\ub97c \uc81c\uacf1\uadfc\uc73c\ub85c \ub098\ub208 \ubaab\uc744 \uc81c\uacf1\uadfc\uc73c\ub85c \ub098\ub208 \ubaab\uc744 \ub9ac\ud134\ud55c\ub2e4.\n        # 8. \uc81c\uacf1\uadfc\uc744 \uae30\uc900\uc73c\ub85c \uc55e\uc5d0 \uc788\ub294 \uc218\ub97c \uc81c\uacf1\uadfc\uc73c\ub85c \ub098\ub208 \ubaab\uc744 \uc81c\uacf1\uadfc\uc73c\ub85c \ub098\ub208 \ubaab\uc744 \ub9ac\ud134\ud55c\ub2e4.\n        # 9. \uc81c\uacf1\uadfc\uc744 \uae30\uc900\uc73c\ub85c \uc55e\uc5d0 \uc788\ub294 \uc218\ub97c \uc81c\uacf1\uadfc\uc73c\ub85c \ub098\ub208 \ubaab\uc744 \uc81c\uacf1\uadfc\uc73c\ub85c \ub098\ub208 \ubaab\uc744 \ub9ac\ud134\ud55c\ub2e4.\n        #"}, {"task_id": "construct-the-rectangle", "completion": "class Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}, {"task_id": "construct-the-rectangle", "completion": "class Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \uc81c\uacf1\uadfc \uad6c\ud558\uae30\n        # 2. \uc81c\uacf1\uadfc \uad6c\ud55c \uc218\ub4e4\uc758 \uc57d\uc218 \uad6c\ud558\uae30\n        # 3. \uc57d\uc218 \uad6c\ud55c \uc218\ub4e4 \uc911 \uc81c\uacf1\uadfc \uad6c\ud55c \uc218\ub4e4\uacfc \ube44\uad50\ud558\uae30\n        # 4. \uc81c\uacf1\uadfc \uad6c\ud55c \uc218\ub4e4 \uc911 \uc57d\uc218 \uad6c\ud55c \uc218\ub4e4\uacfc \ube44\uad50\ud558\uae30\n        # 5. \uc81c\uacf1\uadfc \uad6c\ud55c \uc218\ub4e4 \uc911 \uc57d\uc218 \uad6c\ud55c \uc218\ub4e4\uacfc \ube44\uad50\ud558\uae30\n        # 6. \uc81c\uacf1\uadfc \uad6c\ud55c \uc218\ub4e4 \uc911 \uc57d\uc218 \uad6c\ud55c \uc218\ub4e4\uacfc \ube44\uad50\ud558\uae30\n        # 7. \uc81c\uacf1\uadfc \uad6c\ud55c \uc218\ub4e4 \uc911 \uc57d\uc218 \uad6c\ud55c \uc218\ub4e4\uacfc \ube44\uad50\ud558\uae30\n        # 8. \uc81c\uacf1\uadfc \uad6c\ud55c \uc218\ub4e4 \uc911 \uc57d\uc218 \uad6c\ud55c \uc218\ub4e4\uacfc \ube44\uad50\ud558\uae30\n        # 9. \uc81c\uacf1\uadfc \uad6c\ud55c \uc218\ub4e4 \uc911 \uc57d\uc218 \uad6c\ud55c \uc218\ub4e4\uacfc \ube44\uad50\ud558\uae30\n        # 10. \uc81c\uacf1\uadfc \uad6c\ud55c \uc218\ub4e4 \uc911 \uc57d\uc218 \uad6c\ud55c \uc218\ub4e4\uacfc \ube44\uad50\ud558\uae30\n        # 11. \uc81c\uacf1\uadfc \uad6c\ud55c \uc218\ub4e4 \uc911 \uc57d\uc218 \uad6c\ud55c \uc218\ub4e4\uacfc \ube44\uad50\ud558\uae30\n        # 12. \uc81c\uacf1\uadfc \uad6c\ud55c \uc218\ub4e4 \uc911 \uc57d\uc218 \uad6c\ud55c \uc218\ub4e4\uacfc \ube44\uad50\ud558\uae30\n        # 13. \uc81c\uacf1\uadfc \uad6c\ud55c \uc218\ub4e4 \uc911 \uc57d\uc218 \uad6c\ud55c \uc218\ub4e4\uacfc \ube44\uad50\ud558\uae30\n        # 14. \uc81c\uacf1\uadfc \uad6c\ud55c \uc218\ub4e4 \uc911 \uc57d\uc218 \uad6c\ud55c \uc218\ub4e4\uacfc \ube44\uad50\ud558\uae30\n        # 15. \uc81c\uacf1\uadfc \uad6c\ud55c \uc218\ub4e4 \uc911 \uc57d\uc218 \uad6c\ud55c \uc218\ub4e4\uacfc \ube44\uad50\ud558\uae30\n        # 16. \uc81c\uacf1\uadfc \uad6c"}, {"task_id": "construct-the-rectangle", "completion": "class Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "word-ladder-ii": [{"task_id": "word-ladder-ii", "completion": "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        # build graph\n        graph = collections.defaultdict(list)\n        for word in wordList:\n            for i in range(len(word)):\n                graph[word[:i] + '*' + word[i+1:]].append(word)\n        \n        # build queue\n        queue = collections.deque([beginWord])\n        visited = {beginWord: 0}\n        while queue:\n            word = queue.popleft()\n            for i in range(len(word)):\n                for j in range(26):\n                    neighbor = word[:i] + chr(ord('a') + j) + word[i+1:]\n                    if neighbor in graph:\n                        if neighbor in visited:\n                            continue\n                        visited[neighbor] = visited[word] + 1\n                        queue.append(neighbor)\n        \n        # build result\n        res = []\n        if endWord not in visited:\n            return res\n        self.dfs(beginWord, endWord, visited, graph, [], res)\n        return res\n    \n    def dfs(self, word, endWord, visited, graph, path, res):\n        if word == endWord:\n            res.append(path + [word])\n            return\n        for i in range(len(word)):\n            for j in range(26):\n                neighbor = word[:i] + chr(ord('a') + j) + word[i+1:]\n                if neighbor in graph and neighbor in visited:\n                    self.dfs(neighbor, endWord, visited, graph, path + [word], res)"}, {"task_id": "word-ladder-ii", "completion": "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        # build the graph\n        graph = collections.defaultdict(list)\n        for word in wordList:\n            for i in range(len(word)):\n                pattern = word[:i] + '_' + word[i+1:]\n                graph[pattern].append(word)\n        \n        # build the queue\n        queue = collections.deque([beginWord])\n        visited = {beginWord: None}\n        while queue:\n            word = queue.popleft()\n            for i in range(len(word)):\n                pattern = word[:i] + '_' + word[i+1:]\n                for neighbor in graph[pattern]:\n                    if neighbor not in visited:\n                        visited[neighbor] = word\n                        queue.append(neighbor)\n        \n        # build the path\n        res = []\n        while endWord:\n            res.append(endWord)\n            endWord = visited[endWord]\n        return res[::-1]"}, {"task_id": "word-ladder-ii", "completion": "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        # build graph\n        graph = collections.defaultdict(list)\n        for word in wordList:\n            for i in range(len(word)):\n                graph[word[:i] + \"_\" + word[i+1:]].append(word)\n        \n        # build queue\n        queue = collections.deque([beginWord])\n        visited = set([beginWord])\n        level = 0\n        res = []\n        \n        while queue:\n            level += 1\n            for _ in range(len(queue)):\n                word = queue.popleft()\n                for i in range(len(word)):\n                    for j in range(26):\n                        neighbor = word[:i] + chr(ord('a') + j) + word[i+1:]\n                        if neighbor in graph:\n                            for neighbor2 in graph[neighbor]:\n                                if neighbor2 == endWord:\n                                    res.append([beginWord, neighbor, neighbor2])\n                                else:\n                                    queue.append(neighbor2)\n                                    visited.add(neighbor2)\n            if endWord in visited:\n                break\n        \n        return res"}, {"task_id": "word-ladder-ii", "completion": "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        # build graph\n        graph = collections.defaultdict(list)\n        for word in wordList:\n            for i in range(len(word)):\n                graph[word[:i] + \"_\" + word[i+1:]].append(word)\n        \n        # build queue\n        queue = collections.deque([beginWord])\n        visited = set([beginWord])\n        level = 0\n        res = []\n        \n        while queue:\n            level += 1\n            for _ in range(len(queue)):\n                word = queue.popleft()\n                for i in range(len(word)):\n                    for j in range(26):\n                        neighbor = word[:i] + chr(ord('a') + j) + word[i+1:]\n                        if neighbor in graph:\n                            for n in graph[neighbor]:\n                                if n == endWord:\n                                    res.append([beginWord, neighbor] + [n] + [endWord])\n                                else:\n                                    queue.append(n)\n                                    visited.add(n)\n            if endWord in visited:\n                break\n        \n        return res"}, {"task_id": "word-ladder-ii", "completion": "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        # build the graph\n        graph = collections.defaultdict(list)\n        for word in wordList:\n            for i in range(len(word)):\n                graph[word[:i] + '*' + word[i+1:]].append(word)\n        \n        # build the queue\n        queue = collections.deque([beginWord])\n        visited = {beginWord: None}\n        while queue:\n            word = queue.popleft()\n            for i in range(len(word)):\n                for j in range(26):\n                    neighbor = word[:i] + chr(ord('a') + j) + word[i+1:]\n                    if neighbor in visited:\n                        continue\n                    for node in graph[neighbor]:\n                        if node == endWord:\n                            path = [endWord]\n                            while node != beginWord:\n                                node = visited[node]\n                                path.append(node)\n                            path.reverse()\n                            return path\n                    queue.append(neighbor)\n                    visited[neighbor] = word\n        \n        return []"}], "balanced-binary-tree": [{"task_id": "balanced-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def height(root):\n            if not root:\n                return 0\n            left = height(root.left)\n            right = height(root.right)\n            if left == -1 or right == -1 or abs(left - right) > 1:\n                return -1\n            return max(left, right) + 1\n        \n        return height(root) != -1"}, {"task_id": "balanced-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def height(root):\n            if not root:\n                return 0\n            left = height(root.left)\n            right = height(root.right)\n            if left == -1 or right == -1 or abs(left - right) > 1:\n                return -1\n            return max(left, right) + 1\n        \n        return height(root) != -1"}, {"task_id": "balanced-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def height(root):\n            if not root:\n                return 0\n            return 1 + max(height(root.left), height(root.right))\n        \n        if not root:\n            return True\n        \n        return abs(height(root.left) - height(root.right)) <= 1 and self.isBalanced(root.left) and self.isBalanced(root.right)"}, {"task_id": "balanced-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def height(root):\n            if not root:\n                return 0\n            left = height(root.left)\n            right = height(root.right)\n            if left == -1 or right == -1 or abs(left - right) > 1:\n                return -1\n            return max(left, right) + 1\n        \n        return height(root) != -1"}, {"task_id": "balanced-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def height(root):\n            if not root:\n                return 0\n            left = height(root.left)\n            right = height(root.right)\n            if left == -1 or right == -1 or abs(left - right) > 1:\n                return -1\n            return max(left, right) + 1\n        \n        return height(root) != -1"}], "power-of-two": [{"task_id": "power-of-two", "completion": "class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 0:\n            return False\n        \n        while n % 2 == 0:\n            n = n / 2\n        \n        return n == 1"}, {"task_id": "power-of-two", "completion": "class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 0:\n            return False\n        while n % 2 == 0:\n            n = n / 2\n        return n == 1"}, {"task_id": "power-of-two", "completion": "class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 0:\n            return False\n        while n % 2 == 0:\n            n = n / 2\n        return n == 1"}, {"task_id": "power-of-two", "completion": "class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 0:\n            return False\n        while n % 2 == 0:\n            n = n / 2\n        return n == 1"}, {"task_id": "power-of-two", "completion": "class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 0:\n            return False\n        while n % 2 == 0:\n            n = n / 2\n        return n == 1"}], "subsets-ii": [{"task_id": "subsets-ii", "completion": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = [[]]\n        for i in range(len(nums)):\n            if i == 0 or nums[i] != nums[i-1]:\n                res += [r + [nums[i]] for r in res]\n        return res"}, {"task_id": "subsets-ii", "completion": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = [[]]\n        for i in range(len(nums)):\n            if i == 0 or nums[i] != nums[i-1]:\n                res += [r + [nums[i]] for r in res]\n        return res"}, {"task_id": "subsets-ii", "completion": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = [[]]\n        for i in range(len(nums)):\n            if i == 0 or nums[i] != nums[i-1]:\n                res += [r + [nums[i]] for r in res]\n        return res"}, {"task_id": "subsets-ii", "completion": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = [[]]\n        for i in range(len(nums)):\n            if i == 0 or nums[i] != nums[i-1]:\n                res += [r + [nums[i]] for r in res]\n        return res"}, {"task_id": "subsets-ii", "completion": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = [[]]\n        for i in range(len(nums)):\n            if i == 0 or nums[i] != nums[i-1]:\n                res += [r + [nums[i]] for r in res]\n        return res"}], "largest-rectangle-in-histogram": [{"task_id": "largest-rectangle-in-histogram", "completion": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uc5ec \uc624\ub984\ucc28\uc21c\uc73c\ub85c \uc815\ub82c\ud55c\ub2e4.\n        # 2. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \uac12\uc744 \uae30\uc900\uc73c\ub85c \uc624\ub978\ucabd\uc5d0 \uc788\ub294 \uac12\ub4e4\uc744 \ucc3e\ub294\ub2e4.\n        # 3. \uc624\ub978\ucabd\uc5d0 \uc788\ub294 \uac12\ub4e4\uc744 \uae30\uc900\uc73c\ub85c \uc67c\ucabd\uc5d0 \uc788\ub294 \uac12\ub4e4\uc744 \ucc3e\ub294\ub2e4.\n        # 4. \uc67c\ucabd\uc5d0 \uc788\ub294 \uac12\ub4e4\uc744 \uae30\uc900\uc73c\ub85c \uc624\ub978\ucabd\uc5d0 \uc788\ub294 \uac12\ub4e4\uc744 \ucc3e\ub294\ub2e4.\n        # 5. \uc624\ub978\ucabd\uc5d0 \uc788\ub294 \uac12\ub4e4\uc744 \uae30\uc900\uc73c\ub85c \uc67c\ucabd\uc5d0 \uc788\ub294 \uac12\ub4e4\uc744 \ucc3e\ub294\ub2e4.\n        # 6. \uc624\ub978\ucabd\uc5d0 \uc788\ub294 \uac12\ub4e4\uc744 \uae30\uc900\uc73c\ub85c \uc67c\ucabd\uc5d0 \uc788\ub294 \uac12\ub4e4\uc744 \ucc3e\ub294\ub2e4.\n        # 7. \uc624\ub978\ucabd\uc5d0 \uc788\ub294 \uac12\ub4e4\uc744 \uae30\uc900\uc73c\ub85c \uc67c\ucabd\uc5d0 \uc788\ub294 \uac12\ub4e4\uc744 \ucc3e\ub294\ub2e4.\n        # 8. \uc624\ub978\ucabd\uc5d0 \uc788\ub294 \uac12\ub4e4\uc744 \uae30\uc900\uc73c\ub85c \uc67c\ucabd\uc5d0 \uc788\ub294 \uac12\ub4e4\uc744 \ucc3e\ub294\ub2e4.\n        # 9. \uc624\ub978\ucabd\uc5d0 \uc788\ub294 \uac12\ub4e4\uc744 \uae30\uc900\uc73c\ub85c \uc67c\ucabd\uc5d0 \uc788\ub294 \uac12\ub4e4\uc744 \ucc3e\ub294\ub2e4.\n        # 10. \uc624\ub978\ucabd\uc5d0 \uc788\ub294 \uac12\ub4e4\uc744 \uae30\uc900\uc73c\ub85c \uc67c\ucabd\uc5d0 \uc788\ub294 \uac12\ub4e4\uc744 \ucc3e\ub294\ub2e4.\n        # 11. \uc624\ub978\ucabd\uc5d0 \uc788\ub294 \uac12\ub4e4\uc744 \uae30\uc900\uc73c\ub85c \uc67c\ucabd\uc5d0 \uc788\ub294 \uac12\ub4e4\uc744 \ucc3e\ub294\ub2e4.\n        # 12. \uc624\ub978\ucabd\uc5d0 \uc788\ub294 \uac12\ub4e4\uc744 \uae30\uc900\uc73c\ub85c \uc67c\ucabd\uc5d0 \uc788\ub294 \uac12\ub4e4\uc744 \ucc3e\ub294\ub2e4.\n        # 13. \uc624\ub978\ucabd\uc5d0 \uc788\ub294 \ufffd"}, {"task_id": "largest-rectangle-in-histogram", "completion": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uc5ec \uc624\ub984\ucc28\uc21c\uc73c\ub85c \uc815\ub82c\ud55c\ub2e4.\n        # 2. \uc2a4\ud0dd\uc5d0 \uc788\ub294 \uac12\uc744 \uaebc\ub0b4\uc11c \uc624\ub978\ucabd\uc5d0\uc11c \uc67c\ucabd\uc73c\ub85c \uacc4\uc0b0\ud55c\ub2e4.\n        # 3. \uc624\ub978\ucabd\uc5d0\uc11c \uc67c\ucabd\uc73c\ub85c \uacc4\uc0b0\ud558\uba74\uc11c \ucd5c\ub300 \ub113\uc774\ub97c \uacc4\uc0b0\ud55c\ub2e4.\n        # 4. \uc624\ub978\ucabd\uc5d0\uc11c \uc67c\ucabd\uc73c\ub85c \uacc4\uc0b0\ud558\uba74\uc11c \ucd5c\ub300 \ub113\uc774\ub97c \uacc4\uc0b0\ud55c\ub2e4.\n        # 5. \uc624\ub978\ucabd\uc5d0\uc11c \uc67c\ucabd\uc73c\ub85c \uacc4\uc0b0\ud558\uba74\uc11c \ucd5c\ub300 \ub113\uc774\ub97c \uacc4\uc0b0\ud55c\ub2e4.\n        # 6. \uc624\ub978\ucabd\uc5d0\uc11c \uc67c\ucabd\uc73c\ub85c \uacc4\uc0b0\ud558\uba74\uc11c \ucd5c\ub300 \ub113\uc774\ub97c \uacc4\uc0b0\ud55c\ub2e4.\n        # 7. \uc624\ub978\ucabd\uc5d0\uc11c \uc67c\ucabd\uc73c\ub85c \uacc4\uc0b0\ud558\uba74\uc11c \ucd5c\ub300 \ub113\uc774\ub97c \uacc4\uc0b0\ud55c\ub2e4.\n        # 8. \uc624\ub978\ucabd\uc5d0\uc11c \uc67c\ucabd\uc73c\ub85c \uacc4\uc0b0\ud558\uba74\uc11c \ucd5c\ub300 \ub113\uc774\ub97c \uacc4\uc0b0\ud55c\ub2e4.\n        # 9. \uc624\ub978\ucabd\uc5d0\uc11c \uc67c\ucabd\uc73c\ub85c \uacc4\uc0b0\ud558\uba74\uc11c \ucd5c\ub300 \ub113\uc774\ub97c \uacc4\uc0b0\ud55c\ub2e4.\n        # 10. \uc624\ub978\ucabd\uc5d0\uc11c \uc67c\ucabd\uc73c\ub85c \uacc4\uc0b0\ud558\uba74\uc11c \ucd5c\ub300 \ub113\uc774\ub97c \uacc4\uc0b0\ud55c\ub2e4.\n        # 11. \uc624\ub978\ucabd\uc5d0\uc11c \uc67c\ucabd\uc73c\ub85c \uacc4\uc0b0\ud558\uba74\uc11c \ucd5c\ub300 \ub113\uc774\ub97c \uacc4\uc0b0\ud55c\ub2e4.\n        # 12. \uc624\ub978\ucabd\uc5d0\uc11c \uc67c\ucabd\uc73c\ub85c \uacc4\uc0b0\ud558\uba74\uc11c \ucd5c\ub300 \ub113\uc774\ub97c \uacc4\uc0b0\ud55c\ub2e4.\n        # 13. \uc624\ub978\ucabd\uc5d0\uc11c \uc67c\ucabd\uc73c\ub85c \uacc4\uc0b0\ud558\uba74\uc11c \ucd5c\ub300 \ub113\uc774\ub97c"}, {"task_id": "largest-rectangle-in-histogram", "completion": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uc5ec \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ufffd"}, {"task_id": "largest-rectangle-in-histogram", "completion": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uc5ec \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ud589\ud558\uba74\uc11c \uc624\ub978\ucabd \ub05d\uc5d0\uc11c \uc67c\ucabd \ub05d\uae4c\uc9c0 \uc9c4\ufffd"}, {"task_id": "largest-rectangle-in-histogram", "completion": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uc5ec \uc624\ub978\ucabd\uc73c\ub85c \uac00\uba74\uc11c \uc624\ub978\ucabd\uc73c\ub85c \uac00\uba74\uc11c \uc624\ub978\ucabd\uc73c\ub85c \uac00\uba74\uc11c \uc624\ub978\ucabd\uc73c\ub85c \uac00\uba74\uc11c \uc624\ub978\ucabd\uc73c\ub85c \uac00\uba74\uc11c \uc624\ub978\ucabd\uc73c\ub85c \uac00\uba74\uc11c \uc624\ub978\ucabd\uc73c\ub85c \uac00\uba74\uc11c \uc624\ub978\ucabd\uc73c\ub85c \uac00\uba74\uc11c \uc624\ub978\ucabd\uc73c\ub85c \uac00\uba74\uc11c \uc624\ub978\ucabd\uc73c\ub85c \uac00\uba74\uc11c \uc624\ub978\ucabd\uc73c\ub85c \uac00\uba74\uc11c \uc624\ub978\ucabd\uc73c\ub85c \uac00\uba74\uc11c \uc624\ub978\ucabd\uc73c\ub85c \uac00\uba74\uc11c \uc624\ub978\ucabd\uc73c\ub85c \uac00\uba74\uc11c \uc624\ub978\ucabd\uc73c\ub85c \uac00\uba74\uc11c \uc624\ub978\ucabd\uc73c\ub85c \uac00\uba74\uc11c \uc624\ub978\ucabd\uc73c\ub85c \uac00\uba74\uc11c \uc624\ub978\ucabd\uc73c\ub85c \uac00\uba74\uc11c \uc624\ub978\ucabd\uc73c\ub85c \uac00\uba74\uc11c \uc624\ub978\ucabd\uc73c\ub85c \uac00\uba74\uc11c \uc624\ub978\ucabd\uc73c\ub85c \uac00\uba74\uc11c \uc624\ub978\ucabd\uc73c\ub85c \uac00\uba74\uc11c \uc624\ub978\ucabd\uc73c\ub85c \uac00\uba74\uc11c \uc624\ub978\ucabd\uc73c\ub85c \uac00\uba74\uc11c \uc624\ub978\ucabd\uc73c\ub85c \uac00\uba74\uc11c \uc624\ub978\ucabd\uc73c\ub85c \uac00\uba74\uc11c \uc624\ub978\ucabd\uc73c\ub85c \uac00\uba74\uc11c \uc624\ub978\ucabd\uc73c\ub85c \uac00\uba74\uc11c \uc624\ub978\ucabd\uc73c\ub85c \uac00\uba74\uc11c \uc624\ub978\ucabd\uc73c\ub85c \uac00\uba74\uc11c \uc624\ub978\ucabd\uc73c\ub85c \uac00\uba74\uc11c \uc624\ub978\ucabd\uc73c\ub85c \uac00\uba74\uc11c \uc624\ub978\ucabd\uc73c\ub85c \uac00\uba74\uc11c \uc624\ub978\ucabd\uc73c\ub85c \uac00\uba74\uc11c \uc624\ub978\ucabd\uc73c\ub85c \uac00\uba74\uc11c \uc624\ub978\ucabd\uc73c\ub85c \uac00\uba74\uc11c \uc624\ub978\ucabd\uc73c\ub85c \uac00\uba74\uc11c \uc624\ub978\ucabd\uc73c\ub85c \uac00\uba74\uc11c \uc624\ub978\ufffd"}], "evaluate-reverse-polish-notation": [{"task_id": "evaluate-reverse-polish-notation", "completion": "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        for i in tokens:\n            if i == \"+\":\n                stack.append(stack.pop() + stack.pop())\n            elif i == \"-\":\n                stack.append(-stack.pop() + stack.pop())\n            elif i == \"*\":\n                stack.append(stack.pop() * stack.pop())\n            elif i == \"/\":\n                num1 = stack.pop()\n                num2 = stack.pop()\n                stack.append(int(num2 / num1))\n            else:\n                stack.append(int(i))\n        return stack[0]"}, {"task_id": "evaluate-reverse-polish-notation", "completion": "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        for i in tokens:\n            if i == \"+\":\n                stack.append(stack.pop() + stack.pop())\n            elif i == \"-\":\n                stack.append(-stack.pop() + stack.pop())\n            elif i == \"*\":\n                stack.append(stack.pop() * stack.pop())\n            elif i == \"/\":\n                num1 = stack.pop()\n                num2 = stack.pop()\n                stack.append(int(num2 / num1))\n            else:\n                stack.append(int(i))\n        return stack[0]"}, {"task_id": "evaluate-reverse-polish-notation", "completion": "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        for i in tokens:\n            if i == \"+\":\n                stack.append(stack.pop() + stack.pop())\n            elif i == \"-\":\n                stack.append(-stack.pop() + stack.pop())\n            elif i == \"*\":\n                stack.append(stack.pop() * stack.pop())\n            elif i == \"/\":\n                num1 = stack.pop()\n                num2 = stack.pop()\n                stack.append(int(num2 / num1))\n            else:\n                stack.append(int(i))\n        return stack[0]"}, {"task_id": "evaluate-reverse-polish-notation", "completion": "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        \n        for i in tokens:\n            if i == \"+\":\n                stack.append(stack.pop() + stack.pop())\n            elif i == \"-\":\n                stack.append(-stack.pop() + stack.pop())\n            elif i == \"*\":\n                stack.append(stack.pop() * stack.pop())\n            elif i == \"/\":\n                num1 = stack.pop()\n                num2 = stack.pop()\n                stack.append(int(num2 / num1))\n            else:\n                stack.append(int(i))\n                \n        return stack[0]"}, {"task_id": "evaluate-reverse-polish-notation", "completion": "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        for i in tokens:\n            if i == \"+\":\n                stack.append(stack.pop() + stack.pop())\n            elif i == \"-\":\n                stack.append(-stack.pop() + stack.pop())\n            elif i == \"*\":\n                stack.append(stack.pop() * stack.pop())\n            elif i == \"/\":\n                num1 = stack.pop()\n                num2 = stack.pop()\n                stack.append(int(num2 / num1))\n            else:\n                stack.append(int(i))\n        return stack[0]"}], "perfect-rectangle": [{"task_id": "perfect-rectangle", "completion": "class Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        \n        x_min, y_min, x_max, y_max = float('inf'), float('inf'), float('-inf'), float('-inf')\n        area = 0\n        for x1, y1, x2, y2 in rectangles:\n            x_min, y_min, x_max, y_max = min(x_min, x1), min(y_min, y1), max(x_max, x2), max(y_max, y2)\n            area += (x2 - x1) * (y2 - y1)\n        if area != (x_max - x_min) * (y_max - y_min):\n            return False\n        for x1, y1, x2, y2 in rectangles:\n            if x1 == x_min and y1 == y_min:\n                if x2 != x_max or y2 != y_max:\n                    return False\n            elif x1 == x_min and y2 == y_max:\n                if x2 != x_max or y1 != y_min:\n                    return False\n            elif x2 == x_max and y1 == y_min:\n                if x1 != x_min or y2 != y_max:\n                    return False\n            elif x2 == x_max and y2 == y_max:\n                if x1 != x_min or y1 != y_min:\n                    return False\n        return True"}, {"task_id": "perfect-rectangle", "completion": "class Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        \n        x_min, y_min = float('inf'), float('inf')\n        x_max, y_max = float('-inf'), float('-inf')\n        area = 0\n        \n        for x1, y1, x2, y2 in rectangles:\n            x_min = min(x_min, x1)\n            y_min = min(y_min, y1)\n            x_max = max(x_max, x2)\n            y_max = max(y_max, y2)\n            area += (x2 - x1) * (y2 - y1)\n        \n        if area != (x_max - x_min) * (y_max - y_min):\n            return False\n        \n        for x1, y1, x2, y2 in rectangles:\n            if x1 == x_min and y1 == y_min:\n                if x2 != x_max or y2 != y_max:\n                    return False\n            elif x1 == x_min and y2 == y_max:\n                if x2 != x_max or y1 != y_min:\n                    return False\n            elif x2 == x_max and y1 == y_min:\n                if x1 != x_min or y2 != y_max:\n                    return False\n            elif x2 == x_max and y2 == y_max:\n                if x1 != x_min or y1 != y_min:\n                    return False\n        \n        return True"}, {"task_id": "perfect-rectangle", "completion": "class Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        \n        x_min, y_min = float('inf'), float('inf')\n        x_max, y_max = float('-inf'), float('-inf')\n        area = 0\n        \n        for x1, y1, x2, y2 in rectangles:\n            x_min = min(x_min, x1)\n            y_min = min(y_min, y1)\n            x_max = max(x_max, x2)\n            y_max = max(y_max, y2)\n            area += (x2 - x1) * (y2 - y1)\n        \n        if area != (x_max - x_min) * (y_max - y_min):\n            return False\n        \n        for x1, y1, x2, y2 in rectangles:\n            if x1 == x_min and y1 == y_min:\n                if x2 != x_max or y2 != y_max:\n                    return False\n            elif x1 == x_min and y2 == y_max:\n                if x2 != x_max or y1 != y_min:\n                    return False\n            elif x2 == x_max and y1 == y_min:\n                if x1 != x_min or y2 != y_max:\n                    return False\n            elif x2 == x_max and y2 == y_max:\n                if x1 != x_min or y1 != y_min:\n                    return False\n        \n        return True"}, {"task_id": "perfect-rectangle", "completion": "class Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        \n        x_min, y_min, x_max, y_max = float('inf'), float('inf'), float('-inf'), float('-inf')\n        area = 0\n        \n        for x1, y1, x2, y2 in rectangles:\n            x_min = min(x_min, x1)\n            y_min = min(y_min, y1)\n            x_max = max(x_max, x2)\n            y_max = max(y_max, y2)\n            area += (x2 - x1) * (y2 - y1)\n        \n        if area != (x_max - x_min) * (y_max - y_min):\n            return False\n        \n        if (x_min, y_min) not in rectangles:\n            return False\n        \n        if (x_max, y_min) not in rectangles:\n            return False\n        \n        if (x_min, y_max) not in rectangles:\n            return False\n        \n        if (x_max, y_max) not in rectangles:\n            return False\n        \n        return True"}, {"task_id": "perfect-rectangle", "completion": "class Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        \n        x_min, y_min, x_max, y_max = float('inf'), float('inf'), float('-inf'), float('-inf')\n        area = 0\n        \n        for x1, y1, x2, y2 in rectangles:\n            x_min = min(x_min, x1)\n            y_min = min(y_min, y1)\n            x_max = max(x_max, x2)\n            y_max = max(y_max, y2)\n            area += (x2 - x1) * (y2 - y1)\n        \n        if area != (x_max - x_min) * (y_max - y_min):\n            return False\n        \n        seen = set()\n        \n        for x1, y1, x2, y2 in rectangles:\n            for x, y in [(x1, y1), (x1, y2), (x2, y1), (x2, y2)]:\n                if (x, y) in seen:\n                    seen.remove((x, y))\n                else:\n                    seen.add((x, y))\n        \n        return len(seen) == 4"}], "excel-sheet-column-title": [{"task_id": "excel-sheet-column-title", "completion": "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 2. 10\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 3. 26\u8fdb\u5236\u8f6c\u5b57\u7b26\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 2. 10\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 3. 26\u8fdb\u5236\u8f6c\u5b57\u7b26\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 2. 10\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 3. 26\u8fdb\u5236\u8f6c\u5b57\u7b26\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 2. 10\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 3. 26\u8fdb\u5236\u8f6c\u5b57\u7b26\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 2. 10\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 3. 26\u8fdb\u5236\u8f6c\u5b57\u7b26\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 2. 10\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 3. 26\u8fdb\u5236\u8f6c\u5b57\u7b26\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 2. 10\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 3. 26\u8fdb\u5236\u8f6c\u5b57\u7b26\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 2. 10\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 3. 26\u8fdb\u5236\u8f6c\u5b57\u7b26\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 2. 10\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 3. 26\u8fdb\u5236\u8f6c\u5b57\u7b26\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 2. 10\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 3. 26\u8fdb\u5236\u8f6c\u5b57\u7b26\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 2. 10\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 3. 26\u8fdb\u5236\u8f6c\u5b57\u7b26\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 2. 10\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 3. 26\u8fdb\u5236\u8f6c\u5b57\u7b26\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 2. 10\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 3. 26\u8fdb\u5236\u8f6c\u5b57\u7b26\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 2. 10\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 3. 26\u8fdb\u5236\u8f6c\u5b57\u7b26\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 2. 10\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 3. 26\u8fdb\u5236\u8f6c\u5b57\u7b26\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 2. 10\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 3. 26\u8fdb\u5236\u8f6c\u5b57\u7b26\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 2. 10\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 3. 26\u8fdb\u5236\u8f6c\u5b57\u7b26\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 2. 10\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 3. 26\u8fdb\u5236\u8f6c\u5b57\u7b26\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 2. 10\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 3. 26\u8fdb\u5236\u8f6c\u5b57\u7b26\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 2. 10\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 3. 26\u8fdb\u5236\u8f6c\u5b57\u7b26\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 2. 10\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 3. 26\u8fdb\u5236\u8f6c\u5b57\u7b26\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236"}, {"task_id": "excel-sheet-column-title", "completion": "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. convert to base 26\n        # 2. reverse the string\n        # 3. convert to base 10\n        # 4. convert to base 26\n        # 5. reverse the string\n        # 6. convert to base 10\n        # 7. convert to base 26\n        # 8. convert to base 10\n        # 9. convert to base 26\n        # 10. convert to base 10\n        # 11. convert to base 26\n        # 12. convert to base 10\n        # 13. convert to base 26\n        # 14. convert to base 10\n        # 15. convert to base 26\n        # 16. convert to base 10\n        # 17. convert to base 26\n        # 18. convert to base 10\n        # 19. convert to base 26\n        # 20. convert to base 10\n        # 21. convert to base 26\n        # 22. convert to base 10\n        # 23. convert to base 26\n        # 24. convert to base 10\n        # 25. convert to base 26\n        # 26. convert to base 10\n        # 27. convert to base 26\n        # 28. convert to base 10\n        # 29. convert to base 26\n        # 30. convert to base 10\n        # 31. convert to base 26\n        # 32. convert to base 10\n        # 33. convert to base 26\n        # 34. convert to base 10\n        # 35. convert to base 26\n        # 36. convert to base 10\n        # 37. convert to base 26\n        # 38. convert to base 10\n        # 39. convert to base 26\n        # 40. convert to base 10\n        # 41. convert to base 26\n        # 42. convert to base 10\n        # 43. convert to base 26\n        # 44. convert to base 10\n        # 45. convert to base 26\n        # 46. convert to base 10\n        # 47. convert to base 26\n        # 48. convert to base 10\n        # 49. convert to base 26\n        # 50. convert to base 10\n        # 51. convert to base 26\n        # 52. convert to base 10\n        # 53. convert to base 26\n        # 54. convert to base 10\n        # 55. convert to base 26\n        # 56. convert to base 10\n        # 57. convert to base 26\n        # 58. convert to base 10\n        # 59. convert to base 26\n        # 60. convert to base 10\n        # 61. convert to base 26\n        # 62. convert to base 10\n        # 63. convert to base 26\n        # 64. convert to base 10\n        # 65. convert to base 26\n        # 66. convert to base 10\n        # 67. convert to base 26\n        # 68. convert to base 10\n        # 69. convert to base 26\n        # 70. convert to base 10\n        # 71. convert to base 26\n        # 72. convert to base 10\n        # 73. convert to base 26\n        # 74. convert to base 10\n        # 75. convert to base 26\n        # 76. convert to base 10\n        # 77. convert to base 26\n        # 78. convert to base 10\n        # 79. convert to base 26\n        # 80. convert to base 10"}, {"task_id": "excel-sheet-column-title", "completion": "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        \n        # 26^0 = 1\n        # 26^1 = 26\n        # 26^2 = 26^1 * 26\n        # 26^3 = 26^2 * 26\n        # 26^4 = 26^3 * 26\n        # 26^5 = 26^4 * 26\n        # 26^6 = 26^5 * 26\n        # 26^7 = 26^6 * 26\n        # 26^8 = 26^7 * 26\n        # 26^9 = 26^8 * 26\n        # 26^10 = 26^9 * 26\n        # 26^11 = 26^10 * 26\n        # 26^12 = 26^11 * 26\n        # 26^13 = 26^12 * 26\n        # 26^14 = 26^13 * 26\n        # 26^15 = 26^14 * 26\n        # 26^16 = 26^15 * 26\n        # 26^17 = 26^16 * 26\n        # 26^18 = 26^17 * 26\n        # 26^19 = 26^18 * 26\n        # 26^20 = 26^19 * 26\n        # 26^21 = 26^20 * 26\n        # 26^22 = 26^21 * 26\n        # 26^23 = 26^22 * 26\n        # 26^24 = 26^23 * 26\n        # 26^25 = 26^24 * 26\n        # 26^26 = 26^25 * 26\n        # 26^27 = 26^26 * 26\n        # 26^28 = 26^27 * 26\n        # 26^29 = 26^28 * 26\n        # 26^30 = 26^29 * 26\n        # 26^31 = 26^30 * 26\n        # 26^32 = 26^31 * 26\n        # 26^33 = 26^32 * 26\n        # 26^34 = 26^33 * 26\n        # 26^35 = 26^34 * 26\n        # 26^36 = 26^35 * 26\n        # 26^37 = 26^36 * 26\n        # 26^38 = 26^37 * 26\n        # 26^39 = 26^38 * 26\n        # 26^40 = 26^39 * 26\n        # 26^41 = 26^40 * 26\n        # 26^42 = 26^41 * 26\n        # 26^43 = 26^42 * 26\n        # 26^44 = 26^43 * 26\n        # 26^45 = 26^44 * 26\n        # 26^46 = 26^45 * 26\n        # 26^47 = 26^46 * 26\n        # 26^48 = 26^47 * 26\n        # 26^49 = 26^48 * 26\n        # 26^50 = 26^49 * 26\n        # 26^51 = 26^50 * 26\n        # 26^52 = 26^51 * 26\n        # 26^53 = 26^52 * 26\n        # 26^54 = 26^53 * 26\n        # 26^55 = 26^5"}, {"task_id": "excel-sheet-column-title", "completion": "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 2. 10\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 3. 26\u8fdb\u5236\u8f6c\u5b57\u7b26\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 2. 10\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 3. 26\u8fdb\u5236\u8f6c\u5b57\u7b26\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 2. 10\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 3. 26\u8fdb\u5236\u8f6c\u5b57\u7b26\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 2. 10\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 3. 26\u8fdb\u5236\u8f6c\u5b57\u7b26\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 2. 10\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 3. 26\u8fdb\u5236\u8f6c\u5b57\u7b26\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 2. 10\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 3. 26\u8fdb\u5236\u8f6c\u5b57\u7b26\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 2. 10\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 3. 26\u8fdb\u5236\u8f6c\u5b57\u7b26\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 2. 10\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 3. 26\u8fdb\u5236\u8f6c\u5b57\u7b26\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 2. 10\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 3. 26\u8fdb\u5236\u8f6c\u5b57\u7b26\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 2. 10\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 3. 26\u8fdb\u5236\u8f6c\u5b57\u7b26\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 2. 10\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 3. 26\u8fdb\u5236\u8f6c\u5b57\u7b26\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 2. 10\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 3. 26\u8fdb\u5236\u8f6c\u5b57\u7b26\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 2. 10\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 3. 26\u8fdb\u5236\u8f6c\u5b57\u7b26\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 2. 10\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 3. 26\u8fdb\u5236\u8f6c\u5b57\u7b26\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 2. 10\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 3. 26\u8fdb\u5236\u8f6c\u5b57\u7b26\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 2. 10\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 3. 26\u8fdb\u5236\u8f6c\u5b57\u7b26\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 2. 10\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 3. 26\u8fdb\u5236\u8f6c\u5b57\u7b26\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 2. 10\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 3. 26\u8fdb\u5236\u8f6c\u5b57\u7b26\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 2. 10\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 3. 26\u8fdb\u5236\u8f6c\u5b57\u7b26\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 2. 10\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 3. 26\u8fdb\u5236\u8f6c\u5b57\u7b26\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 2. 10\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 3. 26\u8fdb\u5236\u8f6c\u5b57\u7b26\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236"}, {"task_id": "excel-sheet-column-title", "completion": "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 2. 10\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 3. 26\u8fdb\u5236\u8f6c\u5b57\u7b26\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 2. 10\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 3. 26\u8fdb\u5236\u8f6c\u5b57\u7b26\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 2. 10\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 3. 26\u8fdb\u5236\u8f6c\u5b57\u7b26\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 2. 10\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 3. 26\u8fdb\u5236\u8f6c\u5b57\u7b26\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 2. 10\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 3. 26\u8fdb\u5236\u8f6c\u5b57\u7b26\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 2. 10\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 3. 26\u8fdb\u5236\u8f6c\u5b57\u7b26\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 2. 10\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 3. 26\u8fdb\u5236\u8f6c\u5b57\u7b26\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 2. 10\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 3. 26\u8fdb\u5236\u8f6c\u5b57\u7b26\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 2. 10\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 3. 26\u8fdb\u5236\u8f6c\u5b57\u7b26\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 2. 10\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 3. 26\u8fdb\u5236\u8f6c\u5b57\u7b26\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 2. 10\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 3. 26\u8fdb\u5236\u8f6c\u5b57\u7b26\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 2. 10\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 3. 26\u8fdb\u5236\u8f6c\u5b57\u7b26\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 2. 10\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 3. 26\u8fdb\u5236\u8f6c\u5b57\u7b26\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 2. 10\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 3. 26\u8fdb\u5236\u8f6c\u5b57\u7b26\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 2. 10\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 3. 26\u8fdb\u5236\u8f6c\u5b57\u7b26\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 2. 10\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 3. 26\u8fdb\u5236\u8f6c\u5b57\u7b26\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 2. 10\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 3. 26\u8fdb\u5236\u8f6c\u5b57\u7b26\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 2. 10\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 3. 26\u8fdb\u5236\u8f6c\u5b57\u7b26\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 2. 10\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 3. 26\u8fdb\u5236\u8f6c\u5b57\u7b26\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 2. 10\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 3. 26\u8fdb\u5236\u8f6c\u5b57\u7b26\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236\n        # 2. 10\u8fdb\u5236\u8f6c26\u8fdb\u5236\n        # 3. 26\u8fdb\u5236\u8f6c\u5b57\u7b26\n        \n        # 1. 26\u8fdb\u5236\u8f6c10\u8fdb\u5236"}], "maximum-subarray": [{"task_id": "maximum-subarray", "completion": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_sum = nums[0]\n        curr_sum = 0\n        \n        for i in range(len(nums)):\n            if curr_sum < 0:\n                curr_sum = 0\n            curr_sum += nums[i]\n            max_sum = max(max_sum, curr_sum)\n        \n        return max_sum"}, {"task_id": "maximum-subarray", "completion": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_sum = nums[0]\n        curr_sum = 0\n        \n        for i in range(len(nums)):\n            if curr_sum < 0:\n                curr_sum = 0\n            curr_sum += nums[i]\n            max_sum = max(max_sum, curr_sum)\n            \n        return max_sum"}, {"task_id": "maximum-subarray", "completion": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_sum = nums[0]\n        curr_sum = 0\n        \n        for num in nums:\n            if curr_sum < 0:\n                curr_sum = 0\n            curr_sum += num\n            max_sum = max(max_sum, curr_sum)\n        \n        return max_sum"}, {"task_id": "maximum-subarray", "completion": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_sum = nums[0]\n        curr_sum = 0\n        \n        for i in range(len(nums)):\n            if curr_sum < 0:\n                curr_sum = 0\n            curr_sum += nums[i]\n            max_sum = max(max_sum, curr_sum)\n            \n        return max_sum"}, {"task_id": "maximum-subarray", "completion": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_sum = nums[0]\n        curr_sum = 0\n        \n        for i in range(len(nums)):\n            if curr_sum < 0:\n                curr_sum = 0\n            curr_sum += nums[i]\n            max_sum = max(max_sum, curr_sum)\n            \n        return max_sum"}], "sliding-puzzle": [{"task_id": "sliding-puzzle", "completion": "class Solution(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def swap(board, i, j):\n            board[i], board[j] = board[j], board[i]\n            return board\n        \n        def get_zero(board):\n            for i in range(len(board)):\n                for j in range(len(board[0])):\n                    if board[i][j] == 0:\n                        return i, j\n            return None\n        \n        def get_neighbors(board):\n            i, j = get_zero(board)\n            neighbors = []\n            if i > 0:\n                neighbors.append(swap(board, i, j))\n            if i < 1:\n                neighbors.append(swap(board, i, j))\n            if j > 0:\n                neighbors.append(swap(board, i, j))\n            if j < 2:\n                neighbors.append(swap(board, i, j))\n            return neighbors\n        \n        def get_goal(board):\n            goal = [[1,2,3],[4,5,0]]\n            return goal\n        \n        def get_distance(board):\n            distance = 0\n            for i in range(len(board)):\n                for j in range(len(board[0])):\n                    if board[i][j] != goal[i][j]:\n                        distance += 1\n            return distance\n        \n        goal = get_goal(board)\n        distance = 0\n        queue = [board]\n        visited = set()\n        while queue:\n            board = queue.pop(0)\n            if board == goal:\n                return distance\n            neighbors = get_neighbors(board)\n            for neighbor in neighbors:\n                if neighbor not in visited:\n                    visited.add(tuple(neighbor))\n                    queue.append(neighbor)\n            distance += 1\n        return -1"}, {"task_id": "sliding-puzzle", "completion": "class Solution(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def swap(board, i, j):\n            board[i], board[j] = board[j], board[i]\n            return board\n        \n        def get_zero(board):\n            for i in range(len(board)):\n                for j in range(len(board[0])):\n                    if board[i][j] == 0:\n                        return i, j\n            return None\n        \n        def get_neighbors(board):\n            i, j = get_zero(board)\n            neighbors = []\n            if i > 0:\n                neighbors.append(swap(board, i, j))\n            if i < 1:\n                neighbors.append(swap(board, i, j))\n            if j > 0:\n                neighbors.append(swap(board, i, j))\n            if j < 2:\n                neighbors.append(swap(board, i, j))\n            return neighbors\n        \n        def get_goal(board):\n            goal = [[1,2,3],[4,5,0]]\n            return goal\n        \n        def get_distance(board):\n            distance = 0\n            for i in range(len(board)):\n                for j in range(len(board[0])):\n                    if board[i][j] != goal[i][j]:\n                        distance += 1\n            return distance\n        \n        goal = get_goal(board)\n        distance = 0\n        queue = [board]\n        visited = set()\n        while queue:\n            board = queue.pop(0)\n            if board == goal:\n                return distance\n            neighbors = get_neighbors(board)\n            for neighbor in neighbors:\n                if neighbor not in visited:\n                    visited.add(tuple(neighbor))\n                    queue.append(neighbor)\n            distance += 1\n        return -1"}, {"task_id": "sliding-puzzle", "completion": "class Solution(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def swap(board, i, j):\n            board[i], board[j] = board[j], board[i]\n            return board\n        \n        def get_zero(board):\n            for i in range(len(board)):\n                for j in range(len(board[0])):\n                    if board[i][j] == 0:\n                        return i, j\n            return None\n        \n        def get_neighbors(board):\n            i, j = get_zero(board)\n            neighbors = []\n            if i > 0:\n                neighbors.append(swap(board, i, j))\n            if i < 1:\n                neighbors.append(swap(board, i, j))\n            if j > 0:\n                neighbors.append(swap(board, i, j))\n            if j < 2:\n                neighbors.append(swap(board, i, j))\n            return neighbors\n        \n        def get_goal(board):\n            goal = [[1,2,3],[4,5,0]]\n            return goal\n        \n        def get_distance(board, goal):\n            distance = 0\n            for i in range(len(board)):\n                for j in range(len(board[0])):\n                    if board[i][j] != goal[i][j]:\n                        distance += 1\n            return distance\n        \n        def solve(board):\n            if board == get_goal(board):\n                return 0\n            neighbors = get_neighbors(board)\n            min_distance = float('inf')\n            for neighbor in neighbors:\n                distance = solve(neighbor)\n                if distance < min_distance:\n                    min_distance = distance\n            return min_distance + 1\n        \n        return solve(board)"}, {"task_id": "sliding-puzzle", "completion": "class Solution(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def swap(board, i, j):\n            board[i], board[j] = board[j], board[i]\n            return board\n        \n        def get_zero(board):\n            for i in range(len(board)):\n                for j in range(len(board[0])):\n                    if board[i][j] == 0:\n                        return i, j\n            return None\n        \n        def get_neighbors(board):\n            i, j = get_zero(board)\n            neighbors = []\n            if i > 0:\n                neighbors.append(swap(board, i, j))\n            if i < 1:\n                neighbors.append(swap(board, i, j))\n            if j > 0:\n                neighbors.append(swap(board, i, j))\n            if j < 2:\n                neighbors.append(swap(board, i, j))\n            return neighbors\n        \n        def get_goal(board):\n            goal = [[1,2,3],[4,5,0]]\n            return goal\n        \n        def get_distance(board, goal):\n            distance = 0\n            for i in range(len(board)):\n                for j in range(len(board[0])):\n                    if board[i][j] != goal[i][j]:\n                        distance += 1\n            return distance\n        \n        def solve(board):\n            if board == get_goal(board):\n                return 0\n            neighbors = get_neighbors(board)\n            min_distance = float('inf')\n            for neighbor in neighbors:\n                distance = solve(neighbor)\n                if distance < min_distance:\n                    min_distance = distance\n            return min_distance + 1\n        \n        return solve(board)"}, {"task_id": "sliding-puzzle", "completion": "class Solution(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def swap(board, i, j):\n            board[i], board[j] = board[j], board[i]\n            return board\n        \n        def get_zero(board):\n            for i in range(len(board)):\n                for j in range(len(board[0])):\n                    if board[i][j] == 0:\n                        return i, j\n            return None\n        \n        def get_neighbors(board):\n            i, j = get_zero(board)\n            neighbors = []\n            if i > 0:\n                neighbors.append(swap(board, i, j))\n            if i < 1:\n                neighbors.append(swap(board, i, j))\n            if j > 0:\n                neighbors.append(swap(board, i, j))\n            if j < 2:\n                neighbors.append(swap(board, i, j))\n            return neighbors\n        \n        def get_goal(board):\n            goal = [[1,2,3],[4,5,0]]\n            for i in range(len(board)):\n                for j in range(len(board[0])):\n                    if board[i][j] != goal[i][j]:\n                        return False\n            return True\n        \n        def bfs(board):\n            queue = [(board, 0)]\n            visited = set()\n            while queue:\n                board, moves = queue.pop(0)\n                if get_goal(board):\n                    return moves\n                for neighbor in get_neighbors(board):\n                    if neighbor not in visited:\n                        visited.add(tuple(neighbor))\n                        queue.append((neighbor, moves + 1))\n            return -1\n        \n        return bfs(tuple(board))"}], "isomorphic-strings": [{"task_id": "isomorphic-strings", "completion": "class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_dict = {}\n        t_dict = {}\n        \n        for i in range(len(s)):\n            if s[i] in s_dict:\n                if s_dict[s[i]] != t[i]:\n                    return False\n            else:\n                s_dict[s[i]] = t[i]\n                \n            if t[i] in t_dict:\n                if t_dict[t[i]] != s[i]:\n                    return False\n            else:\n                t_dict[t[i]] = s[i]\n                \n        return True"}, {"task_id": "isomorphic-strings", "completion": "class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_dict = {}\n        t_dict = {}\n        \n        for i in range(len(s)):\n            if s[i] in s_dict:\n                if s_dict[s[i]] != t[i]:\n                    return False\n            else:\n                s_dict[s[i]] = t[i]\n                \n            if t[i] in t_dict:\n                if t_dict[t[i]] != s[i]:\n                    return False\n            else:\n                t_dict[t[i]] = s[i]\n                \n        return True"}, {"task_id": "isomorphic-strings", "completion": "class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_dict = {}\n        t_dict = {}\n        \n        for i in range(len(s)):\n            if s[i] in s_dict:\n                if s_dict[s[i]] != t[i]:\n                    return False\n            else:\n                s_dict[s[i]] = t[i]\n                \n            if t[i] in t_dict:\n                if t_dict[t[i]] != s[i]:\n                    return False\n            else:\n                t_dict[t[i]] = s[i]\n                \n        return True"}, {"task_id": "isomorphic-strings", "completion": "class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_dict = {}\n        t_dict = {}\n        \n        for i in range(len(s)):\n            if s[i] in s_dict:\n                if s_dict[s[i]] != t[i]:\n                    return False\n            else:\n                s_dict[s[i]] = t[i]\n                \n            if t[i] in t_dict:\n                if t_dict[t[i]] != s[i]:\n                    return False\n            else:\n                t_dict[t[i]] = s[i]\n                \n        return True"}, {"task_id": "isomorphic-strings", "completion": "class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_dict = {}\n        t_dict = {}\n        \n        for i in range(len(s)):\n            if s[i] not in s_dict:\n                s_dict[s[i]] = t[i]\n            else:\n                if s_dict[s[i]] != t[i]:\n                    return False\n                \n            if t[i] not in t_dict:\n                t_dict[t[i]] = s[i]\n            else:\n                if t_dict[t[i]] != s[i]:\n                    return False\n                \n        return True"}], "search-in-rotated-sorted-array-ii": [{"task_id": "search-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        def binary_search(nums, target):\n            left, right = 0, len(nums) - 1\n            while left <= right:\n                mid = (left + right) // 2\n                if nums[mid] == target:\n                    return True\n                elif nums[mid] < target:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return False\n        \n        if len(nums) == 0:\n            return False\n        \n        if len(nums) == 1:\n            return nums[0] == target\n        \n        if nums[0] < nums[-1]:\n            return binary_search(nums, target)\n        \n        pivot = -1\n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] > nums[mid + 1]:\n                pivot = mid + 1\n                break\n            elif nums[mid] < nums[mid - 1]:\n                pivot = mid\n                break\n            else:\n                if nums[mid] > nums[left]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n        \n        if pivot == -1:\n            return binary_search(nums, target)\n        \n        if nums[pivot] == target:\n            return True\n        \n        if nums[0] <= target:\n            return binary_search(nums[:pivot + 1], target) or binary_search(nums[pivot + 1:], target)\n        else:\n            return binary_search(nums[pivot + 1:], target) or binary_search(nums[:pivot + 1], target)"}, {"task_id": "search-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        def binary_search(nums, target, left, right):\n            if left > right:\n                return False\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return True\n            if nums[mid] > target:\n                return binary_search(nums, target, left, mid - 1)\n            else:\n                return binary_search(nums, target, mid + 1, right)\n        \n        return binary_search(nums, target, 0, len(nums) - 1)"}, {"task_id": "search-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        def binary_search(nums, target, left, right):\n            if left > right:\n                return False\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return True\n            if nums[mid] > target:\n                return binary_search(nums, target, left, mid - 1)\n            else:\n                return binary_search(nums, target, mid + 1, right)\n        \n        return binary_search(nums, target, 0, len(nums) - 1)"}, {"task_id": "search-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        def binary_search(nums, target):\n            left, right = 0, len(nums) - 1\n            while left <= right:\n                mid = (left + right) // 2\n                if nums[mid] == target:\n                    return True\n                elif nums[mid] < target:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return False\n        \n        if not nums:\n            return False\n        \n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return True\n            elif nums[mid] < nums[right]:\n                if nums[mid] < target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            else:\n                if nums[left] <= target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n        return False"}, {"task_id": "search-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        def binary_search(nums, target):\n            left, right = 0, len(nums) - 1\n            while left <= right:\n                mid = (left + right) // 2\n                if nums[mid] == target:\n                    return True\n                if nums[mid] < target:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return False\n        \n        if not nums:\n            return False\n        \n        left, right = 0, len(nums) - 1\n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return True\n            if nums[mid] < nums[right]:\n                if nums[mid] < target and target <= nums[right]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            else:\n                if nums[left] <= target and target < nums[mid]:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n        return False"}], "unique-paths-ii": [{"task_id": "unique-paths-ii", "completion": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(obstacleGrid)\n        n = len(obstacleGrid[0])\n        \n        if obstacleGrid[m-1][n-1] == 1:\n            return 0\n        \n        if obstacleGrid[0][0] == 1:\n            return 0\n        \n        dp = [[0] * n for _ in range(m)]\n        \n        for i in range(m):\n            for j in range(n):\n                if obstacleGrid[i][j] == 1:\n                    dp[i][j] = 0\n                elif i == 0 and j == 0:\n                    dp[i][j] = 1\n                elif i == 0:\n                    dp[i][j] = dp[i][j-1]\n                elif j == 0:\n                    dp[i][j] = dp[i-1][j]\n                else:\n                    dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        \n        return dp[m-1][n-1]"}, {"task_id": "unique-paths-ii", "completion": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(obstacleGrid)\n        n = len(obstacleGrid[0])\n        \n        if obstacleGrid[m-1][n-1] == 1:\n            return 0\n        \n        if obstacleGrid[0][0] == 1:\n            return 0\n        \n        if m == 1 and n == 1:\n            return 1\n        \n        dp = [[0 for i in range(n)] for j in range(m)]\n        \n        for i in range(m):\n            for j in range(n):\n                if obstacleGrid[i][j] == 1:\n                    dp[i][j] = 0\n                elif i == 0 and j == 0:\n                    dp[i][j] = 1\n                elif i == 0:\n                    dp[i][j] = dp[i][j-1]\n                elif j == 0:\n                    dp[i][j] = dp[i-1][j]\n                else:\n                    dp[i][j] = dp[i-1][j] + dp[i][j-1]\n                    \n        return dp[m-1][n-1]"}, {"task_id": "unique-paths-ii", "completion": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(obstacleGrid)\n        n = len(obstacleGrid[0])\n        \n        if obstacleGrid[m-1][n-1] == 1:\n            return 0\n        \n        dp = [[0]*n for _ in range(m)]\n        \n        for i in range(m):\n            for j in range(n):\n                if obstacleGrid[i][j] == 1:\n                    dp[i][j] = 0\n                elif i == 0 and j == 0:\n                    dp[i][j] = 1\n                elif i == 0:\n                    dp[i][j] = dp[i][j-1]\n                elif j == 0:\n                    dp[i][j] = dp[i-1][j]\n                else:\n                    dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        \n        return dp[m-1][n-1]"}, {"task_id": "unique-paths-ii", "completion": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(obstacleGrid)\n        n = len(obstacleGrid[0])\n        \n        if obstacleGrid[m-1][n-1] == 1:\n            return 0\n        \n        if obstacleGrid[0][0] == 1:\n            return 0\n        \n        if m == 1 and n == 1:\n            return 1\n        \n        dp = [[0]*n for _ in range(m)]\n        \n        for i in range(m):\n            for j in range(n):\n                if obstacleGrid[i][j] == 1:\n                    dp[i][j] = 0\n                else:\n                    if i == 0 and j == 0:\n                        dp[i][j] = 1\n                    elif i == 0:\n                        dp[i][j] = dp[i][j-1]\n                    elif j == 0:\n                        dp[i][j] = dp[i-1][j]\n                    else:\n                        dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        \n        return dp[m-1][n-1]"}, {"task_id": "unique-paths-ii", "completion": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(obstacleGrid)\n        n = len(obstacleGrid[0])\n        \n        dp = [[0] * n for _ in range(m)]\n        \n        for i in range(m):\n            for j in range(n):\n                if obstacleGrid[i][j] == 1:\n                    dp[i][j] = 0\n                elif i == 0 and j == 0:\n                    dp[i][j] = 1\n                elif i == 0:\n                    dp[i][j] = dp[i][j-1]\n                elif j == 0:\n                    dp[i][j] = dp[i-1][j]\n                else:\n                    dp[i][j] = dp[i-1][j] + dp[i][j-1]\n                    \n        return dp[m-1][n-1]"}], "decode-ways-ii": [{"task_id": "decode-ways-ii", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if s[0] == '0':\n            return 0\n        \n        if len(s) == 1:\n            return 1\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] += dp[i - 1]\n            if s[i - 2] != '0' and int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        \n        return dp[-1]"}, {"task_id": "decode-ways-ii", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if s[0] == '0':\n            return 0\n        \n        if len(s) == 1:\n            return 1\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] += dp[i - 1]\n            if s[i - 2] != '0' and int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        \n        return dp[-1]"}, {"task_id": "decode-ways-ii", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if s[0] == '0':\n            return 0\n        \n        if len(s) == 1:\n            return 1\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] += dp[i - 1]\n            if s[i - 2] != '0' and int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        \n        return dp[-1]"}, {"task_id": "decode-ways-ii", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if s[0] == '0':\n            return 0\n        \n        if len(s) == 1:\n            return 1\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] += dp[i - 1]\n            if s[i - 2] != '0' and int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        \n        return dp[-1]"}, {"task_id": "decode-ways-ii", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        if s[0] == '0':\n            return 0\n        \n        if len(s) == 1:\n            return 1\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i - 1] != '0':\n                dp[i] += dp[i - 1]\n            if s[i - 2] != '0' and int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        \n        return dp[-1]"}], "3sum-closest": [{"task_id": "3sum-closest", "completion": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        closest = nums[0] + nums[1] + nums[2]\n        for i in range(len(nums)-2):\n            l = i + 1\n            r = len(nums) - 1\n            while l < r:\n                sum = nums[i] + nums[l] + nums[r]\n                if abs(sum - target) < abs(closest - target):\n                    closest = sum\n                if sum < target:\n                    l += 1\n                else:\n                    r -= 1\n        return closest"}, {"task_id": "3sum-closest", "completion": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        closest = nums[0] + nums[1] + nums[2]\n        \n        for i in range(len(nums)-2):\n            l = i + 1\n            r = len(nums) - 1\n            \n            while l < r:\n                sum = nums[i] + nums[l] + nums[r]\n                \n                if abs(target - sum) < abs(target - closest):\n                    closest = sum\n                \n                if sum < target:\n                    l += 1\n                else:\n                    r -= 1\n                \n        return closest"}, {"task_id": "3sum-closest", "completion": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        closest = nums[0] + nums[1] + nums[2]\n        for i in range(len(nums)-2):\n            l = i + 1\n            r = len(nums) - 1\n            while l < r:\n                sum = nums[i] + nums[l] + nums[r]\n                if abs(target - sum) < abs(target - closest):\n                    closest = sum\n                if sum < target:\n                    l += 1\n                else:\n                    r -= 1\n        return closest"}, {"task_id": "3sum-closest", "completion": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        closest = nums[0] + nums[1] + nums[2]\n        for i in range(len(nums)-2):\n            l = i + 1\n            r = len(nums) - 1\n            while l < r:\n                sum = nums[i] + nums[l] + nums[r]\n                if abs(sum - target) < abs(closest - target):\n                    closest = sum\n                if sum < target:\n                    l += 1\n                else:\n                    r -= 1\n        return closest"}, {"task_id": "3sum-closest", "completion": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        closest = nums[0] + nums[1] + nums[2]\n        \n        for i in range(len(nums)-2):\n            l = i + 1\n            r = len(nums) - 1\n            \n            while l < r:\n                sum = nums[i] + nums[l] + nums[r]\n                if abs(target - sum) < abs(target - closest):\n                    closest = sum\n                if sum < target:\n                    l += 1\n                else:\n                    r -= 1\n        return closest"}], "maximum-depth-of-binary-tree": [{"task_id": "maximum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))"}, {"task_id": "maximum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))"}, {"task_id": "maximum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))"}, {"task_id": "maximum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))"}, {"task_id": "maximum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))"}], "intersection-of-two-arrays-ii": [{"task_id": "intersection-of-two-arrays-ii", "completion": "class Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(nums1) > len(nums2):\n            return self.intersect(nums2, nums1)\n        \n        nums1.sort()\n        nums2.sort()\n        \n        i = 0\n        j = 0\n        res = []\n        \n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] < nums2[j]:\n                i += 1\n            elif nums1[i] > nums2[j]:\n                j += 1\n            else:\n                res.append(nums1[i])\n                i += 1\n                j += 1\n        \n        return res"}, {"task_id": "intersection-of-two-arrays-ii", "completion": "class Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(nums1) > len(nums2):\n            return self.intersect(nums2, nums1)\n        \n        nums1.sort()\n        nums2.sort()\n        \n        i = 0\n        j = 0\n        res = []\n        \n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] < nums2[j]:\n                i += 1\n            elif nums1[i] > nums2[j]:\n                j += 1\n            else:\n                res.append(nums1[i])\n                i += 1\n                j += 1\n        \n        return res"}, {"task_id": "intersection-of-two-arrays-ii", "completion": "class Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(nums1) > len(nums2):\n            return self.intersect(nums2, nums1)\n        \n        nums1.sort()\n        nums2.sort()\n        \n        i = 0\n        j = 0\n        res = []\n        \n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] < nums2[j]:\n                i += 1\n            elif nums1[i] > nums2[j]:\n                j += 1\n            else:\n                res.append(nums1[i])\n                i += 1\n                j += 1\n        \n        return res"}, {"task_id": "intersection-of-two-arrays-ii", "completion": "class Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(nums1) > len(nums2):\n            return self.intersect(nums2, nums1)\n        \n        nums1.sort()\n        nums2.sort()\n        \n        i = 0\n        j = 0\n        res = []\n        \n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] == nums2[j]:\n                res.append(nums1[i])\n                i += 1\n                j += 1\n            elif nums1[i] < nums2[j]:\n                i += 1\n            else:\n                j += 1\n        \n        return res"}, {"task_id": "intersection-of-two-arrays-ii", "completion": "class Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        if len(nums1) > len(nums2):\n            return self.intersect(nums2, nums1)\n        \n        nums1.sort()\n        nums2.sort()\n        \n        i = 0\n        j = 0\n        res = []\n        \n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] < nums2[j]:\n                i += 1\n            elif nums1[i] > nums2[j]:\n                j += 1\n            else:\n                res.append(nums1[i])\n                i += 1\n                j += 1\n                \n        return res"}], "minimum-absolute-difference-in-bst": [{"task_id": "minimum-absolute-difference-in-bst", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def inorder(root):\n            if root:\n                inorder(root.left)\n                self.min_diff = min(self.min_diff, root.val - self.prev)\n                self.prev = root.val\n                inorder(root.right)\n                \n        self.min_diff = float('inf')\n        self.prev = -float('inf')\n        inorder(root)\n        return self.min_diff"}, {"task_id": "minimum-absolute-difference-in-bst", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def inorder(root):\n            if root:\n                inorder(root.left)\n                self.min_diff = min(self.min_diff, root.val - self.prev)\n                self.prev = root.val\n                inorder(root.right)\n                \n        self.min_diff = float('inf')\n        self.prev = -float('inf')\n        inorder(root)\n        return self.min_diff"}, {"task_id": "minimum-absolute-difference-in-bst", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def inorder(root):\n            if root:\n                inorder(root.left)\n                self.min_diff = min(self.min_diff, root.val - self.prev)\n                self.prev = root.val\n                inorder(root.right)\n        \n        self.min_diff = float('inf')\n        self.prev = -float('inf')\n        inorder(root)\n        return self.min_diff"}, {"task_id": "minimum-absolute-difference-in-bst", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def inorder(root):\n            if root:\n                inorder(root.left)\n                self.min_diff = min(self.min_diff, root.val - self.prev)\n                self.prev = root.val\n                inorder(root.right)\n        \n        self.min_diff = float('inf')\n        self.prev = -float('inf')\n        inorder(root)\n        return self.min_diff"}, {"task_id": "minimum-absolute-difference-in-bst", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def inorder(root):\n            if root:\n                inorder(root.left)\n                self.min_diff = min(self.min_diff, root.val - self.prev)\n                self.prev = root.val\n                inorder(root.right)\n                \n        self.min_diff = float('inf')\n        self.prev = -float('inf')\n        inorder(root)\n        return self.min_diff"}], "find-mode-in-binary-search-tree": [{"task_id": "find-mode-in-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        def dfs(root):\n            if not root:\n                return []\n            return [root.val] + dfs(root.left) + dfs(root.right)\n        \n        def count(nums):\n            if not nums:\n                return []\n            c = collections.Counter(nums)\n            return [k for k, v in c.items() if v == max(c.values())]\n        \n        return count(dfs(root))"}, {"task_id": "find-mode-in-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        def dfs(root):\n            if not root:\n                return []\n            return [root.val] + dfs(root.left) + dfs(root.right)\n        \n        def count(nums):\n            if not nums:\n                return []\n            count = {}\n            for num in nums:\n                if num not in count:\n                    count[num] = 0\n                count[num] += 1\n            return [(v, k) for k, v in count.items()]\n        \n        nums = dfs(root)\n        counts = count(nums)\n        if not counts:\n            return []\n        max_count = max(counts, key=lambda x: x[0])[0]\n        return [c[1] for c in counts if c[0] == max_count]"}, {"task_id": "find-mode-in-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        def dfs(root):\n            if not root:\n                return []\n            return dfs(root.left) + [root.val] + dfs(root.right)\n        \n        def count(nums):\n            if not nums:\n                return []\n            c = collections.Counter(nums)\n            return [k for k, v in c.items() if v == max(c.values())]\n        \n        return count(dfs(root))"}, {"task_id": "find-mode-in-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        def dfs(root):\n            if not root:\n                return []\n            return [root.val] + dfs(root.left) + dfs(root.right)\n        \n        def count(nums):\n            if not nums:\n                return []\n            count = {}\n            for num in nums:\n                if num not in count:\n                    count[num] = 0\n                count[num] += 1\n            return [(v, k) for k, v in count.items()]\n        \n        nums = dfs(root)\n        counts = count(nums)\n        if not counts:\n            return []\n        max_count = max(counts, key=lambda x: x[0])[0]\n        return [c[1] for c in counts if c[0] == max_count]"}, {"task_id": "find-mode-in-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        def dfs(root):\n            if not root:\n                return []\n            return dfs(root.left) + [root.val] + dfs(root.right)\n        \n        def count(nums):\n            if not nums:\n                return []\n            max_count = 0\n            max_num = nums[0]\n            count_dict = {}\n            for num in nums:\n                if num in count_dict:\n                    count_dict[num] += 1\n                else:\n                    count_dict[num] = 1\n                if count_dict[num] > max_count:\n                    max_count = count_dict[num]\n                    max_num = num\n            return [max_num] if max_count == 1 else [num for num in count_dict if count_dict[num] == max_count]\n        \n        return count(dfs(root))"}], "find-the-index-of-the-first-occurrence-in-a-string": [{"task_id": "find-the-index-of-the-first-occurrence-in-a-string", "completion": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        \n        if len(needle) == 0:\n            return 0\n        \n        for i in range(len(haystack)):\n            if haystack[i:i+len(needle)] == needle:\n                return i\n        \n        return -1"}, {"task_id": "find-the-index-of-the-first-occurrence-in-a-string", "completion": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        \n        if len(needle) == 0:\n            return 0\n        \n        for i in range(len(haystack)):\n            if haystack[i:i+len(needle)] == needle:\n                return i\n        \n        return -1"}, {"task_id": "find-the-index-of-the-first-occurrence-in-a-string", "completion": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        \n        if len(needle) == 0:\n            return 0\n        \n        for i in range(len(haystack)):\n            if haystack[i:i+len(needle)] == needle:\n                return i\n        \n        return -1"}, {"task_id": "find-the-index-of-the-first-occurrence-in-a-string", "completion": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        \n        if len(needle) == 0:\n            return 0\n        \n        if len(haystack) == 0:\n            return -1\n        \n        if len(haystack) < len(needle):\n            return -1\n        \n        for i in range(len(haystack) - len(needle) + 1):\n            if haystack[i:i+len(needle)] == needle:\n                return i\n        \n        return -1"}, {"task_id": "find-the-index-of-the-first-occurrence-in-a-string", "completion": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        \n        if len(needle) == 0:\n            return 0\n        \n        for i in range(len(haystack)):\n            if haystack[i:i+len(needle)] == needle:\n                return i\n        \n        return -1"}], "strong-password-checker": [{"task_id": "strong-password-checker", "completion": "class Solution(object):\n    def strongPasswordChecker(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first 3 repeating characters\n        # 3. replace the first 3 repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the"}, {"task_id": "strong-password-checker", "completion": "class Solution(object):\n    def strongPasswordChecker(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. check the length of password\n        # 2. check the length of password\n        # 3. check the length of password\n        # 4. check the length of password\n        # 5. check the length of password\n        # 6. check the length of password\n        # 7. check the length of password\n        # 8. check the length of password\n        # 9. check the length of password\n        # 10. check the length of password\n        # 11. check the length of password\n        # 12. check the length of password\n        # 13. check the length of password\n        # 14. check the length of password\n        # 15. check the length of password\n        # 16. check the length of password\n        # 17. check the length of password\n        # 18. check the length of password\n        # 19. check the length of password\n        # 20. check the length of password\n        # 21. check the length of password\n        # 22. check the length of password\n        # 23. check the length of password\n        # 24. check the length of password\n        # 25. check the length of password\n        # 26. check the length of password\n        # 27. check the length of password\n        # 28. check the length of password\n        # 29. check the length of password\n        # 30. check the length of password\n        # 31. check the length of password\n        # 32. check the length of password\n        # 33. check the length of password\n        # 34. check the length of password\n        # 35. check the length of password\n        # 36. check the length of password\n        # 37. check the length of password\n        # 38. check the length of password\n        # 39. check the length of password\n        # 40. check the length of password\n        # 41. check the length of password\n        # 42. check the length of password\n        # 43. check the length of password\n        # 44. check the length of password\n        # 45. check the length of password\n        # 46. check the length of password\n        # 47. check the length of password\n        # 48. check the length of password\n        # 49. check the length of password\n        # 50. check the length of password\n        # 51. check the length of password\n        # 52. check the length of password\n        # 53. check the length of password\n        # 54. check the length of password\n        # 55. check the length of password\n        # 56. check the length of password\n        # 57. check the length of password\n        # 58. check the length of password\n        # 59. check the length of password\n        # 60. check the length of password\n        # 61. check the length of password\n        # 62. check the length of password\n        # 63. check the length of password\n        # 64. check the length of password\n        # 65. check the length of password\n        # 66. check the length of password\n        # 67. check the length of password\n        # 68. check the length of password\n        # 69. check the length of password\n        # 70. check the length of password\n        # 71. check the length of password\n        # 72. check the length of password\n        # 73. check the length of password\n        # 74. check the length of password\n        # 75. check the length of password\n        # 76. check the length of password\n        # 77. check the length of password\n        # 78. check the length of password\n        # 79. check the length of password\n        # 80. check the length of password\n        # 81. check the length of password\n        # 82. check the length of password\n        # 83. check the length of password\n        # 84. check the length of password\n        # 85. check the length of password\n        # 86. check the length of password"}, {"task_id": "strong-password-checker", "completion": "class Solution(object):\n    def strongPasswordChecker(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with a character\n        # 4. repeat the above steps until password is strong\n        \n        # 1. check if password is strong\n        # 2. if not, find the first three repeating characters\n        # 3. replace the first three repeating characters with a character\n        # 4. repeat the above steps until password is strong"}, {"task_id": "strong-password-checker", "completion": "class Solution(object):\n    def strongPasswordChecker(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. check the length of password\n        # 2. check the length of password\n        # 3. check the length of password\n        # 4. check the length of password\n        # 5. check the length of password\n        # 6. check the length of password\n        # 7. check the length of password\n        # 8. check the length of password\n        # 9. check the length of password\n        # 10. check the length of password\n        # 11. check the length of password\n        # 12. check the length of password\n        # 13. check the length of password\n        # 14. check the length of password\n        # 15. check the length of password\n        # 16. check the length of password\n        # 17. check the length of password\n        # 18. check the length of password\n        # 19. check the length of password\n        # 20. check the length of password\n        # 21. check the length of password\n        # 22. check the length of password\n        # 23. check the length of password\n        # 24. check the length of password\n        # 25. check the length of password\n        # 26. check the length of password\n        # 27. check the length of password\n        # 28. check the length of password\n        # 29. check the length of password\n        # 30. check the length of password\n        # 31. check the length of password\n        # 32. check the length of password\n        # 33. check the length of password\n        # 34. check the length of password\n        # 35. check the length of password\n        # 36. check the length of password\n        # 37. check the length of password\n        # 38. check the length of password\n        # 39. check the length of password\n        # 40. check the length of password\n        # 41. check the length of password\n        # 42. check the length of password\n        # 43. check the length of password\n        # 44. check the length of password\n        # 45. check the length of password\n        # 46. check the length of password\n        # 47. check the length of password\n        # 48. check the length of password\n        # 49. check the length of password\n        # 50. check the length of password\n        # 51. check the length of password\n        # 52. check the length of password\n        # 53. check the length of password\n        # 54. check the length of password\n        # 55. check the length of password\n        # 56. check the length of password\n        # 57. check the length of password\n        # 58. check the length of password\n        # 59. check the length of password\n        # 60. check the length of password\n        # 61. check the length of password\n        # 62. check the length of password\n        # 63. check the length of password\n        # 64. check the length of password\n        # 65. check the length of password\n        # 66. check the length of password\n        # 67. check the length of password\n        # 68. check the length of password\n        # 69. check the length of password\n        # 70. check the length of password\n        # 71. check the length of password\n        # 72. check the length of password\n        # 73. check the length of password\n        # 74. check the length of password\n        # 75. check the length of password\n        # 76. check the length of password\n        # 77. check the length of password\n        # 78. check the length of password\n        # 79. check the length of password\n        # 80. check the length of password\n        # 81. check the length of password\n        # 82. check the length of password\n        # 83. check the length of password\n        # 84. check the length of password\n        # 85. check the length of password\n        # 86. check the length of password"}, {"task_id": "strong-password-checker", "completion": "class Solution(object):\n    def strongPasswordChecker(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. check the length of password\n        if len(password) < 6 or len(password) > 20:\n            return 5\n        \n        # 2. check the password contains at least one lowercase letter, at least one uppercase letter, and at least one digit\n        if not any(c.islower() for c in password) or not any(c.isupper() for c in password) or not any(c.isdigit() for c in password):\n            return 5\n        \n        # 3. check the password does not contain three repeating characters in a row (i.e., \"Baaabb0\" is weak, but \"Baaba0\" is strong).\n        # 3.1 check the length of password\n        if len(password) < 3:\n            return 5\n        \n        # 3.2 check the password contains three repeating characters in a row\n        for i in range(len(password)-2):\n            if password[i] == password[i+1] == password[i+2]:\n                return 5\n        \n        # 4. check the password contains at least one lowercase letter, at least one uppercase letter, and at least one digit\n        if not any(c.islower() for c in password) or not any(c.isupper() for c in password) or not any(c.isdigit() for c in password):\n            return 5\n        \n        # 5. check the password does not contain three repeating characters in a row (i.e., \"Baaabb0\" is weak, but \"Baaba0\" is strong).\n        # 5.1 check the length of password\n        if len(password) < 3:\n            return 5\n        \n        # 5.2 check the password contains three repeating characters in a row\n        for i in range(len(password)-2):\n            if password[i] == password[i+1] == password[i+2]:\n                return 5\n        \n        # 6. check the password contains at least one lowercase letter, at least one uppercase letter, and at least one digit\n        if not any(c.islower() for c in password) or not any(c.isupper() for c in password) or not any(c.isdigit() for c in password):\n            return 5\n        \n        # 7. check the password does not contain three repeating characters in a row (i.e., \"Baaabb0\" is weak, but \"Baaba0\" is strong).\n        # 7.1 check the length of password\n        if len(password) < 3:\n            return 5\n        \n        # 7.2 check the password contains three repeating characters in a row\n        for i in range(len(password)-2):\n            if password[i] == password[i+1] == password[i+2]:\n                return 5\n        \n        # 8. check the password contains at least one lowercase letter, at least one uppercase letter, and at least one digit\n        if not any(c.islower() for c in password) or not any(c.isupper() for c in password) or not any(c.isdigit() for c in password):\n            return 5\n        \n        # 9. check the password does not contain three repeating characters in a row (i.e., \"Baaabb0\" is weak, but \"Baaba0\" is strong).\n        # 9.1 check the length of password\n        if len(password) < 3:\n            return 5\n        \n        # 9.2 check the password contains three repeating characters in a row\n        for i in range(len(password)-2):\n            if password[i] == password[i+1] == password[i+2]:\n                return 5\n        \n        # 10. check the password contains at least one lowercase letter, at least one uppercase letter, and at least one digit\n        if not any(c.islower() for c in password) or not any(c.isupper() for c in password) or not any(c.isdigit() for c in password):\n            return 5\n        \n        # 11. check the password does not contain three repeating characters in a row (i.e., \"Baaabb0\" is weak, but \"Baaba0\" is strong).\n        # 11.1 check the length of password\n        if len(password"}], "factorial-trailing-zeroes": [{"task_id": "factorial-trailing-zeroes", "completion": "class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        \n        count = 0\n        while n > 0:\n            n = n // 5\n            count += n\n        return count"}, {"task_id": "factorial-trailing-zeroes", "completion": "class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n < 5:\n            return 0\n        \n        count = 0\n        while n >= 5:\n            n = n // 5\n            count += n\n        return count"}, {"task_id": "factorial-trailing-zeroes", "completion": "class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        \n        count = 0\n        while n > 0:\n            n = n // 5\n            count += n\n        return count"}, {"task_id": "factorial-trailing-zeroes", "completion": "class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        \n        count = 0\n        while n > 0:\n            n = n // 5\n            count += n\n        return count"}, {"task_id": "factorial-trailing-zeroes", "completion": "class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        \n        count = 0\n        while n > 0:\n            n = n // 5\n            count += n\n        return count"}], "zigzag-conversion": [{"task_id": "zigzag-conversion", "completion": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        \n        if numRows == 1:\n            return s\n        \n        res = [\"\" for i in range(numRows)]\n        i = 0\n        down = True\n        \n        for c in s:\n            res[i] += c\n            if i == numRows - 1:\n                down = False\n            elif i == 0:\n                down = True\n            if down:\n                i += 1\n            else:\n                i -= 1\n        \n        return \"\".join(res)"}, {"task_id": "zigzag-conversion", "completion": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        \n        if numRows == 1:\n            return s\n        \n        res = [\"\" for i in range(numRows)]\n        currRow = 0\n        goingDown = False\n        \n        for c in s:\n            res[currRow] += c\n            if currRow == 0 or currRow == numRows - 1:\n                goingDown = not goingDown\n            currRow += 1 if goingDown else -1\n        \n        return \"\".join(res)"}, {"task_id": "zigzag-conversion", "completion": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        \n        if numRows == 1:\n            return s\n        \n        res = [\"\" for i in range(numRows)]\n        curRow = 0\n        goingDown = False\n        \n        for c in s:\n            res[curRow] += c\n            if curRow == 0 or curRow == numRows - 1:\n                goingDown = not goingDown\n            curRow += 1 if goingDown else -1\n        \n        return \"\".join(res)"}, {"task_id": "zigzag-conversion", "completion": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        \n        if numRows == 1:\n            return s\n        \n        res = [\"\" for i in range(numRows)]\n        curRow = 0\n        goingDown = False\n        \n        for c in s:\n            res[curRow] += c\n            if curRow == 0 or curRow == numRows - 1:\n                goingDown = not goingDown\n            curRow += 1 if goingDown else -1\n        \n        return \"\".join(res)"}, {"task_id": "zigzag-conversion", "completion": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        \n        if numRows == 1:\n            return s\n        \n        res = [\"\" for i in range(numRows)]\n        i = 0\n        down = True\n        for c in s:\n            res[i] += c\n            if i == numRows - 1:\n                down = False\n            elif i == 0:\n                down = True\n            if down:\n                i += 1\n            else:\n                i -= 1\n        return \"\".join(res)"}], "trapping-rain-water": [{"task_id": "trapping-rain-water", "completion": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. find the max height\n        max_height = max(height)\n        \n        # 2. find the index of max height\n        max_height_index = height.index(max_height)\n        \n        # 3. find the left and right max height\n        left_max_height = max(height[:max_height_index])\n        right_max_height = max(height[max_height_index:])\n        \n        # 4. find the water\n        water = 0\n        for i in range(max_height_index):\n            water += min(left_max_height, right_max_height) - height[i]\n        \n        for i in range(len(height)-1, max_height_index, -1):\n            water += min(left_max_height, right_max_height) - height[i]\n        \n        return water"}, {"task_id": "trapping-rain-water", "completion": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Brute force\n        ## Time complexity: O(n^2)\n        ## Space complexity: O(1)\n        ## TLE\n        ## 2022-03-24\n        ## 100%\n        \n        ## 2022-03-24\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%\n        ## 100%"}, {"task_id": "trapping-rain-water", "completion": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc815\ub82c\n        # 2. \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \ucc3e\uc544\uc11c \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \ucc3e\uc544\uc11c \ucc28\uc774\ub9cc\ud07c \ub354\ud558\uae30\n        # 3. \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \ucc3e\uc544\uc11c \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \ucc3e\uc544\uc11c \ucc28\uc774\ub9cc\ud07c \ub354\ud558\uae30\n        # 4. \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \ucc3e\uc544\uc11c \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \ucc3e\uc544\uc11c \ucc28\uc774\ub9cc\ud07c \ub354\ud558\uae30\n        # 5. \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \ucc3e\uc544\uc11c \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \ucc3e\uc544\uc11c \ucc28\uc774\ub9cc\ud07c \ub354\ud558\uae30\n        # 6. \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \ucc3e\uc544\uc11c \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \ucc3e\uc544\uc11c \ucc28\uc774\ub9cc\ud07c \ub354\ud558\uae30\n        # 7. \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \ucc3e\uc544\uc11c \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \ucc3e\uc544\uc11c \ucc28\uc774\ub9cc\ud07c \ub354\ud558\uae30\n        # 8. \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \ucc3e\uc544\uc11c \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \ucc3e\uc544\uc11c \ucc28\uc774\ub9cc\ud07c \ub354\ud558\uae30\n        # 9. \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \ucc3e\uc544\uc11c \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192\uc740 \uac12\uc744 \ucc3e\uc544\uc11c \ucc28\uc774\ub9cc\ud07c \ub354\ud558\uae30\n        # 10. \uc67c\ucabd \uc624\ub978\ucabd \uc911 \ub354 \ub192"}, {"task_id": "trapping-rain-water", "completion": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. find the max height\n        max_height = max(height)\n        \n        # 2. find the index of max height\n        max_height_index = height.index(max_height)\n        \n        # 3. find the left and right max height\n        left_max_height = max(height[:max_height_index])\n        right_max_height = max(height[max_height_index:])\n        \n        # 4. find the water\n        water = 0\n        for i in range(max_height_index):\n            water += min(left_max_height, right_max_height) - height[i]\n        \n        for i in range(len(height)-1, max_height_index, -1):\n            water += min(left_max_height, right_max_height) - height[i]\n        \n        return water"}, {"task_id": "trapping-rain-water", "completion": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Brute force\n        ## Time complexity: O(n^2)\n        ## Space complexity: O(1)\n        ## TLE\n        ## 2022-09-24\n        ## 1. find the max height\n        ## 2. find the left and right max height\n        ## 3. find the water\n        ## 4. update the left and right max height\n        ## 5. repeat 2,3,4\n        ## 6. return the sum\n        \n        ## 2022-09-24\n        ## 1. find the max height\n        ## 2. find the left and right max height\n        ## 3. find the water\n        ## 4. update the left and right max height\n        ## 5. repeat 2,3,4\n        ## 6. return the sum\n        \n        ## 2022-09-24\n        ## 1. find the max height\n        ## 2. find the left and right max height\n        ## 3. find the water\n        ## 4. update the left and right max height\n        ## 5. repeat 2,3,4\n        ## 6. return the sum\n        \n        ## 2022-09-24\n        ## 1. find the max height\n        ## 2. find the left and right max height\n        ## 3. find the water\n        ## 4. update the left and right max height\n        ## 5. repeat 2,3,4\n        ## 6. return the sum\n        \n        ## 2022-09-24\n        ## 1. find the max height\n        ## 2. find the left and right max height\n        ## 3. find the water\n        ## 4. update the left and right max height\n        ## 5. repeat 2,3,4\n        ## 6. return the sum\n        \n        ## 2022-09-24\n        ## 1. find the max height\n        ## 2. find the left and right max height\n        ## 3. find the water\n        ## 4. update the left and right max height\n        ## 5. repeat 2,3,4\n        ## 6. return the sum\n        \n        ## 2022-09-24\n        ## 1. find the max height\n        ## 2. find the left and right max height\n        ## 3. find the water\n        ## 4. update the left and right max height\n        ## 5. repeat 2,3,4\n        ## 6. return the sum\n        \n        ## 2022-09-24\n        ## 1. find the max height\n        ## 2. find the left and right max height\n        ## 3. find the water\n        ## 4. update the left and right max height\n        ## 5. repeat 2,3,4\n        ## 6. return the sum\n        \n        ## 2022-09-24\n        ## 1. find the max height\n        ## 2. find the left and right max height\n        ## 3. find the water\n        ## 4. update the left and right max height\n        ## 5. repeat 2,3,4\n        ## 6. return the sum\n        \n        ## 2022-09-24\n        ## 1. find the max height\n        ## 2. find the left and right max height\n        ## 3. find the water\n        ## 4. update the left and right max height\n        ## 5. repeat 2,3,4\n        ## 6. return the sum\n        \n        ## 2022-09-24\n        ## 1. find the max height\n        ## 2. find the left and right max height\n        ## 3. find the water\n        ## 4. update the left and right max height\n        ## 5. repeat 2,3,4\n        ## 6. return the sum"}], "find-all-numbers-disappeared-in-an-array": [{"task_id": "find-all-numbers-disappeared-in-an-array", "completion": "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        ## O(n) time and O(1) space\n        ## 1. create a list of all numbers from 1 to n\n        ## 2. iterate through the list and mark the numbers as visited\n        ## 3. return the list of numbers that are not visited\n        \n        ## O(n) time and O(1) space\n        ## 1. create a list of all numbers from 1 to n\n        ## 2. iterate through the list and mark the numbers as visited\n        ## 3. return the list of numbers that are not visited\n        \n        ## O(n) time and O(1) space\n        ## 1. create a list of all numbers from 1 to n\n        ## 2. iterate through the list and mark the numbers as visited\n        ## 3. return the list of numbers that are not visited\n        \n        ## O(n) time and O(1) space\n        ## 1. create a list of all numbers from 1 to n\n        ## 2. iterate through the list and mark the numbers as visited\n        ## 3. return the list of numbers that are not visited\n        \n        ## O(n) time and O(1) space\n        ## 1. create a list of all numbers from 1 to n\n        ## 2. iterate through the list and mark the numbers as visited\n        ## 3. return the list of numbers that are not visited\n        \n        ## O(n) time and O(1) space\n        ## 1. create a list of all numbers from 1 to n\n        ## 2. iterate through the list and mark the numbers as visited\n        ## 3. return the list of numbers that are not visited\n        \n        ## O(n) time and O(1) space\n        ## 1. create a list of all numbers from 1 to n\n        ## 2. iterate through the list and mark the numbers as visited\n        ## 3. return the list of numbers that are not visited\n        \n        ## O(n) time and O(1) space\n        ## 1. create a list of all numbers from 1 to n\n        ## 2. iterate through the list and mark the numbers as visited\n        ## 3. return the list of numbers that are not visited\n        \n        ## O(n) time and O(1) space\n        ## 1. create a list of all numbers from 1 to n\n        ## 2. iterate through the list and mark the numbers as visited\n        ## 3. return the list of numbers that are not visited\n        \n        ## O(n) time and O(1) space\n        ## 1. create a list of all numbers from 1 to n\n        ## 2. iterate through the list and mark the numbers as visited\n        ## 3. return the list of numbers that are not visited\n        \n        ## O(n) time and O(1) space\n        ## 1. create a list of all numbers from 1 to n\n        ## 2. iterate through the list and mark the numbers as visited\n        ## 3. return the list of numbers that are not visited\n        \n        ## O(n) time and O(1) space\n        ## 1. create a list of all numbers from 1 to n\n        ## 2. iterate through the list and mark the numbers as visited\n        ## 3. return the list of numbers that are not visited\n        \n        ## O(n) time and O(1) space\n        ## 1. create a list of all numbers from 1 to n\n        ## 2. iterate through the list and mark the numbers as visited\n        ## 3. return the list of numbers that are not visited\n        \n        ## O(n) time and O(1) space\n        ## 1. create a list of all numbers from 1 to n\n        ## 2. iterate through the list and mark the numbers as visited\n        ## 3. return the list of numbers that are not visited\n        \n        ## O(n) time and O(1) space\n        ## 1. create a list of all numbers from 1 to n\n        ## 2. iterate through the list and mark the numbers as visited\n        ## 3. return"}, {"task_id": "find-all-numbers-disappeared-in-an-array", "completion": "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        ## O(n) space\n        ## O(n) time\n        ## 1 <= n <= 10\u2075\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <="}, {"task_id": "find-all-numbers-disappeared-in-an-array", "completion": "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        ## O(n) space\n        ## O(n) time\n        ## 1 <= n <= 10\u2075\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <= n\n        ## 1 <= nums[i] <="}, {"task_id": "find-all-numbers-disappeared-in-an-array", "completion": "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        ## O(n) time and O(1) space\n        ## 1. create a list of all numbers from 1 to n\n        ## 2. iterate through the list and mark the number as negative\n        ## 3. iterate through the list again and add the numbers that are still positive to the result\n        \n        n = len(nums)\n        result = []\n        for i in range(1, n+1):\n            nums[abs(nums[i-1])-1] = -abs(nums[abs(nums[i-1])-1])\n        for i in range(n):\n            if nums[i] > 0:\n                result.append(i+1)\n        return result"}, {"task_id": "find-all-numbers-disappeared-in-an-array", "completion": "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        ## O(n) time and O(1) space\n        ## 1. create a list of all numbers from 1 to n\n        ## 2. iterate through the list of all numbers and mark the number as negative if it is in the list\n        ## 3. iterate through the list again and return the list of all numbers that are still positive\n        \n        n = len(nums)\n        nums_list = [0] * (n+1)\n        \n        for num in nums:\n            nums_list[num] = -1\n            \n        for i in range(1, n+1):\n            if nums_list[i] == 0:\n                nums_list[i] = -1\n                \n        return [i for i in range(1, n+1) if nums_list[i] > 0]"}], "count-of-smaller-numbers-after-self": [{"task_id": "count-of-smaller-numbers-after-self", "completion": "class Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        def mergeSort(nums):\n            if len(nums) <= 1:\n                return nums\n            \n            mid = len(nums) // 2\n            left = mergeSort(nums[:mid])\n            right = mergeSort(nums[mid:])\n            \n            return merge(left, right)\n        \n        def merge(left, right):\n            result = []\n            i = j = 0\n            \n            while i < len(left) and j < len(right):\n                if left[i][0] <= right[j][0]:\n                    result.append(left[i])\n                    i += 1\n                else:\n                    result.append(right[j])\n                    j += 1\n            \n            while i < len(left):\n                result.append(left[i])\n                i += 1\n            \n            while j < len(right):\n                result.append(right[j])\n                j += 1\n            \n            return result\n        \n        return [x[1] for x in mergeSort([(num, i) for i, num in enumerate(nums)])]"}, {"task_id": "count-of-smaller-numbers-after-self", "completion": "class Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        def mergeSort(nums):\n            if len(nums) <= 1:\n                return nums\n            mid = len(nums) // 2\n            left = mergeSort(nums[:mid])\n            right = mergeSort(nums[mid:])\n            return merge(left, right)\n        \n        def merge(left, right):\n            result = []\n            i = j = 0\n            while i < len(left) and j < len(right):\n                if left[i] <= right[j]:\n                    result.append(left[i])\n                    i += 1\n                else:\n                    result.append(right[j])\n                    j += 1\n            result += left[i:]\n            result += right[j:]\n            return result\n        \n        return [sum(num > nums[i] for num in nums[i+1:]) for i in range(len(nums)-1)]"}, {"task_id": "count-of-smaller-numbers-after-self", "completion": "class Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        def mergeSort(nums):\n            if len(nums) <= 1:\n                return nums\n            mid = len(nums) // 2\n            left = mergeSort(nums[:mid])\n            right = mergeSort(nums[mid:])\n            return merge(left, right)\n        \n        def merge(left, right):\n            result = []\n            i = j = 0\n            while i < len(left) and j < len(right):\n                if left[i] <= right[j]:\n                    result.append(left[i])\n                    i += 1\n                else:\n                    result.append(right[j])\n                    j += 1\n            result += left[i:]\n            result += right[j:]\n            return result\n        \n        return [sum(1 for x in nums[i+1:] if x < nums[i]) for i in range(len(nums))]"}, {"task_id": "count-of-smaller-numbers-after-self", "completion": "class Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        def mergeSort(nums):\n            if len(nums) <= 1:\n                return nums\n            \n            mid = len(nums) // 2\n            left = mergeSort(nums[:mid])\n            right = mergeSort(nums[mid:])\n            \n            return merge(left, right)\n        \n        def merge(left, right):\n            result = []\n            i = j = 0\n            \n            while i < len(left) and j < len(right):\n                if left[i][0] <= right[j][0]:\n                    result.append(left[i])\n                    i += 1\n                else:\n                    result.append(right[j])\n                    j += 1\n            \n            while i < len(left):\n                result.append(left[i])\n                i += 1\n            \n            while j < len(right):\n                result.append(right[j])\n                j += 1\n            \n            return result\n        \n        return [x[1] for x in mergeSort([(num, i) for i, num in enumerate(nums)])]"}, {"task_id": "count-of-smaller-numbers-after-self", "completion": "class Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        def mergeSort(nums):\n            if len(nums) <= 1:\n                return nums\n            mid = len(nums) // 2\n            left = mergeSort(nums[:mid])\n            right = mergeSort(nums[mid:])\n            return merge(left, right)\n        \n        def merge(left, right):\n            result = []\n            i = j = 0\n            while i < len(left) and j < len(right):\n                if left[i] <= right[j]:\n                    result.append(left[i])\n                    i += 1\n                else:\n                    result.append(right[j])\n                    j += 1\n            while i < len(left):\n                result.append(left[i])\n                i += 1\n            while j < len(right):\n                result.append(right[j])\n                j += 1\n            return result\n        \n        return [len(mergeSort(nums[i+1:])) for i in range(len(nums)-1)]"}], "set-intersection-size-at-least-two": [{"task_id": "set-intersection-size-at-least-two", "completion": "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        intervals.sort(key=lambda x: x[1])\n        ans = 0\n        for i in range(len(intervals)):\n            if i == 0:\n                ans += 2\n                continue\n            if intervals[i][0] > intervals[i-1][1]:\n                ans += 2\n            else:\n                ans += 1\n        return ans"}, {"task_id": "set-intersection-size-at-least-two", "completion": "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort the intervals by start\n        intervals.sort(key=lambda x: x[0])\n        \n        # initialize the result\n        res = 0\n        \n        # initialize the max end\n        max_end = -1\n        \n        # iterate over the intervals\n        for interval in intervals:\n            # if the current interval is not overlapping with the max end\n            if interval[0] > max_end:\n                # update the result\n                res += 2\n                # update the max end\n                max_end = interval[1]\n            # if the current interval is overlapping with the max end\n            else:\n                # update the result\n                res += 1\n                # update the max end\n                max_end = min(max_end, interval[1])\n        \n        # return the result\n        return res"}, {"task_id": "set-intersection-size-at-least-two", "completion": "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        intervals.sort(key=lambda x: x[1])\n        ans = 0\n        for i in range(len(intervals)):\n            if i == 0:\n                ans += 2\n                continue\n            if intervals[i][0] > intervals[i-1][1]:\n                ans += 2\n            else:\n                ans += 1\n        return ans"}, {"task_id": "set-intersection-size-at-least-two", "completion": "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort the intervals by start\n        intervals.sort(key=lambda x: x[0])\n        \n        # initialize the result\n        res = 0\n        \n        # initialize the set\n        s = set()\n        \n        # iterate over the intervals\n        for i in intervals:\n            # add the end of the interval to the set\n            s.add(i[1])\n            \n            # add 2 to the result\n            res += 2\n            \n            # iterate over the set\n            for j in s:\n                # if the end of the interval is less than the end of the set\n                if i[1] < j:\n                    # add 1 to the result\n                    res += 1\n                    # add the end of the interval to the set\n                    s.add(i[1])\n                    \n        # return the result\n        return res"}, {"task_id": "set-intersection-size-at-least-two", "completion": "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        intervals.sort(key=lambda x: x[1])\n        ans = 0\n        for i in range(len(intervals)):\n            if i == 0:\n                ans += 2\n                continue\n            if intervals[i][0] > intervals[i-1][1]:\n                ans += 2\n            else:\n                ans += 1\n        return ans"}], "symmetric-tree": [{"task_id": "symmetric-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def isMirror(left, right):\n            if left is None and right is None:\n                return True\n            if left is None or right is None:\n                return False\n            return left.val == right.val and isMirror(left.left, right.right) and isMirror(left.right, right.left)\n        \n        return isMirror(root, root)"}, {"task_id": "symmetric-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def isMirror(left, right):\n            if left is None and right is None:\n                return True\n            if left is None or right is None:\n                return False\n            return left.val == right.val and isMirror(left.left, right.right) and isMirror(left.right, right.left)\n        \n        return isMirror(root, root)"}, {"task_id": "symmetric-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def isMirror(left, right):\n            if left is None and right is None:\n                return True\n            if left is None or right is None:\n                return False\n            return left.val == right.val and isMirror(left.left, right.right) and isMirror(left.right, right.left)\n        \n        return isMirror(root, root)"}, {"task_id": "symmetric-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def isMirror(left, right):\n            if left is None and right is None:\n                return True\n            if left is None or right is None:\n                return False\n            return left.val == right.val and isMirror(left.left, right.right) and isMirror(left.right, right.left)\n        \n        return isMirror(root, root)"}, {"task_id": "symmetric-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def isMirror(left, right):\n            if left is None and right is None:\n                return True\n            if left is None or right is None:\n                return False\n            return left.val == right.val and isMirror(left.left, right.right) and isMirror(left.right, right.left)\n        \n        return isMirror(root, root)"}], "number-of-atoms": [{"task_id": "number-of-atoms", "completion": "class Solution(object):\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}, {"task_id": "number-of-atoms", "completion": "class Solution(object):\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}, {"task_id": "number-of-atoms", "completion": "class Solution(object):\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}, {"task_id": "number-of-atoms", "completion": "class Solution(object):\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}, {"task_id": "number-of-atoms", "completion": "class Solution(object):\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "binary-tree-preorder-traversal": [{"task_id": "binary-tree-preorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = [root]\n        result = []\n        \n        while stack:\n            node = stack.pop()\n            result.append(node.val)\n            \n            if node.right:\n                stack.append(node.right)\n                \n            if node.left:\n                stack.append(node.left)\n                \n        return result"}, {"task_id": "binary-tree-preorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = [root]\n        result = []\n        \n        while stack:\n            node = stack.pop()\n            result.append(node.val)\n            \n            if node.right:\n                stack.append(node.right)\n                \n            if node.left:\n                stack.append(node.left)\n                \n        return result"}, {"task_id": "binary-tree-preorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = [root]\n        result = []\n        \n        while stack:\n            node = stack.pop()\n            result.append(node.val)\n            \n            if node.right:\n                stack.append(node.right)\n                \n            if node.left:\n                stack.append(node.left)\n                \n        return result"}, {"task_id": "binary-tree-preorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = [root]\n        res = []\n        \n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            \n            if node.right:\n                stack.append(node.right)\n                \n            if node.left:\n                stack.append(node.left)\n                \n        return res"}, {"task_id": "binary-tree-preorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = [root]\n        res = []\n        \n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            \n            if node.right:\n                stack.append(node.right)\n                \n            if node.left:\n                stack.append(node.left)\n                \n        return res"}], "power-of-four": [{"task_id": "power-of-four", "completion": "class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 4 == 0:\n            n = n / 4\n            \n        return n == 1"}, {"task_id": "power-of-four", "completion": "class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 4 == 0:\n            n = n / 4\n        \n        return n == 1"}, {"task_id": "power-of-four", "completion": "class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 4 == 0:\n            n = n / 4\n        \n        return n == 1"}, {"task_id": "power-of-four", "completion": "class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 4 == 0:\n            n = n / 4\n        \n        return n == 1"}, {"task_id": "power-of-four", "completion": "class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 4 == 0:\n            n = n / 4\n            \n        return n == 1"}], "invert-binary-tree": [{"task_id": "invert-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        \n        if root is None:\n            return None\n        \n        temp = root.left\n        root.left = root.right\n        root.right = temp\n        \n        self.invertTree(root.left)\n        self.invertTree(root.right)\n        \n        return root"}, {"task_id": "invert-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        \n        if root:\n            root.left, root.right = root.right, root.left\n            self.invertTree(root.left)\n            self.invertTree(root.right)\n            \n        return root"}, {"task_id": "invert-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        \n        if root is None:\n            return None\n        \n        temp = root.left\n        root.left = root.right\n        root.right = temp\n        \n        self.invertTree(root.left)\n        self.invertTree(root.right)\n        \n        return root"}, {"task_id": "invert-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        \n        if root is None:\n            return None\n        \n        temp = root.left\n        root.left = root.right\n        root.right = temp\n        \n        self.invertTree(root.left)\n        self.invertTree(root.right)\n        \n        return root"}, {"task_id": "invert-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        \n        if root is None:\n            return None\n        \n        temp = root.left\n        root.left = root.right\n        root.right = temp\n        \n        self.invertTree(root.left)\n        self.invertTree(root.right)\n        \n        return root"}], "generate-parentheses": [{"task_id": "generate-parentheses", "completion": "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def generate(left, right, s, ans):\n            if left == 0 and right == 0:\n                ans.append(s)\n                return\n            if left > 0:\n                generate(left - 1, right, s + '(', ans)\n            if right > left:\n                generate(left, right - 1, s + ')', ans)\n        \n        ans = []\n        generate(n, n, '', ans)\n        return ans"}, {"task_id": "generate-parentheses", "completion": "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def backtrack(left, right, curr, res):\n            if left == right == n:\n                res.append(curr)\n                return\n            if left < n:\n                backtrack(left + 1, right, curr + '(', res)\n            if right < left:\n                backtrack(left, right + 1, curr + ')', res)\n        \n        res = []\n        backtrack(0, 0, '', res)\n        return res"}, {"task_id": "generate-parentheses", "completion": "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def backtrack(left, right, curr, res):\n            if left == right == n:\n                res.append(curr)\n                return\n            if left < n:\n                backtrack(left + 1, right, curr + '(', res)\n            if right < left:\n                backtrack(left, right + 1, curr + ')', res)\n        \n        res = []\n        backtrack(0, 0, '', res)\n        return res"}, {"task_id": "generate-parentheses", "completion": "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def generate(left, right, s, ans):\n            if left == 0 and right == 0:\n                ans.append(s)\n                return\n            if left > 0:\n                generate(left - 1, right, s + '(', ans)\n            if right > left:\n                generate(left, right - 1, s + ')', ans)\n        \n        ans = []\n        generate(n, n, '', ans)\n        return ans"}, {"task_id": "generate-parentheses", "completion": "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def backtrack(left, right, curr, res):\n            if left == right == n:\n                res.append(curr)\n                return\n            if left < n:\n                backtrack(left + 1, right, curr + '(', res)\n            if right < left:\n                backtrack(left, right + 1, curr + ')', res)\n        \n        res = []\n        backtrack(0, 0, '', res)\n        return res"}], "patching-array": [{"task_id": "patching-array", "completion": "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # edge case\n        if len(nums) == 0:\n            return 0\n        \n        # initialize\n        count = 0\n        i = 0\n        nums.append(n+1)\n        \n        # loop\n        while i < len(nums):\n            if nums[i] <= n:\n                n = n - nums[i]\n                i += 1\n            else:\n                if i > 0:\n                    nums.insert(i, nums[i-1] + nums[i-1])\n                    count += 1\n                else:\n                    nums.insert(i, nums[i] + nums[i])\n                    count += 1\n                    \n        return count"}, {"task_id": "patching-array", "completion": "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # edge case\n        if len(nums) == 0:\n            return 0\n        \n        # initialize\n        count = 0\n        i = 0\n        nums.append(n+1)\n        \n        # iterate\n        while i < len(nums)-1:\n            if nums[i] <= n:\n                n = n - nums[i]\n                i += 1\n            else:\n                n = n + nums[i]\n                count += 1\n        \n        return count"}, {"task_id": "patching-array", "completion": "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # edge case\n        if len(nums) == 0:\n            return 0\n        \n        # initialize\n        count = 0\n        i = 0\n        nums.append(n+1)\n        \n        # iterate\n        while i < len(nums)-1:\n            if nums[i] <= n:\n                n = n - nums[i]\n                i += 1\n            else:\n                n = n + nums[i]\n                count += 1\n        \n        return count"}, {"task_id": "patching-array", "completion": "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # edge case\n        if len(nums) == 0:\n            return 0\n        \n        # initialize\n        count = 0\n        i = 0\n        nums.append(n+1)\n        \n        # iterate\n        while i < len(nums):\n            if nums[i] <= n:\n                n = n - nums[i]\n                i += 1\n            else:\n                if i > 0:\n                    nums.insert(i, nums[i-1]*2)\n                    count += 1\n                else:\n                    nums.insert(i, nums[i]*2)\n                    count += 1\n                    \n        return count"}, {"task_id": "patching-array", "completion": "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # edge case\n        if len(nums) == 0:\n            return 0\n        \n        # initialize\n        count = 0\n        i = 0\n        nums.append(n+1)\n        \n        # loop\n        while i < len(nums)-1:\n            if nums[i] <= n:\n                n = n - nums[i]\n                i += 1\n            else:\n                n = n + nums[i]\n                count += 1\n        \n        return count"}], "longest-valid-parentheses": [{"task_id": "longest-valid-parentheses", "completion": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud55c \ubc29\ubc95\n        # 2. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uc9c0 \uc54a\uace0 \uc9c1\uc811 \uad6c\ud604\ud55c \ubc29\ubc95\n        # 3. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uc9c0 \uc54a\uace0 \uc9c1\uc811 \uad6c\ud604\ud55c \ubc29\ubc95\n        # 4. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uc9c0 \uc54a\uace0 \uc9c1\uc811 \uad6c\ud604\ud55c \ubc29\ubc95\n        # 5. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uc9c0 \uc54a\uace0 \uc9c1\uc811 \uad6c\ud604\ud55c \ubc29\ubc95\n        # 6. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uc9c0 \uc54a\uace0 \uc9c1\uc811 \uad6c\ud604\ud55c \ubc29\ubc95\n        # 7. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uc9c0 \uc54a\uace0 \uc9c1\uc811 \uad6c\ud604\ud55c \ubc29\ubc95\n        # 8. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uc9c0 \uc54a\uace0 \uc9c1\uc811 \uad6c\ud604\ud55c \ubc29\ubc95\n        # 9. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uc9c0 \uc54a\uace0 \uc9c1\uc811 \uad6c\ud604\ud55c \ubc29\ubc95\n        # 10. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uc9c0 \uc54a\uace0 \uc9c1\uc811 \uad6c\ud604\ud55c \ubc29\ubc95\n        # 11. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uc9c0 \uc54a\uace0 \uc9c1\uc811 \uad6c\ud604\ud55c \ubc29\ubc95\n        # 12. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uc9c0 \uc54a\uace0 \uc9c1\uc811 \uad6c\ud604\ud55c \ubc29\ubc95\n        # 13. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uc9c0 \uc54a\uace0 \uc9c1\uc811 \uad6c\ud604\ud55c \ubc29\ubc95\n        # 14. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uc9c0 \uc54a\uace0 \uc9c1\uc811 \uad6c\ud604\ud55c \ubc29\ubc95\n        # 15. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uc9c0 \uc54a\uace0 \uc9c1\uc811 \uad6c\ud604\ud55c \ubc29\ubc95\n        # 16. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uc9c0 \uc54a\uace0 \uc9c1\uc811 \uad6c\ud604\ud55c \ubc29\ubc95\n        # 17. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uc9c0 \uc54a\uace0 \uc9c1\uc811 \uad6c\ud604\ud55c \ubc29\ubc95\n        # 18. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uc9c0 \uc54a\uace0 \uc9c1\ufffd"}, {"task_id": "longest-valid-parentheses", "completion": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud55c \ubc29\ubc95\n        # \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uc5ec \uc9dd\uc774 \ub9de\ub294 \uacbd\uc6b0 \uc81c\uac70\ud558\uace0 \uc9dd\uc774 \ub9de\uc9c0 \uc54a\ub294 \uacbd\uc6b0 \uc2a4\ud0dd\uc5d0 \ucd94\uac00\n        # \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\ud558\uba74 \ub41c\ub2e4.\n        # \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\ud558\uba74 \ub41c\ub2e4.\n        # \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\ud558\uba74 \ub41c\ub2e4.\n        # \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\ud558\uba74 \ub41c\ub2e4.\n        # \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\ud558\uba74 \ub41c\ub2e4.\n        # \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\ud558\uba74 \ub41c\ub2e4.\n        # \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\ud558\uba74 \ub41c\ub2e4.\n        # \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\ud558\uba74 \ub41c\ub2e4.\n        # \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\ud558\uba74 \ub41c\ub2e4.\n        # \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\ud558\uba74 \ub41c\ub2e4.\n        # \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\ud558\uba74 \ub41c\ub2e4.\n        # \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\ud558\uba74 \ub41c\ub2e4.\n        # \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\ud558\uba74 \ub41c\ub2e4.\n        # \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\ud558\uba74 \ub41c\ub2e4.\n        # \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\ud558\uba74 \ub41c\ub2e4.\n        # \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\ud558\uba74 \ub41c\ub2e4.\n        # \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\ud558\uba74 \ub41c\ub2e4.\n        # \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\ud558\uba74 \ub41c\ub2e4.\n        # \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\ud558\uba74 \ub41c\ub2e4.\n        # \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\ud558\uba74 \ub41c\ub2e4.\n        # \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ufffd"}, {"task_id": "longest-valid-parentheses", "completion": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud55c \ubc29\ubc95\n        # \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uba74 \uc2dc\uac04\ubcf5\uc7a1\ub3c4\ub294 O(n)\uc774 \ub418\uc9c0\ub9cc \uacf5\uac04\ubcf5\uc7a1\ub3c4\ub294 O(n)\uc774 \ub41c\ub2e4.\n        # \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uba74 \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \uc54c \uc218 \uc788\ub2e4.\n        # \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \uc54c\uace0 \uc788\uc73c\uba74 \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \uc54c \uc218 \uc788\ub2e4.\n        # \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \uc54c\uace0 \uc788\uc73c\uba74 \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \uc54c \uc218 \uc788\ub2e4.\n        # \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \uc54c\uace0 \uc788\uc73c\uba74 \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \uc54c \uc218 \uc788\ub2e4.\n        # \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \uc54c\uace0 \uc788\uc73c\uba74 \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \uc54c \uc218 \uc788\ub2e4.\n        # \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \uc54c\uace0 \uc788\uc73c\uba74 \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \uc54c \uc218 \uc788\ub2e4.\n        # \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \uc54c\uace0 \uc788\uc73c\uba74 \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \uc54c \uc218 \uc788\ub2e4.\n        # \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \uc54c\uace0 \uc788\uc73c\uba74 \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \uc54c \uc218 \uc788\ub2e4.\n        # \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \uc54c\uace0 \uc788\uc73c\uba74 \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \uc54c \uc218 \uc788\ub2e4.\n        # \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \uc54c\uace0 \uc788\uc73c\uba74 \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \uc54c \uc218 \uc788\ub2e4.\n        # \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \uc54c\uace0 \uc788\uc73c\uba74 \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \uc54c \uc218 \uc788\ub2e4.\n        # \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \uc54c\uace0 \uc788\uc73c\uba74 \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \uc54c \uc218 \uc788\ub2e4.\n        # \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \uc54c\uace0 \uc788\uc73c\uba74 \uc2a4\ud0dd\uc758 \ufffd"}, {"task_id": "longest-valid-parentheses", "completion": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uc5ec \uc9dd\uc774 \ub9de\ub294 \uacbd\uc6b0 \uc81c\uac70\ud558\uace0 \uc9dd\uc774 \ub9de\uc9c0 \uc54a\ub294 \uacbd\uc6b0 \uc800\uc7a5\n        # 2. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 3. \uc2a4\ud0dd\uc774 \ube44\uc5b4\uc788\ub294 \uacbd\uc6b0 0\uc744 \ubc18\ud658\n        \n        stack = []\n        max_len = 0\n        \n        for i in range(len(s)):\n            if s[i] == '(':\n                stack.append(i)\n            else:\n                if stack:\n                    stack.pop()\n                    if not stack:\n                        max_len = max(max_len, i+1)\n                    else:\n                        max_len = max(max_len, i-stack[-1])\n                else:\n                    stack.append(i)\n        \n        return max_len"}, {"task_id": "longest-valid-parentheses", "completion": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc2a4\ud0dd\uc744 \uc0ac\uc6a9\ud558\uc5ec \uc9dd\uc774 \ub9de\ub294 \uacbd\uc6b0 \uc81c\uac70\ud558\uace0 \uc9dd\uc774 \ub9de\uc9c0 \uc54a\ub294 \uacbd\uc6b0 \uc800\uc7a5\n        # 2. \uc2a4\ud0dd\uc758 \uae38\uc774\ub97c \ubc18\ud658\n        # 3. \uc2a4\ud0dd\uc774 \ube44\uc5b4\uc788\ub294 \uacbd\uc6b0 0\uc744 \ubc18\ud658\n        \n        stack = []\n        max_len = 0\n        \n        for i in range(len(s)):\n            if s[i] == '(':\n                stack.append(i)\n            else:\n                if stack:\n                    stack.pop()\n                    if not stack:\n                        max_len = max(max_len, i + 1)\n                    else:\n                        max_len = max(max_len, i - stack[-1])\n                else:\n                    stack.append(i)\n        \n        return max_len"}], "fraction-to-recurring-decimal": [{"task_id": "fraction-to-recurring-decimal", "completion": "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        \n        if numerator == 0:\n            return \"0\"\n        \n        if numerator < 0 and denominator > 0:\n            sign = -1\n        elif numerator > 0 and denominator < 0:\n            sign = 1\n        else:\n            sign = 1\n        \n        numerator = abs(numerator)\n        denominator = abs(denominator)\n        \n        quotient = numerator // denominator\n        remainder = numerator % denominator\n        \n        if remainder == 0:\n            return str(sign * quotient)\n        \n        remainder_dict = {}\n        remainder_dict[remainder] = len(remainder_dict)\n        \n        quotient_str = str(sign * quotient)\n        remainder_str = \"\"\n        \n        while remainder != 0:\n            remainder *= 10\n            quotient = remainder // denominator\n            remainder = remainder % denominator\n            \n            if remainder in remainder_dict:\n                remainder_str = \"(\" + remainder_str + \")\"\n                break\n            \n            remainder_dict[remainder] = len(remainder_dict)\n            remainder_str += str(quotient)\n        \n        return quotient_str + remainder_str"}, {"task_id": "fraction-to-recurring-decimal", "completion": "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        \n        if numerator == 0:\n            return \"0\"\n        \n        if denominator == 0:\n            return \"NaN\"\n        \n        if numerator < 0 and denominator > 0:\n            sign = -1\n        elif numerator > 0 and denominator < 0:\n            sign = 1\n        else:\n            sign = 1\n        \n        numerator = abs(numerator)\n        denominator = abs(denominator)\n        \n        quotient = numerator // denominator\n        remainder = numerator % denominator\n        \n        if remainder == 0:\n            return str(sign * quotient)\n        \n        remainder_dict = {}\n        remainder_dict[remainder] = len(remainder_dict)\n        \n        decimal_part = \"\"\n        while remainder != 0:\n            remainder *= 10\n            quotient = remainder // denominator\n            remainder = remainder % denominator\n            decimal_part += str(quotient)\n            \n            if remainder in remainder_dict:\n                decimal_part = decimal_part[:remainder_dict[remainder]] + \"(\" + decimal_part[remainder_dict[remainder]:] + \")\"\n                break\n            remainder_dict[remainder] = len(decimal_part)\n        \n        return str(sign * quotient) + \".\" + decimal_part"}, {"task_id": "fraction-to-recurring-decimal", "completion": "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        \n        if numerator == 0:\n            return \"0\"\n        \n        if numerator < 0 and denominator < 0:\n            numerator = abs(numerator)\n            denominator = abs(denominator)\n        elif numerator < 0:\n            numerator = -numerator\n            sign = \"-\"\n        elif denominator < 0:\n            denominator = -denominator\n            sign = \"-\"\n        else:\n            sign = \"\"\n        \n        quotient = numerator // denominator\n        remainder = numerator % denominator\n        if remainder == 0:\n            return sign + str(quotient)\n        \n        remainder_dict = {}\n        remainder_dict[remainder] = len(remainder_dict)\n        remainder_str = \"\"\n        while remainder != 0:\n            remainder *= 10\n            quotient = remainder // denominator\n            remainder = remainder % denominator\n            if remainder in remainder_dict:\n                remainder_str = \"(\" + remainder_str + \")\"\n                break\n            remainder_dict[remainder] = len(remainder_dict)\n            remainder_str += str(quotient)\n        \n        return sign + str(quotient) + \".\" + remainder_str"}, {"task_id": "fraction-to-recurring-decimal", "completion": "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        \n        if numerator == 0:\n            return \"0\"\n        \n        if numerator < 0 and denominator < 0:\n            numerator = abs(numerator)\n            denominator = abs(denominator)\n        elif numerator < 0:\n            numerator = -numerator\n            sign = \"-\"\n        elif denominator < 0:\n            denominator = -denominator\n            sign = \"-\"\n        else:\n            sign = \"\"\n        \n        quotient = numerator // denominator\n        remainder = numerator % denominator\n        if remainder == 0:\n            return sign + str(quotient)\n        \n        remainder_dict = {}\n        remainder_dict[remainder] = len(remainder_dict)\n        remainder_str = \"\"\n        while remainder != 0:\n            remainder *= 10\n            quotient = remainder // denominator\n            remainder = remainder % denominator\n            if remainder in remainder_dict:\n                remainder_str = \"(\" + remainder_str + \")\"\n                break\n            remainder_dict[remainder] = len(remainder_dict)\n            remainder_str = str(quotient) + remainder_str\n        return sign + str(quotient) + \".\" + remainder_str"}, {"task_id": "fraction-to-recurring-decimal", "completion": "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        \n        if numerator == 0:\n            return \"0\"\n        \n        if denominator == 0:\n            return \"NaN\"\n        \n        if numerator < 0 and denominator > 0:\n            sign = -1\n        elif numerator > 0 and denominator < 0:\n            sign = 1\n        else:\n            sign = 1\n        \n        numerator = abs(numerator)\n        denominator = abs(denominator)\n        \n        quotient = numerator // denominator\n        remainder = numerator % denominator\n        \n        if remainder == 0:\n            return str(sign * quotient)\n        \n        result = str(sign * quotient) + \".\"\n        \n        remainder_dict = {}\n        \n        while remainder != 0:\n            if remainder in remainder_dict:\n                result += \"(\"\n                result += \"\".join(result[remainder_dict[remainder]:])\n                result += \")\"\n                break\n            remainder_dict[remainder] = len(result)\n            remainder *= 10\n            quotient = remainder // denominator\n            remainder = remainder % denominator\n            result += str(quotient)\n        \n        return result"}], "sort-list": [{"task_id": "sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return head\n        \n        slow = fast = head\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        mid = slow.next\n        slow.next = None\n        \n        left = self.sortList(head)\n        right = self.sortList(mid)\n        \n        dummy = ListNode()\n        curr = dummy\n        \n        while left and right:\n            if left.val < right.val:\n                curr.next = left\n                left = left.next\n            else:\n                curr.next = right\n                right = right.next\n            curr = curr.next\n        \n        if left:\n            curr.next = left\n        else:\n            curr.next = right\n        \n        return dummy.next"}, {"task_id": "sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return head\n        \n        slow = fast = head\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        mid = slow.next\n        slow.next = None\n        \n        l1 = self.sortList(head)\n        l2 = self.sortList(mid)\n        \n        return self.merge(l1, l2)\n        \n    def merge(self, l1, l2):\n        dummy = ListNode()\n        curr = dummy\n        \n        while l1 and l2:\n            if l1.val < l2.val:\n                curr.next = l1\n                l1 = l1.next\n            else:\n                curr.next = l2\n                l2 = l2.next\n            curr = curr.next\n        \n        if l1:\n            curr.next = l1\n        if l2:\n            curr.next = l2\n        \n        return dummy.next"}, {"task_id": "sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return head\n        \n        slow = fast = head\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        mid = slow.next\n        slow.next = None\n        \n        left = self.sortList(head)\n        right = self.sortList(mid)\n        \n        dummy = ListNode()\n        curr = dummy\n        \n        while left and right:\n            if left.val < right.val:\n                curr.next = left\n                left = left.next\n            else:\n                curr.next = right\n                right = right.next\n            curr = curr.next\n        \n        if left:\n            curr.next = left\n        else:\n            curr.next = right\n        \n        return dummy.next"}, {"task_id": "sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return head\n        \n        slow = fast = head\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        mid = slow.next\n        slow.next = None\n        \n        left = self.sortList(head)\n        right = self.sortList(mid)\n        \n        dummy = ListNode()\n        curr = dummy\n        \n        while left and right:\n            if left.val < right.val:\n                curr.next = left\n                left = left.next\n            else:\n                curr.next = right\n                right = right.next\n            curr = curr.next\n        \n        if left:\n            curr.next = left\n        if right:\n            curr.next = right\n        \n        return dummy.next"}, {"task_id": "sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return head\n        \n        slow = fast = head\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        mid = slow.next\n        slow.next = None\n        \n        l1 = self.sortList(head)\n        l2 = self.sortList(mid)\n        \n        return self.merge(l1, l2)\n        \n    def merge(self, l1, l2):\n        dummy = ListNode()\n        curr = dummy\n        \n        while l1 and l2:\n            if l1.val < l2.val:\n                curr.next = l1\n                l1 = l1.next\n            else:\n                curr.next = l2\n                l2 = l2.next\n            curr = curr.next\n        \n        if l1:\n            curr.next = l1\n        if l2:\n            curr.next = l2\n        \n        return dummy.next"}], "russian-doll-envelopes": [{"task_id": "russian-doll-envelopes", "completion": "class Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not envelopes:\n            return 0\n        \n        envelopes.sort(key=lambda x: (x[0], -x[1]))\n        \n        dp = [1] * len(envelopes)\n        \n        for i in range(1, len(envelopes)):\n            for j in range(i):\n                if envelopes[j][0] < envelopes[i][0] and envelopes[j][1] < envelopes[i][1]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        \n        return max(dp)"}, {"task_id": "russian-doll-envelopes", "completion": "class Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        if not envelopes:\n            return 0\n        \n        envelopes.sort(key=lambda x: (x[0], -x[1]))\n        dp = [1] * len(envelopes)\n        max_len = 1\n        for i in range(1, len(envelopes)):\n            for j in range(i):\n                if envelopes[j][0] < envelopes[i][0] and envelopes[j][1] < envelopes[i][1]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n            max_len = max(max_len, dp[i])\n        return max_len"}, {"task_id": "russian-doll-envelopes", "completion": "class Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort the envelopes by width and height\n        envelopes.sort(key=lambda x: (x[0], -x[1]))\n        \n        # find the longest increasing subsequence of heights\n        heights = [envelope[1] for envelope in envelopes]\n        return self.lengthOfLIS(heights)\n    \n    def lengthOfLIS(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        if not nums:\n            return 0\n        \n        dp = [1] * len(nums)\n        for i in range(len(nums)):\n            for j in range(i):\n                if nums[j] < nums[i]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        \n        return max(dp)"}, {"task_id": "russian-doll-envelopes", "completion": "class Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort the array by width\n        envelopes.sort(key=lambda x: x[0])\n        \n        # find the longest increasing subsequence\n        dp = [1] * len(envelopes)\n        for i in range(len(envelopes)):\n            for j in range(i):\n                if envelopes[j][1] < envelopes[i][1]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        \n        return max(dp)"}, {"task_id": "russian-doll-envelopes", "completion": "class Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort the array by width\n        envelopes.sort(key=lambda x: x[0])\n        \n        # create a list to store the height of the envelopes\n        heights = []\n        \n        # loop through the envelopes\n        for envelope in envelopes:\n            # add the height to the list\n            heights.append(envelope[1])\n        \n        # sort the list\n        heights.sort()\n        \n        # create a list to store the number of envelopes\n        num_envelopes = []\n        \n        # loop through the list\n        for height in heights:\n            # add the number of envelopes to the list\n            num_envelopes.append(heights.count(height))\n        \n        # return the maximum number of envelopes\n        return max(num_envelopes)"}], "set-matrix-zeroes": [{"task_id": "set-matrix-zeroes", "completion": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        ## O(m*n) space\n        ## row = [0]*m\n        ## col = [0]*n\n        ## for i in range(m):\n        ##     for j in range(n):\n        ##         if matrix[i][j] == 0:\n        ##             row[i] = 1\n        ##             col[j] = 1\n        ## for i in range(m):\n        ##     for j in range(n):\n        ##         if row[i] == 1 or col[j] == 1:\n        ##             matrix[i][j] = 0\n        \n        ## O(1) space\n        m = len(matrix)\n        n = len(matrix[0])\n        row = [0]*m\n        col = [0]*n\n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == 0:\n                    row[i] = 1\n                    col[j] = 1\n        for i in range(m):\n            for j in range(n):\n                if row[i] == 1 or col[j] == 1:\n                    matrix[i][j] = 0"}, {"task_id": "set-matrix-zeroes", "completion": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        ## 1. Brute force\n        ## Time Complexity: O(mn)\n        ## Space Complexity: O(1)\n        ## 2. Using set\n        ## Time Complexity: O(mn)\n        ## Space Complexity: O(m+n)\n        ## 3. Using set\n        ## Time Complexity: O(mn)\n        ## Space Complexity: O(m+n)\n        ## 4. Using set\n        ## Time Complexity: O(mn)\n        ## Space Complexity: O(m+n)\n        ## 5. Using set\n        ## Time Complexity: O(mn)\n        ## Space Complexity: O(m+n)\n        ## 6. Using set\n        ## Time Complexity: O(mn)\n        ## Space Complexity: O(m+n)\n        ## 7. Using set\n        ## Time Complexity: O(mn)\n        ## Space Complexity: O(m+n)\n        ## 8. Using set\n        ## Time Complexity: O(mn)\n        ## Space Complexity: O(m+n)\n        ## 9. Using set\n        ## Time Complexity: O(mn)\n        ## Space Complexity: O(m+n)\n        ## 10. Using set\n        ## Time Complexity: O(mn)\n        ## Space Complexity: O(m+n)\n        ## 11. Using set\n        ## Time Complexity: O(mn)\n        ## Space Complexity: O(m+n)\n        ## 12. Using set\n        ## Time Complexity: O(mn)\n        ## Space Complexity: O(m+n)\n        ## 13. Using set\n        ## Time Complexity: O(mn)\n        ## Space Complexity: O(m+n)\n        ## 14. Using set\n        ## Time Complexity: O(mn)\n        ## Space Complexity: O(m+n)\n        ## 15. Using set\n        ## Time Complexity: O(mn)\n        ## Space Complexity: O(m+n)\n        ## 16. Using set\n        ## Time Complexity: O(mn)\n        ## Space Complexity: O(m+n)\n        ## 17. Using set\n        ## Time Complexity: O(mn)\n        ## Space Complexity: O(m+n)\n        ## 18. Using set\n        ## Time Complexity: O(mn)\n        ## Space Complexity: O(m+n)\n        ## 19. Using set\n        ## Time Complexity: O(mn)\n        ## Space Complexity: O(m+n)\n        ## 20. Using set\n        ## Time Complexity: O(mn)\n        ## Space Complexity: O(m+n)\n        ## 21. Using set\n        ## Time Complexity: O(mn)\n        ## Space Complexity: O(m+n)\n        ## 22. Using set\n        ## Time Complexity: O(mn)\n        ## Space Complexity: O(m+n)\n        ## 23. Using set\n        ## Time Complexity: O(mn)\n        ## Space Complexity: O(m+n)\n        ## 24. Using set\n        ## Time Complexity: O(mn)\n        ## Space Complexity: O(m+n)\n        ## 25. Using set\n        ## Time Complexity: O(mn)\n        ## Space Complexity: O(m+n)\n        ## 26. Using set\n        ## Time Complexity: O(mn)\n        ## Space Complexity: O(m+n)\n        ## 27. Using set\n        ## Time Complexity: O(mn)\n        ## Space Complexity: O(m+n)\n        ## 28. Using"}, {"task_id": "set-matrix-zeroes", "completion": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        ## O(m*n) space\n        ## O(m+n) space\n        ## O(1) space\n        \n        ## O(m*n) space\n        ## O(m+n) space\n        ## O(1) space\n        \n        ## O(m*n) space\n        ## O(m+n) space\n        ## O(1) space\n        \n        ## O(m*n) space\n        ## O(m+n) space\n        ## O(1) space\n        \n        ## O(m*n) space\n        ## O(m+n) space\n        ## O(1) space\n        \n        ## O(m*n) space\n        ## O(m+n) space\n        ## O(1) space\n        \n        ## O(m*n) space\n        ## O(m+n) space\n        ## O(1) space\n        \n        ## O(m*n) space\n        ## O(m+n) space\n        ## O(1) space\n        \n        ## O(m*n) space\n        ## O(m+n) space\n        ## O(1) space\n        \n        ## O(m*n) space\n        ## O(m+n) space\n        ## O(1) space\n        \n        ## O(m*n) space\n        ## O(m+n) space\n        ## O(1) space\n        \n        ## O(m*n) space\n        ## O(m+n) space\n        ## O(1) space\n        \n        ## O(m*n) space\n        ## O(m+n) space\n        ## O(1) space\n        \n        ## O(m*n) space\n        ## O(m+n) space\n        ## O(1) space\n        \n        ## O(m*n) space\n        ## O(m+n) space\n        ## O(1) space\n        \n        ## O(m*n) space\n        ## O(m+n) space\n        ## O(1) space\n        \n        ## O(m*n) space\n        ## O(m+n) space\n        ## O(1) space\n        \n        ## O(m*n) space\n        ## O(m+n) space\n        ## O(1) space\n        \n        ## O(m*n) space\n        ## O(m+n) space\n        ## O(1) space\n        \n        ## O(m*n) space\n        ## O(m+n) space\n        ## O(1) space\n        \n        ## O(m*n) space\n        ## O(m+n) space\n        ## O(1) space\n        \n        ## O(m*n) space\n        ## O(m+n) space\n        ## O(1) space\n        \n        ## O(m*n) space\n        ## O(m+n) space\n        ## O(1) space\n        \n        ## O(m*n) space\n        ## O(m+n) space\n        ## O(1) space\n        \n        ## O(m*n) space\n        ## O(m+n) space\n        ## O(1) space\n        \n        ## O(m*n) space\n        ## O(m+n) space\n        ## O(1) space\n        \n        ## O(m*n) space\n        ## O(m+n) space\n        ## O(1) space\n        \n        ## O(m*n) space\n        ## O(m+n) space\n        ## O(1) space\n        \n        ## O(m*n) space\n        ## O(m+n) space\n        ## O(1) space\n        \n        ## O(m*n) space\n        ## O(m+n) space\n        ## O(1) space\n        \n        ## O(m*n) space\n        ## O(m+n) space\n        ## O(1) space"}, {"task_id": "set-matrix-zeroes", "completion": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        row = [0] * m\n        col = [0] * n\n        \n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == 0:\n                    row[i] = 1\n                    col[j] = 1\n        \n        for i in range(m):\n            for j in range(n):\n                if row[i] == 1 or col[j] == 1:\n                    matrix[i][j] = 0"}, {"task_id": "set-matrix-zeroes", "completion": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        row_zero = False\n        col_zero = False\n        \n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == 0:\n                    if i == 0:\n                        row_zero = True\n                    if j == 0:\n                        col_zero = True\n                    matrix[i][0] = 0\n                    matrix[0][j] = 0\n        \n        for i in range(1, m):\n            for j in range(1, n):\n                if matrix[i][0] == 0 or matrix[0][j] == 0:\n                    matrix[i][j] = 0\n        \n        if row_zero:\n            for i in range(m):\n                matrix[i][0] = 0\n        \n        if col_zero:\n            for j in range(n):\n                matrix[0][j] = 0"}], "remove-nth-node-from-end-of-list": [{"task_id": "remove-nth-node-from-end-of-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # create a dummy node\n        dummy = ListNode(0)\n        dummy.next = head\n        \n        # create a slow and fast pointer\n        slow = dummy\n        fast = dummy\n        \n        # move the fast pointer n steps ahead\n        for i in range(n+1):\n            fast = fast.next\n        \n        # move the slow pointer until the fast pointer reaches the end\n        while fast:\n            slow = slow.next\n            fast = fast.next\n        \n        # remove the node at the end\n        slow.next = slow.next.next\n        \n        # return the updated head\n        return dummy.next"}, {"task_id": "remove-nth-node-from-end-of-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # create a dummy node\n        dummy = ListNode(0)\n        dummy.next = head\n        \n        # create a slow and fast pointer\n        slow = dummy\n        fast = dummy\n        \n        # move the fast pointer n steps ahead\n        for i in range(n+1):\n            fast = fast.next\n        \n        # move both the slow and fast pointers until fast reaches the end\n        while fast:\n            slow = slow.next\n            fast = fast.next\n        \n        # remove the node at the end\n        slow.next = slow.next.next\n        \n        # return the updated head\n        return dummy.next"}, {"task_id": "remove-nth-node-from-end-of-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # create a dummy node\n        dummy = ListNode(0)\n        dummy.next = head\n        \n        # create a slow and fast pointer\n        slow = dummy\n        fast = dummy\n        \n        # move the fast pointer n steps ahead\n        for i in range(n+1):\n            fast = fast.next\n        \n        # move the slow pointer until the fast pointer reaches the end\n        while fast:\n            slow = slow.next\n            fast = fast.next\n        \n        # remove the node at the end\n        slow.next = slow.next.next\n        \n        # return the modified list\n        return dummy.next"}, {"task_id": "remove-nth-node-from-end-of-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # create a dummy node\n        dummy = ListNode(0)\n        dummy.next = head\n        \n        # create a slow and fast pointer\n        slow = dummy\n        fast = dummy\n        \n        # move the fast pointer n steps ahead\n        for i in range(n+1):\n            fast = fast.next\n        \n        # move both the slow and fast pointers until fast reaches the end\n        while fast:\n            slow = slow.next\n            fast = fast.next\n        \n        # remove the node at the end\n        slow.next = slow.next.next\n        \n        # return the modified list\n        return dummy.next"}, {"task_id": "remove-nth-node-from-end-of-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # create a dummy node\n        dummy = ListNode(0)\n        dummy.next = head\n        \n        # create a slow and fast pointer\n        slow = dummy\n        fast = dummy\n        \n        # move the fast pointer n steps ahead\n        for i in range(n+1):\n            fast = fast.next\n        \n        # move the slow pointer until the fast pointer reaches the end\n        while fast:\n            slow = slow.next\n            fast = fast.next\n        \n        # remove the node at the end\n        slow.next = slow.next.next\n        \n        # return the updated head\n        return dummy.next"}], "intersection-of-two-arrays": [{"task_id": "intersection-of-two-arrays", "completion": "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use list\n        ## 4. use set\n        ## 5. use dict\n        ## 6. use list\n        ## 7. use set\n        ## 8. use dict\n        ## 9. use list\n        ## 10. use set\n        ## 11. use dict\n        ## 12. use list\n        ## 13. use set\n        ## 14. use dict\n        ## 15. use list\n        ## 16. use set\n        ## 17. use dict\n        ## 18. use list\n        ## 19. use set\n        ## 20. use dict\n        ## 21. use list\n        ## 22. use set\n        ## 23. use dict\n        ## 24. use list\n        ## 25. use set\n        ## 26. use dict\n        ## 27. use list\n        ## 28. use set\n        ## 29. use dict\n        ## 30. use list\n        ## 31. use set\n        ## 32. use dict\n        ## 33. use list\n        ## 34. use set\n        ## 35. use dict\n        ## 36. use list\n        ## 37. use set\n        ## 38. use dict\n        ## 39. use list\n        ## 40. use set\n        ## 41. use dict\n        ## 42. use list\n        ## 43. use set\n        ## 44. use dict\n        ## 45. use list\n        ## 46. use set\n        ## 47. use dict\n        ## 48. use list\n        ## 49. use set\n        ## 50. use dict\n        ## 51. use list\n        ## 52. use set\n        ## 53. use dict\n        ## 54. use list\n        ## 55. use set\n        ## 56. use dict\n        ## 57. use list\n        ## 58. use set\n        ## 59. use dict\n        ## 60. use list\n        ## 61. use set\n        ## 62. use dict\n        ## 63. use list\n        ## 64. use set\n        ## 65. use dict\n        ## 66. use list\n        ## 67. use set\n        ## 68. use dict\n        ## 69. use list\n        ## 70. use set\n        ## 71. use dict\n        ## 72. use list\n        ## 73. use set\n        ## 74. use dict\n        ## 75. use list\n        ## 76. use set\n        ## 77. use dict\n        ## 78. use list\n        ## 79. use set\n        ## 80. use dict\n        ## 81. use list\n        ## 82. use set\n        ## 83. use dict\n        ## 84. use list\n        ## 85. use set\n        ## 86. use dict\n        ## 87. use list\n        ## 88. use set\n        ## 89. use dict\n        ## 90. use list\n        ## 91. use set\n        ## 92. use dict\n        ## 93. use list\n        ## 94. use set\n        ## 95. use dict\n        ## 96. use list\n        ## 97. use set\n        ## 98. use dict\n        ## 99. use list\n        ## 100. use set\n        ## 101. use dict\n        ## 102. use list\n        ## 103. use set"}, {"task_id": "intersection-of-two-arrays", "completion": "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        ## Solution 1:\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(n)\n        ## Runtime: 124 ms, faster than 99.45% of Python online submissions for Intersection of Two Arrays.\n        ## Memory Usage: 14.4 MB, less than 99.45% of Python online submissions for Intersection of Two Arrays.\n        ## 2022.01.25\n        ## 2022.01.26\n        ## 2022.01.27\n        ## 2022.01.28\n        ## 2022.01.29\n        ## 2022.01.30\n        ## 2022.01.31\n        ## 2022.02.01\n        ## 2022.02.02\n        ## 2022.02.03\n        ## 2022.02.04\n        ## 2022.02.05\n        ## 2022.02.06\n        ## 2022.02.07\n        ## 2022.02.08\n        ## 2022.02.09\n        ## 2022.02.10\n        ## 2022.02.11\n        ## 2022.02.12\n        ## 2022.02.13\n        ## 2022.02.14\n        ## 2022.02.15\n        ## 2022.02.16\n        ## 2022.02.17\n        ## 2022.02.18\n        ## 2022.02.19\n        ## 2022.02.20\n        ## 2022.02.21\n        ## 2022.02.22\n        ## 2022.02.23\n        ## 2022.02.24\n        ## 2022.02.25\n        ## 2022.02.26\n        ## 2022.02.27\n        ## 2022.02.28\n        ## 2022.02.29\n        ## 2022.03.01\n        ## 2022.03.02\n        ## 2022.03.03\n        ## 2022.03.04\n        ## 2022.03.05\n        ## 2022.03.06\n        ## 2022.03.07\n        ## 2022.03.08\n        ## 2022.03.09\n        ## 2022.03.10\n        ## 2022.03.11\n        ## 2022.03.12\n        ## 2022.03.13\n        ## 2022.03.14\n        ## 2022.03.15\n        ## 2022.03.16\n        ## 2022.03.17\n        ## 2022.03.18\n        ## 2022.03.19\n        ## 2022.03.20\n        ## 2022.03.21\n        ## 2022.03.22\n        ## 2022.03.23\n        ## 2022.03.24\n        ## 2022.03.25"}, {"task_id": "intersection-of-two-arrays", "completion": "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use list\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use list\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use list\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use list\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use list\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use list\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use list\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use list\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use list\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use list\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use list\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use list\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use list\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use list\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use list\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use list\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use list\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use list\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use list\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use list\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use list\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use list\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use list\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use list\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use list\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use list\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use list\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use list\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use list\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use list\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use list\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use list\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use list\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use list\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use list\n        \n        ## 1. use set"}, {"task_id": "intersection-of-two-arrays", "completion": "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        ## Solution 1:\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(n)\n        ## Runtime: 120 ms, faster than 99.45% of Python online submissions for Intersection of Two Arrays.\n        ## Memory Usage: 14.3 MB, less than 99.45% of Python online submissions for Intersection of Two Arrays.\n        ## 2021.04.27\n        ## 2021.04.28\n        ## 2021.04.29\n        ## 2021.04.30\n        ## 2021.05.01\n        ## 2021.05.02\n        ## 2021.05.03\n        ## 2021.05.04\n        ## 2021.05.05\n        ## 2021.05.06\n        ## 2021.05.07\n        ## 2021.05.08\n        ## 2021.05.09\n        ## 2021.05.10\n        ## 2021.05.11\n        ## 2021.05.12\n        ## 2021.05.13\n        ## 2021.05.14\n        ## 2021.05.15\n        ## 2021.05.16\n        ## 2021.05.17\n        ## 2021.05.18\n        ## 2021.05.19\n        ## 2021.05.20\n        ## 2021.05.21\n        ## 2021.05.22\n        ## 2021.05.23\n        ## 2021.05.24\n        ## 2021.05.25\n        ## 2021.05.26\n        ## 2021.05.27\n        ## 2021.05.28\n        ## 2021.05.29\n        ## 2021.05.30\n        ## 2021.05.31\n        ## 2021.06.01\n        ## 2021.06.02\n        ## 2021.06.03\n        ## 2021.06.04\n        ## 2021.06.05\n        ## 2021.06.06\n        ## 2021.06.07\n        ## 2021.06.08\n        ## 2021.06.09\n        ## 2021.06.10\n        ## 2021.06.11\n        ## 2021.06.12\n        ## 2021.06.13\n        ## 2021.06.14\n        ## 2021.06.15\n        ## 2021.06.16\n        ## 2021.06.17\n        ## 2021.06.18\n        ## 2021.06.19\n        ## 2021.06.20\n        ## 2021.06.21\n        ## 2021.06.22\n        ## 2021.06.23\n        ## 2021.06.24\n        ## 2021.06.25\n        ## 2021.06.26"}, {"task_id": "intersection-of-two-arrays", "completion": "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        ## 1. use set\n        ## 2. use dict\n        ## 3. use list\n        ## 4. use set\n        ## 5. use dict\n        ## 6. use list\n        ## 7. use set\n        ## 8. use dict\n        ## 9. use list\n        ## 10. use set\n        ## 11. use dict\n        ## 12. use list\n        ## 13. use set\n        ## 14. use dict\n        ## 15. use list\n        ## 16. use set\n        ## 17. use dict\n        ## 18. use list\n        ## 19. use set\n        ## 20. use dict\n        ## 21. use list\n        ## 22. use set\n        ## 23. use dict\n        ## 24. use list\n        ## 25. use set\n        ## 26. use dict\n        ## 27. use list\n        ## 28. use set\n        ## 29. use dict\n        ## 30. use list\n        ## 31. use set\n        ## 32. use dict\n        ## 33. use list\n        ## 34. use set\n        ## 35. use dict\n        ## 36. use list\n        ## 37. use set\n        ## 38. use dict\n        ## 39. use list\n        ## 40. use set\n        ## 41. use dict\n        ## 42. use list\n        ## 43. use set\n        ## 44. use dict\n        ## 45. use list\n        ## 46. use set\n        ## 47. use dict\n        ## 48. use list\n        ## 49. use set\n        ## 50. use dict\n        ## 51. use list\n        ## 52. use set\n        ## 53. use dict\n        ## 54. use list\n        ## 55. use set\n        ## 56. use dict\n        ## 57. use list\n        ## 58. use set\n        ## 59. use dict\n        ## 60. use list\n        ## 61. use set\n        ## 62. use dict\n        ## 63. use list\n        ## 64. use set\n        ## 65. use dict\n        ## 66. use list\n        ## 67. use set\n        ## 68. use dict\n        ## 69. use list\n        ## 70. use set\n        ## 71. use dict\n        ## 72. use list\n        ## 73. use set\n        ## 74. use dict\n        ## 75. use list\n        ## 76. use set\n        ## 77. use dict\n        ## 78. use list\n        ## 79. use set\n        ## 80. use dict\n        ## 81. use list\n        ## 82. use set\n        ## 83. use dict\n        ## 84. use list\n        ## 85. use set\n        ## 86. use dict\n        ## 87. use list\n        ## 88. use set\n        ## 89. use dict\n        ## 90. use list\n        ## 91. use set\n        ## 92. use dict\n        ## 93. use list\n        ## 94. use set\n        ## 95. use dict\n        ## 96. use list\n        ## 97. use set\n        ## 98. use dict\n        ## 99. use list\n        ## 100. use set\n        ## 101. use dict\n        ## 102. use list\n        ## 103. use set"}], "super-washing-machines": [{"task_id": "super-washing-machines", "completion": "class Solution(object):\n    def findMinMoves(self, machines):\n        \"\"\"\n        :type machines: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(machines)\n        if n == 0:\n            return 0\n        if n == 1:\n            return 0\n        if n == 2:\n            return max(machines[0], machines[1]) - min(machines[0], machines[1])\n        \n        sum_machines = sum(machines)\n        if sum_machines % n != 0:\n            return -1\n        \n        avg = sum_machines / n\n        if avg == 0:\n            return 0\n        \n        cur_sum = 0\n        max_diff = 0\n        for i in range(n):\n            cur_sum += machines[i]\n            max_diff = max(max_diff, abs(cur_sum - avg * (i + 1)))\n        \n        return max_diff"}, {"task_id": "super-washing-machines", "completion": "class Solution(object):\n    def findMinMoves(self, machines):\n        \"\"\"\n        :type machines: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(machines)\n        if n == 0:\n            return 0\n        if n == 1:\n            return 0\n        if n == 2:\n            return max(machines[0], machines[1]) - min(machines[0], machines[1])\n        \n        total = sum(machines)\n        if total % n != 0:\n            return -1\n        avg = total / n\n        \n        left = 0\n        right = 0\n        curr = 0\n        ans = 0\n        for i in range(n):\n            curr += machines[i]\n            right = max(right, curr)\n            curr -= avg\n            ans = max(ans, right - avg * i)\n        return ans"}, {"task_id": "super-washing-machines", "completion": "class Solution(object):\n    def findMinMoves(self, machines):\n        \"\"\"\n        :type machines: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(machines)\n        if n == 0:\n            return 0\n        if n == 1:\n            return 0\n        if n == 2:\n            return max(machines[0], machines[1]) - min(machines[0], machines[1])\n        \n        total = sum(machines)\n        if total % n != 0:\n            return -1\n        avg = total / n\n        \n        left = 0\n        right = 0\n        curr = 0\n        ans = 0\n        for i in range(n):\n            curr += machines[i]\n            right = max(right, curr)\n            curr -= avg\n            ans = max(ans, right - avg * i)\n        return ans"}, {"task_id": "super-washing-machines", "completion": "class Solution(object):\n    def findMinMoves(self, machines):\n        \"\"\"\n        :type machines: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(machines)\n        if n == 0:\n            return 0\n        if n == 1:\n            return 0\n        if n == 2:\n            return max(machines[0], machines[1]) - min(machines[0], machines[1])\n        \n        total = sum(machines)\n        if total % n != 0:\n            return -1\n        avg = total / n\n        \n        left = 0\n        right = 0\n        curr = 0\n        ans = 0\n        for i in range(n):\n            curr += machines[i]\n            right = max(right, curr)\n            curr -= avg\n            ans = max(ans, right - avg * i)\n        return ans"}, {"task_id": "super-washing-machines", "completion": "class Solution(object):\n    def findMinMoves(self, machines):\n        \"\"\"\n        :type machines: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(machines)\n        if n == 0:\n            return 0\n        if n == 1:\n            return 0\n        if n == 2:\n            return max(machines[0], machines[1]) - min(machines[0], machines[1])\n        \n        sum_machines = sum(machines)\n        if sum_machines % n != 0:\n            return -1\n        \n        avg = sum_machines / n\n        if avg == 0:\n            return 0\n        \n        cur_sum = 0\n        max_move = 0\n        for i in range(n):\n            cur_sum += machines[i]\n            max_move = max(max_move, abs(cur_sum - avg * (i + 1)))\n        \n        return max_move"}], "kth-smallest-number-in-multiplication-table": [{"task_id": "kth-smallest-number-in-multiplication-table", "completion": "class Solution(object):\n    def findKthNumber(self, m, n, k):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def get_count(x):\n            count = 0\n            for i in range(1, m + 1):\n                count += min(n, x // i)\n            return count\n        \n        low = 1\n        high = m * n\n        \n        while low < high:\n            mid = (low + high) // 2\n            if get_count(mid) < k:\n                low = mid + 1\n            else:\n                high = mid\n        \n        return low"}, {"task_id": "kth-smallest-number-in-multiplication-table", "completion": "class Solution(object):\n    def findKthNumber(self, m, n, k):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def count(x):\n            c = 0\n            for i in range(1, m + 1):\n                c += min(n, x // i)\n            return c\n        \n        l, r = 1, m * n\n        while l < r:\n            mid = (l + r) // 2\n            if count(mid) < k:\n                l = mid + 1\n            else:\n                r = mid\n        return l"}, {"task_id": "kth-smallest-number-in-multiplication-table", "completion": "class Solution(object):\n    def findKthNumber(self, m, n, k):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def count(x):\n            c = 0\n            for i in range(1, m + 1):\n                c += min(n, x // i)\n            return c\n        \n        l, r = 1, m * n\n        while l < r:\n            mid = (l + r) // 2\n            if count(mid) < k:\n                l = mid + 1\n            else:\n                r = mid\n        return l"}, {"task_id": "kth-smallest-number-in-multiplication-table", "completion": "class Solution(object):\n    def findKthNumber(self, m, n, k):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def get_count(x):\n            count = 0\n            for i in range(1, m + 1):\n                count += min(n, x // i)\n            return count\n        \n        low = 1\n        high = m * n\n        \n        while low < high:\n            mid = (low + high) // 2\n            if get_count(mid) < k:\n                low = mid + 1\n            else:\n                high = mid\n        \n        return low"}, {"task_id": "kth-smallest-number-in-multiplication-table", "completion": "class Solution(object):\n    def findKthNumber(self, m, n, k):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def get_count(x):\n            count = 0\n            for i in range(1, m + 1):\n                count += min(n, x // i)\n            return count\n        \n        low = 1\n        high = m * n\n        \n        while low < high:\n            mid = (low + high) // 2\n            if get_count(mid) < k:\n                low = mid + 1\n            else:\n                high = mid\n        \n        return low"}], "convert-sorted-list-to-binary-search-tree": [{"task_id": "convert-sorted-list-to-binary-search-tree", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return TreeNode(head.val)\n        \n        slow = fast = head\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        root = TreeNode(slow.val)\n        root.right = self.sortedListToBST(slow.next)\n        root.left = self.sortedListToBST(head)\n        \n        return root"}, {"task_id": "convert-sorted-list-to-binary-search-tree", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return TreeNode(head.val)\n        \n        slow = fast = head\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        root = TreeNode(slow.val)\n        root.right = self.sortedListToBST(slow.next)\n        root.left = self.sortedListToBST(head)\n        \n        return root"}, {"task_id": "convert-sorted-list-to-binary-search-tree", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return TreeNode(head.val)\n        \n        slow = fast = head\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        root = TreeNode(slow.val)\n        root.right = self.sortedListToBST(slow.next)\n        root.left = self.sortedListToBST(head)\n        \n        return root"}, {"task_id": "convert-sorted-list-to-binary-search-tree", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return TreeNode(head.val)\n        \n        slow = fast = head\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        root = TreeNode(slow.val)\n        root.right = self.sortedListToBST(slow.next)\n        root.left = self.sortedListToBST(head)\n        \n        return root"}, {"task_id": "convert-sorted-list-to-binary-search-tree", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        \n        if not head:\n            return None\n        \n        if not head.next:\n            return TreeNode(head.val)\n        \n        slow = fast = head\n        \n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        root = TreeNode(slow.val)\n        root.right = self.sortedListToBST(slow.next)\n        root.left = self.sortedListToBST(head)\n        \n        return root"}], "merge-two-sorted-lists": [{"task_id": "merge-two-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: Optional[ListNode]\n        :type list2: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        \n        if list1 is None:\n            return list2\n        if list2 is None:\n            return list1\n        \n        if list1.val < list2.val:\n            head = list1\n            list1 = list1.next\n        else:\n            head = list2\n            list2 = list2.next\n        \n        curr = head\n        \n        while list1 is not None and list2 is not None:\n            if list1.val < list2.val:\n                curr.next = list1\n                list1 = list1.next\n            else:\n                curr.next = list2\n                list2 = list2.next\n            curr = curr.next\n        \n        if list1 is None:\n            curr.next = list2\n        else:\n            curr.next = list1\n        \n        return head"}, {"task_id": "merge-two-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: Optional[ListNode]\n        :type list2: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        \n        if list1 is None:\n            return list2\n        if list2 is None:\n            return list1\n        \n        if list1.val < list2.val:\n            list1.next = self.mergeTwoLists(list1.next, list2)\n            return list1\n        else:\n            list2.next = self.mergeTwoLists(list1, list2.next)\n            return list2"}, {"task_id": "merge-two-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: Optional[ListNode]\n        :type list2: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        \n        if list1 is None:\n            return list2\n        if list2 is None:\n            return list1\n        \n        if list1.val < list2.val:\n            head = list1\n            list1 = list1.next\n        else:\n            head = list2\n            list2 = list2.next\n        \n        curr = head\n        \n        while list1 is not None and list2 is not None:\n            if list1.val < list2.val:\n                curr.next = list1\n                list1 = list1.next\n            else:\n                curr.next = list2\n                list2 = list2.next\n            curr = curr.next\n        \n        if list1 is None:\n            curr.next = list2\n        else:\n            curr.next = list1\n        \n        return head"}, {"task_id": "merge-two-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: Optional[ListNode]\n        :type list2: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        \n        if list1 is None:\n            return list2\n        if list2 is None:\n            return list1\n        \n        if list1.val < list2.val:\n            head = list1\n            list1 = list1.next\n        else:\n            head = list2\n            list2 = list2.next\n        \n        curr = head\n        \n        while list1 is not None and list2 is not None:\n            if list1.val < list2.val:\n                curr.next = list1\n                list1 = list1.next\n            else:\n                curr.next = list2\n                list2 = list2.next\n            curr = curr.next\n        \n        if list1 is None:\n            curr.next = list2\n        else:\n            curr.next = list1\n        \n        return head"}, {"task_id": "merge-two-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: Optional[ListNode]\n        :type list2: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        \n        if list1 is None:\n            return list2\n        if list2 is None:\n            return list1\n        \n        if list1.val < list2.val:\n            head = list1\n            list1 = list1.next\n        else:\n            head = list2\n            list2 = list2.next\n        \n        curr = head\n        \n        while list1 is not None and list2 is not None:\n            if list1.val < list2.val:\n                curr.next = list1\n                list1 = list1.next\n            else:\n                curr.next = list2\n                list2 = list2.next\n            curr = curr.next\n        \n        if list1 is None:\n            curr.next = list2\n        else:\n            curr.next = list1\n        \n        return head"}], "maximal-rectangle": [{"task_id": "maximal-rectangle", "completion": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        # 1. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u9762\u79ef\n        # 2. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 3. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 4. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        \n        # 1. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u9762\u79ef\n        max_area = 0\n        for i in range(n):\n            height = [0] * m\n            for j in range(m):\n                if matrix[j][i] == '1':\n                    height[j] += 1\n                else:\n                    height[j] = 0\n            max_area = max(max_area, self.largestRectangleArea(height))\n        \n        # 2. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        for i in range(m):\n            height = [0] * n\n            for j in range(n):\n                if matrix[i][j] == '1':\n                    height[j] += 1\n                else:\n                    height[j] = 0\n            max_area = max(max_area, self.largestRectangleArea(height))\n        \n        # 3. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        for i in range(m):\n            height = [0] * n\n            for j in range(n-1, -1, -1):\n                if matrix[i][j] == '1':\n                    height[j] += 1\n                else:\n                    height[j] = 0\n            max_area = max(max_area, self.largestRectangleArea(height))\n        \n        # 4. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        for j in range(n):\n            height = [0] * m\n            for i in range(m-1, -1, -1):\n                if matrix[i][j] == '1':\n                    height[i] += 1\n                else:\n                    height[i] = 0\n            max_area = max(max_area, self.largestRectangleArea(height))\n        \n        return max_area\n    \n    def largestRectangleArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        if not height:\n            return 0\n        \n        stack = []\n        max_area = 0\n        for i in range(len(height)):\n            while stack and height[i] <= height[stack[-1]]:\n                h = height[stack.pop()]\n                w = i if not stack else i - stack[-1] - 1\n                max_area = max(max_area, h * w)\n            stack.append(i)\n        \n        while stack:\n            h = height[stack.pop()]\n            w = len(height) if not stack else len(height) - stack[-1] - 1\n            max_area = max(max_area, h * w)\n        \n        return max_area"}, {"task_id": "maximal-rectangle", "completion": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        # 1. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u9762\u79ef\n        # 2. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 3. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 4. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        \n        # 1. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u9762\u79ef\n        max_area = 0\n        for i in range(n):\n            max_area = max(max_area, self.largestRectangleArea(matrix, i))\n        \n        # 2. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        heights = [0] * n\n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == '1':\n                    heights[j] += 1\n                else:\n                    heights[j] = 0\n            max_area = max(max_area, self.largestRectangleArea(heights))\n        \n        # 3. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        for i in range(m):\n            max_area = max(max_area, self.largestRectangleArea(matrix[i], heights))\n        \n        # 4. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        for i in range(m):\n            max_area = max(max_area, self.largestRectangleArea(matrix[i], heights))\n        \n        return max_area\n    \n    def largestRectangleArea(self, heights, heights_len=None):\n        if heights_len is None:\n            heights_len = len(heights)\n        \n        stack = []\n        max_area = 0\n        for i in range(heights_len):\n            while stack and heights[stack[-1]] > heights[i]:\n                h = heights[stack.pop()]\n                w = i if not stack else i - stack[-1] - 1\n                max_area = max(max_area, h * w)\n            stack.append(i)\n        \n        while stack:\n            h = heights[stack.pop()]\n            w = heights_len if not stack else heights_len - stack[-1] - 1\n            max_area = max(max_area, h * w)\n        \n        return max_area"}, {"task_id": "maximal-rectangle", "completion": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        # 1. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u9762\u79ef\n        # 2. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 3. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 4. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        \n        # 1. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u9762\u79ef\n        max_area = 0\n        for i in range(n):\n            max_area = max(max_area, self.largestRectangleArea(matrix, i))\n        \n        # 2. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        heights = [0] * n\n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == '1':\n                    heights[j] += 1\n                else:\n                    heights[j] = 0\n            max_area = max(max_area, self.largestRectangleArea(heights))\n        \n        # 3. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        for i in range(m):\n            max_area = max(max_area, self.largestRectangleArea(matrix[i], heights))\n        \n        # 4. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        for i in range(m):\n            max_area = max(max_area, self.largestRectangleArea(matrix[i], heights))\n        \n        return max_area\n    \n    def largestRectangleArea(self, heights, heights_len=None):\n        if heights_len is None:\n            heights_len = len(heights)\n        \n        stack = []\n        max_area = 0\n        for i in range(heights_len):\n            while stack and heights[stack[-1]] > heights[i]:\n                h = heights[stack.pop()]\n                w = i if not stack else i - stack[-1] - 1\n                max_area = max(max_area, h * w)\n            stack.append(i)\n        \n        while stack:\n            h = heights[stack.pop()]\n            w = heights_len if not stack else heights_len - stack[-1] - 1\n            max_area = max(max_area, h * w)\n        \n        return max_area"}, {"task_id": "maximal-rectangle", "completion": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        heights = [0] * n\n        max_area = 0\n        \n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == '1':\n                    heights[j] += 1\n                else:\n                    heights[j] = 0\n            max_area = max(max_area, self.largestRectangleArea(heights))\n        \n        return max_area\n    \n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        max_area = 0\n        \n        for i in range(len(heights)):\n            while stack and heights[stack[-1]] > heights[i]:\n                h = heights[stack.pop()]\n                w = i if not stack else i - stack[-1] - 1\n                max_area = max(max_area, h * w)\n            stack.append(i)\n        \n        while stack:\n            h = heights[stack.pop()]\n            w = len(heights) if not stack else len(heights) - stack[-1] - 1\n            max_area = max(max_area, h * w)\n        \n        return max_area"}, {"task_id": "maximal-rectangle", "completion": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        # 1. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u9762\u79ef\n        # 2. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        # 3. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        # 4. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        \n        # 1. \u8ba1\u7b97\u6bcf\u4e00\u5217\u7684\u6700\u5927\u9762\u79ef\n        max_area = 0\n        for i in range(n):\n            max_area = max(max_area, self.largestRectangleArea(matrix, i))\n        \n        # 2. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\n        heights = [0] * n\n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == '1':\n                    heights[j] += 1\n                else:\n                    heights[j] = 0\n            max_area = max(max_area, self.largestRectangleArea(heights))\n        \n        # 3. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        for i in range(m):\n            max_area = max(max_area, self.largestRectangleArea(matrix[i], heights))\n        \n        # 4. \u8ba1\u7b97\u6bcf\u4e00\u884c\u7684\u9ad8\u5ea6\u5bf9\u5e94\u7684\u6700\u5927\u9762\u79ef\n        for i in range(m):\n            max_area = max(max_area, self.largestRectangleArea(matrix[i], heights))\n        \n        return max_area\n    \n    def largestRectangleArea(self, heights, heights_len=None):\n        if heights_len is None:\n            heights_len = len(heights)\n        \n        stack = []\n        max_area = 0\n        for i in range(heights_len):\n            while stack and heights[stack[-1]] > heights[i]:\n                h = heights[stack.pop()]\n                w = i if not stack else i - stack[-1] - 1\n                max_area = max(max_area, h * w)\n            stack.append(i)\n        \n        while stack:\n            h = heights[stack.pop()]\n            w = heights_len if not stack else heights_len - stack[-1] - 1\n            max_area = max(max_area, h * w)\n        \n        return max_area"}], "subsets": [{"task_id": "subsets", "completion": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(first = 0):\n            if len(subset) == k:\n                output.append(subset[:])\n            for i in range(first, len(nums)):\n                subset.append(nums[i])\n                backtrack(i + 1)\n                subset.pop()\n        \n        output = []\n        for k in range(len(nums) + 1):\n            backtrack()\n        return output"}, {"task_id": "subsets", "completion": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(first = 0):\n            if len(subset) == k:\n                output.append(subset[:])\n            for i in range(first, n):\n                subset.append(nums[i])\n                backtrack(i + 1)\n                subset.pop()\n        \n        output = []\n        n = len(nums)\n        for k in range(n + 1):\n            subset = []\n            backtrack()\n        return output"}, {"task_id": "subsets", "completion": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(first = 0):\n            if len(subset) == k:\n                output.append(subset[:])\n            for i in range(first, len(nums)):\n                subset.append(nums[i])\n                backtrack(i + 1)\n                subset.pop()\n        \n        output = []\n        for k in range(len(nums) + 1):\n            backtrack()\n        return output"}, {"task_id": "subsets", "completion": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(first = 0):\n            if len(subset) == k:\n                output.append(subset[:])\n            for i in range(first, len(nums)):\n                subset.append(nums[i])\n                backtrack(i + 1)\n                subset.pop()\n        \n        output = []\n        for k in range(len(nums) + 1):\n            backtrack()\n        return output"}, {"task_id": "subsets", "completion": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(first = 0):\n            if len(subset) == k:\n                output.append(subset[:])\n            for i in range(first, len(nums)):\n                subset.append(nums[i])\n                backtrack(i + 1)\n                subset.pop()\n        \n        output = []\n        for k in range(len(nums) + 1):\n            backtrack()\n        return output"}], "find-minimum-in-rotated-sorted-array-ii": [{"task_id": "find-minimum-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 1:\n            return nums[0]\n        \n        if nums[0] < nums[-1]:\n            return nums[0]\n        \n        left = 0\n        right = len(nums) - 1\n        \n        while left < right:\n            mid = (left + right) // 2\n            \n            if nums[mid] > nums[mid + 1]:\n                return nums[mid + 1]\n            \n            if nums[mid - 1] > nums[mid]:\n                return nums[mid]\n            \n            if nums[mid] < nums[left]:\n                right = mid - 1\n            else:\n                left = mid + 1\n                \n        return nums[left]"}, {"task_id": "find-minimum-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 1:\n            return nums[0]\n        \n        if nums[0] < nums[-1]:\n            return nums[0]\n        \n        left = 0\n        right = len(nums) - 1\n        \n        while left < right:\n            mid = (left + right) // 2\n            \n            if nums[mid] > nums[mid + 1]:\n                return nums[mid + 1]\n            \n            if nums[mid - 1] > nums[mid]:\n                return nums[mid]\n            \n            if nums[mid] > nums[0]:\n                left = mid + 1\n            else:\n                right = mid - 1\n                \n        return nums[0]"}, {"task_id": "find-minimum-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 1:\n            return nums[0]\n        \n        if nums[0] < nums[-1]:\n            return nums[0]\n        \n        left = 0\n        right = len(nums) - 1\n        \n        while left < right:\n            mid = (left + right) // 2\n            \n            if nums[mid] > nums[mid + 1]:\n                return nums[mid + 1]\n            \n            if nums[mid - 1] > nums[mid]:\n                return nums[mid]\n            \n            if nums[mid] < nums[left]:\n                right = mid - 1\n            else:\n                left = mid + 1\n                \n        return nums[left]"}, {"task_id": "find-minimum-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 1:\n            return nums[0]\n        \n        if nums[0] < nums[-1]:\n            return nums[0]\n        \n        left = 0\n        right = len(nums) - 1\n        \n        while left < right:\n            mid = (left + right) // 2\n            \n            if nums[mid] > nums[mid + 1]:\n                return nums[mid + 1]\n            \n            if nums[mid - 1] > nums[mid]:\n                return nums[mid]\n            \n            if nums[mid] < nums[left]:\n                right = mid - 1\n            else:\n                left = mid + 1\n                \n        return nums[left]"}, {"task_id": "find-minimum-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) == 1:\n            return nums[0]\n        \n        if nums[0] < nums[-1]:\n            return nums[0]\n        \n        left = 0\n        right = len(nums) - 1\n        \n        while left < right:\n            mid = (left + right) // 2\n            \n            if nums[mid] > nums[mid + 1]:\n                return nums[mid + 1]\n            \n            if nums[mid - 1] > nums[mid]:\n                return nums[mid]\n            \n            if nums[mid] > nums[left]:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return nums[left]"}], "valid-number": [{"task_id": "valid-number", "completion": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # 1. remove all spaces\n        s = s.strip()\n        \n        # 2. check if it is a valid number\n        if not s or len(s) == 0:\n            return False\n        \n        # 3. check if it is a valid integer\n        if s[0] == '-' or s[0] == '+':\n            s = s[1:]\n        \n        if s[0] == 'e':\n            return False\n        \n        if s[0] == '.':\n            return False\n        \n        if s[0] == '+' or s[0] == '-':\n            s = s[1:]\n        \n        if s[0] == 'e':\n            return False\n        \n        if s[0] == '.':\n            return False\n        \n        if s[0] == '+' or s[0] == '-':\n            s = s[1:]\n        \n        if s[0] == 'e':\n            return False\n        \n        if s[0] == '.':\n            return False\n        \n        if s[0] == '+' or s[0] == '-':\n            s = s[1:]\n        \n        if s[0] == 'e':\n            return False\n        \n        if s[0] == '.':\n            return False\n        \n        if s[0] == '+' or s[0] == '-':\n            s = s[1:]\n        \n        if s[0] == 'e':\n            return False\n        \n        if s[0] == '.':\n            return False\n        \n        if s[0] == '+' or s[0] == '-':\n            s = s[1:]\n        \n        if s[0] == 'e':\n            return False\n        \n        if s[0] == '.':\n            return False\n        \n        if s[0] == '+' or s[0] == '-':\n            s = s[1:]\n        \n        if s[0] == 'e':\n            return False\n        \n        if s[0] == '.':\n            return False\n        \n        if s[0] == '+' or s[0] == '-':\n            s = s[1:]\n        \n        if s[0] == 'e':\n            return False\n        \n        if s[0] == '.':\n            return False\n        \n        if s[0] == '+' or s[0] == '-':\n            s = s[1:]\n        \n        if s[0] == 'e':\n            return False\n        \n        if s[0] == '.':\n            return False\n        \n        if s[0] == '+' or s[0] == '-':\n            s = s[1:]\n        \n        if s[0] == 'e':\n            return False\n        \n        if s[0] == '.':\n            return False\n        \n        if s[0] == '+' or s[0] == '-':\n            s = s[1:]\n        \n        if s[0] == 'e':\n            return False\n        \n        if s[0] == '.':\n            return False\n        \n        if s[0] == '+' or s[0] == '-':\n            s = s[1:]\n        \n        if s[0] == 'e':\n            return False\n        \n        if s[0] == '.':\n            return False\n        \n        if s[0] == '+' or s[0] == '-':\n            s = s[1:]\n        \n        if s[0] == 'e':\n            return False\n        \n        if s[0] == '.':\n            return False\n        \n        if s[0] == '+' or s[0] == '-':\n            s = s[1:]\n        \n        if s[0] == 'e':\n            return False\n        \n        if s[0] == '.':\n            return False\n        \n        if s[0] == '+' or s[0] == '-':\n            s = s[1:]\n        \n        if s[0] == 'e':\n            return False\n        \n        if s[0] == '.':\n            return False\n        \n        if s[0] == '+' or s[0] == '-':\n            s = s[1:]"}, {"task_id": "valid-number", "completion": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # 1. remove all spaces\n        s = s.strip()\n        \n        # 2. check if it is a valid number\n        if not s or s[0] not in '+-' and (s[0] not in '0123456789'):\n            return False\n        \n        # 3. check if it is a valid integer\n        if s[0] in '+-' and len(s) > 1:\n            s = s[1:]\n            if not s or s[0] not in '0123456789':\n                return False\n        \n        # 4. check if it is a valid decimal\n        if 'e' in s:\n            s = s.split('e')\n            if len(s) != 2:\n                return False\n            if not s[0] or not s[1]:\n                return False\n            if s[0][0] not in '+-' and (s[0][0] not in '0123456789'):\n                return False\n            if s[1][0] not in '0123456789':\n                return False\n        \n        # 5. check if it is a valid float\n        if '.' in s:\n            s = s.split('.')\n            if len(s) != 2:\n                return False\n            if not s[0] or not s[1]:\n                return False\n            if s[0][0] not in '+-' and (s[0][0] not in '0123456789'):\n                return False\n            if s[1][0] not in '0123456789':\n                return False\n        \n        return True"}, {"task_id": "valid-number", "completion": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # 1. remove all spaces\n        s = s.strip()\n        \n        # 2. check if it is a valid number\n        if not s or s[0] not in '+-' and (s[0] not in '0123456789' or len(s) == 1):\n            return False\n        \n        # 3. check if it is a valid integer\n        if s[0] in '+-' and len(s) > 1:\n            s = s[1:]\n            if not s or s[0] not in '0123456789' or len(s) == 1:\n                return False\n        \n        # 4. check if it is a valid decimal\n        if s[0] in '+-' and len(s) > 1:\n            s = s[1:]\n            if s[0] not in '0123456789' and s[1] != '.':\n                return False\n            if len(s) > 2 and s[1] == '.':\n                return False\n            if len(s) > 3 and s[2] not in '0123456789':\n                return False\n            if len(s) > 3 and s[1] == '.' and s[2] not in '0123456789':\n                return False\n        \n        # 5. check if it is a valid exponential\n        if s[0] in '+-' and len(s) > 1:\n            s = s[1:]\n            if s[0] not in '0123456789' and s[1] != 'e':\n                return False\n            if len(s) > 2 and s[1] == 'e':\n                return False\n            if len(s) > 3 and s[2] not in '0123456789':\n                return False\n            if len(s) > 3 and s[1] == 'e' and s[2] not in '0123456789':\n                return False\n        \n        # 6. check if it is a valid number\n        return True"}, {"task_id": "valid-number", "completion": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # 1. remove all spaces\n        s = s.strip()\n        \n        # 2. check if it is a valid number\n        if not s or s[0] not in ('+', '-') and not s[0].isdigit():\n            return False\n        \n        # 3. check if it is a valid integer\n        if s[0] in ('+', '-') and len(s) > 1 and s[1] in ('+', '-') and s[1] != '.' and s[1].isdigit():\n            return False\n        \n        # 4. check if it is a valid decimal\n        if s[0] not in ('+', '-') and s[0] != '.' and s[0].isdigit():\n            if s[1] not in ('+', '-') and s[1] != '.' and s[1].isdigit():\n                return False\n            else:\n                return True\n        \n        # 5. check if it is a valid exponential\n        if s[0] not in ('+', '-') and s[0] != '.' and s[0].isdigit():\n            if s[1] not in ('+', '-') and s[1] != '.' and s[1].isdigit():\n                return False\n            else:\n                if s[2] not in ('+', '-') and s[2] != '.' and s[2].isdigit():\n                    return False\n                else:\n                    return True\n        \n        # 6. check if it is a valid integer\n        if s[0] in ('+', '-') and len(s) > 1 and s[1] in ('+', '-') and s[1] != '.' and s[1].isdigit():\n            return False\n        \n        # 7. check if it is a valid decimal\n        if s[0] not in ('+', '-') and s[0] != '.' and s[0].isdigit():\n            if s[1] not in ('+', '-') and s[1] != '.' and s[1].isdigit():\n                return False\n            else:\n                return True\n        \n        # 8. check if it is a valid exponential\n        if s[0] not in ('+', '-') and s[0] != '.' and s[0].isdigit():\n            if s[1] not in ('+', '-') and s[1] != '.' and s[1].isdigit():\n                return False\n            else:\n                if s[2] not in ('+', '-') and s[2] != '.' and s[2].isdigit():\n                    return False\n                else:\n                    return True\n        \n        # 9. check if it is a valid integer\n        if s[0] in ('+', '-') and len(s) > 1 and s[1] in ('+', '-') and s[1] != '.' and s[1].isdigit():\n            return False\n        \n        # 10. check if it is a valid decimal\n        if s[0] not in ('+', '-') and s[0] != '.' and s[0].isdigit():\n            if s[1] not in ('+', '-') and s[1] != '.' and s[1].isdigit():\n                return False\n            else:\n                return True\n        \n        # 11. check if it is a valid exponential\n        if s[0] not in ('+', '-') and s[0] != '.' and s[0].isdigit():\n            if s[1] not in ('+', '-') and s[1] != '.' and s[1].isdigit():\n                return False\n            else:\n                if s[2] not in ('+', '-') and s[2] != '.' and s[2].isdigit():\n                    return False\n                else:\n                    return True\n        \n        # 12. check if it is a valid integer\n        if s[0] in ('+', '-') and len(s) > 1 and s[1] in ('+', '-') and s[1] != '.' and s[1].isdigit():\n            return False\n        \n        # 13. check if it is a valid decimal\n        if s["}, {"task_id": "valid-number", "completion": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # 1. remove all spaces\n        s = s.strip()\n        \n        # 2. check if it is a valid number\n        if not s or s[0] not in '+-' and (s[0] not in '0123456789' or len(s) == 1):\n            return False\n        \n        # 3. check if it is a valid integer\n        if s[0] in '+-' and len(s) > 1:\n            s = s[1:]\n        if not s or s[0] not in '0123456789' or len(s) == 1:\n            return False\n        \n        # 4. check if it is a valid decimal\n        if 'e' in s:\n            s = s.split('e')\n            if len(s) != 2:\n                return False\n            if not s[0] or not s[1]:\n                return False\n            if s[0][0] not in '+-' and (s[0][0] not in '0123456789' or len(s[0]) == 1):\n                return False\n            if s[1][0] not in '0123456789' or len(s[1]) == 1:\n                return False\n        \n        # 5. check if it is a valid float\n        if '.' in s:\n            s = s.split('.')\n            if len(s) != 2:\n                return False\n            if not s[0] or not s[1]:\n                return False\n            if s[0][0] not in '+-' and (s[0][0] not in '0123456789' or len(s[0]) == 1):\n                return False\n            if s[1][0] not in '0123456789' or len(s[1]) == 1:\n                return False\n        \n        return True"}], "integer-to-roman": [{"task_id": "integer-to-roman", "completion": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # 2. I, II, III, IV, V, VI, VII, VIII, IX, X, XX, XXX, XL, L, XC, LX, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C"}, {"task_id": "integer-to-roman", "completion": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, II, III, IV, V, VI, VII, VIII, IX, X, XX, XXX, XL, L, XC, LX, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX"}, {"task_id": "integer-to-roman", "completion": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        # 1000 - M\n        # 900 - CM\n        # 500 - D\n        # 400 - CD\n        # 100 - C\n        # 90 - XC\n        # 50 - L\n        # 40 - XL\n        # 10 - X\n        # 9 - IX\n        # 5 - V\n        # 4 - IV\n        # 1 - I\n        \n        # 1000 - M\n        # 900 - CM\n        # 500 - D\n        # 400 - CD\n        # 100 - C\n        # 90 - XC\n        # 50 - L\n        # 40 - XL\n        # 10 - X\n        # 9 - IX\n        # 5 - V\n        # 4 - IV\n        # 1 - I\n        \n        # 1000 - M\n        # 900 - CM\n        # 500 - D\n        # 400 - CD\n        # 100 - C\n        # 90 - XC\n        # 50 - L\n        # 40 - XL\n        # 10 - X\n        # 9 - IX\n        # 5 - V\n        # 4 - IV\n        # 1 - I\n        \n        # 1000 - M\n        # 900 - CM\n        # 500 - D\n        # 400 - CD\n        # 100 - C\n        # 90 - XC\n        # 50 - L\n        # 40 - XL\n        # 10 - X\n        # 9 - IX\n        # 5 - V\n        # 4 - IV\n        # 1 - I\n        \n        # 1000 - M\n        # 900 - CM\n        # 500 - D\n        # 400 - CD\n        # 100 - C\n        # 90 - XC\n        # 50 - L\n        # 40 - XL\n        # 10 - X\n        # 9 - IX\n        # 5 - V\n        # 4 - IV\n        # 1 - I\n        \n        # 1000 - M\n        # 900 - CM\n        # 500 - D\n        # 400 - CD\n        # 100 - C\n        # 90 - XC\n        # 50 - L\n        # 40 - XL\n        # 10 - X\n        # 9 - IX\n        # 5 - V\n        # 4 - IV\n        # 1 - I\n        \n        # 1000 - M\n        # 900 - CM\n        # 500 - D\n        # 400 - CD\n        # 100 - C\n        # 90 - XC\n        # 50 - L\n        # 40 - XL\n        # 10 - X\n        # 9 - IX\n        # 5 - V\n        # 4 - IV\n        # 1 - I\n        \n        # 1000 - M\n        # 900 - CM\n        # 500 - D\n        # 400 - CD\n        # 100 - C\n        # 90 - XC\n        # 50 - L\n        # 40 - XL\n        # 10 - X\n        # 9 - IX\n        # 5 - V\n        # 4 - IV\n        # 1 - I\n        \n        # 1000 - M\n        # 900 - CM\n        # 500 - D\n        # 400 - CD\n        # 100 - C\n        # 90 - XC\n        # 50 - L\n        # 40 - XL\n        # 10 - X\n        # 9 - IX\n        # 5 - V\n        # 4 - IV\n        # 1 - I\n        \n        # 1000 - M\n        # 900 - CM\n        # 500 - D\n        # 400"}, {"task_id": "integer-to-roman", "completion": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. 1000 - M\n        # 2. 900 - CM\n        # 3. 500 - D\n        # 4. 400 - CD\n        # 5. 100 - C\n        # 6. 90 - XC\n        # 7. 50 - L\n        # 8. 40 - XL\n        # 9. 10 - X\n        # 10. 9 - IX\n        # 11. 5 - V\n        # 12. 4 - IV\n        # 13. 1 - I\n        \n        # 1. 1000 - M\n        # 2. 900 - CM\n        # 3. 500 - D\n        # 4. 400 - CD\n        # 5. 100 - C\n        # 6. 90 - XC\n        # 7. 50 - L\n        # 8. 40 - XL\n        # 9. 10 - X\n        # 10. 9 - IX\n        # 11. 5 - V\n        # 12. 4 - IV\n        # 13. 1 - I\n        \n        # 1. 1000 - M\n        # 2. 900 - CM\n        # 3. 500 - D\n        # 4. 400 - CD\n        # 5. 100 - C\n        # 6. 90 - XC\n        # 7. 50 - L\n        # 8. 40 - XL\n        # 9. 10 - X\n        # 10. 9 - IX\n        # 11. 5 - V\n        # 12. 4 - IV\n        # 13. 1 - I\n        \n        # 1. 1000 - M\n        # 2. 900 - CM\n        # 3. 500 - D\n        # 4. 400 - CD\n        # 5. 100 - C\n        # 6. 90 - XC\n        # 7. 50 - L\n        # 8. 40 - XL\n        # 9. 10 - X\n        # 10. 9 - IX\n        # 11. 5 - V\n        # 12. 4 - IV\n        # 13. 1 - I\n        \n        # 1. 1000 - M\n        # 2. 900 - CM\n        # 3. 500 - D\n        # 4. 400 - CD\n        # 5. 100 - C\n        # 6. 90 - XC\n        # 7. 50 - L\n        # 8. 40 - XL\n        # 9. 10 - X\n        # 10. 9 - IX\n        # 11. 5 - V\n        # 12. 4 - IV\n        # 13. 1 - I\n        \n        # 1. 1000 - M\n        # 2. 900 - CM\n        # 3. 500 - D\n        # 4. 400 - CD\n        # 5. 100 - C\n        # 6. 90 - XC\n        # 7. 50 - L\n        # 8. 40 - XL\n        # 9. 10 - X\n        # 10. 9 - IX\n        # 11. 5 - V\n        # 12. 4 - IV\n        # 13. 1 - I\n        \n        # 1. 1000 - M\n        # 2. 900 - CM\n        # 3. 500 - D\n        # 4. 400 - CD\n        # 5. 100 - C\n        # 6. 90 - XC\n        # 7. 50 - L\n        # 8. 40 - XL\n        # 9. 10 - X"}, {"task_id": "integer-to-roman", "completion": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # I, II, III, IV, V, VI, VII, VIII, IX, X, XX, XXX, XL, L, XC, LX, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX, XC, C, XL, LXX"}], "find-the-difference": [{"task_id": "find-the-difference", "completion": "class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        ## Solution 1:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 12 ms, faster than 99.45% of Python online submissions for Find the Difference.\n        ## Memory Usage: 13.3 MB, less than 100.00% of Python online submissions for Find the Difference.\n        \n        ## Solution 2:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 12 ms, faster than 99.45% of Python online submissions for Find the Difference.\n        ## Memory Usage: 13.3 MB, less than 100.00% of Python online submissions for Find the Difference.\n        \n        ## Solution 3:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 12 ms, faster than 99.45% of Python online submissions for Find the Difference.\n        ## Memory Usage: 13.3 MB, less than 100.00% of Python online submissions for Find the Difference.\n        \n        ## Solution 4:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 12 ms, faster than 99.45% of Python online submissions for Find the Difference.\n        ## Memory Usage: 13.3 MB, less than 100.00% of Python online submissions for Find the Difference.\n        \n        ## Solution 5:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 12 ms, faster than 99.45% of Python online submissions for Find the Difference.\n        ## Memory Usage: 13.3 MB, less than 100.00% of Python online submissions for Find the Difference.\n        \n        ## Solution 6:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 12 ms, faster than 99.45% of Python online submissions for Find the Difference.\n        ## Memory Usage: 13.3 MB, less than 100.00% of Python online submissions for Find the Difference.\n        \n        ## Solution 7:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 12 ms, faster than 99.45% of Python online submissions for Find the Difference.\n        ## Memory Usage: 13.3 MB, less than 100.00% of Python online submissions for Find the Difference.\n        \n        ## Solution 8:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 12 ms, faster than 99.45% of Python online submissions for Find the Difference.\n        ## Memory Usage: 13.3 MB, less than 100.00% of Python online submissions for Find the Difference.\n        \n        ## Solution 9:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 12 ms, faster than 99.45% of Python online submissions for Find the Difference.\n        ## Memory Usage: 13.3 MB, less than 100.00% of Python online submissions for Find the Difference.\n        \n        ## Solution 10:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 12 ms, faster than 99.45% of Python online submissions for Find the Difference.\n        ## Memory Usage: 13.3 MB, less than 100."}, {"task_id": "find-the-difference", "completion": "class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        ## 1st method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 2nd method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 3rd method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 4th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 5th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 6th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 7th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 8th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 9th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 10th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 11th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 12th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 13th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 14th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 15th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 16th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 17th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 18th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 19th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 20th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 21th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 22th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 23th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 24th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 25th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 26th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 27th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 28th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 29th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 30th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 31th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 32th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 33th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 34th method"}, {"task_id": "find-the-difference", "completion": "class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        ## 1st method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2nd method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 3rd method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 4th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 5th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 6th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 7th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 8th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 9th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 10th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 11th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 12th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 13th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 14th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 15th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 16th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 17th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 18th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 19th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 20th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 21th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 22th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 23th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 24th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 25th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 26th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 27th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 28th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 29th method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 30th method\n        ## Time Complexity: O"}, {"task_id": "find-the-difference", "completion": "class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        ## 1st method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## 2nd method\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        \n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        ## 1st method\n        #"}, {"task_id": "find-the-difference", "completion": "class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        ## 1st method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 2nd method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 3rd method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 4th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 5th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 6th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 7th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 8th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 9th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 10th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 11th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 12th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 13th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 14th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 15th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 16th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 17th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 18th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 19th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 20th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 21th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 22th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 23th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 24th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 25th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 26th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 27th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 28th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 29th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 30th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 31th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 32th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 33th method\n        ## time complexity: O(n)\n        ## space complexity: O(1)\n        ## 34th method"}], "sudoku-solver": [{"task_id": "sudoku-solver", "completion": "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def find_empty_location(board,l):\n            for row in range(9):\n                for col in range(9):\n                    if board[row][col] == '.':\n                        l[0] = row\n                        l[1] = col\n                        return True\n            return False\n        \n        def used_in_row(board,row,num):\n            for col in range(9):\n                if board[row][col] == num:\n                    return True\n            return False\n        \n        def used_in_col(board,col,num):\n            for row in range(9):\n                if board[row][col] == num:\n                    return True\n            return False\n        \n        def used_in_box(board,row,col,num):\n            for i in range(3):\n                for j in range(3):\n                    if board[i+row][j+col] == num:\n                        return True\n            return False\n        \n        def is_valid(board,row,col,num):\n            return not used_in_row(board,row,num) and not used_in_col(board,col,num) and not used_in_box(board,row - row%3,col - col%3,num)\n        \n        def solve_sudoku(board):\n            l = [0,0]\n            if not find_empty_location(board,l):\n                return True\n            row = l[0]\n            col = l[1]\n            for num in range(1,10):\n                if is_valid(board,row,col,str(num)):\n                    board[row][col] = str(num)\n                    if solve_sudoku(board):\n                        return True\n                    board[row][col] = '.'\n            return False\n        \n        solve_sudoku(board)"}, {"task_id": "sudoku-solver", "completion": "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def find_empty_location(board,l):\n            for row in range(9):\n                for col in range(9):\n                    if board[row][col] == '.':\n                        l[0] = row\n                        l[1] = col\n                        return True\n            return False\n        \n        def used_in_row(board,row,num):\n            for col in range(9):\n                if board[row][col] == num:\n                    return True\n            return False\n        \n        def used_in_col(board,col,num):\n            for row in range(9):\n                if board[row][col] == num:\n                    return True\n            return False\n        \n        def used_in_box(board,row,col,num):\n            for i in range(3):\n                for j in range(3):\n                    if board[i+row][j+col] == num:\n                        return True\n            return False\n        \n        def used_in_board(board,row,col,num):\n            for i in range(3):\n                for j in range(3):\n                    if board[i+row][j+col] == num:\n                        return True\n            return False\n        \n        def solve(board):\n            l = [0,0]\n            if not find_empty_location(board,l):\n                return True\n            row = l[0]\n            col = l[1]\n            \n            for num in range(1,10):\n                if not used_in_row(board,row,num) and not used_in_col(board,col,num) and not used_in_box(board,row-row%3,col-col%3,num) and not used_in_board(board,row-row%3,col-col%3,num):\n                    board[row][col] = num\n                    if solve(board):\n                        return True\n                    board[row][col] = '.'\n            return False\n        \n        solve(board)"}, {"task_id": "sudoku-solver", "completion": "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def find_empty_location(board,l):\n            for row in range(9):\n                for col in range(9):\n                    if board[row][col] == '.':\n                        l[0] = row\n                        l[1] = col\n                        return True\n            return False\n        \n        def used_in_row(board,row,num):\n            for col in range(9):\n                if board[row][col] == num:\n                    return True\n            return False\n        \n        def used_in_col(board,col,num):\n            for row in range(9):\n                if board[row][col] == num:\n                    return True\n            return False\n        \n        def used_in_box(board,row,col,num):\n            for i in range(3):\n                for j in range(3):\n                    if board[i+row][j+col] == num:\n                        return True\n            return False\n        \n        def used_in_board(board,row,col,num):\n            for i in range(3):\n                for j in range(3):\n                    if board[i+row][j+col] == num:\n                        return True\n            return False\n        \n        def solve(board):\n            l = [0,0]\n            if not find_empty_location(board,l):\n                return True\n            row = l[0]\n            col = l[1]\n            for num in range(1,10):\n                if not used_in_row(board,row,num) and not used_in_col(board,col,num) and not used_in_box(board,row-row%3,col-col%3,num) and not used_in_board(board,row-row%3,col-col%3,num):\n                    board[row][col] = num\n                    if solve(board):\n                        return True\n                    board[row][col] = '.'\n            return False\n        \n        solve(board)"}, {"task_id": "sudoku-solver", "completion": "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def find_empty_location(board,l):\n            for row in range(9):\n                for col in range(9):\n                    if board[row][col] == '.':\n                        l[0] = row\n                        l[1] = col\n                        return True\n            return False\n        \n        def used_in_row(board,row,num):\n            for col in range(9):\n                if board[row][col] == num:\n                    return True\n            return False\n        \n        def used_in_col(board,col,num):\n            for row in range(9):\n                if board[row][col] == num:\n                    return True\n            return False\n        \n        def used_in_box(board,row,col,num):\n            for i in range(3):\n                for j in range(3):\n                    if board[i+row][j+col] == num:\n                        return True\n            return False\n        \n        def used_in_board(board,row,col,num):\n            for i in range(3):\n                for j in range(3):\n                    if board[i+row][j+col] == num:\n                        return True\n            return False\n        \n        def solve(board):\n            l = [0,0]\n            if not find_empty_location(board,l):\n                return True\n            row = l[0]\n            col = l[1]\n            \n            for num in range(1,10):\n                if not used_in_row(board,row,num) and not used_in_col(board,col,num) and not used_in_box(board,row-row%3,col-col%3,num) and not used_in_board(board,row-row%3,col-col%3,num):\n                    board[row][col] = num\n                    if solve(board):\n                        return True\n                    board[row][col] = '.'\n            return False\n        \n        solve(board)"}, {"task_id": "sudoku-solver", "completion": "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def find_empty_location(board,l):\n            for row in range(9):\n                for col in range(9):\n                    if board[row][col] == '.':\n                        l[0] = row\n                        l[1] = col\n                        return True\n            return False\n        \n        def used_in_row(board,row,num):\n            for col in range(9):\n                if board[row][col] == num:\n                    return True\n            return False\n        \n        def used_in_col(board,col,num):\n            for row in range(9):\n                if board[row][col] == num:\n                    return True\n            return False\n        \n        def used_in_box(board,row,col,num):\n            for i in range(3):\n                for j in range(3):\n                    if board[i+row][j+col] == num:\n                        return True\n            return False\n        \n        def used_in_board(board,row,col,num):\n            for i in range(3):\n                for j in range(3):\n                    if board[i+row][j+col] == num:\n                        return True\n            return False\n        \n        def solve(board):\n            l = [0,0]\n            if not find_empty_location(board,l):\n                return True\n            row = l[0]\n            col = l[1]\n            \n            for num in range(1,10):\n                if not used_in_row(board,row,num) and not used_in_col(board,col,num) and not used_in_box(board,row-row%3,col-col%3,num) and not used_in_board(board,row-row%3,col-col%3,num):\n                    board[row][col] = num\n                    if solve(board):\n                        return True\n                    board[row][col] = '.'\n            return False\n        \n        solve(board)"}], "recover-binary-search-tree": [{"task_id": "recover-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        # swap the values of the two nodes\n        \n        # find the first node that is smaller than its parent\n        # find the second node that is larger than its parent\n        #"}, {"task_id": "recover-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # find the first and second node\n        first = None\n        second = None\n        prev = None\n        \n        def inorder(root):\n            nonlocal first, second, prev\n            if not root:\n                return\n            \n            inorder(root.left)\n            \n            if prev and prev.val > root.val:\n                if not first:\n                    first = prev\n                second = root\n            \n            prev = root\n            inorder(root.right)\n        \n        inorder(root)\n        \n        # swap the values\n        first.val, second.val = second.val, first.val\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # find the first and second node\n        first = None\n        second = None\n        prev = None\n        \n        def inorder(root):\n            nonlocal first, second, prev\n            if not root:\n                return\n            \n            inorder(root.left)\n            \n            if prev and prev.val > root.val:\n                if not first:\n                    first = prev\n                second = root\n            \n            prev = root\n            inorder(root.right)\n        \n        inorder(root)\n        \n        # swap the values\n        first.val, second.val = second.val, first.val\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # find the first and second node\n        first = None\n        second = None\n        prev = None\n        \n        def inorder(root):\n            nonlocal first, second, prev\n            if not root:\n                return\n            \n            inorder(root.left)\n            \n            if prev and prev.val > root.val:\n                if not first:\n                    first = prev\n                second = root\n            \n            prev = root\n            inorder(root.right)\n        \n        inorder(root)\n        \n        # swap the values\n        first.val, second.val = second.val, first.val\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # find the first and second node\n        first = None\n        second = None\n        prev = None\n        \n        def inorder(root):\n            nonlocal first, second, prev\n            if not root:\n                return\n            \n            inorder(root.left)\n            \n            if prev and prev.val > root.val:\n                if not first:\n                    first = prev\n                second = root\n            \n            prev = root\n            inorder(root.right)\n        \n        inorder(root)\n        \n        # swap the values\n        first.val, second.val = second.val, first.val\n\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify"}, {"task_id": "recover-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # find the two nodes that are swapped\n        # find the first node that is smaller than the second node\n        # find the second node that is larger than the first node\n        # swap the two nodes\n        \n        # find the two nodes that are swapped\n        # find the first node that is smaller than the second node\n        # find the second node that is larger than the first node\n        # swap the two nodes\n        \n        # find the two nodes that are swapped\n        # find the first node that is smaller than the second node\n        # find the second node that is larger than the first node\n        # swap the two nodes\n        \n        # find the two nodes that are swapped\n        # find the first node that is smaller than the second node\n        # find the second node that is larger than the first node\n        # swap the two nodes\n        \n        # find the two nodes that are swapped\n        # find the first node that is smaller than the second node\n        # find the second node that is larger than the first node\n        # swap the two nodes\n        \n        # find the two nodes that are swapped\n        # find the first node that is smaller than the second node\n        # find the second node that is larger than the first node\n        # swap the two nodes\n        \n        # find the two nodes that are swapped\n        # find the first node that is smaller than the second node\n        # find the second node that is larger than the first node\n        # swap the two nodes\n        \n        # find the two nodes that are swapped\n        # find the first node that is smaller than the second node\n        # find the second node that is larger than the first node\n        # swap the two nodes\n        \n        # find the two nodes that are swapped\n        # find the first node that is smaller than the second node\n        # find the second node that is larger than the first node\n        # swap the two nodes\n        \n        # find the two nodes that are swapped\n        # find the first node that is smaller than the second node\n        # find the second node that is larger than the first node\n        # swap the two nodes\n        \n        # find the two nodes that are swapped\n        # find the first node that is smaller than the second node\n        # find the second node that is larger than the first node\n        # swap the two nodes\n        \n        # find the two nodes that are swapped\n        # find the first node that is smaller than the second node\n        # find the second node that is larger than the first node\n        # swap the two nodes\n        \n        # find the two nodes that are swapped\n        # find the first node that is smaller than the second node\n        # find the second node that is larger than the first node\n        # swap the two nodes\n        \n        # find the two nodes that are swapped\n        # find the first node that is smaller than the second node\n        # find the second node that is larger than the first node\n        # swap the two nodes\n        \n        # find the two nodes that are swapped\n        # find the first node that is smaller than the second node\n        # find the second node that is larger than the first node\n        # swap the two nodes\n        \n        # find the two nodes that are swapped\n        # find the first node that is smaller than the second node\n        # find the second node that is larger than the first node\n        # swap the two nodes\n        \n        # find the two nodes that are swapped\n        # find the first node that is smaller than the second node\n        # find the second node that is larger than the first node\n        # swap the two nodes\n        \n        # find the two nodes that are swapped\n        # find the first node that is smaller than the second node\n        # find the second node that is larger than the first node\n        # swap the two nodes\n        \n        # find the two nodes that are swapped\n        # find the first node that is smaller than the second node\n        # find the second node that is larger than the first node\n        # swap the two nodes\n        \n        # find the two nodes that are swapped\n        # find the first node that is smaller than the second node\n        # find the second node that is larger than the first node\n        # swap the two nodes\n        \n        # find the two nodes that are swapped\n        # find the first node that is smaller than the second node\n        # find the second node that is larger than the first node\n        # swap the two nodes\n        \n        # find the two nodes that are swapped\n        # find the first"}, {"task_id": "recover-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # find the two nodes that are swapped\n        # find the first node that is smaller than the second node\n        # find the second node that is larger than the first node\n        # swap the values of the two nodes\n        \n        # find the two nodes that are swapped\n        # find the first node that is smaller than the second node\n        # find the second node that is larger than the first node\n        # swap the values of the two nodes\n        \n        # find the two nodes that are swapped\n        # find the first node that is smaller than the second node\n        # find the second node that is larger than the first node\n        # swap the values of the two nodes\n        \n        # find the two nodes that are swapped\n        # find the first node that is smaller than the second node\n        # find the second node that is larger than the first node\n        # swap the values of the two nodes\n        \n        # find the two nodes that are swapped\n        # find the first node that is smaller than the second node\n        # find the second node that is larger than the first node\n        # swap the values of the two nodes\n        \n        # find the two nodes that are swapped\n        # find the first node that is smaller than the second node\n        # find the second node that is larger than the first node\n        # swap the values of the two nodes\n        \n        # find the two nodes that are swapped\n        # find the first node that is smaller than the second node\n        # find the second node that is larger than the first node\n        # swap the values of the two nodes\n        \n        # find the two nodes that are swapped\n        # find the first node that is smaller than the second node\n        # find the second node that is larger than the first node\n        # swap the values of the two nodes\n        \n        # find the two nodes that are swapped\n        # find the first node that is smaller than the second node\n        # find the second node that is larger than the first node\n        # swap the values of the two nodes\n        \n        # find the two nodes that are swapped\n        # find the first node that is smaller than the second node\n        # find the second node that is larger than the first node\n        # swap the values of the two nodes\n        \n        # find the two nodes that are swapped\n        # find the first node that is smaller than the second node\n        # find the second node that is larger than the first node\n        # swap the values of the two nodes\n        \n        # find the two nodes that are swapped\n        # find the first node that is smaller than the second node\n        # find the second node that is larger than the first node\n        # swap the values of the two nodes\n        \n        # find the two nodes that are swapped\n        # find the first node that is smaller than the second node\n        # find the second node that is larger than the first node\n        # swap the values of the two nodes\n        \n        # find the two nodes that are swapped\n        # find the first node that is smaller than the second node\n        # find the second node that is larger than the first node\n        # swap the values of the two nodes\n        \n        # find the two nodes that are swapped\n        # find the first node that is smaller than the second node\n        # find the second node that is larger than the first node\n        # swap the values of the two nodes\n        \n        # find the two nodes that are swapped\n        # find the first node that is smaller than the second node\n        # find the second node that is larger than the first node\n        # swap the values of the two nodes\n        \n        # find the two nodes that are swapped\n        # find the first node that is smaller than the second node\n        # find the second node that is larger than the first node\n        # swap the values of the two nodes\n        \n        # find the two nodes that are swapped\n        # find the first node that is smaller than the second node\n        # find the second node that is larger than the first node\n        # swap the values of the two nodes\n        \n        # find the two nodes that are swapped\n        # find the first node that is smaller than the second node\n        # find the second node that is larger than the first node\n        # swap the values of the two nodes\n        \n        # find the two nodes that are swapped\n        # find the first node that is smaller than the second node\n        # find the second node that is larger than the first node\n        # swap the values of the two nodes\n        \n        # find the"}, {"task_id": "recover-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # inorder traversal\n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        # swap the values of the two nodes\n        \n        # find the first node that is smaller than its parent\n        # find the second node that is bigger than its parent\n        #"}], "palindrome-linked-list": [{"task_id": "palindrome-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        \n        # find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the list\n        prev = None\n        while slow:\n            nxt = slow.next\n            slow.next = prev\n            prev = slow\n            slow = nxt\n        \n        # compare the first half with the second half\n        while prev:\n            if prev.val != head.val:\n                return False\n            prev = prev.next\n            head = head.next\n        \n        return True"}, {"task_id": "palindrome-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        \n        # find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the list\n        prev = None\n        while slow:\n            nxt = slow.next\n            slow.next = prev\n            prev = slow\n            slow = nxt\n        \n        # compare the first half with the second half\n        while prev:\n            if prev.val != head.val:\n                return False\n            prev = prev.next\n            head = head.next\n        \n        return True"}, {"task_id": "palindrome-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        \n        # find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the list\n        prev = None\n        while slow:\n            nxt = slow.next\n            slow.next = prev\n            prev = slow\n            slow = nxt\n        \n        # compare the first half with the second half\n        while prev:\n            if prev.val != head.val:\n                return False\n            prev = prev.next\n            head = head.next\n        \n        return True"}, {"task_id": "palindrome-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        \n        # find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the list\n        prev = None\n        while slow:\n            nxt = slow.next\n            slow.next = prev\n            prev = slow\n            slow = nxt\n        \n        # compare the first half with the second half\n        while prev:\n            if prev.val != head.val:\n                return False\n            prev = prev.next\n            head = head.next\n        \n        return True"}, {"task_id": "palindrome-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        \n        # find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the list\n        prev = None\n        while slow:\n            nxt = slow.next\n            slow.next = prev\n            prev = slow\n            slow = nxt\n        \n        # compare the first half with the second half\n        while prev:\n            if prev.val != head.val:\n                return False\n            prev = prev.next\n            head = head.next\n        \n        return True"}], "valid-perfect-square": [{"task_id": "valid-perfect-square", "completion": "class Solution(object):\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return True\n        \n        i = 1\n        while i * i < num:\n            i += 1\n        \n        return i * i == num"}, {"task_id": "valid-perfect-square", "completion": "class Solution(object):\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return True\n        \n        i = 1\n        while i * i < num:\n            i += 1\n        \n        return i * i == num"}, {"task_id": "valid-perfect-square", "completion": "class Solution(object):\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return True\n        \n        i = 1\n        while i * i < num:\n            i += 1\n        \n        return i * i == num"}, {"task_id": "valid-perfect-square", "completion": "class Solution(object):\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return True\n        \n        i = 1\n        while i * i < num:\n            i += 1\n        \n        return i * i == num"}, {"task_id": "valid-perfect-square", "completion": "class Solution(object):\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return True\n        \n        i = 1\n        while i * i < num:\n            i += 1\n        \n        if i * i == num:\n            return True\n        \n        return False"}], "counting-bits": [{"task_id": "counting-bits", "completion": "class Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if n == 0:\n            return [0]\n        \n        if n == 1:\n            return [0,1]\n        \n        ans = [0,1]\n        for i in range(2,n+1):\n            if i%2 == 0:\n                ans.append(ans[i//2])\n            else:\n                ans.append(ans[i//2]+1)\n        return ans"}, {"task_id": "counting-bits", "completion": "class Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if n == 0:\n            return [0]\n        if n == 1:\n            return [0,1]\n        \n        ans = [0]\n        for i in range(1,n+1):\n            if i%2 == 0:\n                ans.append(ans[i//2])\n            else:\n                ans.append(ans[i//2]+1)\n        return ans"}, {"task_id": "counting-bits", "completion": "class Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if n == 0:\n            return [0]\n        if n == 1:\n            return [0,1]\n        if n == 2:\n            return [0,1,1]\n        if n == 3:\n            return [0,1,1,2]\n        if n == 4:\n            return [0,1,1,2,2]\n        if n == 5:\n            return [0,1,1,2,2,3]\n        if n == 6:\n            return [0,1,1,2,2,3,3]\n        if n == 7:\n            return [0,1,1,2,2,3,3,4]\n        if n == 8:\n            return [0,1,1,2,2,3,3,4,4]\n        if n == 9:\n            return [0,1,1,2,2,3,3,4,4,5]\n        if n == 10:\n            return [0,1,1,2,2,3,3,4,4,5,5]\n        if n == 11:\n            return [0,1,1,2,2,3,3,4,4,5,5,6]\n        if n == 12:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6]\n        if n == 13:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7]\n        if n == 14:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7]\n        if n == 15:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8]\n        if n == 16:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8]\n        if n == 17:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9]\n        if n == 18:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9]\n        if n == 19:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10]\n        if n == 20:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10]\n        if n == 21:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11]\n        if n == 22:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11]\n        if n == 23:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12]\n        if n == 24:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12]\n        if n == 25:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12"}, {"task_id": "counting-bits", "completion": "class Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if n == 0:\n            return [0]\n        if n == 1:\n            return [0,1]\n        if n == 2:\n            return [0,1,1]\n        if n == 3:\n            return [0,1,1,2]\n        if n == 4:\n            return [0,1,1,2,2]\n        if n == 5:\n            return [0,1,1,2,2,3]\n        if n == 6:\n            return [0,1,1,2,2,3,3]\n        if n == 7:\n            return [0,1,1,2,2,3,3,4]\n        if n == 8:\n            return [0,1,1,2,2,3,3,4,4]\n        if n == 9:\n            return [0,1,1,2,2,3,3,4,4,5]\n        if n == 10:\n            return [0,1,1,2,2,3,3,4,4,5,5]\n        if n == 11:\n            return [0,1,1,2,2,3,3,4,4,5,5,6]\n        if n == 12:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6]\n        if n == 13:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7]\n        if n == 14:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7]\n        if n == 15:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8]\n        if n == 16:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8]\n        if n == 17:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9]\n        if n == 18:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9]\n        if n == 19:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10]\n        if n == 20:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10]\n        if n == 21:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11]\n        if n == 22:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11]\n        if n == 23:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12]\n        if n == 24:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12]\n        if n == 25:\n            return [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12"}, {"task_id": "counting-bits", "completion": "class Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if n == 0:\n            return [0]\n        if n == 1:\n            return [0,1]\n        if n == 2:\n            return [0,1,1]\n        \n        ans = [0,1,1]\n        for i in range(3,n+1):\n            if i%2 == 0:\n                ans.append(ans[i//2])\n            else:\n                ans.append(ans[i//2]+1)\n        return ans"}], "remove-linked-list-elements": [{"task_id": "remove-linked-list-elements", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        \n        while head and head.val == val:\n            head = head.next\n        \n        if not head:\n            return None\n        \n        curr = head\n        while curr.next:\n            if curr.next.val == val:\n                curr.next = curr.next.next\n            else:\n                curr = curr.next\n        \n        return head"}, {"task_id": "remove-linked-list-elements", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        \n        while head and head.val == val:\n            head = head.next\n        \n        if not head:\n            return None\n        \n        curr = head\n        while curr.next:\n            if curr.next.val == val:\n                curr.next = curr.next.next\n            else:\n                curr = curr.next\n        \n        return head"}, {"task_id": "remove-linked-list-elements", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        \n        while head and head.val == val:\n            head = head.next\n        \n        if not head:\n            return None\n        \n        curr = head\n        while curr.next:\n            if curr.next.val == val:\n                curr.next = curr.next.next\n            else:\n                curr = curr.next\n        \n        return head"}, {"task_id": "remove-linked-list-elements", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        \n        while head and head.val == val:\n            head = head.next\n        \n        if not head:\n            return None\n        \n        curr = head\n        while curr.next:\n            if curr.next.val == val:\n                curr.next = curr.next.next\n            else:\n                curr = curr.next\n        \n        return head"}, {"task_id": "remove-linked-list-elements", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        \n        while head and head.val == val:\n            head = head.next\n        \n        curr = head\n        \n        while curr and curr.next:\n            if curr.next.val == val:\n                curr.next = curr.next.next\n            else:\n                curr = curr.next\n        \n        return head"}], "scramble-string": [{"task_id": "scramble-string", "completion": "class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) != len(s2):\n            return False\n        \n        if s1 == s2:\n            return True\n        \n        if sorted(s1) != sorted(s2):\n            return False\n        \n        for i in range(1, len(s1)):\n            if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):\n                return True\n            \n            if self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i]):\n                return True\n        \n        return False"}, {"task_id": "scramble-string", "completion": "class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) != len(s2):\n            return False\n        \n        if s1 == s2:\n            return True\n        \n        if sorted(s1) != sorted(s2):\n            return False\n        \n        for i in range(1, len(s1)):\n            if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):\n                return True\n            \n            if self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i]):\n                return True\n        \n        return False"}, {"task_id": "scramble-string", "completion": "class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) != len(s2):\n            return False\n        \n        if s1 == s2:\n            return True\n        \n        if sorted(s1) != sorted(s2):\n            return False\n        \n        for i in range(1, len(s1)):\n            if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):\n                return True\n            \n            if self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i]):\n                return True\n        \n        return False"}, {"task_id": "scramble-string", "completion": "class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) != len(s2):\n            return False\n        \n        if s1 == s2:\n            return True\n        \n        if sorted(s1) != sorted(s2):\n            return False\n        \n        for i in range(1, len(s1)):\n            if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):\n                return True\n            \n            if self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i]):\n                return True\n        \n        return False"}, {"task_id": "scramble-string", "completion": "class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) != len(s2):\n            return False\n        \n        if s1 == s2:\n            return True\n        \n        if sorted(s1) != sorted(s2):\n            return False\n        \n        for i in range(1, len(s1)):\n            if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):\n                return True\n            \n            if self.isScramble(s1[:i], s2[-i:]) and self.isScramble(s1[i:], s2[:-i]):\n                return True\n        \n        return False"}], "simplify-path": [{"task_id": "simplify-path", "completion": "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        \n        stack = []\n        for i in path.split('/'):\n            if i == '..':\n                if stack:\n                    stack.pop()\n            elif i and i != '.':\n                stack.append(i)\n        return '/' + '/'.join(stack)"}, {"task_id": "simplify-path", "completion": "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        \n        stack = []\n        for i in path.split('/'):\n            if i == '..':\n                if stack:\n                    stack.pop()\n            elif i and i != '.':\n                stack.append(i)\n        return '/' + '/'.join(stack)"}, {"task_id": "simplify-path", "completion": "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        \n        stack = []\n        for i in path.split('/'):\n            if i == '..':\n                if stack:\n                    stack.pop()\n            elif i and i != '.':\n                stack.append(i)\n        return '/' + '/'.join(stack)"}, {"task_id": "simplify-path", "completion": "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        \n        stack = []\n        for i in path.split('/'):\n            if i == '..':\n                if stack:\n                    stack.pop()\n            elif i and i != '.':\n                stack.append(i)\n        return '/' + '/'.join(stack)"}, {"task_id": "simplify-path", "completion": "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        \n        stack = []\n        for i in path.split('/'):\n            if i == '..':\n                if stack:\n                    stack.pop()\n            elif i and i != '.':\n                stack.append(i)\n        return '/' + '/'.join(stack)"}], "word-search-ii": [{"task_id": "word-search-ii", "completion": "class Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(i, j, board, word, visited, res):\n            if len(word) == 0:\n                res.append(word)\n                return\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or visited[i][j]:\n                return\n            visited[i][j] = True\n            for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:\n                if board[x][y] == word[0]:\n                    dfs(x, y, board, word[1:], visited, res)\n            visited[i][j] = False\n        \n        res = []\n        visited = [[False] * len(board[0]) for _ in range(len(board))]\n        for word in words:\n            for i in range(len(board)):\n                for j in range(len(board[0])):\n                    if board[i][j] == word[0]:\n                        dfs(i, j, board, word, visited, res)\n        return res"}, {"task_id": "word-search-ii", "completion": "class Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(i, j, word, visited):\n            if len(word) == 0:\n                return True\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or visited[i][j]:\n                return False\n            if board[i][j] != word[0]:\n                return False\n            visited[i][j] = True\n            res = dfs(i+1, j, word[1:], visited) or dfs(i-1, j, word[1:], visited) or dfs(i, j+1, word[1:], visited) or dfs(i, j-1, word[1:], visited)\n            visited[i][j] = False\n            return res\n        \n        res = []\n        for word in words:\n            for i in range(len(board)):\n                for j in range(len(board[0])):\n                    if dfs(i, j, word, [[False] * len(board[0]) for _ in range(len(board))]):\n                        res.append(word)\n                        break\n        return res"}, {"task_id": "word-search-ii", "completion": "class Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(i, j, board, word, visited, res):\n            if len(word) == 0:\n                res.append(word)\n                return\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or visited[i][j]:\n                return\n            visited[i][j] = True\n            for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:\n                if board[x][y] == word[0]:\n                    dfs(x, y, board, word[1:], visited, res)\n            visited[i][j] = False\n        \n        res = []\n        visited = [[False for _ in range(len(board[0]))] for _ in range(len(board))]\n        for word in words:\n            for i in range(len(board)):\n                for j in range(len(board[0])):\n                    if board[i][j] == word[0]:\n                        dfs(i, j, board, word, visited, res)\n        return list(set(res))"}, {"task_id": "word-search-ii", "completion": "class Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(i, j, board, word, visited, res):\n            if len(word) == 0:\n                res.append(word)\n                return\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or visited[i][j]:\n                return\n            visited[i][j] = True\n            for x, y in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]:\n                dfs(x, y, board, word + board[x][y], visited, res)\n            visited[i][j] = False\n        \n        res = []\n        for word in words:\n            for i in range(len(board)):\n                for j in range(len(board[0])):\n                    visited = [[False] * len(board[0]) for _ in range(len(board))]\n                    dfs(i, j, board, word, visited, res)\n        return res"}, {"task_id": "word-search-ii", "completion": "class Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(i, j, board, word, visited, res):\n            if len(word) == 0:\n                res.append(word)\n                return\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]):\n                return\n            if board[i][j] != word[0]:\n                return\n            if (i, j) in visited:\n                return\n            visited.add((i, j))\n            dfs(i + 1, j, board, word[1:], visited, res)\n            dfs(i - 1, j, board, word[1:], visited, res)\n            dfs(i, j + 1, board, word[1:], visited, res)\n            dfs(i, j - 1, board, word[1:], visited, res)\n            visited.remove((i, j))\n            \n        res = []\n        for word in words:\n            for i in range(len(board)):\n                for j in range(len(board[0])):\n                    if board[i][j] == word[0]:\n                        dfs(i, j, board, word, set(), res)\n        return res"}], "valid-anagram": [{"task_id": "valid-anagram", "completion": "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_dict = {}\n        t_dict = {}\n        \n        for i in range(len(s)):\n            s_dict[s[i]] = s_dict.get(s[i], 0) + 1\n            t_dict[t[i]] = t_dict.get(t[i], 0) + 1\n        \n        for key in s_dict:\n            if s_dict[key] != t_dict.get(key, 0):\n                return False\n        \n        return True"}, {"task_id": "valid-anagram", "completion": "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_dict = {}\n        t_dict = {}\n        \n        for i in range(len(s)):\n            s_dict[s[i]] = s_dict.get(s[i], 0) + 1\n            t_dict[t[i]] = t_dict.get(t[i], 0) + 1\n        \n        for i in s_dict:\n            if s_dict[i] != t_dict.get(i, 0):\n                return False\n        \n        return True"}, {"task_id": "valid-anagram", "completion": "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_dict = {}\n        t_dict = {}\n        \n        for i in range(len(s)):\n            s_dict[s[i]] = s_dict.get(s[i], 0) + 1\n            t_dict[t[i]] = t_dict.get(t[i], 0) + 1\n        \n        for key in s_dict:\n            if s_dict[key] != t_dict.get(key, 0):\n                return False\n        \n        return True"}, {"task_id": "valid-anagram", "completion": "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_dict = {}\n        t_dict = {}\n        \n        for i in range(len(s)):\n            s_dict[s[i]] = s_dict.get(s[i], 0) + 1\n            t_dict[t[i]] = t_dict.get(t[i], 0) + 1\n        \n        for i in s_dict:\n            if s_dict[i] != t_dict.get(i, 0):\n                return False\n        \n        return True"}, {"task_id": "valid-anagram", "completion": "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_dict = {}\n        t_dict = {}\n        \n        for i in range(len(s)):\n            s_dict[s[i]] = s_dict.get(s[i], 0) + 1\n            t_dict[t[i]] = t_dict.get(t[i], 0) + 1\n        \n        for key in s_dict:\n            if s_dict[key] != t_dict.get(key, 0):\n                return False\n        \n        return True"}], "valid-sudoku": [{"task_id": "valid-sudoku", "completion": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        def check_row(board):\n            for row in board:\n                if len(set(row)) != 9:\n                    return False\n            return True\n        \n        def check_col(board):\n            for i in range(9):\n                col = [row[i] for row in board]\n                if len(set(col)) != 9:\n                    return False\n            return True\n        \n        def check_box(board):\n            for i in range(0, 9, 3):\n                for j in range(0, 9, 3):\n                    box = [board[i+k][j+l] for k in range(3) for l in range(3)]\n                    if len(set(box)) != 9:\n                        return False\n            return True\n        \n        return check_row(board) and check_col(board) and check_box(board)"}, {"task_id": "valid-sudoku", "completion": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        def check_row(board):\n            for row in board:\n                if len(set(row)) != 9:\n                    return False\n            return True\n        \n        def check_col(board):\n            for i in range(9):\n                col = [row[i] for row in board]\n                if len(set(col)) != 9:\n                    return False\n            return True\n        \n        def check_box(board):\n            for i in range(0, 9, 3):\n                for j in range(0, 9, 3):\n                    box = [board[i+k][j+l] for k in range(3) for l in range(3)]\n                    if len(set(box)) != 9:\n                        return False\n            return True\n        \n        return check_row(board) and check_col(board) and check_box(board)"}, {"task_id": "valid-sudoku", "completion": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        def check_row(board):\n            for row in board:\n                if len(set(row)) != 9:\n                    return False\n            return True\n        \n        def check_col(board):\n            for i in range(9):\n                col = [row[i] for row in board]\n                if len(set(col)) != 9:\n                    return False\n            return True\n        \n        def check_box(board):\n            for i in range(0,9,3):\n                for j in range(0,9,3):\n                    box = [board[i+k][j+l] for k in range(3) for l in range(3)]\n                    if len(set(box)) != 9:\n                        return False\n            return True\n        \n        return check_row(board) and check_col(board) and check_box(board)"}, {"task_id": "valid-sudoku", "completion": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        # check rows\n        for row in board:\n            if len(set(row)) != 9:\n                return False\n        \n        # check columns\n        for i in range(9):\n            col = [row[i] for row in board]\n            if len(set(col)) != 9:\n                return False\n        \n        # check 3x3 boxes\n        for i in range(0, 9, 3):\n            for j in range(0, 9, 3):\n                box = [board[i+k][j+l] for k in range(3) for l in range(3)]\n                if len(set(box)) != 9:\n                    return False\n        \n        return True"}, {"task_id": "valid-sudoku", "completion": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        def check_row(board):\n            for row in board:\n                if len(set(row)) != 9:\n                    return False\n            return True\n        \n        def check_col(board):\n            for i in range(9):\n                col = [row[i] for row in board]\n                if len(set(col)) != 9:\n                    return False\n            return True\n        \n        def check_box(board):\n            for i in range(0, 9, 3):\n                for j in range(0, 9, 3):\n                    box = [board[i+k][j+l] for k in range(3) for l in range(3)]\n                    if len(set(box)) != 9:\n                        return False\n            return True\n        \n        return check_row(board) and check_col(board) and check_box(board)"}], "fizz-buzz": [{"task_id": "fizz-buzz", "completion": "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        ans = []\n        for i in range(1,n+1):\n            if i%3 == 0 and i%5 == 0:\n                ans.append(\"FizzBuzz\")\n            elif i%3 == 0:\n                ans.append(\"Fizz\")\n            elif i%5 == 0:\n                ans.append(\"Buzz\")\n            else:\n                ans.append(str(i))\n        return ans"}, {"task_id": "fizz-buzz", "completion": "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        ans = []\n        for i in range(1,n+1):\n            if i%3 == 0 and i%5 == 0:\n                ans.append(\"FizzBuzz\")\n            elif i%3 == 0:\n                ans.append(\"Fizz\")\n            elif i%5 == 0:\n                ans.append(\"Buzz\")\n            else:\n                ans.append(str(i))\n        return ans"}, {"task_id": "fizz-buzz", "completion": "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        ans = []\n        for i in range(1,n+1):\n            if i%3 == 0 and i%5 == 0:\n                ans.append(\"FizzBuzz\")\n            elif i%3 == 0:\n                ans.append(\"Fizz\")\n            elif i%5 == 0:\n                ans.append(\"Buzz\")\n            else:\n                ans.append(str(i))\n        return ans"}, {"task_id": "fizz-buzz", "completion": "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        ans = []\n        for i in range(1,n+1):\n            if i%3 == 0 and i%5 == 0:\n                ans.append(\"FizzBuzz\")\n            elif i%3 == 0:\n                ans.append(\"Fizz\")\n            elif i%5 == 0:\n                ans.append(\"Buzz\")\n            else:\n                ans.append(str(i))\n        return ans"}, {"task_id": "fizz-buzz", "completion": "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        ans = []\n        for i in range(1,n+1):\n            if i%3 == 0 and i%5 == 0:\n                ans.append(\"FizzBuzz\")\n            elif i%3 == 0:\n                ans.append(\"Fizz\")\n            elif i%5 == 0:\n                ans.append(\"Buzz\")\n            else:\n                ans.append(str(i))\n        return ans"}], "reverse-words-in-a-string": [{"task_id": "reverse-words-in-a-string", "completion": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # reverse the order of the words\n        words.reverse()\n        \n        # join the words back into a string\n        return ' '.join(words)"}, {"task_id": "reverse-words-in-a-string", "completion": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # reverse the order of the words\n        words.reverse()\n        \n        # join the words back into a string\n        return ' '.join(words)"}, {"task_id": "reverse-words-in-a-string", "completion": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # reverse the order of the words\n        words.reverse()\n        \n        # join the words back into a string\n        return ' '.join(words)"}, {"task_id": "reverse-words-in-a-string", "completion": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # reverse the order of the words\n        words.reverse()\n        \n        # join the words back into a string\n        return ' '.join(words)"}, {"task_id": "reverse-words-in-a-string", "completion": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # reverse the order of the words\n        words.reverse()\n        \n        # join the words back into a string\n        return ' '.join(words)"}], "excel-sheet-column-number": [{"task_id": "excel-sheet-column-number", "completion": "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        \"\"\"\n        :type columnTitle: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. convert the string to a list\n        # 2. reverse the list\n        # 3. iterate through the list\n        # 4. multiply the current number by 26^(index)\n        # 5. add the current number to the total\n        # 6. return the total\n        \n        # 1. convert the string to a list\n        columnTitle = list(columnTitle)\n        \n        # 2. reverse the list\n        columnTitle.reverse()\n        \n        # 3. iterate through the list\n        total = 0\n        for i in range(len(columnTitle)):\n            \n            # 4. multiply the current number by 26^(index)\n            current_number = ord(columnTitle[i]) - 64\n            current_number = current_number * (26**i)\n            \n            # 5. add the current number to the total\n            total += current_number\n            \n        # 6. return the total\n        return total"}, {"task_id": "excel-sheet-column-number", "completion": "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        \"\"\"\n        :type columnTitle: str\n        :rtype: int\n        \"\"\"\n        \n        ## 1. convert the string to a list of characters\n        ## 2. reverse the list\n        ## 3. convert each character to a number\n        ## 4. add the numbers together\n        \n        ## 1. convert the string to a list of characters\n        columnTitle = list(columnTitle)\n        \n        ## 2. reverse the list\n        columnTitle.reverse()\n        \n        ## 3. convert each character to a number\n        columnNumber = 0\n        for i in range(len(columnTitle)):\n            columnNumber += (26**i) * (ord(columnTitle[i]) - ord('A') + 1)\n        \n        ## 4. add the numbers together\n        return columnNumber"}, {"task_id": "excel-sheet-column-number", "completion": "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        \"\"\"\n        :type columnTitle: str\n        :rtype: int\n        \"\"\"\n        \n        ## 1. convert the string to a list of characters\n        ## 2. reverse the list\n        ## 3. convert each character to a number\n        ## 4. add the numbers together\n        \n        ## 1. convert the string to a list of characters\n        columnTitle = list(columnTitle)\n        \n        ## 2. reverse the list\n        columnTitle.reverse()\n        \n        ## 3. convert each character to a number\n        columnNumber = 0\n        for i in range(len(columnTitle)):\n            columnNumber += (26**i) * (ord(columnTitle[i]) - ord('A') + 1)\n        \n        ## 4. add the numbers together\n        return columnNumber"}, {"task_id": "excel-sheet-column-number", "completion": "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        \"\"\"\n        :type columnTitle: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. convert the string to a list\n        # 2. reverse the list\n        # 3. iterate through the list\n        # 4. multiply the current number by 26^(index)\n        # 5. add the current number to the total\n        # 6. return the total\n        \n        # 1. convert the string to a list\n        columnTitle = list(columnTitle)\n        \n        # 2. reverse the list\n        columnTitle.reverse()\n        \n        # 3. iterate through the list\n        total = 0\n        for i in range(len(columnTitle)):\n            \n            # 4. multiply the current number by 26^(index)\n            total += (26**i) * (ord(columnTitle[i]) - ord('A') + 1)\n            \n        # 5. return the total\n        return total"}, {"task_id": "excel-sheet-column-number", "completion": "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        \"\"\"\n        :type columnTitle: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. convert the string to a list of characters\n        # 2. reverse the list\n        # 3. convert each character to its corresponding number\n        # 4. add the numbers together\n        \n        # 1. convert the string to a list of characters\n        columnTitle = list(columnTitle)\n        \n        # 2. reverse the list\n        columnTitle.reverse()\n        \n        # 3. convert each character to its corresponding number\n        # 3.1. create a dictionary to map each character to its corresponding number\n        char_to_num = {\n            'A': 1,\n            'B': 2,\n            'C': 3,\n            'D': 4,\n            'E': 5,\n            'F': 6,\n            'G': 7,\n            'H': 8,\n            'I': 9,\n            'J': 10,\n            'K': 11,\n            'L': 12,\n            'M': 13,\n            'N': 14,\n            'O': 15,\n            'P': 16,\n            'Q': 17,\n            'R': 18,\n            'S': 19,\n            'T': 20,\n            'U': 21,\n            'V': 22,\n            'W': 23,\n            'X': 24,\n            'Y': 25,\n            'Z': 26\n        }\n        \n        # 3.2. create a list to store the numbers\n        num_list = []\n        \n        # 3.3. loop through the list of characters\n        for char in columnTitle:\n            # 3.3.1. add the corresponding number to the list\n            num_list.append(char_to_num[char])\n        \n        # 4. add the numbers together\n        # 4.1. create a variable to store the sum\n        sum = 0\n        \n        # 4.2. loop through the list of numbers\n        for num in num_list:\n            # 4.2.1. add the number to the sum\n            sum += num\n        \n        # 5. return the sum\n        return sum"}], "candy": [{"task_id": "candy", "completion": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(ratings)\n        candies = [1] * n\n        \n        for i in range(1, n):\n            if ratings[i] > ratings[i - 1]:\n                candies[i] = candies[i - 1] + 1\n        \n        for i in range(n - 2, -1, -1):\n            if ratings[i] > ratings[i + 1]:\n                candies[i] = max(candies[i], candies[i + 1] + 1)\n        \n        return sum(candies)"}, {"task_id": "candy", "completion": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(ratings)\n        candies = [1] * n\n        \n        for i in range(1, n):\n            if ratings[i] > ratings[i - 1]:\n                candies[i] = candies[i - 1] + 1\n        \n        for i in range(n - 2, -1, -1):\n            if ratings[i] > ratings[i + 1]:\n                candies[i] = max(candies[i], candies[i + 1] + 1)\n        \n        return sum(candies)"}, {"task_id": "candy", "completion": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(ratings)\n        candies = [1] * n\n        \n        for i in range(1, n):\n            if ratings[i] > ratings[i-1]:\n                candies[i] = candies[i-1] + 1\n        \n        for i in range(n-2, -1, -1):\n            if ratings[i] > ratings[i+1]:\n                candies[i] = max(candies[i], candies[i+1] + 1)\n        \n        return sum(candies)"}, {"task_id": "candy", "completion": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(ratings)\n        candies = [1] * n\n        \n        for i in range(1, n):\n            if ratings[i] > ratings[i-1]:\n                candies[i] = candies[i-1] + 1\n        \n        for i in range(n-2, -1, -1):\n            if ratings[i] > ratings[i+1]:\n                candies[i] = max(candies[i], candies[i+1] + 1)\n        \n        return sum(candies)"}, {"task_id": "candy", "completion": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(ratings)\n        candies = [1] * n\n        \n        for i in range(1, n):\n            if ratings[i] > ratings[i - 1]:\n                candies[i] = candies[i - 1] + 1\n        \n        for i in range(n - 2, -1, -1):\n            if ratings[i] > ratings[i + 1]:\n                candies[i] = max(candies[i], candies[i + 1] + 1)\n        \n        return sum(candies)"}], "same-tree": [{"task_id": "same-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if p == None and q == None:\n            return True\n        elif p == None or q == None:\n            return False\n        elif p.val != q.val:\n            return False\n        else:\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)"}, {"task_id": "same-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if p == None and q == None:\n            return True\n        elif p == None or q == None:\n            return False\n        elif p.val != q.val:\n            return False\n        else:\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)"}, {"task_id": "same-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if p == None and q == None:\n            return True\n        elif p == None or q == None:\n            return False\n        elif p.val != q.val:\n            return False\n        else:\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)"}, {"task_id": "same-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if p is None and q is None:\n            return True\n        elif p is None or q is None:\n            return False\n        elif p.val != q.val:\n            return False\n        else:\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)"}, {"task_id": "same-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if p is None and q is None:\n            return True\n        elif p is None or q is None:\n            return False\n        elif p.val != q.val:\n            return False\n        else:\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)"}], "reorder-list": [{"task_id": "reorder-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reorderList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: None Do not return anything, modify head in-place instead.\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        # find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the list\n        prev = None\n        while slow:\n            next = slow.next\n            slow.next = prev\n            prev = slow\n            slow = next\n        \n        # merge the first and second halves\n        first, second = head, prev\n        while second.next:\n            first, second = first.next, second.next\n        \n        return first"}, {"task_id": "reorder-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reorderList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: None Do not return anything, modify head in-place instead.\n        \"\"\"\n        \n        # find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the list\n        prev = None\n        while slow:\n            next = slow.next\n            slow.next = prev\n            prev = slow\n            slow = next\n        \n        # merge the first and second halves\n        first, second = head, prev\n        while second.next:\n            first, second = first.next, second.next\n        \n        return first"}, {"task_id": "reorder-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reorderList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: None Do not return anything, modify head in-place instead.\n        \"\"\"\n        \n        # find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the list\n        prev = None\n        while slow:\n            next = slow.next\n            slow.next = prev\n            prev = slow\n            slow = next\n        \n        # merge the first and second halves\n        first, second = head, prev\n        while second.next:\n            first, second = first.next, second.next\n        \n        return first"}, {"task_id": "reorder-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reorderList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: None Do not return anything, modify head in-place instead.\n        \"\"\"\n        \n        # find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the list\n        prev = None\n        while slow:\n            next = slow.next\n            slow.next = prev\n            prev = slow\n            slow = next\n        \n        # merge the first and second halves\n        first, second = head, prev\n        while second.next:\n            first, second = first.next, second.next\n        \n        # connect the first half back to the second half\n        first.next = second\n        \n        return head"}, {"task_id": "reorder-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reorderList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: None Do not return anything, modify head in-place instead.\n        \"\"\"\n        \n        # find the middle of the list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the list\n        prev = None\n        while slow:\n            nxt = slow.next\n            slow.next = prev\n            prev = slow\n            slow = nxt\n        \n        # merge the two halves\n        first, second = head, prev\n        while second.next:\n            first, second = first.next, second.next\n        \n        return first"}], "word-pattern": [{"task_id": "word-pattern", "completion": "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # check if the number of words is equal to the number of letters in the pattern\n        if len(words) != len(pattern):\n            return False\n        \n        # create a dictionary to store the mapping of letters to words\n        mapping = {}\n        \n        # iterate over the pattern and words\n        for letter, word in zip(pattern, words):\n            # check if the letter is already in the dictionary\n            if letter in mapping:\n                # check if the word is already mapped to the letter\n                if mapping[letter] != word:\n                    return False\n            # if the letter is not in the dictionary, add it with the word\n            else:\n                mapping[letter] = word\n        \n        # return True if the pattern and words are mapped correctly\n        return True"}, {"task_id": "word-pattern", "completion": "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # check if the length of pattern and words are equal\n        if len(pattern) != len(words):\n            return False\n        \n        # create a dictionary to store the mapping\n        mapping = {}\n        \n        # iterate over the pattern and words\n        for i in range(len(pattern)):\n            # check if the pattern and word are already in the mapping\n            if pattern[i] in mapping:\n                # check if the pattern and word are mapped to the same word\n                if mapping[pattern[i]] != words[i]:\n                    return False\n            # check if the pattern and word are not in the mapping\n            else:\n                # add the pattern and word to the mapping\n                mapping[pattern[i]] = words[i]\n        \n        # return True if the pattern and words are mapped\n        return True"}, {"task_id": "word-pattern", "completion": "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # check if the length of pattern and words are equal\n        if len(pattern) != len(words):\n            return False\n        \n        # create a dictionary to store the mapping\n        mapping = {}\n        \n        # iterate over the pattern and words\n        for i in range(len(pattern)):\n            # check if the pattern and word are already in the mapping\n            if pattern[i] in mapping:\n                # check if the pattern and word are mapped to the same word\n                if mapping[pattern[i]] != words[i]:\n                    return False\n            # check if the pattern and word are not in the mapping\n            else:\n                # add the pattern and word to the mapping\n                mapping[pattern[i]] = words[i]\n        \n        # return True if the pattern and words are mapped\n        return True"}, {"task_id": "word-pattern", "completion": "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # check if the number of words is equal to the number of letters in the pattern\n        if len(words) != len(pattern):\n            return False\n        \n        # create a dictionary to store the mapping between letters and words\n        mapping = {}\n        \n        # iterate through the pattern and words\n        for letter, word in zip(pattern, words):\n            # if the letter is already in the dictionary, check if the word is the same as the previous word\n            if letter in mapping:\n                if mapping[letter] != word:\n                    return False\n            # if the letter is not in the dictionary, add it to the dictionary with the word as the value\n            else:\n                mapping[letter] = word\n        \n        # return True if the pattern and words are mapped correctly\n        return True"}, {"task_id": "word-pattern", "completion": "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # check if the number of words is equal to the number of letters in the pattern\n        if len(words) != len(pattern):\n            return False\n        \n        # create a dictionary to store the mapping between letters and words\n        mapping = {}\n        \n        # iterate through the pattern and words\n        for letter, word in zip(pattern, words):\n            # if the letter is already in the dictionary, check if the word is the same as the previous word\n            if letter in mapping:\n                if mapping[letter] != word:\n                    return False\n            # if the letter is not in the dictionary, add it to the dictionary with the word as the value\n            else:\n                mapping[letter] = word\n        \n        # return True if the pattern and words are mapped correctly\n        return True"}], "permutations": [{"task_id": "permutations", "completion": "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(first = 0):\n            if first == n:\n                output.append(nums[:])\n            for i in range(first, n):\n                nums[first], nums[i] = nums[i], nums[first]\n                backtrack(first + 1)\n                nums[first], nums[i] = nums[i], nums[first]\n        \n        n = len(nums)\n        output = []\n        backtrack()\n        return output"}, {"task_id": "permutations", "completion": "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(first = 0):\n            if first == n:\n                output.append(nums[:])\n            for i in range(first, n):\n                nums[first], nums[i] = nums[i], nums[first]\n                backtrack(first + 1)\n                nums[first], nums[i] = nums[i], nums[first]\n        \n        n = len(nums)\n        output = []\n        backtrack()\n        return output"}, {"task_id": "permutations", "completion": "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(first = 0):\n            if first == n:\n                output.append(nums[:])\n            for i in range(first, n):\n                nums[first], nums[i] = nums[i], nums[first]\n                backtrack(first + 1)\n                nums[first], nums[i] = nums[i], nums[first]\n        \n        n = len(nums)\n        output = []\n        backtrack()\n        return output"}, {"task_id": "permutations", "completion": "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(first = 0):\n            if first == n:\n                output.append(nums[:])\n            for i in range(first, n):\n                nums[first], nums[i] = nums[i], nums[first]\n                backtrack(first + 1)\n                nums[first], nums[i] = nums[i], nums[first]\n        \n        n = len(nums)\n        output = []\n        backtrack()\n        return output"}, {"task_id": "permutations", "completion": "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(first = 0):\n            if first == n:\n                output.append(nums[:])\n            for i in range(first, n):\n                nums[first], nums[i] = nums[i], nums[first]\n                backtrack(first + 1)\n                nums[first], nums[i] = nums[i], nums[first]\n        \n        n = len(nums)\n        output = []\n        backtrack()\n        return output"}], "search-a-2d-matrix": [{"task_id": "search-a-2d-matrix", "completion": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        if target < matrix[0][0] or target > matrix[-1][-1]:\n            return False\n        \n        for i in range(m):\n            if target >= matrix[i][0] and target <= matrix[i][-1]:\n                for j in range(n):\n                    if target == matrix[i][j]:\n                        return True\n        \n        return False"}, {"task_id": "search-a-2d-matrix", "completion": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        if target < matrix[0][0] or target > matrix[-1][-1]:\n            return False\n        \n        for i in range(m):\n            if target >= matrix[i][0] and target <= matrix[i][-1]:\n                for j in range(n):\n                    if target == matrix[i][j]:\n                        return True\n        \n        return False"}, {"task_id": "search-a-2d-matrix", "completion": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        if target < matrix[0][0] or target > matrix[-1][-1]:\n            return False\n        \n        for i in range(m):\n            if target >= matrix[i][0] and target <= matrix[i][-1]:\n                for j in range(n):\n                    if target == matrix[i][j]:\n                        return True\n        \n        return False"}, {"task_id": "search-a-2d-matrix", "completion": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        if target < matrix[0][0] or target > matrix[-1][-1]:\n            return False\n        \n        for i in range(m):\n            if target >= matrix[i][0] and target <= matrix[i][-1]:\n                for j in range(n):\n                    if target == matrix[i][j]:\n                        return True\n        \n        return False"}, {"task_id": "search-a-2d-matrix", "completion": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        if target < matrix[0][0] or target > matrix[-1][-1]:\n            return False\n        \n        for i in range(m):\n            if target >= matrix[i][0] and target <= matrix[i][-1]:\n                for j in range(n):\n                    if matrix[i][j] == target:\n                        return True\n        return False"}], "add-two-numbers": [{"task_id": "add-two-numbers", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # create a dummy node\n        dummy = ListNode()\n        # create a pointer to the dummy node\n        curr = dummy\n        # create a carry variable\n        carry = 0\n        # create a while loop to iterate through the linked lists\n        while l1 or l2 or carry:\n            # create a variable to store the sum of the current node\n            val1 = l1.val if l1 else 0\n            val2 = l2.val if l2 else 0\n            # create a variable to store the sum of the current node\n            val = val1 + val2 + carry\n            # create a variable to store the remainder of the sum\n            carry = val // 10\n            # create a variable to store the remainder of the sum\n            val = val % 10\n            # create a new node with the value of the sum\n            curr.next = ListNode(val)\n            # move the pointer to the next node\n            curr = curr.next\n            # move the pointers to the next node\n            l1 = l1.next if l1 else None\n            l2 = l2.next if l2 else None\n        # return the dummy node\n        return dummy.next"}, {"task_id": "add-two-numbers", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # create a dummy node\n        dummy = ListNode()\n        # create a pointer to the dummy node\n        curr = dummy\n        # create a carry variable\n        carry = 0\n        # loop until both lists are empty\n        while l1 or l2 or carry:\n            # if l1 is empty, set sum to 0\n            if not l1:\n                sum = 0\n            # if l2 is empty, set sum to 0\n            elif not l2:\n                sum = 0\n            # otherwise, add the values of l1 and l2\n            else:\n                sum = l1.val + l2.val\n            # add the carry to the sum\n            sum += carry\n            # set carry to the sum modulo 10\n            carry = sum // 10\n            # set the value of the current node to the sum modulo 10\n            curr.next = ListNode(sum % 10)\n            # move the current node to the next node\n            curr = curr.next\n            # move the pointers to the next node\n            l1 = l1.next if l1 else None\n            l2 = l2.next if l2 else None\n        # return the dummy node\n        return dummy.next"}, {"task_id": "add-two-numbers", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # create a dummy node\n        dummy = ListNode()\n        # create a pointer to the dummy node\n        curr = dummy\n        # create a carry variable\n        carry = 0\n        # create a while loop to iterate through the linked lists\n        while l1 or l2 or carry:\n            # create a variable to store the value of the current node\n            val1 = l1.val if l1 else 0\n            val2 = l2.val if l2 else 0\n            # create a variable to store the sum of the current node\n            val = val1 + val2 + carry\n            # create a variable to store the remainder of the sum\n            carry = val // 10\n            # create a variable to store the remainder of the sum\n            val = val % 10\n            # create a new node with the value of the sum\n            curr.next = ListNode(val)\n            # move the pointer to the next node\n            curr = curr.next\n            # move the pointers to the next node\n            l1 = l1.next if l1 else None\n            l2 = l2.next if l2 else None\n        # return the dummy node\n        return dummy.next"}, {"task_id": "add-two-numbers", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        carry = 0\n        head = ListNode(0)\n        curr = head\n        \n        while l1 or l2 or carry:\n            val1 = l1.val if l1 else 0\n            val2 = l2.val if l2 else 0\n            \n            sum = val1 + val2 + carry\n            \n            carry = sum // 10\n            curr.next = ListNode(sum % 10)\n            \n            curr = curr.next\n            l1 = l1.next if l1 else None\n            l2 = l2.next if l2 else None\n            \n        return head.next"}, {"task_id": "add-two-numbers", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # Initialize a new linked list\n        head = ListNode()\n        # Initialize a pointer to the new linked list\n        curr = head\n        # Initialize a variable to store the carry\n        carry = 0\n        \n        # Loop through both linked lists\n        while l1 or l2 or carry:\n            # If both linked lists are not empty, add the values of the nodes\n            if l1:\n                val1 = l1.val\n            else:\n                val1 = 0\n            if l2:\n                val2 = l2.val\n            else:\n                val2 = 0\n            # Add the values of the nodes to the carry\n            carry, out = divmod(val1 + val2 + carry, 10)\n            # Create a new node with the sum of the values\n            curr.next = ListNode(out)\n            # Move to the next node\n            curr = curr.next\n            # Move to the next node\n            if l1:\n                l1 = l1.next\n            if l2:\n                l2 = l2.next\n        \n        # Return the new linked list\n        return head.next"}], "number-complement": [{"task_id": "number-complement", "completion": "class Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        ## convert to binary\n        binary = bin(num)[2:]\n        \n        ## convert to complement\n        complement = \"\"\n        for i in binary:\n            if i == \"0\":\n                complement += \"1\"\n            else:\n                complement += \"0\"\n        \n        ## convert to decimal\n        return int(complement, 2)"}, {"task_id": "number-complement", "completion": "class Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        ## convert to binary\n        binary = bin(num)[2:]\n        ## reverse the binary\n        binary = binary[::-1]\n        ## convert to decimal\n        decimal = int(binary, 2)\n        ## return the complement\n        return decimal"}, {"task_id": "number-complement", "completion": "class Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        ## convert to binary\n        binary = bin(num)[2:]\n        ## convert to list\n        binary_list = list(binary)\n        ## reverse the list\n        binary_list.reverse()\n        ## convert to string\n        binary_string = ''.join(binary_list)\n        ## convert to integer\n        complement = int(binary_string, 2)\n        return complement"}, {"task_id": "number-complement", "completion": "class Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        ## convert to binary\n        binary = bin(num)[2:]\n        \n        ## convert to complement\n        complement = \"\"\n        for i in binary:\n            if i == \"0\":\n                complement += \"1\"\n            else:\n                complement += \"0\"\n        \n        ## convert to decimal\n        return int(complement, 2)"}, {"task_id": "number-complement", "completion": "class Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        ## convert to binary\n        binary = bin(num)[2:]\n        \n        ## convert to complement\n        complement = \"\"\n        for i in binary:\n            if i == \"0\":\n                complement += \"1\"\n            else:\n                complement += \"0\"\n        \n        ## convert to decimal\n        return int(complement, 2)"}], "arithmetic-slices-ii-subsequence": [{"task_id": "arithmetic-slices-ii-subsequence", "completion": "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 3:\n            return 0\n        \n        count = 0\n        for i in range(len(nums)-2):\n            if nums[i+2] - nums[i+1] == nums[i+1] - nums[i]:\n                count += 1\n                j = i + 1\n                while j < len(nums)-1 and nums[j+1] - nums[j] == nums[j] - nums[j-1]:\n                    j += 1\n                count += j - i\n        return count"}, {"task_id": "arithmetic-slices-ii-subsequence", "completion": "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 3:\n            return 0\n        \n        count = 0\n        for i in range(len(nums)-2):\n            if nums[i+2] - nums[i+1] == nums[i+1] - nums[i]:\n                count += 1\n                j = i + 1\n                while j < len(nums)-1 and nums[j+1] - nums[j] == nums[j] - nums[j-1]:\n                    j += 1\n                count += j - i\n        return count"}, {"task_id": "arithmetic-slices-ii-subsequence", "completion": "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 3:\n            return 0\n        \n        count = 0\n        for i in range(len(nums)-2):\n            if nums[i+2] - nums[i+1] == nums[i+1] - nums[i]:\n                count += 1\n                j = i + 1\n                while j < len(nums)-1 and nums[j+1] - nums[j] == nums[j] - nums[j-1]:\n                    j += 1\n                count += j - i\n        return count"}, {"task_id": "arithmetic-slices-ii-subsequence", "completion": "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 3:\n            return 0\n        \n        count = 0\n        for i in range(len(nums)-2):\n            if nums[i+2] - nums[i+1] == nums[i+1] - nums[i]:\n                count += 1\n                j = i + 1\n                while j < len(nums)-1 and nums[j+1] - nums[j] == nums[j] - nums[j-1]:\n                    j += 1\n                count += j - i\n        return count"}, {"task_id": "arithmetic-slices-ii-subsequence", "completion": "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 3:\n            return 0\n        \n        count = 0\n        for i in range(len(nums)-2):\n            if nums[i+2] - nums[i+1] == nums[i+1] - nums[i]:\n                count += 1\n                j = i + 1\n                while j < len(nums)-1 and nums[j+1] - nums[j] == nums[j] - nums[j-1]:\n                    j += 1\n                count += j - i\n        return count"}], "text-justification": [{"task_id": "text-justification", "completion": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}, {"task_id": "text-justification", "completion": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        \n        res = []\n        i = 0\n        while i < len(words):\n            line = []\n            line_len = 0\n            while i < len(words) and line_len + len(words[i]) + len(line) <= maxWidth:\n                line.append(words[i])\n                line_len += len(words[i])\n                i += 1\n            if i == len(words):\n                res.append(' '.join(line) + ' ' * (maxWidth - len(line) - len(line) + 1))\n            else:\n                if len(line) == 1:\n                    res.append(line[0] + ' ' * (maxWidth - len(line[0])))\n                else:\n                    spaces = (maxWidth - line_len) // (len(line) - 1)\n                    extra = (maxWidth - line_len) % (len(line) - 1)\n                    res.append(' '.join(line[0:1] + [' ' * spaces + line[i] for i in range(1, len(line))] + [' ' * extra]))\n        return res"}, {"task_id": "text-justification", "completion": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        \n        res = []\n        curr = []\n        curr_len = 0\n        for word in words:\n            if curr_len + len(word) + len(curr) > maxWidth:\n                if len(curr) == 1:\n                    res.append(curr[0] + ' ' * (maxWidth - curr_len))\n                else:\n                    spaces = (maxWidth - curr_len) // (len(curr) - 1)\n                    extra = (maxWidth - curr_len) % (len(curr) - 1)\n                    for i in range(len(curr) - 1):\n                        curr[i] += ' ' * spaces + (' ' if extra > 0 else '')\n                        extra -= 1\n                    res.append(''.join(curr))\n                curr = []\n                curr_len = 0\n            curr.append(word)\n            curr_len += len(word)\n        if curr:\n            if len(curr) == 1:\n                res.append(curr[0] + ' ' * (maxWidth - curr_len))\n            else:\n                spaces = (maxWidth - curr_len) // (len(curr) - 1)\n                extra = (maxWidth - curr_len) % (len(curr) - 1)\n                for i in range(len(curr) - 1):\n                    curr[i] += ' ' * spaces + (' ' if extra > 0 else '')\n                    extra -= 1\n                res.append(''.join(curr))\n        return res"}, {"task_id": "text-justification", "completion": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}, {"task_id": "text-justification", "completion": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}], "binary-tree-postorder-traversal": [{"task_id": "binary-tree-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = [root]\n        res = []\n        \n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            \n            if node.left:\n                stack.append(node.left)\n                \n            if node.right:\n                stack.append(node.right)\n                \n        return res[::-1]"}, {"task_id": "binary-tree-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = [root]\n        result = []\n        \n        while stack:\n            node = stack.pop()\n            result.append(node.val)\n            \n            if node.left:\n                stack.append(node.left)\n                \n            if node.right:\n                stack.append(node.right)\n                \n        return result[::-1]"}, {"task_id": "binary-tree-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = [root]\n        result = []\n        \n        while stack:\n            node = stack.pop()\n            result.append(node.val)\n            \n            if node.left:\n                stack.append(node.left)\n                \n            if node.right:\n                stack.append(node.right)\n                \n        return result[::-1]"}, {"task_id": "binary-tree-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = [root]\n        res = []\n        \n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            \n            if node.left:\n                stack.append(node.left)\n            if node.right:\n                stack.append(node.right)\n                \n        return res[::-1]"}, {"task_id": "binary-tree-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        stack = [root]\n        result = []\n        \n        while stack:\n            node = stack.pop()\n            result.append(node.val)\n            \n            if node.left:\n                stack.append(node.left)\n                \n            if node.right:\n                stack.append(node.right)\n                \n        return result[::-1]"}], "container-with-most-water": [{"task_id": "container-with-most-water", "completion": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_area = 0\n        left = 0\n        right = len(height) - 1\n        \n        while left < right:\n            area = min(height[left], height[right]) * (right - left)\n            max_area = max(max_area, area)\n            \n            if height[left] < height[right]:\n                left += 1\n            else:\n                right -= 1\n                \n        return max_area"}, {"task_id": "container-with-most-water", "completion": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_area = 0\n        left = 0\n        right = len(height) - 1\n        \n        while left < right:\n            area = min(height[left], height[right]) * (right - left)\n            max_area = max(max_area, area)\n            \n            if height[left] < height[right]:\n                left += 1\n            else:\n                right -= 1\n                \n        return max_area"}, {"task_id": "container-with-most-water", "completion": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Brute force\n        # Time Complexity: O(n^2)\n        # Space Complexity: O(1)\n        # max_area = 0\n        # for i in range(len(height)):\n        #     for j in range(i+1, len(height)):\n        #         area = min(height[i], height[j]) * (j-i)\n        #         max_area = max(max_area, area)\n        # return max_area\n        \n        # Two Pointer\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        max_area = 0\n        left = 0\n        right = len(height) - 1\n        while left < right:\n            area = min(height[left], height[right]) * (right - left)\n            max_area = max(max_area, area)\n            if height[left] < height[right]:\n                left += 1\n            else:\n                right -= 1\n        return max_area"}, {"task_id": "container-with-most-water", "completion": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## Brute force\n        ## Time complexity: O(n^2)\n        ## Space complexity: O(1)\n        ## Runtime: 108 ms, faster than 99.25% of Python online submissions for Container With Most Water.\n        ## Memory Usage: 14.5 MB, less than 99.25% of Python online submissions for Container With Most Water.\n        \n        ## Two pointers\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## Runtime: 100 ms, faster than 100.00% of Python online submissions for Container With Most Water.\n        ## Memory Usage: 14.5 MB, less than 99.25% of Python online submissions for Container With Most Water.\n        \n        ## Two pointers\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## Runtime: 100 ms, faster than 100.00% of Python online submissions for Container With Most Water.\n        ## Memory Usage: 14.5 MB, less than 99.25% of Python online submissions for Container With Most Water.\n        \n        ## Two pointers\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## Runtime: 100 ms, faster than 100.00% of Python online submissions for Container With Most Water.\n        ## Memory Usage: 14.5 MB, less than 99.25% of Python online submissions for Container With Most Water.\n        \n        ## Two pointers\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## Runtime: 100 ms, faster than 100.00% of Python online submissions for Container With Most Water.\n        ## Memory Usage: 14.5 MB, less than 99.25% of Python online submissions for Container With Most Water.\n        \n        ## Two pointers\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## Runtime: 100 ms, faster than 100.00% of Python online submissions for Container With Most Water.\n        ## Memory Usage: 14.5 MB, less than 99.25% of Python online submissions for Container With Most Water.\n        \n        ## Two pointers\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## Runtime: 100 ms, faster than 100.00% of Python online submissions for Container With Most Water.\n        ## Memory Usage: 14.5 MB, less than 99.25% of Python online submissions for Container With Most Water.\n        \n        ## Two pointers\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## Runtime: 100 ms, faster than 100.00% of Python online submissions for Container With Most Water.\n        ## Memory Usage: 14.5 MB, less than 99.25% of Python online submissions for Container With Most Water.\n        \n        ## Two pointers\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## Runtime: 100 ms, faster than 100.00% of Python online submissions for Container With Most Water.\n        ## Memory Usage: 14.5 MB, less than 99.25% of Python online submissions for Container With Most Water.\n        \n        ## Two pointers\n        ## Time complexity: O(n)\n        ## Space complexity: O(1)\n        ## Runtime: 100 ms, faster than 100.00% of Python online submissions for Container With Most Water.\n        ## Memory Usage: 14.5 MB, less than 99.25% of Python online submissions for Container With Most Water.\n        \n        ## Two"}, {"task_id": "container-with-most-water", "completion": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        max_area = 0\n        left = 0\n        right = len(height) - 1\n        \n        while left < right:\n            area = min(height[left], height[right]) * (right - left)\n            max_area = max(max_area, area)\n            \n            if height[left] < height[right]:\n                left += 1\n            else:\n                right -= 1\n                \n        return max_area"}], "concatenated-words": [{"task_id": "concatenated-words", "completion": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        def is_concatenated(word, word_dict):\n            if word in word_dict:\n                return True\n            for i in range(1, len(word)):\n                left = word[:i]\n                right = word[i:]\n                if left in word_dict and right in word_dict:\n                    return True\n            return False\n        \n        word_dict = set(words)\n        res = []\n        for word in words:\n            if is_concatenated(word, word_dict):\n                res.append(word)\n        return res"}, {"task_id": "concatenated-words", "completion": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        def is_concatenated(word, word_dict):\n            if word in word_dict:\n                return True\n            for i in range(1, len(word)):\n                left = word[:i]\n                right = word[i:]\n                if left in word_dict and right in word_dict:\n                    return True\n                if left in word_dict and is_concatenated(right, word_dict):\n                    return True\n            return False\n        \n        word_dict = set(words)\n        return [word for word in words if is_concatenated(word, word_dict)]"}, {"task_id": "concatenated-words", "completion": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        def is_concatenated(word, word_dict):\n            if word in word_dict:\n                return True\n            for i in range(1, len(word)):\n                left = word[:i]\n                right = word[i:]\n                if left in word_dict and right in word_dict:\n                    return True\n            return False\n        \n        word_dict = set(words)\n        res = []\n        for word in words:\n            if is_concatenated(word, word_dict):\n                res.append(word)\n        return res"}, {"task_id": "concatenated-words", "completion": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        def is_concatenated(word, word_dict):\n            if word in word_dict:\n                return True\n            for i in range(1, len(word)):\n                left = word[:i]\n                right = word[i:]\n                if left in word_dict and right in word_dict:\n                    return True\n                if left in word_dict and is_concatenated(right, word_dict):\n                    return True\n            return False\n        \n        word_dict = set(words)\n        return [word for word in words if is_concatenated(word, word_dict)]"}, {"task_id": "concatenated-words", "completion": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        def is_concatenated(word, word_dict):\n            if word in word_dict:\n                return True\n            for i in range(1, len(word)):\n                left = word[:i]\n                right = word[i:]\n                if left in word_dict and right in word_dict:\n                    return True\n                if left in word_dict and is_concatenated(right, word_dict):\n                    return True\n            return False\n        \n        word_dict = set(words)\n        return [word for word in words if is_concatenated(word, word_dict)]"}], "base-7": [{"task_id": "base-7", "completion": "class Solution(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        if num < 0:\n            num = abs(num)\n            sign = -1\n        else:\n            sign = 1\n        \n        res = \"\"\n        while num > 0:\n            res = str(num % 7) + res\n            num = num // 7\n        \n        if sign == -1:\n            res = \"-\" + res\n        \n        return res"}, {"task_id": "base-7", "completion": "class Solution(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        if num < 0:\n            return \"-\" + self.convertToBase7(-num)\n        \n        res = \"\"\n        while num:\n            res = str(num % 7) + res\n            num //= 7\n        \n        return res"}, {"task_id": "base-7", "completion": "class Solution(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        if num < 0:\n            return \"-\" + self.convertToBase7(-num)\n        \n        res = \"\"\n        while num:\n            res = str(num % 7) + res\n            num = num // 7\n        \n        return res"}, {"task_id": "base-7", "completion": "class Solution(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        if num < 0:\n            return \"-\" + self.convertToBase7(-num)\n        \n        res = \"\"\n        while num:\n            res = str(num % 7) + res\n            num = num // 7\n        \n        return res"}, {"task_id": "base-7", "completion": "class Solution(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        if num < 0:\n            num = abs(num)\n            sign = -1\n        else:\n            sign = 1\n        \n        res = \"\"\n        while num > 0:\n            res = str(num % 7) + res\n            num = num // 7\n        \n        return sign * res"}], "nim-game": [{"task_id": "nim-game", "completion": "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 3:\n            return True\n        else:\n            return False"}, {"task_id": "nim-game", "completion": "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 3:\n            return True\n        else:\n            return False"}, {"task_id": "nim-game", "completion": "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 3:\n            return True\n        else:\n            return False"}, {"task_id": "nim-game", "completion": "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n % 4 == 0:\n            return False\n        else:\n            return True"}, {"task_id": "nim-game", "completion": "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 3:\n            return True\n        else:\n            return False"}], "n-queens-ii": [{"task_id": "n-queens-ii", "completion": "class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        def backtrack(row, cols, diag1, diag2):\n            if row == n:\n                return 1\n            \n            count = 0\n            for col in range(n):\n                if col not in cols and row + col not in diag1 and row - col not in diag2:\n                    cols.add(col)\n                    diag1.add(row + col)\n                    diag2.add(row - col)\n                    count += backtrack(row + 1, cols, diag1, diag2)\n                    cols.remove(col)\n                    diag1.remove(row + col)\n                    diag2.remove(row - col)\n            return count\n        \n        return backtrack(0, set(), set(), set())"}, {"task_id": "n-queens-ii", "completion": "class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        def backtrack(row, cols, diag1, diag2):\n            if row == n:\n                return 1\n            \n            count = 0\n            for col in range(n):\n                if col not in cols and row + col not in diag1 and row - col not in diag2:\n                    cols.add(col)\n                    diag1.add(row + col)\n                    diag2.add(row - col)\n                    count += backtrack(row + 1, cols, diag1, diag2)\n                    cols.remove(col)\n                    diag1.remove(row + col)\n                    diag2.remove(row - col)\n            return count\n        \n        return backtrack(0, set(), set(), set())"}, {"task_id": "n-queens-ii", "completion": "class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        def backtrack(row, cols, diag1, diag2):\n            if row == n:\n                return 1\n            \n            count = 0\n            for col in range(n):\n                if col not in cols and row + col not in diag1 and row - col not in diag2:\n                    cols.add(col)\n                    diag1.add(row + col)\n                    diag2.add(row - col)\n                    count += backtrack(row + 1, cols, diag1, diag2)\n                    cols.remove(col)\n                    diag1.remove(row + col)\n                    diag2.remove(row - col)\n            return count\n        \n        return backtrack(0, set(), set(), set())"}, {"task_id": "n-queens-ii", "completion": "class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        def backtrack(row, cols, diag1, diag2):\n            if row == n:\n                return 1\n            \n            count = 0\n            for col in range(n):\n                if col not in cols and row + col not in diag1 and row - col not in diag2:\n                    cols.add(col)\n                    diag1.add(row + col)\n                    diag2.add(row - col)\n                    count += backtrack(row + 1, cols, diag1, diag2)\n                    cols.remove(col)\n                    diag1.remove(row + col)\n                    diag2.remove(row - col)\n            return count\n        \n        return backtrack(0, set(), set(), set())"}, {"task_id": "n-queens-ii", "completion": "class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        def backtrack(row, cols, diag1, diag2):\n            if row == n:\n                return 1\n            \n            count = 0\n            for col in range(n):\n                if col not in cols and row + col not in diag1 and row - col not in diag2:\n                    cols.add(col)\n                    diag1.add(row + col)\n                    diag2.add(row - col)\n                    count += backtrack(row + 1, cols, diag1, diag2)\n                    cols.remove(col)\n                    diag1.remove(row + col)\n                    diag2.remove(row - col)\n            return count\n        \n        return backtrack(0, set(), set(), set())"}], "n-queens": [{"task_id": "n-queens", "completion": "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def is_valid(board, row, col):\n            for i in range(row):\n                if board[i][col] == 'Q':\n                    return False\n            for i, j in zip(range(row, -1, -1), range(col, -1, -1)):\n                if board[i][j] == 'Q':\n                    return False\n            for i, j in zip(range(row, n), range(col, -1, -1)):\n                if board[i][j] == 'Q':\n                    return False\n            return True\n        \n        def backtrack(board, row):\n            if row == n:\n                res.append([\"\".join(row) for row in board])\n                return\n            for col in range(n):\n                if is_valid(board, row, col):\n                    board[row][col] = 'Q'\n                    backtrack(board, row + 1)\n                    board[row][col] = '.'\n        \n        res = []\n        board = [['.' for _ in range(n)] for _ in range(n)]\n        backtrack(board, 0)\n        return res"}, {"task_id": "n-queens", "completion": "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def is_valid(board, row, col):\n            for i in range(row):\n                if board[i][col] == 'Q':\n                    return False\n            for i, j in zip(range(row, -1, -1), range(col, -1, -1)):\n                if board[i][j] == 'Q':\n                    return False\n            for i, j in zip(range(row, n), range(col, -1, -1)):\n                if board[i][j] == 'Q':\n                    return False\n            return True\n        \n        def backtrack(board, row):\n            if row == n:\n                res.append([\"\".join(row) for row in board])\n                return\n            for col in range(n):\n                if is_valid(board, row, col):\n                    board[row][col] = 'Q'\n                    backtrack(board, row + 1)\n                    board[row][col] = '.'\n        \n        res = []\n        board = [['.' for _ in range(n)] for _ in range(n)]\n        backtrack(board, 0)\n        return res"}, {"task_id": "n-queens", "completion": "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def is_valid(board, row, col):\n            for i in range(row):\n                if board[i][col] == 'Q':\n                    return False\n            i, j = row - 1, col - 1\n            while i >= 0 and j >= 0:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j -= 1\n            i, j = row - 1, col + 1\n            while i >= 0 and j < n:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j += 1\n            return True\n        \n        def backtrack(board, row):\n            if row == n:\n                res.append([''.join(row) for row in board])\n                return\n            for col in range(n):\n                if is_valid(board, row, col):\n                    board[row][col] = 'Q'\n                    backtrack(board, row + 1)\n                    board[row][col] = '.'\n        \n        res = []\n        board = [['.' for _ in range(n)] for _ in range(n)]\n        backtrack(board, 0)\n        return res"}, {"task_id": "n-queens", "completion": "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def is_valid(board, row, col):\n            for i in range(row):\n                if board[i][col] == 'Q':\n                    return False\n            i, j = row - 1, col - 1\n            while i >= 0 and j >= 0:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j -= 1\n            i, j = row - 1, col + 1\n            while i >= 0 and j < n:\n                if board[i][j] == 'Q':\n                    return False\n                i -= 1\n                j += 1\n            return True\n        \n        def backtrack(board, row):\n            if row == n:\n                res.append([''.join(row) for row in board])\n                return\n            for col in range(n):\n                if is_valid(board, row, col):\n                    board[row][col] = 'Q'\n                    backtrack(board, row + 1)\n                    board[row][col] = '.'\n        \n        res = []\n        board = [['.' for _ in range(n)] for _ in range(n)]\n        backtrack(board, 0)\n        return res"}, {"task_id": "n-queens", "completion": "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def is_valid(board, row, col):\n            for i in range(row):\n                if board[i][col] == 'Q':\n                    return False\n            for i, j in zip(range(row, -1, -1), range(col, -1, -1)):\n                if board[i][j] == 'Q':\n                    return False\n            for i, j in zip(range(row, n), range(col, -1, -1)):\n                if board[i][j] == 'Q':\n                    return False\n            return True\n        \n        def backtrack(board, row):\n            if row == n:\n                res.append([\"\".join(row) for row in board])\n                return\n            for col in range(n):\n                if is_valid(board, row, col):\n                    board[row][col] = 'Q'\n                    backtrack(board, row + 1)\n                    board[row][col] = '.'\n        \n        res = []\n        board = [['.' for _ in range(n)] for _ in range(n)]\n        backtrack(board, 0)\n        return res"}], "word-search": [{"task_id": "word-search", "completion": "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(i,j,k):\n            if k == len(word):\n                return True\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[k]:\n                return False\n            board[i][j] = '#'\n            res = dfs(i+1,j,k+1) or dfs(i-1,j,k+1) or dfs(i,j+1,k+1) or dfs(i,j-1,k+1)\n            board[i][j] = word[k]\n            return res\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if dfs(i,j,0):\n                    return True\n        return False"}, {"task_id": "word-search", "completion": "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(i,j,k):\n            if k == len(word):\n                return True\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[k]:\n                return False\n            board[i][j] = '#'\n            res = dfs(i+1,j,k+1) or dfs(i-1,j,k+1) or dfs(i,j+1,k+1) or dfs(i,j-1,k+1)\n            board[i][j] = word[k]\n            return res\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if dfs(i,j,0):\n                    return True\n        return False"}, {"task_id": "word-search", "completion": "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(i,j,k):\n            if k == len(word):\n                return True\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[k]:\n                return False\n            board[i][j] = '#'\n            res = dfs(i+1,j,k+1) or dfs(i-1,j,k+1) or dfs(i,j+1,k+1) or dfs(i,j-1,k+1)\n            board[i][j] = word[k]\n            return res\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if dfs(i,j,0):\n                    return True\n        return False"}, {"task_id": "word-search", "completion": "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(i,j,k):\n            if k == len(word):\n                return True\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[k]:\n                return False\n            board[i][j] = '#'\n            res = dfs(i+1,j,k+1) or dfs(i-1,j,k+1) or dfs(i,j+1,k+1) or dfs(i,j-1,k+1)\n            board[i][j] = word[k]\n            return res\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if dfs(i,j,0):\n                    return True\n        return False"}, {"task_id": "word-search", "completion": "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(i,j,k):\n            if k == len(word):\n                return True\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[k]:\n                return False\n            board[i][j] = '#'\n            res = dfs(i+1,j,k+1) or dfs(i-1,j,k+1) or dfs(i,j+1,k+1) or dfs(i,j-1,k+1)\n            board[i][j] = word[k]\n            return res\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if dfs(i,j,0):\n                    return True\n        return False"}], "merge-sorted-array": [{"task_id": "merge-sorted-array", "completion": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3"}, {"task_id": "merge-sorted-array", "completion": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1"}, {"task_id": "merge-sorted-array", "completion": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1"}, {"task_id": "merge-sorted-array", "completion": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3"}, {"task_id": "merge-sorted-array", "completion": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1\n        \n        # nums1 = [1,2,3,0,0,0]\n        # m = 3\n        # nums2 = [2,5,6]\n        # n = 3\n        \n        # nums1 = [1]\n        # m = 1\n        # nums2 = []\n        # n = 0\n        \n        # nums1 = [0]\n        # m = 0\n        # nums2 = [1]\n        # n = 1"}], "third-maximum-number": [{"task_id": "third-maximum-number", "completion": "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = list(set(nums))\n        if len(nums) < 3:\n            return max(nums)\n        else:\n            nums.sort()\n            return nums[-3]"}, {"task_id": "third-maximum-number", "completion": "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. sort the list\n        # 2. check if the list has 3 elements\n        # 3. if not, return the max element\n        # 4. if yes, return the third max element\n        \n        nums.sort()\n        if len(nums) < 3:\n            return nums[-1]\n        else:\n            return nums[-3]"}, {"task_id": "third-maximum-number", "completion": "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = sorted(set(nums))\n        if len(nums) < 3:\n            return nums[-1]\n        else:\n            return nums[-3]"}, {"task_id": "third-maximum-number", "completion": "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = list(set(nums))\n        if len(nums) < 3:\n            return max(nums)\n        else:\n            nums.sort()\n            return nums[-3]"}, {"task_id": "third-maximum-number", "completion": "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. sort the list\n        # 2. find the third max\n        # 3. if the third max is not in the list, return the last max\n        \n        nums.sort()\n        if len(nums) < 3:\n            return nums[-1]\n        else:\n            return nums[-3]"}]}