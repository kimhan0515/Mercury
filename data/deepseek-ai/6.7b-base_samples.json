{"spiral-matrix": [{"task_id": "spiral-matrix", "completion": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \uc608\uc678\ucc98\ub9ac\n        if not matrix:\n            return []\n        \n        # 2. \ucd08\uae30\ud654\n        rows, cols = len(matrix), len(matrix[0])\n        up, left = 0, 0\n        right, down = cols - 1, rows - 1\n        res = []\n        \n        # 3. \ubc18\ubcf5\n        while len(res) < rows * cols:\n            # \uc624\ub978\ucabd\uc73c\ub85c \uc774\ub3d9\n            for col in range(left, right + 1):\n                res.append(matrix[up][col])\n            # \uc544\ub798\ub85c \uc774\ub3d9\n            for row in range(up + 1, down + 1):\n                res.append(matrix[row][right])\n            # \uc67c\ucabd\uc73c\ub85c \uc774\ub3d9\n            if up != down:\n                for col in range(right - 1, left - 1, -1):\n                    res.append(matrix[down][col])\n            # \uc704\ub85c \uc774\ub3d9\n            if left != right:\n                for row in range(down - 1, up, -1):\n                    res.append(matrix[row][left])\n            # \uc88c\ud45c \uc774\ub3d9\n            up += 1\n            left += 1\n            right -= 1\n            down -= 1\n            \n        return res"}, {"task_id": "spiral-matrix", "completion": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not matrix:\n            return []\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        res = []\n        \n        i = 0\n        j = 0\n        \n        while i < m and j < n:\n            for k in range(j, n):\n                res.append(matrix[i][k])\n            i += 1\n            \n            for k in range(i, m):\n                res.append(matrix[k][n-1])\n            n -= 1\n            \n            if i < m:\n                for k in range(n-1, j-1, -1):\n                    res.append(matrix[m-1][k])\n                m -= 1\n            \n            if j < n:\n                for k in range(m-1, i-1, -1):\n                    res.append(matrix[k][j])\n                j += 1\n        \n        return res"}, {"task_id": "spiral-matrix", "completion": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \uc608\uc678\ucc98\ub9ac\n        if not matrix:\n            return []\n        \n        # 2. \ucd08\uae30\ud654\n        row_begin = 0\n        row_end = len(matrix) - 1\n        col_begin = 0\n        col_end = len(matrix[0]) - 1\n        \n        # 3. \uc21c\ud68c\n        result = []\n        while row_begin <= row_end and col_begin <= col_end:\n            # \uc624\ub978\ucabd\uc73c\ub85c \uc774\ub3d9\n            for i in range(col_begin, col_end + 1):\n                result.append(matrix[row_begin][i])\n            row_begin += 1\n            \n            # \uc544\ub798\ucabd\uc73c\ub85c \uc774\ub3d9\n            for i in range(row_begin, row_end + 1):\n                result.append(matrix[i][col_end])\n            col_end -= 1\n            \n            # \uc67c\ucabd\uc73c\ub85c \uc774\ub3d9\n            if row_begin <= row_end:\n                for i in range(col_end, col_begin - 1, -1):\n                    result.append(matrix[row_end][i])\n                row_end -= 1\n            \n            # \uc704\ucabd\uc73c\ub85c \uc774\ub3d9\n            if col_begin <= col"}, {"task_id": "spiral-matrix", "completion": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \uc608\uc678\ucc98\ub9ac\n        if not matrix:\n            return []\n        \n        # 2. \ucd08\uae30\ud654\n        row_begin = 0\n        row_end = len(matrix) - 1\n        col_begin = 0\n        col_end = len(matrix[0]) - 1\n        result = []\n        \n        # 3. \ubc18\ubcf5\n        while row_begin <= row_end and col_begin <= col"}, {"task_id": "spiral-matrix", "completion": "class Solution(object):\n    def spiralOrder(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not matrix:\n            return []\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        res = []\n        \n        i = 0\n        j = 0\n        \n        while i < m and j < n:\n            for k in range(j, n):\n                res.append(matrix[i][k])\n            i += 1\n            \n            for k in range(i, m):\n                res.append(matrix[k][n-1])\n            n -= 1\n            \n            if i < m:\n                for k in range(n-1, j-1, -1):\n                    res.append(matrix[m-1][k])\n                m -= 1\n            \n            if j < n:\n                for k in range(m-1, i-1, -1):\n                    res.append(matrix[k][j])\n                j += 1\n        \n        return res"}], "summary-ranges": [{"task_id": "summary-ranges", "completion": "class Solution(object):\n    def summaryRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        if not nums:\n            return []\n        \n        res = []\n        start = nums[0]\n        end = nums[0]\n        \n        for i in range(1, len(nums)):\n            if nums[i] == end + 1:\n                end = nums[i]\n            else:\n                if start == end:\n                    res.append(str(start))\n                else:\n                    res.append(str(start) + \"->\" + str(end))\n                start = nums[i]\n                end = nums[i]\n        \n        if start == end:\n            res.append(str(start))\n        else:\n            res.append(str(start) + \"->\" + str(end))\n        \n        return res"}, {"task_id": "summary-ranges", "completion": "class Solution(object):\n    def summaryRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(nums) == 0:\n            return []\n        \n        if len(nums) == 1:\n            return [str(nums[0])]\n        \n        start = nums[0]\n        end = nums[0]\n        res = []\n        \n        for i in range(1, len(nums)):\n            if nums[i] == end + 1:\n                end = nums[i]\n            else:\n                if start == end:\n                    res.append(str(start))\n                else:\n                    res.append(str(start) + \"->\" + str(end))\n                start = nums[i]\n                end = nums[i]\n        \n        if start == end:\n            res.append(str(start))\n        else:\n            res.append(str(start) + \"->\" + str(end))\n        \n        return res"}, {"task_id": "summary-ranges", "completion": "class Solution(object):\n    def summaryRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(nums) == 0:\n            return []\n        \n        if len(nums) == 1:\n            return [str(nums[0])]\n        \n        start = nums[0]\n        end = nums[0]\n        res = []\n        \n        for i in range(1, len(nums)):\n            if nums[i] == end + 1:\n                end = nums[i]\n            else:\n                if start == end:\n                    res.append(str(start))\n                else:\n                    res.append(str(start) + \"->\" + str(end))\n                start = nums[i]\n                end = nums[i]\n        \n        if start == end:\n            res.append(str(start))\n        else:\n            res.append(str(start) + \"->\" + str(end))\n        \n        return res"}, {"task_id": "summary-ranges", "completion": "class Solution(object):\n    def summaryRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(nums) == 0:\n            return []\n        \n        if len(nums) == 1:\n            return [str(nums[0])]\n        \n        start = nums[0]\n        end = nums[0]\n        res = []\n        \n        for i in range(1, len(nums)):\n            if nums[i] == end + 1:\n                end = nums[i]\n            else:\n                if start == end:\n                    res.append(str(start))\n                else:\n                    res.append(str(start) + \"->\" + str(end))\n                start = nums[i]\n                end = nums[i]\n        \n        if start == end:\n            res.append(str(start))\n        else:\n            res.append(str(start) + \"->\" + str(end))\n        \n        return res"}, {"task_id": "summary-ranges", "completion": "class Solution(object):\n    def summaryRanges(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(nums) == 0:\n            return []\n        \n        if len(nums) == 1:\n            return [str(nums[0])]\n        \n        start = nums[0]\n        end = nums[0]\n        res = []\n        \n        for i in range(1, len(nums)):\n            if nums[i] == end + 1:\n                end = nums[i]\n            else:\n                if start == end:\n                    res.append(str(start))\n                else:\n                    res.append(str(start) + \"->\" + str(end))\n                start = nums[i]\n                end = nums[i]\n        \n        if start == end:\n            res.append(str(start))\n        else:\n            res.append(str(start) + \"->\" + str(end))\n        \n        return res"}], "distinct-subsequences": [{"task_id": "distinct-subsequences", "completion": "class Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = number of distinct subsequences of s[:i] which equals t[:j]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] if s[i-1] == t[j-1]\n        # dp[i][j] = dp[i-1][j] if s[i-1] != t[j-1]\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][0] = 1\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] if s[i-1] == t[j-1]\n        # dp[i][j] = dp[i-1][j] if s[i-1] != t[j-1]\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][0] = 1\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] if s[i-1] == t[j-1]\n        # dp[i][j] = dp[i-1][j] if s[i-1] != t[j-1]\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][0] = 1\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] if s[i-1] == t[j-1]\n        # dp[i][j] = dp[i-1][j] if s[i-1] != t[j-1]\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][0] = 1\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] if s[i-1] == t[j-1]\n        # dp[i][j] = dp[i-1][j] if s[i-1] != t[j-1]\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][0] = 1\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] if s[i-1] == t[j-1]\n        # dp[i][j] = dp[i-1][j] if s[i-1] != t[j-1]\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][0] = 1\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] if s[i-1] == t[j-1]\n        # dp[i][j] = dp[i-1][j] if s[i-1] != t[j-1]\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][0] = 1\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] if s[i-1] == t[j-1]\n        # dp[i][j] = dp[i-1][j] if s[i-1] != t[j-1]\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][0] = 1\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] if s[i-1] == t[j-1]\n        # dp[i][j] = dp[i"}, {"task_id": "distinct-subsequences", "completion": "class Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = number of distinct subsequences of s[:i] which equals t[:j]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] if s[i-1] == t[j-1]\n        # dp[i][j] = dp[i-1][j] if s[i-1] != t[j-1]\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][0] = 1\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] if s[i-1] == t[j-1]\n        # dp[i][j] = dp[i-1][j] if s[i-1] != t[j-1]\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][0] = 1\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] if s[i-1] == t[j-1]\n        # dp[i][j] = dp[i-1][j] if s[i-1] != t[j-1]\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][0] = 1\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] if s[i-1] == t[j-1]\n        # dp[i][j] = dp[i-1][j] if s[i-1] != t[j-1]\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][0] = 1\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] if s[i-1] == t[j-1]\n        # dp[i][j] = dp[i-1][j] if s[i-1] != t[j-1]\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][0] = 1\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] if s[i-1] == t[j-1]\n        # dp[i][j] = dp[i-1][j] if s[i-1] != t[j-1]\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][0] = 1\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] if s[i-1] == t[j-1]\n        # dp[i][j] = dp[i-1][j] if s[i-1] != t[j-1]\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][0] = 1\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] if s[i-1] == t[j-1]\n        # dp[i][j] = dp[i-1][j] if s[i-1] != t[j-1]\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][0] = 1\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] if s[i-1] == t[j-1]\n        # dp[i][j] = dp[i"}, {"task_id": "distinct-subsequences", "completion": "class Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = number of distinct subsequences of s[:i] which equals t[:j]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] if s[i-1] == t[j-1]\n        # dp[i][j] = dp[i-1][j] if s[i-1] != t[j-1]\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][0] = 1\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] if s[i-1] == t[j-1]\n        # dp[i][j] = dp[i-1][j] if s[i-1] != t[j-1]\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][0] = 1\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] if s[i-1] == t[j-1]\n        # dp[i][j] = dp[i-1][j] if s[i-1] != t[j-1]\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][0] = 1\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] if s[i-1] == t[j-1]\n        # dp[i][j] = dp[i-1][j] if s[i-1] != t[j-1]\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][0] = 1\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] if s[i-1] == t[j-1]\n        # dp[i][j] = dp[i-1][j] if s[i-1] != t[j-1]\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][0] = 1\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] if s[i-1] == t[j-1]\n        # dp[i][j] = dp[i-1][j] if s[i-1] != t[j-1]\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][0] = 1\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] if s[i-1] == t[j-1]\n        # dp[i][j] = dp[i-1][j] if s[i-1] != t[j-1]\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][0] = 1\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] if s[i-1] == t[j-1]\n        # dp[i][j] = dp[i-1][j] if s[i-1] != t[j-1]\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][0] = 1\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] if s[i-1] == t[j-1]\n        # dp[i][j] = dp[i"}, {"task_id": "distinct-subsequences", "completion": "class Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = number of distinct subsequences of s[:i] which equals t[:j]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] if s[i-1] == t[j-1]\n        # dp[i][j] = dp[i-1][j] if s[i-1] != t[j-1]\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][0] = 1\n        \n        # Time: O(n*m)\n        # Space: O(n*m)\n        \n        n = len(s)\n        m = len(t)\n        \n        dp = [[0 for _ in range(m+1)] for _ in range(n+1)]\n        \n        for i in range(n+1):\n            dp[i][0] = 1\n        \n        for i in range(1, n+1):\n            for j in range(1, m+1):\n                if s[i-1] == t[j-1]:\n                    dp[i][j] = dp[i-1][j] + dp[i-1][j-1]\n                else:\n                    dp[i][j] = dp[i-1][j]\n        \n        return dp[n][m]"}, {"task_id": "distinct-subsequences", "completion": "class Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = number of distinct subsequences of s[:i] which equals t[:j]\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] if s[i-1] == t[j-1]\n        # dp[i][j] = dp[i-1][j] if s[i-1] != t[j-1]\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][0] = 1\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] if s[i-1] == t[j-1]\n        # dp[i][j] = dp[i-1][j] if s[i-1] != t[j-1]\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][0] = 1\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] if s[i-1] == t[j-1]\n        # dp[i][j] = dp[i-1][j] if s[i-1] != t[j-1]\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][0] = 1\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] if s[i-1] == t[j-1]\n        # dp[i][j] = dp[i-1][j] if s[i-1] != t[j-1]\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][0] = 1\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] if s[i-1] == t[j-1]\n        # dp[i][j] = dp[i-1][j] if s[i-1] != t[j-1]\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][0] = 1\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] if s[i-1] == t[j-1]\n        # dp[i][j] = dp[i-1][j] if s[i-1] != t[j-1]\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][0] = 1\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] if s[i-1] == t[j-1]\n        # dp[i][j] = dp[i-1][j] if s[i-1] != t[j-1]\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][0] = 1\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] if s[i-1] == t[j-1]\n        # dp[i][j] = dp[i-1][j] if s[i-1] != t[j-1]\n        # dp[0][j] = 0\n        # dp[i][0] = 1\n        # dp[0][0] = 1\n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] if s[i-1] == t[j-1]\n        # dp[i][j] = dp[i"}], "first-missing-positive": [{"task_id": "first-missing-positive", "completion": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u5c06\u6240\u6709\u8d1f\u6570\u548c0\u90fd\u7f6e\u4e3an+1\n        n = len(nums)\n        for i in range(n):\n            if nums[i] <= 0:\n                nums[i] = n + 1\n        \n        # 2. \u5c06\u6240\u6709\u5728[1,n]\u8303\u56f4\u5185\u7684\u6570\u5bf9\u5e94\u7684\u6570\u7ec4\u4e0b\u6807\u5bf9\u5e94\u7684\u6570\u7f6e\u4e3a\u8d1f\u6570\n        for i in range(n):\n            num = abs(nums[i])\n            if num <= n:\n                nums[num - 1] = -abs(nums[num - 1])\n        \n        # 3. \u627e\u5230\u7b2c\u4e00\u4e2a\u6b63\u6570\uff0c\u8fd4\u56de\u4e0b\u6807+1\n        for i in range(n):\n            if nums[i] > 0:\n                return i + 1\n        \n        # 4. \u5982\u679c\u6240\u6709\u6570\u90fd\u4e3a\u8d1f\u6570\uff0c\u8fd4\u56den+1\n        return n + 1"}, {"task_id": "first-missing-positive", "completion": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc815\ub82c\n        nums.sort()\n        \n        # 2. \uccab\ubc88\uc9f8 \uc22b\uc790\uac00 1\uc774 \uc544\ub2c8\ub77c\uba74 1\uc744 \ubc18\ud658\n        if nums[0] > 1:\n            return 1\n        \n        # 3. \uccab\ubc88\uc9f8 \uc22b\uc790\uac00 1\uc774\ub77c\uba74 \uc21c\ud68c\ud558\uba74\uc11c \uc5f0\uc18d\ub418\uc9c0 \uc54a\ub294 \uc22b\uc790\ub97c \ucc3e\uc544 \ubc18\ud658\n        for i in range(len(nums)-1):\n            if nums[i+1] - nums[i] > 1:\n                return nums[i] + 1\n        \n        # 4. \ub9c8\uc9c0\ub9c9 \uc22b\uc790\uae4c\uc9c0 \uc5f0\uc18d\ub418\uc9c0 \uc54a\ub294 \uc22b\uc790\uac00 \uc5c6\ub2e4\uba74 \ub9c8\uc9c0\ub9c9 \uc22b\uc790 + 1 \ubc18\ud658\n        return nums[-1] + 1"}, {"task_id": "first-missing-positive", "completion": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u5c06\u8d1f\u6570\u548c0\u90fd\u53d8\u4e3an+1\n        n = len(nums)\n        for i in range(n):\n            if nums[i] <= 0:\n                nums[i] = n + 1\n        \n        # 2. \u5c06nums[i]\u5bf9\u5e94\u7684nums[nums[i] - 1] \u53d8\u4e3a\u8d1f\u6570\n        for i in range(n):\n            num = abs(nums[i])\n            if num <= n:\n                nums[num - 1] = -abs(nums[num - 1])\n        \n        # 3. \u627e\u5230\u7b2c\u4e00\u4e2a\u6b63\u6570\u7684\u4f4d\u7f6e\n        for i in range(n):\n            if nums[i] > 0:\n                return i + 1\n        \n        # 4. \u5982\u679c\u90fd\u4e3a\u8d1f\u6570\uff0c\u5219\u8fd4\u56den+1\n        return n + 1"}, {"task_id": "first-missing-positive", "completion": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc815\ub82c\n        nums.sort()\n        \n        # 2. \uccab\ubc88\uc9f8 \uc22b\uc790\uac00 1\uc774 \uc544\ub2c8\uba74 1 \ubc18\ud658\n        if nums[0] > 1:\n            return 1\n        \n        # 3. \uccab\ubc88\uc9f8 \uc22b\uc790\uac00 1\uc774\uba74 \ub450\ubc88\uc9f8 \uc22b\uc790\ubd80\ud130 \uc21c\ud68c\n        for i in range(1, len(nums)):\n            # 3-1. \uc22b\uc790\uac00 \uc5f0\uc18d\ub418\uc9c0 \uc54a\uc73c\uba74 \uc22b\uc790 \ubc18\ud658\n            if nums[i] - nums[i-1] > 1:\n                return nums[i-1] + 1\n        \n        # 4. \ub9c8\uc9c0\ub9c9 \uc22b\uc790\uae4c\uc9c0 \uc5f0\uc18d\ub418\uba74 \ub9c8\uc9c0\ub9c9 \uc22b\uc790 + 1 \ubc18\ud658\n        return nums[-1] + 1"}, {"task_id": "first-missing-positive", "completion": "class Solution(object):\n    def firstMissingPositive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u5c06\u8d1f\u6570\u548c0\u66ff\u6362\u4e3an+1\n        n = len(nums)\n        for i in range(n):\n            if nums[i] <= 0:\n                nums[i] = n + 1\n        \n        # 2. \u5c06\u6570\u7ec4\u4e2d\u51fa\u73b0\u7684\u6570\u5b57\u5bf9\u5e94\u7684\u4e0b\u6807\u7684\u6570\u5b57\u7f6e\u4e3a\u8d1f\u6570\n        for i in range(n):\n            num = abs(nums[i])\n            if num <= n:\n                nums[num - 1] = -abs(nums[num - 1])\n        \n        # 3. \u627e\u5230\u7b2c\u4e00\u4e2a\u6b63\u6570\u7684\u4e0b\u6807\n        for i in range(n):\n            if nums[i] > 0:\n                return i + 1\n        \n        # 4. \u5982\u679c\u6240\u6709\u6570\u5b57\u90fd\u4e3a\u8d1f\u6570\uff0c\u5219\u8fd4\u56den+1\n        return n + 1"}], "permutation-sequence": [{"task_id": "permutation-sequence", "completion": "class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. 1st permutation is 123456789\n        # 2. 2nd permutation is 123456798\n        # 3. 3rd permutation is 123456879\n        # 4. 4th permutation is 123456897\n        # 5. 5th permutation is 123456978\n        # 6. 6th permutation is 123456987\n        # 7. 7th permutation is 123457869\n        # 8. 8th permutation is 123457896\n        # 9. 9th permutation is 123457968\n        # 10. 10th permutation is 123457986\n        # 11. 11th permutation is 123458679\n        # 12. 12th permutation is 123458697\n        # 13. 13th permutation is 123458769\n        # 14. 14th permutation is 123458796\n        # 15. 15th permutation is 123458967\n        # 16. 16th permutation is 123458976\n        # 17. 17th permutation is 123459678\n        # 18. 18th permutation is 123459768\n        # 19. 19th permutation is 123459786\n        # 20. 20th permutation is 123459867\n        # 21. 21st permutation is 123459876\n        # 22. 22nd permutation is 123461234\n        # 23. 23rd permutation is 123461243\n        # 24. 24th permutation is 123461324\n        # 25. 25th permutation is 123461342\n        # 26. 26th permutation is 123461423\n        # 27. 27th permutation is 123461432\n        # 28. 28th permutation is 123462134\n        # 29. 29th permutation is 123462143\n        # 30. 30th permutation is 123462314\n        # 31. 31st permutation is 123462341\n        # 32. 32nd permutation is 123462413\n        # 33. 33rd permutation is 123462431\n        # 34. 34th permutation is 123463124\n        # 35. 35th permutation is 123463142\n        # 36. 36th permutation is 123463214\n        # 37. 37th permutation is 123463241\n        # 38. 38th permutation is 123463412\n        # 39. 39th permutation is 123463421\n        # 40. 40th permutation is 123464123\n        # 41. 41st permutation is 123464132\n        # 42. 42nd permutation is 123464213\n        # 43. 43rd permutation is 123464231\n        # 44. 44th"}, {"task_id": "permutation-sequence", "completion": "class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. 1st permutation is 123456789\n        # 2. 2nd permutation is 123456798\n        # 3. 3rd permutation is 123456879\n        # 4. 4th permutation is 123456897\n        # 5. 5th permutation is 123456978\n        # 6. 6th permutation is 123456987\n        # 7. 7th permutation is 123457869\n        # 8. 8th permutation is 123457896\n        # 9. 9th permutation is 123457968\n        # 10. 10th permutation is 123457986\n        # 11. 11th permutation is 123458679\n        # 12. 12th permutation is 123458697\n        # 13. 13th permutation is 123458769\n        # 14. 14th permutation is 123458796\n        # 15. 15th permutation is 123458967\n        # 16. 16th permutation is 123458976\n        # 17. 17th permutation is 123459678\n        # 18. 18th permutation is 123459768\n        # 19. 19th permutation is 123459786\n        # 20. 20th permutation is 123459867\n        # 21. 21st permutation is 123459876\n        # 22. 22nd permutation is 123461234\n        # 23. 23rd permutation is 123461243\n        # 24. 24th permutation is 123461324\n        # 25. 25th permutation is 123461342\n        # 26. 26th permutation is 123461423\n        # 27. 27th permutation is 123461432\n        # 28. 28th permutation is 123462134\n        # 29. 29th permutation is 123462143\n        # 30. 30th permutation is 123462314\n        # 31. 31st permutation is 123462341\n        # 32. 32nd permutation is 123462413\n        # 33. 33rd permutation is 123462431\n        # 34. 34th permutation is 123463124\n        # 35. 35th permutation is 123463142\n        # 36. 36th permutation is 123463214\n        # 37. 37th permutation is 123463241\n        # 38. 38th permutation is 123463412\n        # 39. 39th permutation is 123463421\n        # 40. 40th permutation is 123464123\n        # 41. 41st permutation is 123464132\n        # 42. 42nd permutation is 123464213\n        # 43. 43rd permutation is 123464231\n        # 44. 44th"}, {"task_id": "permutation-sequence", "completion": "class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. 1st permutation is 123456789\n        # 2. 2nd permutation is 123456798\n        # 3. 3rd permutation is 123456879\n        # 4. 4th permutation is 123456897\n        # 5. 5th permutation is 123456978\n        # 6. 6th permutation is 123456987\n        # 7. 7th permutation is 123457869\n        # 8. 8th permutation is 123457896\n        # 9. 9th permutation is 123457968\n        # 10. 10th permutation is 123457986\n        # 11. 11th permutation is 123458679\n        # 12. 12th permutation is 123458697\n        # 13. 13th permutation is 123458769\n        # 14. 14th permutation is 123458796\n        # 15. 15th permutation is 123458967\n        # 16. 16th permutation is 123458976\n        # 17. 17th permutation is 123459678\n        # 18. 18th permutation is 123459768\n        # 19. 19th permutation is 123459786\n        # 20. 20th permutation is 123459867\n        # 21. 21st permutation is 123459876\n        # 22. 22nd permutation is 123461234\n        # 23. 23rd permutation is 123461243\n        # 24. 24th permutation is 123461324\n        # 25. 25th permutation is 123461342\n        # 26. 26th permutation is 123461423\n        # 27. 27th permutation is 123461432\n        # 28. 28th permutation is 123462134\n        # 29. 29th permutation is 123462143\n        # 30. 30th permutation is 123462314\n        # 31. 31st permutation is 123462341\n        # 32. 32nd permutation is 123462413\n        # 33. 33rd permutation is 123462431\n        # 34. 34th permutation is 123463124\n        # 35. 35th permutation is 123463142\n        # 36. 36th permutation is 123463214\n        # 37. 37th permutation is 123463241\n        # 38. 38th permutation is 123463412\n        # 39. 39th permutation is 123463421\n        # 40. 40th permutation is 123464123\n        # 41. 41st permutation is 123464132\n        # 42. 42nd permutation is 123464213\n        # 43. 43rd permutation is 123464231\n        # 44. 44th"}, {"task_id": "permutation-sequence", "completion": "class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. 1st permutation is 123456789\n        # 2. 2nd permutation is 123456798\n        # 3. 3rd permutation is 123456879\n        # 4. 4th permutation is 123456897\n        # 5. 5th permutation is 123456978\n        # 6. 6th permutation is 123456987\n        # 7. 7th permutation is 123457869\n        # 8. 8th permutation is 123457896\n        # 9. 9th permutation is 123457968\n        # 10. 10th permutation is 123457986\n        # 11. 11th permutation is 123458679\n        # 12. 12th permutation is 123458697\n        # 13. 13th permutation is 123458769\n        # 14. 14th permutation is 123458796\n        # 15. 15th permutation is 123458967\n        # 16. 16th permutation is 123458976\n        # 17. 17th permutation is 123459678\n        # 18. 18th permutation is 123459768\n        # 19. 19th permutation is 123459786\n        # 20. 20th permutation is 123459867\n        # 21. 21st permutation is 123459876\n        # 22. 22nd permutation is 123461234\n        # 23. 23rd permutation is 123461243\n        # 24. 24th permutation is 123461324\n        # 25. 25th permutation is 123461342\n        # 26. 26th permutation is 123461423\n        # 27. 27th permutation is 123461432\n        # 28. 28th permutation is 123462134\n        # 29. 29th permutation is 123462143\n        # 30. 30th permutation is 123462314\n        # 31. 31st permutation is 123462341\n        # 32. 32nd permutation is 123462413\n        # 33. 33rd permutation is 123462431\n        # 34. 34th permutation is 123463124\n        # 35. 35th permutation is 123463142\n        # 36. 36th permutation is 123463214\n        # 37. 37th permutation is 123463241\n        # 38. 38th permutation is 123463412\n        # 39. 39th permutation is 123463421\n        # 40. 40th permutation is 123464123\n        # 41. 41st permutation is 123464132\n        # 42. 42nd permutation is 123464213\n        # 43. 43rd permutation is 123464231\n        # 44. 44th"}, {"task_id": "permutation-sequence", "completion": "class Solution(object):\n    def getPermutation(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. 1st permutation is 123456789\n        # 2. 2nd permutation is 123456798\n        # 3. 3rd permutation is 123456879\n        # 4. 4th permutation is 123456897\n        # 5. 5th permutation is 123456978\n        # 6. 6th permutation is 123456987\n        # 7. 7th permutation is 123457869\n        # 8. 8th permutation is 123457896\n        # 9. 9th permutation is 123457968\n        # 10. 10th permutation is 123457986\n        # 11. 11th permutation is 123458679\n        # 12. 12th permutation is 123458697\n        # 13. 13th permutation is 123458769\n        # 14. 14th permutation is 123458796\n        # 15. 15th permutation is 123458967\n        # 16. 16th permutation is 123458976\n        # 17. 17th permutation is 123459678\n        # 18. 18th permutation is 123459768\n        # 19. 19th permutation is 123459786\n        # 20. 20th permutation is 123459867\n        # 21. 21st permutation is 123459876\n        # 22. 22nd permutation is 123461234\n        # 23. 23rd permutation is 123461243\n        # 24. 24th permutation is 123461324\n        # 25. 25th permutation is 123461342\n        # 26. 26th permutation is 123461423\n        # 27. 27th permutation is 123461432\n        # 28. 28th permutation is 123462134\n        # 29. 29th permutation is 123462143\n        # 30. 30th permutation is 123462314\n        # 31. 31st permutation is 123462341\n        # 32. 32nd permutation is 123462413\n        # 33. 33rd permutation is 123462431\n        # 34. 34th permutation is 123463124\n        # 35. 35th permutation is 123463142\n        # 36. 36th permutation is 123463214\n        # 37. 37th permutation is 123463241\n        # 38. 38th permutation is 123463412\n        # 39. 39th permutation is 123463421\n        # 40. 40th permutation is 123464123\n        # 41. 41st permutation is 123464132\n        # 42. 42nd permutation is 123464213\n        # 43. 43rd permutation is 123464231\n        # 44. 44th"}], "two-sum-ii-input-array-is-sorted": [{"task_id": "two-sum-ii-input-array-is-sorted", "completion": "class Solution(object):\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. Brute Force\n        # Time: O(n^2)\n        # Space: O(1)\n        # for i in range(len(numbers)):\n        #     for j in range(i+1, len(numbers)):\n        #         if numbers[i] + numbers[j] == target:\n        #             return [i+1, j+1]\n        \n        # 2. Two Pointers\n        # Time: O(n)\n        # Space: O(1)\n        left, right = 0, len(numbers)-1\n        while left < right:\n            curr_sum = numbers[left] + numbers[right]\n            if curr_sum == target:\n                return [left+1, right+1]\n            elif currum < target:\n                left += 1\n            else:\n                right -= 1\n        \n        # 3. Binary Search\n        # Time: O(nlogn)\n        # Space: O(1)\n        # for i in range(len(numbers)):\n        #     left, right = i+1, len(numbers)-1\n        #     while left <= right:\n        #         mid = left + (right-left)//2\n        #         if numbers[mid] == target - numbers[i]:\n        #             return [i+1, mid+1]\n        #         elif numbers[mid] < target - numbers[i]:\n        #             left = mid + 1\n        #         else:\n        #             right = mid - 1\n        \n        # 4. Hash Table\n        # Time: O(n)\n        # Space: O(n)\n        # nums = {}\n        # for i, num in enumerate(numbers):\n        #     if target - num in nums:\n        #         return [nums[target-num]+1, i+1]\n        #     nums[num] = i\n        \n        # 5. Binary Search\n        # Time: O(nlogn)\n        # Space: O(1)\n        # for i in range(len(numbers)):\n        #     left, right = i+1, len(numbers)-1\n        #     while left <= right:\n        #         mid = left + (right-left)//2\n        #         if numbers[mid] == target - numbers[i]:\n        #             return [i+1, mid+1]\n        #         elif numbers[mid] < target - numbers[i]:\n        #             left = mid + 1\n        #         else:\n        #             right = mid - 1\n        \n        # 6. Binary Search\n        # Time: O(nlogn)\n        # Space: O(1)\n        # for i in range(len(numbers)):\n        #     left, right = i+1, len(numbers)-1\n        #     while left <= right:\n        #         mid = left + (right-left)//2\n        #         if numbers[mid] == target - numbers[i]:\n        #             return [i+1, mid+1]\n        #         elif numbers[mid] < target - numbers[i]:\n        #             left = mid + 1\n        #         else:\n        #             right = mid - 1\n        \n        # 7. Binary Search\n        # Time: O(nlogn)\n        # Space: O(1)\n        # for i in range(len(numbers)):\n        #     left, right = i+1, len(numbers)-1\n        #     while left <= right:\n        #         mid = left + (right-left)//2\n        #         if numbers[mid] == target - numbers[i]:\n        #             return [i+1, mid+1]\n        #         elif numbers[mid] < target - numbers[i]:\n        #             left = mid + 1\n        #         else:\n        #             right = mid - 1\n        \n        # 8. Binary Search\n        # Time: O(nlogn)\n        # Space: O(1)\n        # for i in range(len(numbers)):\n        #     left, right = i+1, len(numbers)-1\n        #     while left <= right:\n        #         mid = left + (right-left)//2\n        #         if numbers["}, {"task_id": "two-sum-ii-input-array-is-sorted", "completion": "class Solution(object):\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 2 pointer approach\n        # time: O(n)\n        # space: O(1)\n        \n        left = 0\n        right = len(numbers) - 1\n        \n        while left < right:\n            curr_sum = numbers[left] + numbers[right]\n            if curr_sum == target:\n                return [left + 1, right + 1]\n            elif curr"}, {"task_id": "two-sum-ii-input-array-is-sorted", "completion": "class Solution(object):\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. Brute Force\n        # Time: O(n^2)\n        # Space: O(1)\n        # for i in range(len(numbers)):\n        #     for j in range(i+1, len(numbers)):\n        #         if numbers[i] + numbers[j] == target:\n        #             return [i+1, j+1]\n        \n        # 2. Two Pointers\n        # Time: O(n)\n        # Space: O(1)\n        left, right = 0, len(numbers)-1\n        while left < right:\n            curr_sum = numbers[left] + numbers[right]\n            if curr_sum == target:\n                return [left+1, right+1]\n            elif currum < target:\n                left += 1\n            else:\n                right -= 1\n        \n        # 3. Binary Search\n        # Time: O(nlogn)\n        # Space: O(1)\n        # for i in range(len(numbers)):\n        #     left, right = i+1, len(numbers)-1\n        #     while left <= right:\n        #         mid = left + (right-left)//2\n        #         if numbers[mid] == target - numbers[i]:\n        #             return [i+1, mid+1]\n        #         elif numbers[mid] < target - numbers[i]:\n        #             left = mid + 1\n        #         else:\n        #             right = mid - 1\n        \n        # 4. Hash Table\n        # Time: O(n)\n        # Space: O(n)\n        # nums = {}\n        # for i, num in enumerate(numbers):\n        #     if target - num in nums:\n        #         return [nums[target-num]+1, i+1]\n        #     nums[num] = i\n        \n        # 5. Binary Search\n        # Time: O(nlogn)\n        # Space: O(1)\n        # for i in range(len(numbers)):\n        #     left, right = i+1, len(numbers)-1\n        #     while left <= right:\n        #         mid = left + (right-left)//2\n        #         if numbers[mid] == target - numbers[i]:\n        #             return [i+1, mid+1]\n        #         elif numbers[mid] < target - numbers[i]:\n        #             left = mid + 1\n        #         else:\n        #             right = mid - 1\n        \n        # 6. Binary Search\n        # Time: O(nlogn)\n        # Space: O(1)\n        # for i in range(len(numbers)):\n        #     left, right = i+1, len(numbers)-1\n        #     while left <= right:\n        #         mid = left + (right-left)//2\n        #         if numbers[mid] == target - numbers[i]:\n        #             return [i+1, mid+1]\n        #         elif numbers[mid] < target - numbers[i]:\n        #             left = mid + 1\n        #         else:\n        #             right = mid - 1\n        \n        # 7. Binary Search\n        # Time: O(nlogn)\n        # Space: O(1)\n        # for i in range(len(numbers)):\n        #     left, right = i+1, len(numbers)-1\n        #     while left <= right:\n        #         mid = left + (right-left)//2\n        #         if numbers[mid] == target - numbers[i]:\n        #             return [i+1, mid+1]\n        #         elif numbers[mid] < target - numbers[i]:\n        #             left = mid + 1\n        #         else:\n        #             right = mid - 1\n        \n        # 8. Binary Search\n        # Time: O(nlogn)\n        # Space: O(1)\n        # for i in range(len(numbers)):\n        #     left, right = i+1, len(numbers)-1\n        #     while left <= right:\n        #         mid = left + (right-left)//2\n        #         if numbers["}, {"task_id": "two-sum-ii-input-array-is-sorted", "completion": "class Solution(object):\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 2 pointer approach\n        # O(n) time | O(1) space\n        \n        left = 0\n        right = len(numbers) - 1\n        \n        while left < right:\n            currSum = numbers[left] + numbers[right]\n            if currSum > target:\n                right -= 1\n            elif currSum < target:\n                left += 1\n            else:\n                return [left + 1, right + 1]"}, {"task_id": "two-sum-ii-input-array-is-sorted", "completion": "class Solution(object):\n    def twoSum(self, numbers, target):\n        \"\"\"\n        :type numbers: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 2 pointer approach\n        # Time: O(n)\n        # Space: O(1)\n        \n        left = 0\n        right = len(numbers) - 1\n        \n        while left < right:\n            curr_sum = numbers[left] + numbers[right]\n            if curr_sum == target:\n                return [left + 1, right + 1]\n            elif curr"}], "expression-add-operators": [{"task_id": "expression-add-operators", "completion": "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(num, target, path, res, currVal, currNum):\n            if not num and currVal == target:\n                res.append(path)\n                return\n            for i in range(1, len(num) + 1):\n                if i > 1 and num[0] == '0':\n                    break\n                curr = num[:i]\n                if len(path) > 0:\n                    dfs(num[i:], target, path + '+' + curr, res, currVal + int(curr), int(curr))\n                    dfs(num[i:], target, path + '-' + curr, res, currVal - int(curr), -int(curr))\n                    dfs(num[i:], target, path + '*' + curr, res, currVal - currNum + currNum * int(curr), currNum * int(curr))\n                else:\n                    dfs(num[i:], target, curr, res, int(curr), int(curr))\n        \n        res = []\n        dfs(num, target, '', res, 0, 0)\n        return res"}, {"task_id": "expression-add-operators", "completion": "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(num, target, path, res):\n            if not num:\n                if target == 0:\n                    res.append(path)\n                return\n            \n            for i in range(1, len(num) + 1):\n                if i > 1 and num[0] == '0':\n                    break\n                val = int(num[:i])\n                if len(path) == 0:\n                    dfs(num[i:], target - val, path + str(val), res)\n                else:\n                    dfs(num[i:], target - val, path + '+' + str(val), res)\n                    dfs(num[i:], target + val, path + '-' + str(val), res)\n                    dfs(num[i:], target - (val * path[-1] - int(path[-1])), path[:-1] + str(val * path[-1]), res)\n        \n        res = []\n        dfs(num, target, '', res)\n        return res"}, {"task_id": "expression-add-operators", "completion": "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(num, target, path, res, currVal, currNum):\n            if not num and currVal == target:\n                res.append(path)\n                return\n            for i in range(1, len(num) + 1):\n                if i > 1 and num[0] == '0':\n                    break\n                curr = num[:i]\n                if len(path) > 0:\n                    dfs(num[i:], target, path + '+' + curr, res, currVal + int(curr), int(curr))\n                    dfs(num[i:], target, path + '-' + curr, res, currVal - int(curr), -int(curr))\n                    dfs(num[i:], target, path + '*' + curr, res, currVal - currNum + currNum * int(curr), currNum * int(curr))\n                else:\n                    dfs(num[i:], target, curr, res, int(curr), int(curr))\n        \n        res = []\n        dfs(num, target, '', res, 0, 0)\n        return res"}, {"task_id": "expression-add-operators", "completion": "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(num, target, path, res):\n            if not num:\n                if target == 0:\n                    res.append(path)\n                return\n            for i in range(1, len(num) + 1):\n                if i > 1 and num[0] == '0':\n                    break\n                val = int(num[:i])\n                if len(path) == 0:\n                    dfs(num[i:], target - val, num[:i], res)\n                else:\n                    dfs(num[i:], target - val, path + '+' + num[:i], res)\n                    dfs(num[i:], target + val, path + '-' + num[:i], res)\n                    dfs(num[i:], target - (val * path[-1] - '0'), path[:-1] + str(val * path[-1] - '0') + num[:i], res)\n        \n        res = []\n        dfs(num, target, '', res)\n        return res"}, {"task_id": "expression-add-operators", "completion": "class Solution(object):\n    def addOperators(self, num, target):\n        \"\"\"\n        :type num: str\n        :type target: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(num, target, path, res):\n            if not num:\n                if target == 0:\n                    res.append(path)\n                return\n            for i in range(1, len(num) + 1):\n                if i > 1 and num[0] == '0':\n                    break\n                val = int(num[:i])\n                if len(path) == 0:\n                    dfs(num[i:], target - val, num[:i], res)\n                else:\n                    dfs(num[i:], target - val, path + '+' + num[:i], res)\n                    dfs(num[i:], target + val, path + '-' + num[:i], res)\n                    dfs(num[i:], target - (val * path[-1] - '0'), path[:-1] + str(val * path[-1] - '0') + num[:i], res)\n        \n        res = []\n        dfs(num, target, '', res)\n        return res"}], "sum-root-to-leaf-numbers": [{"task_id": "sum-root-to-leaf-numbers", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def dfs(root, curr_sum):\n            if not root:\n                return 0\n            curr_sum = curr_sum * 10 + root.val\n            if not root.left and not root.right:\n                return curr_sum\n            return dfs(root.left, curr_sum) + dfs(root.right, curr_sum)\n        \n        return dfs(root, 0)"}, {"task_id": "sum-root-to-leaf-numbers", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def dfs(root, curr_sum):\n            if not root:\n                return 0\n            \n            curr_sum = curr_sum * 10 + root.val\n            \n            if not root.left and not root.right:\n                return curr_sum\n            \n            return dfs(root.left, curr_sum) + dfs(root.right, curr_sum)\n        \n        return dfs(root, 0)"}, {"task_id": "sum-root-to-leaf-numbers", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def dfs(root, curr_sum):\n            if not root:\n                return 0\n            \n            curr_sum = curr_sum * 10 + root.val\n            \n            if not root.left and not root.right:\n                return curr_sum\n            \n            return dfs(root.left, curr_sum) + dfs(root.right, curr_sum)\n        \n        return dfs(root, 0)"}, {"task_id": "sum-root-to-leaf-numbers", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def dfs(root, curr_sum):\n            if not root:\n                return 0\n            curr_sum = curr_sum * 10 + root.val\n            if not root.left and not root.right:\n                return curr_sum\n            return dfs(root.left, curr_sum) + dfs(root.right, curr_sum)\n        \n        return dfs(root, 0)"}, {"task_id": "sum-root-to-leaf-numbers", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumNumbers(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def dfs(root, curr):\n            if not root:\n                return 0\n            curr = curr * 10 + root.val\n            if not root.left and not root.right:\n                return curr\n            return dfs(root.left, curr) + dfs(root.right, curr)\n        \n        return dfs(root, 0)"}], "license-key-formatting": [{"task_id": "license-key-formatting", "completion": "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        s = s.replace('-', '')\n        s = s.upper()\n        s = s[::-1]\n        res = ''\n        for i in range(len(s)):\n            if i % k == 0 and i != 0:\n                res += '-'\n            res += s[i]\n        return res[::-1]"}, {"task_id": "license-key-formatting", "completion": "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        s = s.replace(\"-\", \"\")\n        s = s.upper()\n        s = s[::-1]\n        ans = \"\"\n        for i in range(len(s)):\n            if i % k == 0 and i != 0:\n                ans += \"-\"\n            ans += s[i]\n        return ans[::-1]"}, {"task_id": "license-key-formatting", "completion": "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        s = s.replace('-', '').upper()\n        n = len(s)\n        if n <= k:\n            return s\n        else:\n            first = n % k\n            if first == 0:\n                first = k\n            res = s[:first]\n            for i in range(first, n, k):\n                res += '-' + s[i:i+k]\n            return res"}, {"task_id": "license-key-formatting", "completion": "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        s = s.replace(\"-\", \"\")\n        s = s.upper()\n        s = s[::-1]\n        res = \"\"\n        for i in range(len(s)):\n            if i % k == 0 and i != 0:\n                res += \"-\"\n            res += s[i]\n        return res[::-1]"}, {"task_id": "license-key-formatting", "completion": "class Solution(object):\n    def licenseKeyFormatting(self, s, k):\n        \"\"\"\n        :type s: str\n        :type k: int\n        :rtype: str\n        \"\"\"\n        \n        s = s.replace(\"-\", \"\")\n        s = s.upper()\n        s = s[::-1]\n        ans = \"\"\n        for i in range(len(s)):\n            if i % k == 0 and i != 0:\n                ans += \"-\"\n            ans += s[i]\n        return ans[::-1]"}], "gas-station": [{"task_id": "gas-station", "completion": "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u5982\u679c\u603b\u6cb9\u91cf\u5c0f\u4e8e\u603b\u6d88\u8017\uff0c\u5219\u4e0d\u53ef\u80fd\u73af\u7ed5\u4e00\u5708\n        if sum(gas) < sum(cost):\n            return -1\n        \n        # 2. \u5982\u679c\u4ece\u67d0\u4e2a\u52a0\u6cb9\u7ad9\u51fa\u53d1\uff0c\u6cb9\u91cf\u59cb\u7ec8\u5927\u4e8e\u7b49\u4e8e0\uff0c\u5219\u4e00\u5b9a\u53ef\u4ee5\u73af\u7ed5\u4e00\u5708\n        start, curSum = 0, 0\n        for i in range(len(gas)):\n            curSum += gas[i] - cost[i]\n            if curSum < 0:\n                start = i + 1\n                curSum = 0\n        return start"}, {"task_id": "gas-station", "completion": "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u5982\u679c\u603b\u6cb9\u91cf\u5c0f\u4e8e\u603b\u6d88\u8017\uff0c\u5219\u4e0d\u53ef\u80fd\u73af\u7ed5\u4e00\u5708\n        if sum(gas) < sum(cost):\n            return -1\n        \n        # 2. \u5982\u679c\u4ece\u67d0\u4e2a\u52a0\u6cb9\u7ad9\u51fa\u53d1\uff0c\u6cb9\u91cf\u59cb\u7ec8\u5927\u4e8e\u7b49\u4e8e0\uff0c\u5219\u4e00\u5b9a\u53ef\u4ee5\u73af\u7ed5\u4e00\u5708\n        start, curSum = 0, 0\n        for i in range(len(gas)):\n            curSum += gas[i] - cost[i]\n            if curSum < 0:\n                start = i + 1\n                curSum = 0\n        return start"}, {"task_id": "gas-station", "completion": "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u5982\u679c\u603b\u6cb9\u91cf\u5c0f\u4e8e\u603b\u6d88\u8017\uff0c\u5219\u4e0d\u53ef\u80fd\u73af\u7ed5\u4e00\u5708\n        if sum(gas) < sum(cost):\n            return -1\n        \n        # 2. \u5982\u679c\u4ece\u67d0\u4e2a\u52a0\u6cb9\u7ad9\u51fa\u53d1\uff0c\u6cb9\u91cf\u59cb\u7ec8\u5927\u4e8e\u7b49\u4e8e0\uff0c\u5219\u4e00\u5b9a\u53ef\u4ee5\u73af\u7ed5\u4e00\u5708\n        start, curSum = 0, 0\n        for i in range(len(gas)):\n            curSum += gas[i] - cost[i]\n            if curSum < 0:\n                start = i + 1\n                curSum = 0\n        return start"}, {"task_id": "gas-station", "completion": "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u5982\u679c\u603b\u6cb9\u91cf\u5c0f\u4e8e\u603b\u6d88\u8017\uff0c\u5219\u4e0d\u53ef\u80fd\u73af\u7ed5\u4e00\u5708\n        if sum(gas) < sum(cost):\n            return -1\n        \n        # 2. \u5982\u679c\u4ece\u67d0\u4e2a\u52a0\u6cb9\u7ad9\u51fa\u53d1\uff0c\u6cb9\u91cf\u59cb\u7ec8\u5927\u4e8e\u7b49\u4e8e0\uff0c\u5219\u4e00\u5b9a\u53ef\u4ee5\u73af\u7ed5\u4e00\u5708\n        start, curSum = 0, 0\n        for i in range(len(gas)):\n            curSum += gas[i] - cost[i]\n            if curSum < 0:\n                start = i + 1\n                curSum = 0\n        return start"}, {"task_id": "gas-station", "completion": "class Solution(object):\n    def canCompleteCircuit(self, gas, cost):\n        \"\"\"\n        :type gas: List[int]\n        :type cost: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u5982\u679c\u603b\u6cb9\u91cf\u5c0f\u4e8e\u603b\u6d88\u8017\uff0c\u5219\u4e0d\u53ef\u80fd\u73af\u7ed5\u4e00\u5708\n        if sum(gas) < sum(cost):\n            return -1\n        \n        # 2. \u5982\u679c\u4ece\u67d0\u4e2a\u52a0\u6cb9\u7ad9\u51fa\u53d1\uff0c\u6cb9\u91cf\u59cb\u7ec8\u5927\u4e8e\u7b49\u4e8e0\uff0c\u5219\u4e00\u5b9a\u53ef\u4ee5\u73af\u7ed5\u4e00\u5708\n        start, curSum = 0, 0\n        for i in range(len(gas)):\n            curSum += gas[i] - cost[i]\n            if curSum < 0:\n                start = i + 1\n                curSum = 0\n        return start"}], "burst-balloons": [{"task_id": "burst-balloons", "completion": "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = [1] + nums + [1]\n        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n        \n        for length in range(2, n):\n            for i in range(n - length):\n                j = i + length\n                for k in range(i + 1, j):\n                    dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + nums[i] * nums[k] * nums[j])\n                    \n        return dp[0][n - 1]"}, {"task_id": "burst-balloons", "completion": "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = [1] + nums + [1]\n        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n        \n        for length in range(2, n):\n            for i in range(n - length):\n                j = i + length\n                for k in range(i + 1, j):\n                    dp[i][j] = max(dp[i][j], nums[i] * nums[k] * nums[j] + dp[i][k] + dp[k][j])\n                    \n        return dp[0][n - 1]"}, {"task_id": "burst-balloons", "completion": "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = [1] + nums + [1]\n        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n        \n        for length in range(2, n):\n            for i in range(n - length):\n                j = i + length\n                for k in range(i + 1, j):\n                    dp[i][j] = max(dp[i][j], nums[i] * nums[k] * nums[j] + dp[i][k] + dp[k][j])\n        \n        return dp[0][n - 1]"}, {"task_id": "burst-balloons", "completion": "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = [1] + nums + [1]\n        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n        \n        for length in range(2, n):\n            for i in range(n - length):\n                j = i + length\n                for k in range(i + 1, j):\n                    dp[i][j] = max(dp[i][j], nums[i] * nums[k] * nums[j] + dp[i][k] + dp[k][j])\n                    \n        return dp[0][n - 1]"}, {"task_id": "burst-balloons", "completion": "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = [1] + nums + [1]\n        n = len(nums)\n        dp = [[0] * n for _ in range(n)]\n        \n        for length in range(2, n):\n            for i in range(n - length):\n                j = i + length\n                for k in range(i + 1, j):\n                    dp[i][j] = max(dp[i][j], nums[i] * nums[k] * nums[j] + dp[i][k] + dp[k][j])\n                    \n        return dp[0][n - 1]"}], "plus-one": [{"task_id": "plus-one", "completion": "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # convert the list of digits to a string\n        digits_str = ''.join(str(digit) for digit in digits)\n        \n        # convert the string to an integer\n        num = int(digits_str)\n        \n        # increment the integer by 1\n        num += 1\n        \n        # convert the integer back to a string\n        num_str = str(num)\n        \n        # convert the string back to a list of digits\n        result = [int(digit) for digit in num_str]\n        \n        return result"}, {"task_id": "plus-one", "completion": "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # convert the list of digits to a string\n        digits_str = ''.join(str(digit) for digit in digits)\n        \n        # convert the string to an integer\n        num = int(digits_str)\n        \n        # increment the integer by 1\n        num += 1\n        \n        # convert the integer back to a string\n        num_str = str(num)\n        \n        # convert the string back to a list of digits\n        result = [int(digit) for digit in num_str]\n        \n        return result"}, {"task_id": "plus-one", "completion": "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # convert digits to a number\n        num = 0\n        for i in range(len(digits)):\n            num += digits[i] * 10**(len(digits)-i-1)\n        \n        # add 1 to the number\n        num += 1\n        \n        # convert the number back to a list\n        digits = []\n        while num > 0:\n            digits.append(num % 10)\n            num //= 10\n        \n        # reverse the list\n        digits.reverse()\n        \n        return digits"}, {"task_id": "plus-one", "completion": "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # convert the list of digits to a string\n        digits_str = ''.join(str(digit) for digit in digits)\n        \n        # convert the string to an integer\n        num = int(digits_str)\n        \n        # increment the integer by 1\n        num += 1\n        \n        # convert the integer back to a string\n        num_str = str(num)\n        \n        # convert the string back to a list of digits\n        result = [int(digit) for digit in num_str]\n        \n        return result"}, {"task_id": "plus-one", "completion": "class Solution(object):\n    def plusOne(self, digits):\n        \"\"\"\n        :type digits: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # convert the list of digits to a string\n        digits_str = ''.join(str(digit) for digit in digits)\n        \n        # convert the string to an integer\n        num = int(digits_str)\n        \n        # increment the integer by 1\n        num += 1\n        \n        # convert the integer back to a string\n        num_str = str(num)\n        \n        # convert the string back to a list of digits\n        result = [int(digit) for digit in num_str]\n        \n        return result"}], "regular-expression-matching": [{"task_id": "regular-expression-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        # DP solution\n        # Time complexity: O(m*n)\n        # Space complexity: O(m*n)\n        \n        # m = len(s)\n        # n = len(p)\n        \n        # dp = [[False]*(n+1) for _ in range(m+1)]\n        \n        # dp[0][0] = True\n        \n        # for i in range(1, n+1):\n        #     if p[i-1] == '*':\n        #         dp[0][i] = dp[0][i-2]\n        \n        # for i in range(1, m+1):\n        #     for j in range(1, n+1):\n        #         if p[j-1] == '.' or p[j-1] == s[i-1]:\n        #             dp[i][j] = dp[i-1][j-1]\n        #         elif p[j-1] == '*':\n        #             dp[i][j] = dp[i][j-2]\n        #             if p[j-2] == '.' or p[j-2] == s[i-1]:\n        #                 dp[i][j] = dp[i][j] or dp[i-1][j]\n        #         else:\n        #             dp[i][j] = False\n        \n        # return dp[m][n]\n        \n        # Recursive solution\n        # Time complexity: O(2^(m+n))\n        # Space complexity: O(m+n)\n        \n        if not p:\n            return not s\n        \n        first_match = bool(s) and p[0] in {s[0], '.'}\n        \n        if len(p) >= 2 and p[1] == '*':\n            return (self.isMatch(s, p[2:]) or\n                    first_match and self.isMatch(s[1:], p))\n        else:\n            return first_match and self.isMatch(s[1:], p[1:])"}, {"task_id": "regular-expression-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        ## DP solution\n        ## Time complexity: O(m*n)\n        ## Space complexity: O(m*n)\n        \n        m, n = len(s), len(p)\n        dp = [[False]*(n+1) for _ in range(m+1)]\n        dp[0][0] = True\n        \n        for i in range(m+1):\n            for j in range(1, n+1):\n                if p[j-1] == '*':\n                    dp[i][j] = dp[i][j-2] or (i > 0 and (s[i-1] == p[j-2] or p[j-2] == '.') and dp[i-1][j])\n                else:\n                    dp[i][j] = i > 0 and dp[i-1][j-1] and (s[i-1] == p[j-1] or p[j-1] == '.')\n                    \n        return dp[m][n]"}, {"task_id": "regular-expression-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        # DP solution\n        # Time: O(m*n)\n        # Space: O(m*n)\n        \n        m, n = len(s), len(p)\n        dp = [[False] * (n+1) for _ in range(m+1)]\n        dp[0][0] = True\n        \n        for j in range(1, n+1):\n            if p[j-1] == '*':\n                dp[0][j] = dp[0][j-2]\n        \n        for i in range(1, m+1):\n            for j in range(1, n+1):\n                if p[j-1] == '.' or p[j-1] == s[i-1]:\n                    dp[i][j] = dp[i-1][j-1]\n                elif p[j-1] == '*':\n                    if p[j-2] != s[i-1] and p[j-2] != '.':\n                        dp[i][j] = dp[i][j-2]\n                    else:\n                        dp[i][j] = dp[i][j-1] or dp[i][j-2] or dp[i-1][j]\n        \n        return dp[m][n]"}, {"task_id": "regular-expression-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        ## DP solution\n        ## Time complexity: O(m*n)\n        ## Space complexity: O(m*n)\n        \n        m, n = len(s), len(p)\n        dp = [[False]*(n+1) for _ in range(m+1)]\n        dp[0][0] = True\n        \n        for i in range(1, n+1):\n            if p[i-1] == '*':\n                dp[0][i] = dp[0][i-2]\n        \n        for i in range(1, m+1):\n            for j in range(1, n+1):\n                if p[j-1] == '.' or p[j-1] == s[i-1]:\n                    dp[i][j] = dp[i-1][j-1]\n                elif p[j-1] == '*':\n                    if p[j-2] == '.' or p[j-2] == s[i-1]:\n                        dp[i][j] = dp[i][j-2] or dp[i-1][j]\n                    else:\n                        dp[i][j] = dp[i][j-2]\n        \n        return dp[m][n]"}, {"task_id": "regular-expression-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        # DP solution\n        # Time complexity: O(m*n)\n        # Space complexity: O(m*n)\n        \n        # m = len(s)\n        # n = len(p)\n        \n        # dp = [[False] * (n+1) for _ in range(m+1)]\n        \n        # dp[0][0] = True\n        \n        # for j in range(1, n+1):\n        #     if p[j-1] == '*':\n        #         dp[0][j] = dp[0][j-2]\n        \n        # for i in range(1, m+1):\n        #     for j in range(1, n+1):\n        #         if p[j-1] == '.' or p[j-1] == s[i-1]:\n        #             dp[i][j] = dp[i-1][j-1]\n        #         elif p[j-1] == '*':\n        #             dp[i][j] = dp[i][j-2]\n        #             if p[j-2] == '.' or p[j-2] == s[i-1]:\n        #                 dp[i][j] = dp[i][j] or dp[i-1][j]\n        #         else:\n        #             dp[i][j] = False\n        \n        # return dp[m][n]\n        \n        # Recursive solution\n        # Time complexity: O(2^(m+n))\n        # Space complexity: O(m+n)\n        \n        if not p:\n            return not s\n        \n        first_match = bool(s) and p[0] in {s[0], '.'}\n        \n        if len(p) >= 2 and p[1] == '*':\n            return (self.isMatch(s, p[2:]) or\n                    first_match and self.isMatch(s[1:], p))\n        else:\n            return first_match and self.isMatch(s[1:], p[1:])"}], "create-maximum-number": [{"task_id": "create-maximum-number", "completion": "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def pick_max(nums, k):\n            stack = []\n            drop = len(nums) - k\n            for num in nums:\n                while drop and stack and stack[-1] < num:\n                    stack.pop()\n                    drop -= 1\n                stack.append(num)\n            return stack[:k]\n        \n        def merge(a, b):\n            ans = []\n            while a or b:\n                if a > b:\n                    ans.append(a[0])\n                    a = a[1:]\n                else:\n                    ans.append(b[0])\n                    b = b[1:]\n            return ans\n        \n        def compare(a, b):\n            return a > b\n        \n        def premax(nums, k):\n            stack = []\n            drop = len(nums) - k\n            for num in nums:\n                while drop and stack and stack[-1] < num:\n                    stack.pop()\n                    drop -= 1\n                stack.append(num)\n            return stack\n        \n        def merge(a, b):\n            ans = []\n            while a or b:\n                if a > b:\n                    ans.append(a[0])\n                    a = a[1:]\n                else:\n                    ans.append(b[0])\n                    b = b[1:]\n            return ans\n        \n        def compare(a, b):\n            return a > b\n        \n        def premax(nums, k):\n            stack = []\n            drop = len(nums) - k\n            for num in nums:\n                while drop and stack and stack[-1] < num:\n                    stack.pop()\n                    drop -= 1\n                stack.append(num)\n            return stack\n        \n        def merge(a, b):\n            ans = []\n            while a or b:\n                if a > b:\n                    ans.append(a[0])\n                    a = a[1:]\n                else:\n                    ans.append(b[0])\n                    b = b[1:]\n            return ans\n        \n        def compare(a, b):\n            return a > b\n        \n        def premax(nums, k):\n            stack = []\n            drop = len(nums) - k\n            for num in nums:\n                while drop and stack and stack[-1] < num:\n                    stack.pop()\n                    drop -= 1\n                stack.append(num)\n            return stack\n        \n        def merge(a, b):\n            ans = []\n            while a or b:\n                if a > b:\n                    ans.append(a[0])\n                    a = a[1:]\n                else:\n                    ans.append(b[0])\n                    b = b[1:]\n            return ans\n        \n        def compare(a, b):\n            return a > b\n        \n        def premax(nums, k):\n            stack = []\n            drop = len(nums) - k\n            for num in nums:\n                while drop and stack and stack[-1] < num:\n                    stack.pop()\n                    drop -= 1\n                stack.append(num)\n            return stack\n        \n        def merge(a, b):\n            ans = []\n            while a or b:\n                if a > b:\n                    ans.append(a[0])\n                    a = a[1:]\n                else:\n                    ans.append(b[0])\n                    b = b[1:]\n            return ans\n        \n        def compare(a, b):\n            return a > b\n        \n        def premax(nums, k):\n            stack = []\n            drop = len(nums) - k\n            for num in nums:\n                while drop and stack and stack[-1] < num:\n                    stack.pop()\n                    drop -= 1\n                stack.append(num)\n            return stack\n        \n        def merge(a, b):\n            ans = []\n            while a or b:\n                if a > b:\n                    ans.append(a[0])\n                    a = a[1:]\n                else:\n                    ans.append(b[0])\n                    b = b[1:]\n            return ans\n        \n        def compare(a, b):\n            return a > b"}, {"task_id": "create-maximum-number", "completion": "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def pick_max(nums, k):\n            stack = []\n            drop = len(nums) - k\n            for num in nums:\n                while drop and stack and stack[-1] < num:\n                    stack.pop()\n                    drop -= 1\n                stack.append(num)\n            return stack[:k]\n        \n        def merge(a, b):\n            ans = []\n            while a or b:\n                if a > b:\n                    ans.append(a[0])\n                    a = a[1:]\n                else:\n                    ans.append(b[0])\n                    b = b[1:]\n            return ans\n        \n        def compare(a, b):\n            return a > b\n        \n        def premax(nums, k):\n            stack = []\n            drop = len(nums) - k\n            for num in nums:\n                while drop and stack and stack[-1] < num:\n                    stack.pop()\n                    drop -= 1\n                stack.append(num)\n            return stack\n        \n        def merge(a, b):\n            ans = []\n            while a or b:\n                if a > b:\n                    ans.append(a[0])\n                    a = a[1:]\n                else:\n                    ans.append(b[0])\n                    b = b[1:]\n            return ans\n        \n        def compare(a, b):\n            return a > b\n        \n        def premax(nums, k):\n            stack = []\n            drop = len(nums) - k\n            for num in nums:\n                while drop and stack and stack[-1] < num:\n                    stack.pop()\n                    drop -= 1\n                stack.append(num)\n            return stack\n        \n        def merge(a, b):\n            ans = []\n            while a or b:\n                if a > b:\n                    ans.append(a[0])\n                    a = a[1:]\n                else:\n                    ans.append(b[0])\n                    b = b[1:]\n            return ans\n        \n        def compare(a, b):\n            return a > b\n        \n        def premax(nums, k):\n            stack = []\n            drop = len(nums) - k\n            for num in nums:\n                while drop and stack and stack[-1] < num:\n                    stack.pop()\n                    drop -= 1\n                stack.append(num)\n            return stack\n        \n        def merge(a, b):\n            ans = []\n            while a or b:\n                if a > b:\n                    ans.append(a[0])\n                    a = a[1:]\n                else:\n                    ans.append(b[0])\n                    b = b[1:]\n            return ans\n        \n        def compare(a, b):\n            return a > b\n        \n        def premax(nums, k):\n            stack = []\n            drop = len(nums) - k\n            for num in nums:\n                while drop and stack and stack[-1] < num:\n                    stack.pop()\n                    drop -= 1\n                stack.append(num)\n            return stack\n        \n        def merge(a, b):\n            ans = []\n            while a or b:\n                if a > b:\n                    ans.append(a[0])\n                    a = a[1:]\n                else:\n                    ans.append(b[0])\n                    b = b[1:]\n            return ans\n        \n        def compare(a, b):\n            return a > b\n        \n        def premax(nums, k):\n            stack = []\n            drop = len(nums) - k\n            for num in nums:\n                while drop and stack and stack[-1] < num:\n                    stack.pop()\n                    drop -= 1\n                stack.append(num)\n            return stack\n        \n        def merge(a, b):\n            ans = []\n            while a or b:\n                if a > b:\n                    ans.append(a[0])\n                    a = a[1:]\n                else:\n                    ans.append(b[0])\n                    b = b[1:]\n            return ans\n        \n        def compare(a, b):\n            return a > b"}, {"task_id": "create-maximum-number", "completion": "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def pick_max(nums, k):\n            stack = []\n            drop = len(nums) - k\n            for num in nums:\n                while drop and stack and stack[-1] < num:\n                    stack.pop()\n                    drop -= 1\n                stack.append(num)\n            return stack[:k]\n        \n        def merge(A, B):\n            ans = []\n            while A or B:\n                if A > B:\n                    ans.append(A[0])\n                    A = A[1:]\n                else:\n                    ans.append(B[0])\n                    B = B[1:]\n            return ans\n        \n        return max(merge(pick_max(nums1, i), pick_max(nums2, k-i)) for i in range(k+1) if i <= len(nums1) and k-i <= len(nums2))"}, {"task_id": "create-maximum-number", "completion": "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def pick_max(nums, k):\n            stack = []\n            drop = len(nums) - k\n            for num in nums:\n                while drop and stack and stack[-1] < num:\n                    stack.pop()\n                    drop -= 1\n                stack.append(num)\n            return stack[:k]\n        \n        def merge(a, b):\n            ans = []\n            while a or b:\n                if a > b:\n                    ans.append(a[0])\n                    a = a[1:]\n                else:\n                    ans.append(b[0])\n                    b = b[1:]\n            return ans\n        \n        def compare(a, b):\n            return a > b\n        \n        def premax(nums, k):\n            stack = []\n            drop = len(nums) - k\n            for num in nums:\n                while drop and stack and stack[-1] < num:\n                    stack.pop()\n                    drop -= 1\n                stack.append(num)\n            return stack\n        \n        def merge(a, b):\n            ans = []\n            while a or b:\n                if a > b:\n                    ans.append(a[0])\n                    a = a[1:]\n                else:\n                    ans.append(b[0])\n                    b = b[1:]\n            return ans\n        \n        def compare(a, b):\n            return a > b\n        \n        def premax(nums, k):\n            stack = []\n            drop = len(nums) - k\n            for num in nums:\n                while drop and stack and stack[-1] < num:\n                    stack.pop()\n                    drop -= 1\n                stack.append(num)\n            return stack\n        \n        def merge(a, b):\n            ans = []\n            while a or b:\n                if a > b:\n                    ans.append(a[0])\n                    a = a[1:]\n                else:\n                    ans.append(b[0])\n                    b = b[1:]\n            return ans\n        \n        def compare(a, b):\n            return a > b\n        \n        def premax(nums, k):\n            stack = []\n            drop = len(nums) - k\n            for num in nums:\n                while drop and stack and stack[-1] < num:\n                    stack.pop()\n                    drop -= 1\n                stack.append(num)\n            return stack\n        \n        def merge(a, b):\n            ans = []\n            while a or b:\n                if a > b:\n                    ans.append(a[0])\n                    a = a[1:]\n                else:\n                    ans.append(b[0])\n                    b = b[1:]\n            return ans\n        \n        def compare(a, b):\n            return a > b\n        \n        def premax(nums, k):\n            stack = []\n            drop = len(nums) - k\n            for num in nums:\n                while drop and stack and stack[-1] < num:\n                    stack.pop()\n                    drop -= 1\n                stack.append(num)\n            return stack\n        \n        def merge(a, b):\n            ans = []\n            while a or b:\n                if a > b:\n                    ans.append(a[0])\n                    a = a[1:]\n                else:\n                    ans.append(b[0])\n                    b = b[1:]\n            return ans\n        \n        def compare(a, b):\n            return a > b\n        \n        def premax(nums, k):\n            stack = []\n            drop = len(nums) - k\n            for num in nums:\n                while drop and stack and stack[-1] < num:\n                    stack.pop()\n                    drop -= 1\n                stack.append(num)\n            return stack\n        \n        def merge(a, b):\n            ans = []\n            while a or b:\n                if a > b:\n                    ans.append(a[0])\n                    a = a[1:]\n                else:\n                    ans.append(b[0])\n                    b = b[1:]\n            return ans\n        \n        def compare(a, b):\n            return a > b"}, {"task_id": "create-maximum-number", "completion": "class Solution(object):\n    def maxNumber(self, nums1, nums2, k):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def pick_max(nums, k):\n            stack = []\n            drop = len(nums) - k\n            for num in nums:\n                while drop and stack and stack[-1] < num:\n                    stack.pop()\n                    drop -= 1\n                stack.append(num)\n            return stack[:k]\n        \n        def merge(a, b):\n            ans = []\n            while a or b:\n                if a > b:\n                    ans.append(a[0])\n                    a = a[1:]\n                else:\n                    ans.append(b[0])\n                    b = b[1:]\n            return ans\n        \n        def compare(a, b):\n            return a > b\n        \n        def premax(nums, k):\n            stack = []\n            drop = len(nums) - k\n            for num in nums:\n                while drop and stack and stack[-1] < num:\n                    stack.pop()\n                    drop -= 1\n                stack.append(num)\n            return stack\n        \n        def merge(a, b):\n            ans = []\n            while a or b:\n                if a > b:\n                    ans.append(a[0])\n                    a = a[1:]\n                else:\n                    ans.append(b[0])\n                    b = b[1:]\n            return ans\n        \n        def compare(a, b):\n            return a > b\n        \n        def premax(nums, k):\n            stack = []\n            drop = len(nums) - k\n            for num in nums:\n                while drop and stack and stack[-1] < num:\n                    stack.pop()\n                    drop -= 1\n                stack.append(num)\n            return stack\n        \n        def merge(a, b):\n            ans = []\n            while a or b:\n                if a > b:\n                    ans.append(a[0])\n                    a = a[1:]\n                else:\n                    ans.append(b[0])\n                    b = b[1:]\n            return ans\n        \n        def compare(a, b):\n            return a > b\n        \n        def premax(nums, k):\n            stack = []\n            drop = len(nums) - k\n            for num in nums:\n                while drop and stack and stack[-1] < num:\n                    stack.pop()\n                    drop -= 1\n                stack.append(num)\n            return stack\n        \n        def merge(a, b):\n            ans = []\n            while a or b:\n                if a > b:\n                    ans.append(a[0])\n                    a = a[1:]\n                else:\n                    ans.append(b[0])\n                    b = b[1:]\n            return ans\n        \n        def compare(a, b):\n            return a > b\n        \n        def premax(nums, k):\n            stack = []\n            drop = len(nums) - k\n            for num in nums:\n                while drop and stack and stack[-1] < num:\n                    stack.pop()\n                    drop -= 1\n                stack.append(num)\n            return stack\n        \n        def merge(a, b):\n            ans = []\n            while a or b:\n                if a > b:\n                    ans.append(a[0])\n                    a = a[1:]\n                else:\n                    ans.append(b[0])\n                    b = b[1:]\n            return ans\n        \n        def compare(a, b):\n            return a > b\n        \n        def premax(nums, k):\n            stack = []\n            drop = len(nums) - k\n            for num in nums:\n                while drop and stack and stack[-1] < num:\n                    stack.pop()\n                    drop -= 1\n                stack.append(num)\n            return stack\n        \n        def merge(a, b):\n            ans = []\n            while a or b:\n                if a > b:\n                    ans.append(a[0])\n                    a = a[1:]\n                else:\n                    ans.append(b[0])\n                    b = b[1:]\n            return ans\n        \n        def compare(a, b):\n            return a > b"}], "perfect-number": [{"task_id": "perfect-number", "completion": "class Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return False\n        \n        divisors = [1]\n        \n        for i in range(2, int(num**0.5)+1):\n            if num % i == 0:\n                divisors.append(i)\n                divisors.append(num//i)\n        \n        return sum(divisors) == num"}, {"task_id": "perfect-number", "completion": "class Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return False\n        \n        divisors = [1]\n        \n        for i in range(2, int(num**0.5)+1):\n            if num % i == 0:\n                divisors.append(i)\n                divisors.append(num//i)\n        \n        return sum(divisors) == num"}, {"task_id": "perfect-number", "completion": "class Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return False\n        \n        divisors = [1]\n        \n        for i in range(2, int(num**0.5)+1):\n            if num % i == 0:\n                divisors.append(i)\n                divisors.append(num//i)\n        \n        return sum(divisors) == num"}, {"task_id": "perfect-number", "completion": "class Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return False\n        \n        divisors = [1]\n        \n        for i in range(2, int(num**0.5)+1):\n            if num % i == 0:\n                divisors.append(i)\n                divisors.append(num//i)\n        \n        return sum(divisors) == num"}, {"task_id": "perfect-number", "completion": "class Solution(object):\n    def checkPerfectNumber(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        if num == 1:\n            return False\n        \n        divisors = [1]\n        \n        for i in range(2, int(num**0.5)+1):\n            if num % i == 0:\n                divisors.append(i)\n                divisors.append(num//i)\n        \n        return sum(divisors) == num"}], "fibonacci-number": [{"task_id": "fibonacci-number", "completion": "class Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        \n        return self.fib(n-1) + self.fib(n-2)"}, {"task_id": "fibonacci-number", "completion": "class Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        \n        return self.fib(n-1) + self.fib(n-2)"}, {"task_id": "fibonacci-number", "completion": "class Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        \n        return self.fib(n-1) + self.fib(n-2)"}, {"task_id": "fibonacci-number", "completion": "class Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        \n        return self.fib(n-1) + self.fib(n-2)"}, {"task_id": "fibonacci-number", "completion": "class Solution(object):\n    def fib(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 0:\n            return 0\n        if n == 1:\n            return 1\n        \n        return self.fib(n-1) + self.fib(n-2)"}], "dungeon-game": [{"task_id": "dungeon-game", "completion": "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        \"\"\"\n        :type dungeon: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(dungeon)\n        n = len(dungeon[0])\n        \n        dp = [[0 for _ in range(n)] for _ in range(m)]\n        \n        dp[m-1][n-1] = max(1, 1 - dungeon[m-1][n-1])\n        \n        for i in range(m-2, -1, -1):\n            dp[i][n-1] = max(1, dp[i+1][n-1] - dungeon[i][n-1])\n        \n        for j in range(n-2, -1, -1):\n            dp[m-1][j] = max(1, dp[m-1][j+1] - dungeon[m-1][j])\n        \n        for i in range(m-2, -1, -1):\n            for j in range(n-2, -1, -1):\n                dp[i][j] = max(1, min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j])\n        \n        return dp[0][0]"}, {"task_id": "dungeon-game", "completion": "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        \"\"\"\n        :type dungeon: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(dungeon)\n        n = len(dungeon[0])\n        \n        dp = [[0 for _ in range(n)] for _ in range(m)]\n        \n        dp[m-1][n-1] = max(1, 1 - dungeon[m-1][n-1])\n        \n        for i in range(m-2, -1, -1):\n            dp[i][n-1] = max(1, dp[i+1][n-1] - dungeon[i][n-1])\n        \n        for j in range(n-2, -1, -1):\n            dp[m-1][j] = max(1, dp[m-1][j+1] - dungeon[m-1][j])\n        \n        for i in range(m-2, -1, -1):\n            for j in range(n-2, -1, -1):\n                dp[i][j] = max(1, min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j])\n        \n        return dp[0][0]"}, {"task_id": "dungeon-game", "completion": "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        \"\"\"\n        :type dungeon: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(dungeon)\n        n = len(dungeon[0])\n        \n        dp = [[0] * n for _ in range(m)]\n        \n        dp[m-1][n-1] = max(1, 1 - dungeon[m-1][n-1])\n        \n        for i in range(m-2, -1, -1):\n            dp[i][n-1] = max(1, dp[i+1][n-1] - dungeon[i][n-1])\n        \n        for j in range(n-2, -1, -1):\n            dp[m-1][j] = max(1, dp[m-1][j+1] - dungeon[m-1][j])\n        \n        for i in range(m-2, -1, -1):\n            for j in range(n-2, -1, -1):\n                dp[i][j] = max(1, min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j])\n        \n        return dp[0][0]"}, {"task_id": "dungeon-game", "completion": "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        \"\"\"\n        :type dungeon: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(dungeon)\n        n = len(dungeon[0])\n        \n        dp = [[0 for _ in range(n)] for _ in range(m)]\n        \n        dp[m-1][n-1] = max(1, 1 - dungeon[m-1][n-1])\n        \n        for i in range(m-2, -1, -1):\n            dp[i][n-1] = max(1, dp[i+1][n-1] - dungeon[i][n-1])\n        \n        for j in range(n-2, -1, -1):\n            dp[m-1][j] = max(1, dp[m-1][j+1] - dungeon[m-1][j])\n        \n        for i in range(m-2, -1, -1):\n            for j in range(n-2, -1, -1):\n                dp[i][j] = max(1, min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j])\n        \n        return dp[0][0]"}, {"task_id": "dungeon-game", "completion": "class Solution(object):\n    def calculateMinimumHP(self, dungeon):\n        \"\"\"\n        :type dungeon: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(dungeon)\n        n = len(dungeon[0])\n        \n        dp = [[0 for _ in range(n)] for _ in range(m)]\n        \n        dp[m-1][n-1] = max(1, 1 - dungeon[m-1][n-1])\n        \n        for i in range(m-2, -1, -1):\n            dp[i][n-1] = max(1, dp[i+1][n-1] - dungeon[i][n-1])\n        \n        for j in range(n-2, -1, -1):\n            dp[m-1][j] = max(1, dp[m-1][j+1] - dungeon[m-1][j])\n        \n        for i in range(m-2, -1, -1):\n            for j in range(n-2, -1, -1):\n                dp[i][j] = max(1, min(dp[i+1][j], dp[i][j+1]) - dungeon[i][j])\n        \n        return dp[0][0]"}], "find-k-th-smallest-pair-distance": [{"task_id": "find-k-th-smallest-pair-distance", "completion": "class Solution(object):\n    def smallestDistancePair(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        n = len(nums)\n        l, r = 0, nums[-1] - nums[0]\n        while l < r:\n            mid = (l + r) // 2\n            if sum(bisect.bisect_right(nums, nums[i] + mid) - i - 1 for i in range(n)) >= k:\n                r = mid\n            else:\n                l = mid + 1\n        return l"}, {"task_id": "find-k-th-smallest-pair-distance", "completion": "class Solution(object):\n    def smallestDistancePair(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        n = len(nums)\n        l, r = 0, nums[-1] - nums[0]\n        while l < r:\n            mid = (l + r) // 2\n            if sum(bisect.bisect_right(nums, nums[i] + mid) - i - 1 for i in range(n)) >= k:\n                r = mid\n            else:\n                l = mid + 1\n        return l"}, {"task_id": "find-k-th-smallest-pair-distance", "completion": "class Solution(object):\n    def smallestDistancePair(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        n = len(nums)\n        l, r = 0, nums[-1] - nums[0]\n        while l < r:\n            mid = (l + r) // 2\n            if sum(bisect.bisect_right(nums, nums[i] + mid) - i - 1 for i in range(n)) >= k:\n                r = mid\n            else:\n                l = mid + 1\n        return l"}, {"task_id": "find-k-th-smallest-pair-distance", "completion": "class Solution(object):\n    def smallestDistancePair(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        n = len(nums)\n        low, high = 0, nums[-1] - nums[0]\n        \n        while low < high:\n            mid = (low + high) // 2\n            count = 0\n            left = 0\n            for right in range(n):\n                while nums[right] - nums[left] > mid:\n                    left += 1\n                count += right - left\n            if count >= k:\n                high = mid\n            else:\n                low = mid + 1\n        return low"}, {"task_id": "find-k-th-smallest-pair-distance", "completion": "class Solution(object):\n    def smallestDistancePair(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        n = len(nums)\n        l, r = 0, nums[-1] - nums[0]\n        while l < r:\n            mid = (l + r) // 2\n            if sum(bisect.bisect_right(nums, nums[i] + mid) - i - 1 for i in range(n)) >= k:\n                r = mid\n            else:\n                l = mid + 1\n        return l"}], "number-of-segments-in-a-string": [{"task_id": "number-of-segments-in-a-string", "completion": "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by"}, {"task_id": "number-of-segments-in-a-string", "completion": "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        segments = s.split()\n        \n        # 2. count the number of segments\n        count = len(segments)\n        \n        # 3. return the number of segments\n        return count"}, {"task_id": "number-of-segments-in-a-string", "completion": "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by space\n        # 2. count the number of segments\n        # 3. return the number of segments\n        \n        # 1. split the string by"}, {"task_id": "number-of-segments-in-a-string", "completion": "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # return len(s.split())\n        \n        # 2.\n        # return len([x for x in s.split()])\n        \n        # 3.\n        # return len(filter(None, s.split()))\n        \n        # 4.\n        # return len(s.split())\n        \n        # 5.\n        # return len(s.split())\n        \n        # 6.\n        # return len(s.split())\n        \n        # 7.\n        # return len(s.split())\n        \n        # 8.\n        # return len(s.split())\n        \n        # 9.\n        # return len(s.split())\n        \n        # 10.\n        # return len(s.split())\n        \n        # 11.\n        # return len(s.split())\n        \n        # 12.\n        # return len(s.split())\n        \n        # 13.\n        # return len(s.split())\n        \n        # 14.\n        # return len(s.split())\n        \n        # 15.\n        # return len(s.split())\n        \n        # 16.\n        # return len(s.split())\n        \n        # 17.\n        # return len(s.split())\n        \n        # 18.\n        # return len(s.split())\n        \n        # 19.\n        # return len(s.split())\n        \n        # 20.\n        # return len(s.split())\n        \n        # 21.\n        # return len(s.split())\n        \n        # 22.\n        # return len(s.split())\n        \n        # 23.\n        # return len(s.split())\n        \n        # 24.\n        # return len(s.split())\n        \n        # 25.\n        # return len(s.split())\n        \n        # 26.\n        # return len(s.split())\n        \n        # 27.\n        # return len(s.split())\n        \n        # 28.\n        # return len(s.split())\n        \n        # 29.\n        # return len(s.split())\n        \n        # 30.\n        # return len(s.split())\n        \n        # 31.\n        # return len(s.split())\n        \n        # 32.\n        # return len(s.split())\n        \n        # 33.\n        # return len(s.split())\n        \n        # 34.\n        # return len(s.split())\n        \n        # 35.\n        # return len(s.split())\n        \n        # 36.\n        # return len(s.split())\n        \n        # 37.\n        # return len(s.split())\n        \n        # 38.\n        # return len(s.split())\n        \n        # 39.\n        # return len(s.split())\n        \n        # 40.\n        # return len(s.split())\n        \n        # 41.\n        # return len(s.split())\n        \n        # 42.\n        # return len(s.split())\n        \n        # 43.\n        # return len(s.split())\n        \n        # 44.\n        # return len(s.split())\n        \n        # 45.\n        # return len(s.split())\n        \n        # 46.\n        # return len(s.split())\n        \n        # 47.\n        # return len(s.split())\n        \n        # 48.\n        # return len(s.split())\n        \n        # 49.\n        # return len(s.split())\n        \n        # 50.\n        # return len(s.split())\n        \n        # 51.\n        # return len(s.split())\n        \n        # 52.\n        # return len(s.split())\n        \n        # 53.\n        # return len(s.split())\n        \n        # 54.\n        # return len(s.split())"}, {"task_id": "number-of-segments-in-a-string", "completion": "class Solution(object):\n    def countSegments(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # return len(s.split())\n        \n        # 2.\n        # return len([i for i in s.split()])\n        \n        # 3.\n        # return len(s.split())\n        \n        # 4.\n        # return len(s.split())\n        \n        # 5.\n        # return len(s.split())\n        \n        # 6.\n        # return len(s.split())\n        \n        # 7.\n        # return len(s.split())\n        \n        # 8.\n        # return len(s.split())\n        \n        # 9.\n        # return len(s.split())\n        \n        # 10.\n        # return len(s.split())\n        \n        # 11.\n        # return len(s.split())\n        \n        # 12.\n        # return len(s.split())\n        \n        # 13.\n        # return len(s.split())\n        \n        # 14.\n        # return len(s.split())\n        \n        # 15.\n        # return len(s.split())\n        \n        # 16.\n        # return len(s.split())\n        \n        # 17.\n        # return len(s.split())\n        \n        # 18.\n        # return len(s.split())\n        \n        # 19.\n        # return len(s.split())\n        \n        # 20.\n        # return len(s.split())\n        \n        # 21.\n        # return len(s.split())\n        \n        # 22.\n        # return len(s.split())\n        \n        # 23.\n        # return len(s.split())\n        \n        # 24.\n        # return len(s.split())\n        \n        # 25.\n        # return len(s.split())\n        \n        # 26.\n        # return len(s.split())\n        \n        # 27.\n        # return len(s.split())\n        \n        # 28.\n        # return len(s.split())\n        \n        # 29.\n        # return len(s.split())\n        \n        # 30.\n        # return len(s.split())\n        \n        # 31.\n        # return len(s.split())\n        \n        # 32.\n        # return len(s.split())\n        \n        # 33.\n        # return len(s.split())\n        \n        # 34.\n        # return len(s.split())\n        \n        # 35.\n        # return len(s.split())\n        \n        # 36.\n        # return len(s.split())\n        \n        # 37.\n        # return len(s.split())\n        \n        # 38.\n        # return len(s.split())\n        \n        # 39.\n        # return len(s.split())\n        \n        # 40.\n        # return len(s.split())\n        \n        # 41.\n        # return len(s.split())\n        \n        # 42.\n        # return len(s.split())\n        \n        # 43.\n        # return len(s.split())\n        \n        # 44.\n        # return len(s.split())\n        \n        # 45.\n        # return len(s.split())\n        \n        # 46.\n        # return len(s.split())\n        \n        # 47.\n        # return len(s.split())\n        \n        # 48.\n        # return len(s.split())\n        \n        # 49.\n        # return len(s.split())\n        \n        # 50.\n        # return len(s.split())\n        \n        # 51.\n        # return len(s.split())\n        \n        # 52.\n        # return len(s.split())\n        \n        # 53.\n        # return len(s.split())\n        \n        # 54.\n        # return len(s.split())"}], "reverse-vowels-of-a-string": [{"task_id": "reverse-vowels-of-a-string", "completion": "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n        s = list(s)\n        i = 0\n        j = len(s) - 1\n        while i < j:\n            if s[i] in vowels and s[j] in vowels:\n                s[i], s[j] = s[j], s[i]\n                i += 1\n                j -= 1\n            elif s[i] in vowels:\n                j -= 1\n            elif s[j] in vowels:\n                i += 1\n            else:\n                i += 1\n                j -= 1\n        return ''.join(s)"}, {"task_id": "reverse-vowels-of-a-string", "completion": "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n        s = list(s)\n        i = 0\n        j = len(s) - 1\n        while i < j:\n            if s[i] in vowels and s[j] in vowels:\n                s[i], s[j] = s[j], s[i]\n                i += 1\n                j -= 1\n            elif s[i] in vowels:\n                j -= 1\n            elif s[j] in vowels:\n                i += 1\n            else:\n                i += 1\n                j -= 1\n        return ''.join(s)"}, {"task_id": "reverse-vowels-of-a-string", "completion": "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n        s = list(s)\n        i = 0\n        j = len(s) - 1\n        while i < j:\n            if s[i] in vowels and s[j] in vowels:\n                s[i], s[j] = s[j], s[i]\n                i += 1\n                j -= 1\n            elif s[i] in vowels:\n                j -= 1\n            elif s[j] in vowels:\n                i += 1\n            else:\n                i += 1\n                j -= 1\n        return ''.join(s)"}, {"task_id": "reverse-vowels-of-a-string", "completion": "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n        s = list(s)\n        i = 0\n        j = len(s) - 1\n        while i < j:\n            if s[i] in vowels and s[j] in vowels:\n                s[i], s[j] = s[j], s[i]\n                i += 1\n                j -= 1\n            elif s[i] in vowels:\n                j -= 1\n            elif s[j] in vowels:\n                i += 1\n            else:\n                i += 1\n                j -= 1\n        return ''.join(s)"}, {"task_id": "reverse-vowels-of-a-string", "completion": "class Solution(object):\n    def reverseVowels(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n        s = list(s)\n        i = 0\n        j = len(s) - 1\n        while i < j:\n            if s[i] in vowels and s[j] in vowels:\n                s[i], s[j] = s[j], s[i]\n                i += 1\n                j -= 1\n            elif s[i] in vowels:\n                j -= 1\n            elif s[j] in vowels:\n                i += 1\n            else:\n                i += 1\n                j -= 1\n        return ''.join(s)"}], "longest-consecutive-sequence": [{"task_id": "longest-consecutive-sequence", "completion": "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = set(nums)\n        longest = 0\n        \n        for num in nums:\n            if num - 1 not in nums:\n                length = 1\n                while num + 1 in nums:\n                    length += 1\n                    num += 1\n                longest = max(longest, length)\n        return longest"}, {"task_id": "longest-consecutive-sequence", "completion": "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = set(nums)\n        longest = 0\n        \n        for num in nums:\n            if num - 1 not in nums:\n                length = 1\n                while num + 1 in nums:\n                    length += 1\n                    num += 1\n                longest = max(longest, length)\n        return longest"}, {"task_id": "longest-consecutive-sequence", "completion": "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = set(nums)\n        longest = 0\n        \n        for num in nums:\n            if num - 1 not in nums:\n                length = 1\n                while num + 1 in nums:\n                    length += 1\n                    num += 1\n                longest = max(longest, length)\n        return longest"}, {"task_id": "longest-consecutive-sequence", "completion": "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = set(nums)\n        longest = 0\n        \n        for num in nums:\n            if num - 1 not in nums:\n                length = 0\n                while num + length in nums:\n                    length += 1\n                longest = max(longest, length)\n        return longest"}, {"task_id": "longest-consecutive-sequence", "completion": "class Solution(object):\n    def longestConsecutive(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        nums = set(nums)\n        longest = 0\n        \n        for num in nums:\n            if num - 1 not in nums:\n                length = 1\n                while num + 1 in nums:\n                    length += 1\n                    num += 1\n                longest = max(longest, length)\n        return longest"}], "missing-number": [{"task_id": "missing-number", "completion": "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. sort the array\n        # 2. iterate through the array\n        # 3. if the current number is not equal to the index, return the index\n        # 4. if the current number is equal to the index, return the length of the array\n        \n        nums.sort()\n        \n        for i in range(len(nums)):\n            if nums[i] != i:\n                return i\n        \n        return len(nums)"}, {"task_id": "missing-number", "completion": "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. sort the array\n        # 2. iterate through the array\n        # 3. if the current number is not equal to the index, return the index\n        # 4. if the current number is equal to the index, return the length of the array\n        \n        nums.sort()\n        \n        for i in range(len(nums)):\n            if nums[i] != i:\n                return i\n        \n        return len(nums)"}, {"task_id": "missing-number", "completion": "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. sort the array\n        # 2. iterate through the array\n        # 3. if the current number is not equal to the index, return the index\n        # 4. if the current number is equal to the index, return the length of the array\n        \n        nums.sort()\n        \n        for i in range(len(nums)):\n            if nums[i] != i:\n                return i\n        \n        return len(nums)"}, {"task_id": "missing-number", "completion": "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. sort the array\n        # 2. iterate through the array\n        # 3. if the current number is not equal to the index, return the index\n        # 4. if the current number is equal to the index, return the length of the array\n        \n        nums.sort()\n        \n        for i in range(len(nums)):\n            if nums[i] != i:\n                return i\n        \n        return len(nums)"}, {"task_id": "missing-number", "completion": "class Solution(object):\n    def missingNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. sort the array\n        # 2. iterate through the array\n        # 3. if the current number is not equal to the index, return the index\n        # 4. if the current number is equal to the index, return the length of the array\n        \n        nums.sort()\n        \n        for i in range(len(nums)):\n            if nums[i] != i:\n                return i\n        \n        return len(nums)"}], "word-ladder": [{"task_id": "word-ladder", "completion": "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        wordSet = set(wordList)\n        queue = collections.deque([(beginWord, 1)])\n        \n        while queue:\n            word, length = queue.popleft()\n            if word == endWord:\n                return length\n            for i in range(len(word)):\n                for c in string.ascii_lowercase:\n                    newWord = word[:i] + c + word[i + 1:]\n                    if newWord in wordSet:\n                        wordSet.remove(newWord)\n                        queue.append((newWord, length + 1))\n        return 0"}, {"task_id": "word-ladder", "completion": "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        wordList = set(wordList)\n        queue = collections.deque([(beginWord, 1)])\n        \n        while queue:\n            word, length = queue.popleft()\n            if word == endWord:\n                return length\n            for i in range(len(word)):\n                for c in string.ascii_lowercase:\n                    next_word = word[:i] + c + word[i + 1:]\n                    if next_word in wordList:\n                        wordList.remove(next_word)\n                        queue.append((next, length + 1))\n        return 0"}, {"task_id": "word-ladder", "completion": "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # n = len(wordList)\n        # m = len(wordList[0])\n        \n        # wordList = set(wordList)\n        # if endWord not in wordList:\n        #     return 0\n        \n        # queue = [(beginWord, 1)]\n        # while queue:\n        #     word, length = queue.pop(0)\n        #     if word == endWord:\n        #         return length\n        #     for i in range(len(word)):\n        #         for c in string.ascii_lowercase:\n        #             new_word = word[:i] + c + word[i+1:]\n        #             if new_word in wordList:\n        #                 wordList.remove(new_word)\n        #                 queue.append((new"}, {"task_id": "word-ladder", "completion": "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        wordList = set(wordList)\n        queue = collections.deque([(beginWord, 1)])\n        while queue:\n            word, length = queue.popleft()\n            if word == endWord:\n                return length\n            for i in range(len(word)):\n                for c in string.ascii_lowercase:\n                    next_word = word[:i] + c + word[i + 1:]\n                    if next_word in wordList:\n                        wordList.remove(next_word)\n                        queue.append((next, length + 1))\n        return 0"}, {"task_id": "word-ladder", "completion": "class Solution(object):\n    def ladderLength(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: int\n        \"\"\"\n        \n        # BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        # n = len(wordList)\n        # m = len(wordList[0])\n        \n        # wordList = set(wordList)\n        # if endWord not in wordList:\n        #     return 0\n        \n        # queue = collections.deque([(beginWord, 1)])\n        # while queue:\n        #     word, length = queue.popleft()\n        #     if word == endWord:\n        #         return length\n        #     for i in range(len(word)):\n        #         for c in string.ascii_lowercase:\n        #             next_word = word[:i] + c + word[i+1:]\n        #             if next_word in wordList:\n        #                 wordList.remove(next_word)\n        #                 queue.append((next, length + 1))\n        # return 0\n        \n        # Bidirectional BFS\n        # Time: O(n * m)\n        # Space: O(n * m)\n        \n        wordList = set(wordList)\n        if endWord not in wordList:\n            return 0\n        \n        left, right = {beginWord}, {endWord}\n        length = 1\n        while left:\n            # always expand the smaller set\n            if len(left) > len(right):\n                left, right = right, left\n            next_left = set()\n            for word in left:\n                for i in range(len(word)):\n                    for c in string.ascii_lowercase:\n                        next_word = word[:i] + c + word[i+1:]\n                        if next_word in right:\n                            return length + 1\n                        if next_word in wordList:\n                            next_left.add(next_word)\n                            wordList.remove(next_word)\n            left = next_left\n            length += 1\n        return 0"}], "add-binary": [{"task_id": "add-binary", "completion": "class Solution(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        \n        # convert to int\n        a = int(a, 2)\n        b = int(b, 2)\n        \n        # add\n        c = a + b\n        \n        # convert to binary\n        c = bin(c)\n        \n        # remove 0b\n        c = c[2:]\n        \n        return c"}, {"task_id": "add-binary", "completion": "class Solution(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        \n        # convert to int\n        a = int(a, 2)\n        b = int(b, 2)\n        \n        # add\n        c = a + b\n        \n        # convert to binary\n        c = bin(c)\n        \n        # remove 0b\n        c = c[2:]\n        \n        return c"}, {"task_id": "add-binary", "completion": "class Solution(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        \n        # convert to int\n        a = int(a, 2)\n        b = int(b, 2)\n        \n        # add\n        c = a + b\n        \n        # convert to binary\n        c = bin(c)\n        \n        # remove 0b\n        c = c[2:]\n        \n        return c"}, {"task_id": "add-binary", "completion": "class Solution(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        \n        # convert to int\n        a = int(a, 2)\n        b = int(b, 2)\n        \n        # add\n        c = a + b\n        \n        # convert to binary\n        c = bin(c)\n        \n        # remove 0b\n        c = c[2:]\n        \n        return c"}, {"task_id": "add-binary", "completion": "class Solution(object):\n    def addBinary(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: str\n        \"\"\"\n        \n        # convert to int\n        a = int(a, 2)\n        b = int(b, 2)\n        \n        # add\n        c = a + b\n        \n        # convert to binary\n        c = bin(c)\n        \n        # remove 0b\n        c = c[2:]\n        \n        return c"}], "find-first-and-last-position-of-element-in-sorted-array": [{"task_id": "find-first-and-last-position-of-element-in-sorted-array", "completion": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def binarySearch(nums, target, leftBias):\n            l, r = 0, len(nums) - 1\n            i = -1\n            while l <= r:\n                m = (l + r) // 2\n                if target > nums[m]:\n                    l = m + 1\n                elif target < nums[m]:\n                    r = m - 1\n                else:\n                    i = m\n                    if leftBias:\n                        r = m - 1\n                    else:\n                        l = m + 1\n            return i\n        \n        left = binarySearch(nums, target, True)\n        right = binarySearch(nums, target, False)\n        return [left, right]"}, {"task_id": "find-first-and-last-position-of-element-in-sorted-array", "completion": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def binarySearch(nums, target):\n            left, right = 0, len(nums) - 1\n            while left <= right:\n                mid = (left + right) // 2\n                if nums[mid] == target:\n                    return mid\n                elif nums[mid] < target:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return -1\n        \n        index = binarySearch(nums, target)\n        if index == -1:\n            return [-1, -1]\n        \n        left, right = index, index\n        while left >= 0 and nums[left] == target:\n            left -= 1\n        while right < len(nums) and nums[right] == target:\n            right += 1\n        return [left + 1, right - 1]"}, {"task_id": "find-first-and-last-position-of-element-in-sorted-array", "completion": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def binarySearch(nums, target):\n            left, right = 0, len(nums) - 1\n            while left <= right:\n                mid = (left + right) // 2\n                if nums[mid] == target:\n                    return mid\n                elif nums[mid] < target:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            return -1\n        \n        index = binarySearch(nums, target)\n        if index == -1:\n            return [-1, -1]\n        \n        left, right = index, index\n        while left >= 0 and nums[left] == target:\n            left -= 1\n        while right < len(nums) and nums[right] == target:\n            right += 1\n        return [left + 1, right - 1]"}, {"task_id": "find-first-and-last-position-of-element-in-sorted-array", "completion": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def binarySearch(nums, target, first):\n            lo, hi = 0, len(nums)\n            while lo < hi:\n                mid = (lo + hi) // 2\n                if nums[mid] > target or (first and target == nums[mid]):\n                    hi = mid\n                else:\n                    lo = mid + 1\n\n            return lo\n        \n        leftIdx = binarySearch(nums, target, True)\n\n        if leftIdx == len(nums) or nums[leftIdx] != target:\n            return [-1, -1]\n\n        return [leftIdx, binarySearch(nums, target, False)-1]"}, {"task_id": "find-first-and-last-position-of-element-in-sorted-array", "completion": "class Solution(object):\n    def searchRange(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def binarySearch(nums, target, first):\n            lo, hi = 0, len(nums)\n            while lo < hi:\n                mid = (lo + hi) // 2\n                if nums[mid] > target or (first and target == nums[mid]):\n                    hi = mid\n                else:\n                    lo = mid + 1\n\n            return lo\n        \n        leftIdx = binarySearch(nums, target, True)\n\n        if leftIdx == len(nums) or nums[leftIdx] != target:\n            return [-1, -1]\n\n        return [leftIdx, binarySearch(nums, target, False)-1]"}], "remove-duplicates-from-sorted-array": [{"task_id": "remove-duplicates-from-sorted-array", "completion": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2 pointers\n        # 2. if nums[i] == nums[i+1], i+=1\n        # 3. if nums[i] != nums[i+1], nums[j] = nums[i+1], j+=1\n        # 4. return j\n        \n        # 1. 2 pointers\n        i = 0\n        j = 0\n        \n        # 2. if nums[i] == nums[i+1], i+=1\n        while i < len(nums)-1:\n            if nums[i] == nums[i+1]:\n                i += 1\n            # 3. if nums[i] != nums[i+1], nums[j] = nums[i+1], j+=1\n            else:\n                nums[j] = nums[i+1]\n                j += 1\n                i += 1\n        \n        # 4. return j\n        return j"}, {"task_id": "remove-duplicates-from-sorted-array", "completion": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2 pointers\n        # 2. if nums[i] == nums[i+1], i+=1\n        # 3. if nums[i] != nums[i+1], nums[j] = nums[i+1], j+=1\n        # 4. return j\n        \n        # 1. 2 pointers\n        i = 0\n        j = 0\n        \n        # 2. if nums[i] == nums[i+1], i+=1\n        while i < len(nums)-1:\n            if nums[i] == nums[i+1]:\n                i += 1\n            # 3. if nums[i] != nums[i+1], nums[j] = nums[i+1], j+=1\n            else:\n                nums[j] = nums[i+1]\n                j += 1\n                i += 1\n        \n        # 4. return j\n        return j"}, {"task_id": "remove-duplicates-from-sorted-array", "completion": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2 pointers\n        # 2. 1st pointer is the slow pointer\n        # 2. 2nd pointer is the fast pointer\n        # 3. if nums[slow] == nums[fast]\n        # 4. then fast++\n        # 5. else nums[slow] = nums[fast]\n        # 6. slow++\n        # 7. return slow\n        \n        slow = 0\n        fast = 0\n        \n        while fast < len(nums):\n            if nums[slow] == nums[fast]:\n                fast += 1\n            else:\n                nums[slow] = nums[fast]\n                slow += 1\n                fast += 1\n                \n        return slow"}, {"task_id": "remove-duplicates-from-sorted-array", "completion": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2 pointers\n        # 2. 1st pointer is the slow pointer\n        # 2. 2nd pointer is the fast pointer\n        # 3. if nums[slow] == nums[fast]\n        # 4. then fast++\n        # 5. else nums[slow] = nums[fast]\n        # 6. slow++\n        # 7. return slow\n        \n        slow = 0\n        fast = 0\n        \n        while fast < len(nums):\n            if nums[slow] == nums[fast]:\n                fast += 1\n            else:\n                nums[slow] = nums[fast]\n                slow += 1\n                fast += 1\n                \n        return slow"}, {"task_id": "remove-duplicates-from-sorted-array", "completion": "class Solution(object):\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2 pointers\n        # 2. if nums[i] == nums[i+1], i+=1\n        # 3. if nums[i] != nums[i+1], nums[j] = nums[i+1], j+=1\n        # 4. return j\n        \n        # 1. 2 pointers\n        i = 0\n        j = 0\n        \n        # 2. if nums[i] == nums[i+1], i+=1\n        while i < len(nums)-1:\n            if nums[i] == nums[i+1]:\n                i += 1\n            # 3. if nums[i] != nums[i+1], nums[j] = nums[i+1], j+=1\n            else:\n                nums[j] = nums[i+1]\n                j += 1\n                i += 1\n        \n        # 4. return j\n        return j"}], "jump-game-ii": [{"task_id": "jump-game-ii", "completion": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. DP\n        # Time: O(n^2)\n        # Space: O(n)\n        # dp = [0] * len(nums)\n        # for i in range(len(nums)-2, -1, -1):\n        #     dp[i] = min(dp[i+1:i+nums[i]+1]) + 1\n        # return dp[0]\n        \n        # 2. Greedy\n        # Time: O(n)\n        # Space: O(1)\n        # curr_end, curr_farthest, jumps = 0, 0, 0\n        # for i in range(len(nums)-1):\n        #     curr_farthest = max(curr_farthest, i+nums[i])\n        #     if i == curr_end:\n        #         jumps += 1\n        #         curr_end = curr_farthest\n        # return jumps\n        \n        # 3. BFS\n        # Time: O(n)\n        # Space: O(n)\n        # queue = deque([(0, 0)])\n        # while queue:\n        #     i, jumps = queue.popleft()\n        #     if i == len(nums)-1:\n        #         return jumps\n        #     for j in range(i+1, min(i+nums[i]+1, len(nums))):\n        #         queue.append((j, jumps+1))\n        # return -1\n        \n        # 4. BFS\n        # Time: O(n)\n        # Space: O(n)\n        # queue = deque([(0, 0)])\n        # farthest = 0\n        # while queue:\n        #     i, jumps = queue.popleft()\n        #     if i == len(nums)-1:\n        #         return jumps\n        #     for j in range(i+1, min(i+nums[i]+1, len(nums))):\n        #         if j == len(nums)-1:\n        #             return jumps+1\n        #         if j > farthest:\n        #             queue.append((j, jumps+1))\n        #             farthest = j\n        # return -1\n        \n        # 5. BFS\n        # Time: O(n)\n        # Space: O(n)\n        # queue = deque([(0, 0)])\n        # farthest = 0\n        # while queue:\n        #     i, jumps = queue.popleft()\n        #     if i == len(nums)-1:\n        #         return jumps\n        #     for j in range(i+1, min(i+nums[i]+1, len(nums))):\n        #         if j == len(nums)-1:\n        #             return jumps+1\n        #         queue.append((j, jumps+1))\n        #         farthest = max(farthest, j)\n        #     if i == farthest:\n        #         return -1\n        # return -1\n        \n        # 6. BFS\n        # Time: O(n)\n        # Space: O(n)\n        queue = deque([(0, 0)])\n        farthest = 0\n        while queue:\n            i, jumps = queue.popleft()\n            if i == len(nums)-1:\n                return jumps\n            for j in range(i+1, min(i+nums[i]+1, len(nums))):\n                queue.append((j, jumps+1))\n                farthest = max(farthest, j)\n            if i == farthest:\n                return -1\n        return -1\n        \n        # 7. BFS\n        # Time: O(n)\n        # Space: O(n)\n        queue = deque([(0, 0)])\n        farthest = 0\n        while queue:\n            i, jumps = queue.popleft()\n            if i == len(nums)-1:\n                return jumps\n            for j in range(i+1, min(i+nums[i]+1, len(num"}, {"task_id": "jump-game-ii", "completion": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # BFS\n        # Time: O(n)\n        # Space: O(n)\n        \n        # BFS\n        # Time: O(n)\n        # Space: O(1)\n        \n        # BFS\n        # Time: O(n)\n        # Space: O(1)\n        \n        # BFS\n        # Time: O(n)\n        # Space: O(1)\n        \n        # BFS\n        # Time: O(n)\n        # Space: O(1)\n        \n        # BFS\n        # Time: O(n)\n        # Space: O(1)\n        \n        # BFS\n        # Time: O(n)\n        # Space: O(1)\n        \n        # BFS\n        # Time: O(n)\n        # Space: O(1)\n        \n        # BFS\n        # Time: O(n)\n        # Space: O(1)\n        \n        # BFS\n        # Time: O(n)\n        # Space: O(1)\n        \n        # BFS\n        # Time: O(n)\n        # Space: O(1)\n        \n        # BFS\n        # Time: O(n)\n        # Space: O(1)\n        \n        # BFS\n        # Time: O(n)\n        # Space: O(1)\n        \n        # BFS\n        # Time: O(n)\n        # Space: O(1)\n        \n        # BFS\n        # Time: O(n)\n        # Space: O(1)\n        \n        # BFS\n        # Time: O(n)\n        # Space: O(1)\n        \n        # BFS\n        # Time: O(n)\n        # Space: O(1)\n        \n        # BFS\n        # Time: O(n)\n        # Space: O(1)\n        \n        # BFS\n        # Time: O(n)\n        # Space: O(1)\n        \n        # BFS\n        # Time: O(n)\n        # Space: O(1)\n        \n        # BFS\n        # Time: O(n)\n        # Space: O(1)\n        \n        # BFS\n        # Time: O(n)\n        # Space: O(1)\n        \n        # BFS\n        # Time: O(n)\n        # Space: O(1)\n        \n        # BFS\n        # Time: O(n)\n        # Space: O(1)\n        \n        # BFS\n        # Time: O(n)\n        # Space: O(1)\n        \n        # BFS\n        # Time: O(n)\n        # Space: O(1)\n        \n        # BFS\n        # Time: O(n)\n        # Space: O(1)\n        \n        # BFS\n        # Time: O(n)\n        # Space: O(1)\n        \n        # BFS\n        # Time: O(n)\n        # Space: O(1)\n        \n        # BFS\n        # Time: O(n)\n        # Space: O(1)\n        \n        # BFS\n        # Time: O(n)\n        # Space: O(1)\n        \n        # BFS\n        # Time: O(n)\n        # Space: O(1)\n        \n        # BFS\n        # Time: O(n)\n        # Space: O(1)\n        \n        # BFS\n        # Time: O(n)\n        # Space: O(1)\n        \n        # BFS\n        # Time: O(n)\n        # Space: O(1)\n        \n        # BFS\n        # Time: O(n)\n        # Space: O(1)\n        \n        # BFS\n        # Time: O(n)\n        # Space: O(1)\n        \n        # BFS\n        # Time: O(n)\n        # Space: O(1)\n        \n        # BFS\n        # Time: O(n)\n        # Space: O(1)\n        \n        # BFS\n        # Time: O(n)\n        # Space: O(1)\n        \n        # BFS\n        # Time: O(n)\n        # Space: O(1)"}, {"task_id": "jump-game-ii", "completion": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # BFS\n        # Time: O(n)\n        # Space: O(n)\n        \n        n = len(nums)\n        q = deque([0])\n        visited = set([0])\n        res = 0\n        \n        while q:\n            for _ in range(len(q)):\n                i = q.popleft()\n                if i == n - 1:\n                    return res\n                for j in range(i + 1, min(i + nums[i] + 1, n)):\n                    if j not in visited:\n                        q.append(j)\n                        visited.add(j)\n            res += 1\n        \n        return res"}, {"task_id": "jump-game-ii", "completion": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. DP\n        # Time: O(n^2)\n        # Space: O(n)\n        # dp = [float('inf')] * len(nums)\n        # dp[0] = 0\n        # for i in range(len(nums)):\n        #     for j in range(1, nums[i] + 1):\n        #         if i + j < len(nums):\n        #             dp[i + j] = min(dp[i + j], dp[i] + 1)\n        # return dp[-1]\n        \n        # 2. Greedy\n        # Time: O(n)\n        # Space: O(1)\n        # curr_end, curr_farthest, jumps = 0, 0, 0\n        # for i in range(len(nums) - 1):\n        #     curr_farthest = max(curr_farthest, i + nums[i])\n        #     if i == curr_end:\n        #         jumps += 1\n        #         curr_end = curr_farthest\n        # return jumps\n        \n        # 3. BFS\n        # Time: O(n)\n        # Space: O(n)\n        # queue = deque([(0, 0)])\n        # while queue:\n        #     idx, step = queue.popleft()\n        #     if idx == len(nums) - 1:\n        #         return step\n        #     for i in range(1, nums[idx] + 1):\n        #         if idx + i < len(nums):\n        #             queue.append((idx + i, step + 1))\n        # return -1\n        \n        # 4. BFS\n        # Time: O(n)\n        # Space: O(n)\n        # queue = deque([(0, 0)])\n        # while queue:\n        #     idx, step = queue.popleft()\n        #     if idx == len(nums) - 1:\n        #         return step\n        #     for i in range(1, nums[idx] + 1):\n        #         if idx + i < len(nums):\n        #             queue.append((idx + i, step + 1))\n        # return -1\n        \n        # 5. BFS\n        # Time: O(n)\n        # Space: O(n)\n        # queue = deque([(0, 0)])\n        # while queue:\n        #     idx, step = queue.popleft()\n        #     if idx == len(nums) - 1:\n        #         return step\n        #     for i in range(1, nums[idx] + 1):\n        #         if idx + i < len(nums):\n        #             queue.append((idx + i, step + 1))\n        # return -1\n        \n        # 6. BFS\n        # Time: O(n)\n        # Space: O(n)\n        # queue = deque([(0, 0)])\n        # while queue:\n        #     idx, step = queue.popleft()\n        #     if idx == len(nums) - 1:\n        #         return step\n        #     for i in range(1, nums[idx] + 1):\n        #         if idx + i < len(nums):\n        #             queue.append((idx + i, step + 1))\n        # return -1\n        \n        # 7. BFS\n        # Time: O(n)\n        # Space: O(n)\n        # queue = deque([(0, 0)])\n        # while queue:\n        #     idx, step = queue.popleft()\n        #     if idx == len(nums) - 1:\n        #         return step\n        #     for i in range(1, nums[idx] + 1):\n        #         if idx + i < len(nums):\n        #             queue.append((idx + i, step + 1))\n        # return -1\n        \n        # 8. BFS\n        # Time: O(n)\n        # Space: O(n)\n        # queue = deque([(0, 0)])\n        # while"}, {"task_id": "jump-game-ii", "completion": "class Solution(object):\n    def jump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # BFS\n        # Time: O(n)\n        # Space: O(n)\n        \n        # BFS\n        # Time: O(n)\n        # Space: O(1)\n        \n        # BFS\n        # Time: O(n)\n        # Space: O(1)\n        \n        # BFS\n        # Time: O(n)\n        # Space: O(1)\n        \n        # BFS\n        # Time: O(n)\n        # Space: O(1)\n        \n        # BFS\n        # Time: O(n)\n        # Space: O(1)\n        \n        # BFS\n        # Time: O(n)\n        # Space: O(1)\n        \n        # BFS\n        # Time: O(n)\n        # Space: O(1)\n        \n        # BFS\n        # Time: O(n)\n        # Space: O(1)\n        \n        # BFS\n        # Time: O(n)\n        # Space: O(1)\n        \n        # BFS\n        # Time: O(n)\n        # Space: O(1)\n        \n        # BFS\n        # Time: O(n)\n        # Space: O(1)\n        \n        # BFS\n        # Time: O(n)\n        # Space: O(1)\n        \n        # BFS\n        # Time: O(n)\n        # Space: O(1)\n        \n        # BFS\n        # Time: O(n)\n        # Space: O(1)\n        \n        # BFS\n        # Time: O(n)\n        # Space: O(1)\n        \n        # BFS\n        # Time: O(n)\n        # Space: O(1)\n        \n        # BFS\n        # Time: O(n)\n        # Space: O(1)\n        \n        # BFS\n        # Time: O(n)\n        # Space: O(1)\n        \n        # BFS\n        # Time: O(n)\n        # Space: O(1)\n        \n        # BFS\n        # Time: O(n)\n        # Space: O(1)\n        \n        # BFS\n        # Time: O(n)\n        # Space: O(1)\n        \n        # BFS\n        # Time: O(n)\n        # Space: O(1)\n        \n        # BFS\n        # Time: O(n)\n        # Space: O(1)\n        \n        # BFS\n        # Time: O(n)\n        # Space: O(1)\n        \n        # BFS\n        # Time: O(n)\n        # Space: O(1)\n        \n        # BFS\n        # Time: O(n)\n        # Space: O(1)\n        \n        # BFS\n        # Time: O(n)\n        # Space: O(1)\n        \n        # BFS\n        # Time: O(n)\n        # Space: O(1)\n        \n        # BFS\n        # Time: O(n)\n        # Space: O(1)\n        \n        # BFS\n        # Time: O(n)\n        # Space: O(1)\n        \n        # BFS\n        # Time: O(n)\n        # Space: O(1)\n        \n        # BFS\n        # Time: O(n)\n        # Space: O(1)\n        \n        # BFS\n        # Time: O(n)\n        # Space: O(1)\n        \n        # BFS\n        # Time: O(n)\n        # Space: O(1)\n        \n        # BFS\n        # Time: O(n)\n        # Space: O(1)\n        \n        # BFS\n        # Time: O(n)\n        # Space: O(1)\n        \n        # BFS\n        # Time: O(n)\n        # Space: O(1)\n        \n        # BFS\n        # Time: O(n)\n        # Space: O(1)\n        \n        # BFS\n        # Time: O(n)\n        # Space: O(1)\n        \n        # BFS\n        # Time: O(n)\n        # Space: O(1)"}], "best-time-to-buy-and-sell-stock-iv": [{"task_id": "best-time-to-buy-and-sell-stock-iv", "completion": "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if not prices:\n            return 0\n        \n        if k >= len(prices) // 2:\n            return sum(i - j for i, j in zip(prices[1:], prices[:-1]) if i - j > 0)\n        \n        dp = [[0] * len(prices) for _ in range(k + 1)]\n        \n        for i in range(1, k + 1):\n            max_diff = -prices[0]\n            for j in range(1, len(prices)):\n                dp[i][j] = max(dp[i][j - 1], prices[j] + max_diff)\n                max_diff = max(max_diff, dp[i - 1][j - 1] - prices[j])\n        \n        return dp[k][-1]"}, {"task_id": "best-time-to-buy-and-sell-stock-iv", "completion": "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if not prices:\n            return 0\n        \n        if k >= len(prices) // 2:\n            return sum(i - j for i, j in zip(prices[1:], prices[:-1]) if i - j > 0)\n        \n        dp = [[0] * len(prices) for _ in range(k + 1)]\n        \n        for i in range(1, k + 1):\n            max_diff = -prices[0]\n            for j in range(1, len(prices)):\n                dp[i][j] = max(dp[i][j - 1], prices[j] + max_diff)\n                max_diff = max(max_diff, dp[i - 1][j - 1] - prices[j])\n        \n        return dp[k][-1]"}, {"task_id": "best-time-to-buy-and-sell-stock-iv", "completion": "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if not prices:\n            return 0\n        \n        if k >= len(prices) // 2:\n            return sum(i - j for i, j in zip(prices[1:], prices[:-1]) if i - j > 0)\n        \n        dp = [[0] * len(prices) for _ in range(k + 1)]\n        \n        for i in range(1, k + 1):\n            max_diff = -prices[0]\n            for j in range(1, len(prices)):\n                dp[i][j] = max(dp[i][j - 1], prices[j] + max_diff)\n                max_diff = max(max_diff, dp[i - 1][j - 1] - prices[j])\n        \n        return dp[k][-1]"}, {"task_id": "best-time-to-buy-and-sell-stock-iv", "completion": "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if not prices:\n            return 0\n        \n        if k >= len(prices) // 2:\n            return sum(i - j for i, j in zip(prices[1:], prices[:-1]) if i - j > 0)\n        \n        dp = [[0] * len(prices) for _ in range(k + 1)]\n        \n        for i in range(1, k + 1):\n            max_diff = -prices[0]\n            for j in range(1, len(prices)):\n                dp[i][j] = max(dp[i][j - 1], prices[j] + max_diff)\n                max_diff = max(max_diff, dp[i - 1][j - 1] - prices[j])\n        \n        return dp[k][-1]"}, {"task_id": "best-time-to-buy-and-sell-stock-iv", "completion": "class Solution(object):\n    def maxProfit(self, k, prices):\n        \"\"\"\n        :type k: int\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if not prices:\n            return 0\n        \n        if k >= len(prices) // 2:\n            return sum(i - j for i, j in zip(prices[1:], prices[:-1]) if i - j > 0)\n        \n        dp = [[0] * len(prices) for _ in range(k + 1)]\n        \n        for i in range(1, k + 1):\n            max_diff = -prices[0]\n            for j in range(1, len(prices)):\n                dp[i][j] = max(dp[i][j - 1], prices[j] + max_diff)\n                max_diff = max(max_diff, dp[i - 1][j - 1] - prices[j])\n        \n        return dp[k][-1]"}], "convert-a-number-to-hexadecimal": [{"task_id": "convert-a-number-to-hexadecimal", "completion": "class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return '0'\n        \n        if num < 0:\n            num = (1 << 32) + num\n        \n        res = ''\n        while num > 0:\n            res = str(hex(num % 16))[2] + res\n            num //= 16\n        \n        return res"}, {"task_id": "convert-a-number-to-hexadecimal", "completion": "class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return '0'\n        \n        if num < 0:\n            num = (1 << 32) + num\n        \n        res = ''\n        while num:\n            res = str(hex(num % 16))[2] + res\n            num //= 16\n        \n        return res"}, {"task_id": "convert-a-number-to-hexadecimal", "completion": "class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return '0'\n        \n        if num < 0:\n            num = (1 << 32) + num\n        \n        res = ''\n        while num > 0:\n            res = str(hex(num % 16))[2] + res\n            num //= 16\n        \n        return res"}, {"task_id": "convert-a-number-to-hexadecimal", "completion": "class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return '0'\n        \n        if num < 0:\n            num = (1 << 32) + num\n        \n        res = ''\n        while num > 0:\n            res = hex(num % 16)[2:] + res\n            num //= 16\n        \n        return res"}, {"task_id": "convert-a-number-to-hexadecimal", "completion": "class Solution(object):\n    def toHex(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return '0'\n        \n        if num < 0:\n            num = (1 << 32) + num\n        \n        res = ''\n        while num > 0:\n            res = hex(num % 16)[2:] + res\n            num //= 16\n        \n        return res"}], "first-unique-character-in-a-string": [{"task_id": "first-unique-character-in-a-string", "completion": "class Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # create a dictionary to store the count of each character\n        char_count = {}\n        \n        # iterate through the string and update the count of each character\n        for char in s:\n            if char in char_count:\n                char_count[char] += 1\n            else:\n                char_count[char] = 1\n        \n        # iterate through the string again and return the index of the first character with a count of 1\n        for i, char in enumerate(s):\n            if char_count[char] == 1:\n                return i\n        \n        # if no character with a count of 1 is found, return -1\n        return -1"}, {"task_id": "first-unique-character-in-a-string", "completion": "class Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # create a dictionary to store the count of each character\n        char_count = {}\n        \n        # iterate through the string and update the count of each character\n        for char in s:\n            if char in char_count:\n                char_count[char] += 1\n            else:\n                char_count[char] = 1\n        \n        # iterate through the string again and return the index of the first character with a count of 1\n        for i, char in enumerate(s):\n            if char_count[char] == 1:\n                return i\n        \n        # if no character with a count of 1 is found, return -1\n        return -1"}, {"task_id": "first-unique-character-in-a-string", "completion": "class Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # create a dictionary to store the count of each character\n        char_count = {}\n        \n        # iterate through the string and update the count of each character\n        for char in s:\n            if char in char_count:\n                char_count[char] += 1\n            else:\n                char_count[char] = 1\n        \n        # iterate through the string again and return the index of the first character with a count of 1\n        for i, char in enumerate(s):\n            if char_count[char] == 1:\n                return i\n        \n        # if no character with a count of 1 is found, return -1\n        return -1"}, {"task_id": "first-unique-character-in-a-string", "completion": "class Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # create a dictionary to store the count of each character\n        char_count = {}\n        \n        # iterate through the string and update the count of each character\n        for char in s:\n            if char in char_count:\n                char_count[char] += 1\n            else:\n                char_count[char] = 1\n        \n        # iterate through the string again and return the index of the first character with a count of 1\n        for i, char in enumerate(s):\n            if char_count[char] == 1:\n                return i\n        \n        # if no character with a count of 1 is found, return -1\n        return -1"}, {"task_id": "first-unique-character-in-a-string", "completion": "class Solution(object):\n    def firstUniqChar(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # create a dictionary to store the count of each character\n        char_count = {}\n        \n        # iterate through the string and update the count of each character\n        for char in s:\n            if char in char_count:\n                char_count[char] += 1\n            else:\n                char_count[char] = 1\n        \n        # iterate through the string again and return the index of the first character with a count of 1\n        for i, char in enumerate(s):\n            if char_count[char] == 1:\n                return i\n        \n        # if no character with a count of 1 is found, return -1\n        return -1"}], "contains-duplicate-iii": [{"task_id": "contains-duplicate-iii", "completion": "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDiff: int\n        :type valueDiff: int\n        :rtype: bool\n        \"\"\"\n        \n        # 1. create a dictionary to store the index and value of each number\n        # 2. iterate through the dictionary\n        # 3. if the index difference is less than or equal to indexDiff, and the value difference is less than or equal to valueDiff, return True\n        # 4. if the index difference is greater than indexDiff, remove the index and value from the dictionary\n        # 5. if the index difference is less than or equal to indexDiff, and the value difference is greater than valueDiff, remove the index and value from the dictionary\n        # 6. if the index difference is greater than indexDiff, and the value difference is less than or equal to valueDiff, remove the index and value from the dictionary\n        # 7. if the index difference is greater than indexDiff, and the value difference is greater than valueDiff, remove the index and value from the dictionary\n        # 8. if the index difference is less than or equal to indexDiff, and the value difference is less than or equal to valueDiff, remove the index and value from the dictionary\n        # 9. if the index difference is greater than indexDiff, and the value difference is less than or equal to valueDiff, remove the index and value from the dictionary\n        # 10. if the index difference is greater than indexDiff, and the value difference is greater than valueDiff, remove the index and value from the dictionary\n        # 11. if the index difference is less than or equal to indexDiff, and the value difference is greater than valueDiff, remove the index and value from the dictionary\n        # 12. if the index difference is greater than indexDiff, and the value difference is less than or equal to valueDiff, remove the index and value from the dictionary\n        # 13. if the index difference is greater than indexDiff, and the value difference is greater than valueDiff, remove the index and value from the dictionary\n        # 14. if the index difference is less than or equal to indexDiff, and the value difference is less than or equal to valueDiff, remove the index and value from the dictionary\n        # 15. if the index difference is greater than indexDiff, and the value difference is less than or equal to valueDiff, remove the index and value from the dictionary\n        # 16. if the index difference is greater than indexDiff, and the value difference is greater than valueDiff, remove the index and value from the dictionary\n        # 17. if the index difference is less than or equal to indexDiff, and the value difference is less than or equal to valueDiff, remove the index and value from the dictionary\n        # 18. if the index difference is greater than indexDiff, and the value difference is less than or equal to valueDiff, remove the index and value from the dictionary\n        # 19. if the index difference is greater than indexDiff, and the value difference is greater than valueDiff, remove the index and value from the dictionary\n        # 20. if the index difference is less than or equal to indexDiff, and the value difference is less than or equal to valueDiff, remove the index and value from the dictionary\n        # 21. if the index difference is greater than indexDiff, and the value difference is less than or equal to valueDiff, remove the index and value from the dictionary\n        # 22. if the index difference is greater than indexDiff, and the value difference is greater than valueDiff, remove the index and value from the dictionary\n        # 23. if the index difference is less than or equal to indexDiff, and the value difference is less than or equal to valueDiff, remove the index and value from the dictionary\n        # 24. if the index difference is greater than indexDiff, and the value difference is less than or equal to valueDiff, remove the index and value from the dictionary\n        # 25. if the index difference is greater than indexDiff, and the value difference is greater than valueDiff, remove the index and value from the dictionary\n        # 26. if the index difference is less than or equal to indexDiff, and the value difference is less than or equal to valueDiff, remove the index and value from the dictionary\n        # 27. if the index difference is greater than indexDiff, and the value difference is less than or equal to valueDiff, remove the index and value from the dictionary\n        # 28. if the index difference is greater than indexDiff, and the value difference is greater than valueDiff, remove the index and value from the dictionary\n        # 29. if the index difference is less than or equal to indexDiff, and the value difference is less than or equal to valueDiff, remove the index and"}, {"task_id": "contains-duplicate-iii", "completion": "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDiff: int\n        :type valueDiff: int\n        :rtype: bool\n        \"\"\"\n        \n        # 1. create a dictionary to store the index and value of each number\n        # 2. iterate through the dictionary\n        # 3. if the index difference is less than or equal to indexDiff and the value difference is less than or equal to valueDiff, return True\n        # 4. if not, return False\n        \n        # 1. create a dictionary to store the index and value of each number\n        d = {}\n        for i in range(len(nums)):\n            d[i] = nums[i]\n        \n        # 2. iterate through the dictionary\n        for i in d:\n            for j in d:\n                # 3. if the index difference is less than or equal to indexDiff and the value difference is less than or equal to valueDiff, return True\n                if abs(i - j) <= indexDiff and abs(d[i] - d[j]) <= valueDiff:\n                    return True\n        \n        # 4. if not, return False\n        return False"}, {"task_id": "contains-duplicate-iii", "completion": "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDiff: int\n        :type valueDiff: int\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \n        # Time: O(n^2)\n        # Space: O(1)\n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if abs(i-j) <= indexDiff and abs(nums[i]-nums[j]) <= valueDiff:\n        #             return True\n        # return False\n        \n        # 2. \n        # Time: O(nlogn)\n        # Space: O(n)\n        # nums_sorted = sorted(nums)\n        # for i in range(len(nums_sorted)):\n        #     for j in range(i+1, len(nums_sorted)):\n        #         if abs(nums_sorted[i]-nums_sorted[j]) <= valueDiff:\n        #             if abs(i-j) <= indexDiff:\n        #                 return True\n        # return False\n        \n        # 3. \n        # Time: O(n)\n        # Space: O(n)\n        # bucket = {}\n        # for i in range(len(nums)):\n        #     bucket_num = nums[i] // (valueDiff+1)\n        #     if bucket_num in bucket:\n        #         return True\n        #     if bucket_num-1 in bucket and abs(nums[i]-bucket[bucket_num-1]) <= valueDiff:\n        #         return True\n        #     if bucket_num+1 in bucket and abs(nums[i]-bucket[bucket_num+1]) <= valueDiff:\n        #         return True\n        #     bucket[bucket_num] = nums[i]\n        #     if i >= indexDiff:\n        #         del bucket[nums[i-indexDiff] // (valueDiff+1)]\n        # return False\n        \n        # 4. \n        # Time: O(n)\n        # Space: O(n)\n        bucket = {}\n        for i in range(len(nums)):\n            bucket_num = nums[i] // (valueDiff+1)\n            if bucket_num in bucket:\n                return True\n            if bucket_num-1 in bucket and abs(nums[i]-bucket[bucket_num-1]) <= valueDiff:\n                return True\n            if bucket_num+1 in bucket and abs(nums[i]-bucket[bucketbucket_num+1"}, {"task_id": "contains-duplicate-iii", "completion": "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDiff: int\n        :type valueDiff: int\n        :rtype: bool\n        \"\"\"\n        \n        # 1. create a dictionary to store the index and value of each number\n        # 2. iterate through the dictionary\n        # 3. if the index difference is less than or equal to indexDiff, and the value difference is less than or equal to valueDiff, return True\n        # 4. if the index difference is greater than indexDiff, remove the index and value from the dictionary\n        # 5. if the index difference is less than or equal to indexDiff, and the value difference is greater than valueDiff, remove the index and value from the dictionary\n        # 6. if the index difference is greater than indexDiff, and the value difference is less than or equal to valueDiff, remove the index and value from the dictionary\n        # 7. if the index difference is greater than indexDiff, and the value difference is greater than valueDiff, remove the index and value from the dictionary\n        # 8. if the index difference is less than or equal to indexDiff, and the value difference is less than or equal to valueDiff, remove the index and value from the dictionary\n        # 9. if the index difference is greater than indexDiff, and the value difference is less than or equal to valueDiff, remove the index and value from the dictionary\n        # 10. if the index difference is less than or equal to indexDiff, and the value difference is greater than valueDiff, remove the index and value from the dictionary\n        # 11. if the index difference is greater than indexDiff, and the value difference is greater than valueDiff, remove the index and value from the dictionary\n        # 12. if the index difference is less than or equal to indexDiff, and the value difference is less than or equal to valueDiff, remove the index and value from the dictionary\n        # 13. if the index difference is greater than indexDiff, and the value difference is less than or equal to valueDiff, remove the index and value from the dictionary\n        # 14. if the index difference is less than or equal to indexDiff, and the value difference is greater than valueDiff, remove the index and value from the dictionary\n        # 15. if the index difference is greater than indexDiff, and the value difference is greater than valueDiff, remove the index and value from the dictionary\n        # 16. if the index difference is less than or equal to indexDiff, and the value difference is less than or equal to valueDiff, remove the index and value from the dictionary\n        # 17. if the index difference is greater than indexDiff, and the value difference is less than or equal to valueDiff, remove the index and value from the dictionary\n        # 18. if the index difference is less than or equal to indexDiff, and the value difference is greater than valueDiff, remove the index and value from the dictionary\n        # 19. if the index difference is greater than indexDiff, and the value difference is greater than valueDiff, remove the index and value from the dictionary\n        # 20. if the index difference is less than or equal to indexDiff, and the value difference is less than or equal to valueDiff, remove the index and value from the dictionary\n        # 21. if the index difference is greater than indexDiff, and the value difference is less than or equal to valueDiff, remove the index and value from the dictionary\n        # 22. if the index difference is less than or equal to indexDiff, and the value difference is greater than valueDiff, remove the index and value from the dictionary\n        # 23. if the index difference is greater than indexDiff, and the value difference is greater than valueDiff, remove the index and value from the dictionary\n        # 24. if the index difference is less than or equal to indexDiff, and the value difference is less than or equal to valueDiff, remove the index and value from the dictionary\n        # 25. if the index difference is greater than indexDiff, and the value difference is less than or equal to valueDiff, remove the index and value from the dictionary\n        # 26. if the index difference is less than or equal to indexDiff, and the value difference is greater than valueDiff, remove the index and value from the dictionary\n        # 27. if the index difference is greater than indexDiff, and the value difference is greater than valueDiff, remove the index and value from the dictionary\n        # 28. if the index difference is less than or equal to indexDiff, and the value difference is less than or equal to valueDiff, remove the index and value from the dictionary\n        # 29. if the index difference is greater than indexDiff, and the value difference is less than or equal to valueDiff, remove"}, {"task_id": "contains-duplicate-iii", "completion": "class Solution(object):\n    def containsNearbyAlmostDuplicate(self, nums, indexDiff, valueDiff):\n        \"\"\"\n        :type nums: List[int]\n        :type indexDiff: int\n        :type valueDiff: int\n        :rtype: bool\n        \"\"\"\n        \n        # 1. create a dictionary to store the index and value of each number\n        # 2. iterate through the dictionary\n        # 3. if the index difference is less than or equal to indexDiff and the value difference is less than or equal to valueDiff, return True\n        # 4. if the index difference is greater than indexDiff, remove the index and value from the dictionary\n        # 5. if the index difference is less than or equal to indexDiff and the value difference is greater than valueDiff, remove the index and value from the dictionary\n        # 6. if the index difference is greater than indexDiff and the value difference is greater than valueDiff, remove the index and value from the dictionary\n        # 7. if the index difference is less than or equal to indexDiff and the value difference is less than or equal to valueDiff, remove the index and value from the dictionary\n        # 8. if the index difference is greater than indexDiff and the value difference is less than or equal to valueDiff, remove the index and value from the dictionary\n        # 9. if the index difference is less than or equal to indexDiff and the value difference is greater than valueDiff, remove the index and value from the dictionary\n        # 10. if the index difference is greater than indexDiff and the value difference is greater than valueDiff, remove the index and value from the dictionary\n        # 11. if the index difference is less than or equal to indexDiff and the value difference is less than or equal to valueDiff, remove the index and value from the dictionary\n        # 12. if the index difference is greater than indexDiff and the value difference is less than or equal to valueDiff, remove the index and value from the dictionary\n        # 13. if the index difference is less than or equal to indexDiff and the value difference is greater than valueDiff, remove the index and value from the dictionary\n        # 14. if the index difference is greater than indexDiff and the value difference is greater than valueDiff, remove the index and value from the dictionary\n        # 15. if the index difference is less than or equal to indexDiff and the value difference is less than or equal to valueDiff, remove the index and value from the dictionary\n        # 16. if the index difference is greater than indexDiff and the value difference is less than or equal to valueDiff, remove the index and value from the dictionary\n        # 17. if the index difference is less than or equal to indexDiff and the value difference is greater than valueDiff, remove the index and value from the dictionary\n        # 18. if the index difference is greater than indexDiff and the value difference is greater than valueDiff, remove the index and value from the dictionary\n        # 19. if the index difference is less than or equal to indexDiff and the value difference is less than or equal to valueDiff, remove the index and value from the dictionary\n        # 20. if the index difference is greater than indexDiff and the value difference is less than or equal to valueDiff, remove the index and value from the dictionary\n        # 21. if the index difference is less than or equal to indexDiff and the value difference is greater than valueDiff, remove the index and value from the dictionary\n        # 22. if the index difference is greater than indexDiff and the value difference is greater than valueDiff, remove the index and value from the dictionary\n        # 23. if the index difference is less than or equal to indexDiff and the value difference is less than or equal to valueDiff, remove the index and value from the dictionary\n        # 24. if the index difference is greater than indexDiff and the value difference is less than or equal to valueDiff, remove the index and value from the dictionary\n        # 25. if the index difference is less than or equal to indexDiff and the value difference is greater than valueDiff, remove the index and value from the dictionary\n        # 26. if the index difference is greater than indexDiff and the value difference is greater than valueDiff, remove the index and value from the dictionary\n        # 27. if the index difference is less than or equal to indexDiff and the value difference is less than or equal to valueDiff, remove the index and value from the dictionary\n        # 28. if the index difference is greater than indexDiff and the value difference is less than or equal to valueDiff, remove the index and value from the dictionary\n        # 29. if the index difference is less than or equal to indexDiff and the value difference is greater than valueDiff, remove the index and value from the dictionary\n        # 30. if the index difference is greater than indexDiff and the value"}], "sort-colors": [{"task_id": "sort-colors", "completion": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # 1. 2-pass solution\n        # count = [0] * 3\n        # for num in nums:\n        #     count[num] += 1\n        # nums[:count[0]] = [0] * count[0]\n        # nums[count[0]:count[0]+count[1]] = [1] * count[1]\n        # nums[count[0]+count[1]:] = [2] * count[2]\n        \n        # 2. 1-pass solution\n        # p0, curr = 0, 0\n        # p2 = len(nums) - 1\n        \n        # while curr <= p2:\n        #     if nums[curr] == 0:\n        #         nums[p0], nums[curr] = nums[curr], nums[p0]\n        #         p0 += 1\n        #         curr += 1\n        #     elif nums[curr] == 2:\n        #         nums[curr], nums[p2] = nums[p2], nums[curr]\n        #         p2 -= 1\n        #     else:\n        #         curr += 1\n        \n        # 3. 1-pass solution\n        p0, p2 = 0, len(nums) - 1\n        curr = 0\n        while curr <= p2:\n            if nums[curr] == 0:\n                nums[p0], nums[curr] = nums[curr], nums[p0]\n                p0 += 1\n                curr += 1\n            elif nums[curr] == 2:\n                nums[curr], nums[p2] = nums"}, {"task_id": "sort-colors", "completion": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # 1. 2-pass solution\n        # count = [0] * 3\n        # for num in nums:\n        #     count[num] += 1\n        # nums[:count[0]] = [0] * count[0]\n        # nums[count[0]:count[0]+count[1]] = [1] * count[1]\n        # nums[count[0]+count[1]:] = [2] * count[2]\n        \n        # 2. 1-pass solution\n        # p0, curr = 0, 0\n        # p2 = len(nums) - 1\n        \n        # while curr <= p2:\n        #     if nums[curr] == 0:\n        #         nums[p0], nums[curr] = nums[curr], nums[p0]\n        #         p0 += 1\n        #         curr += 1\n        #     elif nums[curr] == 2:\n        #         nums[curr], nums[p2] = nums[p2], nums[curr]\n        #         p2 -= 1\n        #     else:\n        #         curr += 1\n        \n        # 3. 1-pass solution\n        p0, p2 = 0, len(nums) - 1\n        curr = 0\n        while curr <= p2:\n            if nums[curr] == 0:\n                nums[p0], nums[curr] = nums[curr], nums[p0]\n                p0 += 1\n                curr += 1\n            elif nums[curr] == 2:\n                nums[curr], nums[p2] = nums"}, {"task_id": "sort-colors", "completion": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # 1. 3-way partitioning\n        # 2. 2-way partitioning\n        # 3. 1-way partitioning\n        \n        # 1. 3-way partitioning\n        # 2. 2-way partitioning\n        # 3. 1-way partitioning\n        \n        # 1. 3-way partitioning\n        # 2. 2-way partitioning\n        # 3. 1-way partitioning\n        \n        # 1. 3-way partitioning\n        # 2. 2-way partitioning\n        # 3. 1-way partitioning\n        \n        # 1. 3-way partitioning\n        # 2. 2-way partitioning\n        # 3. 1-way partitioning\n        \n        # 1. 3-way partitioning\n        # 2. 2-way partitioning\n        # 3. 1-way partitioning\n        \n        # 1. 3-way partitioning\n        # 2. 2-way partitioning\n        # 3. 1-way partitioning\n        \n        # 1. 3-way partitioning\n        # 2. 2-way partitioning\n        # 3. 1-way partitioning\n        \n        # 1. 3-way partitioning\n        # 2. 2-way partitioning\n        # 3. 1-way partitioning\n        \n        # 1. 3-way partitioning\n        # 2. 2-way partitioning\n        # 3. 1-way partitioning\n        \n        # 1. 3-way partitioning\n        # 2. 2-way partitioning\n        # 3. 1-way partitioning\n        \n        # 1. 3-way partitioning\n        # 2. 2-way partitioning\n        # 3. 1-way partitioning\n        \n        # 1. 3-way partitioning\n        # 2. 2-way partitioning\n        # 3. 1-way partitioning\n        \n        # 1. 3-way partitioning\n        # 2. 2-way partitioning\n        # 3. 1-way partitioning\n        \n        # 1. 3-way partitioning\n        # 2. 2-way partitioning\n        # 3. 1-way partitioning\n        \n        # 1. 3-way partitioning\n        # 2. 2-way partitioning\n        # 3. 1-way partitioning\n        \n        # 1. 3-way partitioning\n        # 2. 2-way partitioning\n        # 3. 1-way partitioning\n        \n        # 1. 3-way partitioning\n        # 2. 2-way partitioning\n        # 3. 1-way partitioning\n        \n        # 1. 3-way partitioning\n        # 2. 2-way partitioning\n        # 3. 1-way partitioning\n        \n        # 1. 3-way partitioning\n        # 2. 2-way partitioning\n        # 3. 1-way partitioning\n        \n        # 1. 3-way partitioning\n        # 2. 2-way partitioning\n        # 3. 1-way partitioning\n        \n        # 1. 3-way partitioning\n        # 2. 2-way partitioning\n        # 3. 1-way partitioning\n        \n        # 1. 3-way partitioning\n        # 2. 2-way partitioning\n        # 3. 1-way partitioning\n        \n        # 1. 3-way partitioning\n        # 2. 2-way partitioning\n        # 3. 1-way partitioning\n        \n        # 1. 3-way partitioning\n        # 2. 2-way partitioning\n        # 3. 1-way partitioning\n        \n        # 1. 3-way partitioning\n        # 2. 2-way partitioning\n        # 3. 1-way partitioning\n        \n        # 1. 3-way partitioning\n        # 2. 2-way partitioning\n        # 3. 1-way partitioning"}, {"task_id": "sort-colors", "completion": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # 1. 3-way partitioning\n        # 2. 2-pass\n        # 3. 1-pass\n        \n        # 3-way partitioning\n        # 1. 3-way partitioning\n        # 2. 2-pass\n        # 3. 1-pass\n        \n        # 3-way partitioning\n        # 1. 3-way partitioning\n        # 2. 2-pass\n        # 3. 1-pass\n        \n        # 3-way partitioning\n        # 1. 3-way partitioning\n        # 2. 2-pass\n        # 3. 1-pass\n        \n        # 3-way partitioning\n        # 1. 3-way partitioning\n        # 2. 2-pass\n        # 3. 1-pass\n        \n        # 3-way partitioning\n        # 1. 3-way partitioning\n        # 2. 2-pass\n        # 3. 1-pass\n        \n        # 3-way partitioning\n        # 1. 3-way partitioning\n        # 2. 2-pass\n        # 3. 1-pass\n        \n        # 3-way partitioning\n        # 1. 3-way partitioning\n        # 2. 2-pass\n        # 3. 1-pass\n        \n        # 3-way partitioning\n        # 1. 3-way partitioning\n        # 2. 2-pass\n        # 3. 1-pass\n        \n        # 3-way partitioning\n        # 1. 3-way partitioning\n        # 2. 2-pass\n        # 3. 1-pass\n        \n        # 3-way partitioning\n        # 1. 3-way partitioning\n        # 2. 2-pass\n        # 3. 1-pass\n        \n        # 3-way partitioning\n        # 1. 3-way partitioning\n        # 2. 2-pass\n        # 3. 1-pass\n        \n        # 3-way partitioning\n        # 1. 3-way partitioning\n        # 2. 2-pass\n        # 3. 1-pass\n        \n        # 3-way partitioning\n        # 1. 3-way partitioning\n        # 2. 2-pass\n        # 3. 1-pass\n        \n        # 3-way partitioning\n        # 1. 3-way partitioning\n        # 2. 2-pass\n        # 3. 1-pass\n        \n        # 3-way partitioning\n        # 1. 3-way partitioning\n        # 2. 2-pass\n        # 3. 1-pass\n        \n        # 3-way partitioning\n        # 1. 3-way partitioning\n        # 2. 2-pass\n        # 3. 1-pass\n        \n        # 3-way partitioning\n        # 1. 3-way partitioning\n        # 2. 2-pass\n        # 3. 1-pass\n        \n        # 3-way partitioning\n        # 1. 3-way partitioning\n        # 2. 2-pass\n        # 3. 1-pass\n        \n        # 3-way partitioning\n        # 1. 3-way partitioning\n        # 2. 2-pass\n        # 3. 1-pass\n        \n        # 3-way partitioning\n        # 1. 3-way partitioning\n        # 2. 2-pass\n        # 3. 1-pass\n        \n        # 3-way partitioning\n        # 1. 3-way partitioning\n        # 2. 2-pass\n        # 3. 1-pass\n        \n        # 3-way partitioning\n        # 1. 3-way partitioning\n        # 2. 2-pass\n        # 3. 1-pass\n        \n        # 3-way partitioning\n        # 1. 3-way partitioning\n        # 2. 2-pass\n        # 3. 1-pass"}, {"task_id": "sort-colors", "completion": "class Solution(object):\n    def sortColors(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # 1. 2-pass solution\n        # count = [0] * 3\n        # for num in nums:\n        #     count[num] += 1\n        # nums[:count[0]] = [0] * count[0]\n        # nums[count[0]:count[0]+count[1]] = [1] * count[1]\n        # nums[count[0]+count[1]:] = [2] * count[2]\n        \n        # 2. 1-pass solution\n        # p0, curr = 0, 0\n        # p2 = len(nums) - 1\n        \n        # while curr <= p2:\n        #     if nums[curr] == 0:\n        #         nums[p0], nums[curr] = nums[curr], nums[p0]\n        #         p0 += 1\n        #         curr += 1\n        #     elif nums[curr] == 2:\n        #         nums[curr], nums[p2] = nums[p2], nums[curr]\n        #         p2 -= 1\n        #     else:\n        #         curr += 1\n        \n        # 3. 1-pass solution\n        p0, p2 = 0, len(nums) - 1\n        curr = 0\n        while curr <= p2:\n            if nums[curr] == 0:\n                nums[p0], nums[curr] = nums[curr], nums[p0]\n                p0 += 1\n                curr += 1\n            elif nums[curr] == 2:\n                nums[curr], nums[p2] = nums"}], "max-consecutive-ones": [{"task_id": "max-consecutive-ones", "completion": "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. Initialize variables\n        max_count = 0\n        count = 0\n        \n        # 2. Iterate through the array\n        for num in nums:\n            # 3. If the current element is 1, increment the count\n            if num == 1:\n                count += 1\n            # 4. If the current element is 0, update the max_count if necessary\n            else:\n                max_count = max(max_count, count)\n                count = 0\n        \n        # 5. Return the maximum count\n        return max(max_count, count)"}, {"task_id": "max-consecutive-ones", "completion": "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # Time: O(n)\n        # Space: O(1)\n        # Runtime: 164 ms, faster than 99.86% of Python online submissions for Max Consecutive Ones.\n        # Memory Usage: 13.5 MB, less than 99.99% of Python online submissions for Max Consecutive Ones.\n        # 2 pointers\n        # 1. \n        # Time: O(n)\n        # Space: O(1)\n        # Runtime: 164 ms, faster than 99.86% of Python online submissions for Max Consecutive Ones.\n        # Memory Usage: 13.5 MB, less than 99.99% of Python online submissions for Max Consecutive Ones.\n        # 2 pointers\n        # 2. \n        # Time: O(n)\n        # Space: O(1)\n        # Runtime: 164 ms, faster than 99.86% of Python online submissions for Max Consecutive Ones.\n        # Memory Usage: 13.5 MB, less than 99.99% of Python online submissions for Max Consecutive Ones.\n        # 2 pointers\n        # 3. \n        # Time: O(n)\n        # Space: O(1)\n        # Runtime: 164 ms, faster than 99.86% of Python online submissions for Max Consecutive Ones.\n        # Memory Usage: 13.5 MB, less than 99.99% of Python online submissions for Max Consecutive Ones.\n        # 2 pointers\n        # 4. \n        # Time: O(n)\n        # Space: O(1)\n        # Runtime: 164 ms, faster than 99.86% of Python online submissions for Max Consecutive Ones.\n        # Memory Usage: 13.5 MB, less than 99.99% of Python online submissions for Max Consecutive Ones.\n        # 2 pointers\n        # 5. \n        # Time: O(n)\n        # Space: O(1)\n        # Runtime: 164 ms, faster than 99.86% of Python online submissions for Max Consecutive Ones.\n        # Memory Usage: 13.5 MB, less than 99.99% of Python online submissions for Max Consecutive Ones.\n        # 2 pointers\n        # 6. \n        # Time: O(n)\n        # Space: O(1)\n        # Runtime: 164 ms, faster than 99.86% of Python online submissions for Max Consecutive Ones.\n        # Memory Usage: 13.5 MB, less than 99.99% of Python online submissions for Max Consecutive Ones.\n        # 2 pointers\n        # 7. \n        # Time: O(n)\n        # Space: O(1)\n        # Runtime: 164 ms, faster than 99.86% of Python online submissions for Max Consecutive Ones.\n        # Memory Usage: 13.5 MB, less than 99.99% of Python online submissions for Max Consecutive Ones.\n        # 2 pointers\n        # 8. \n        # Time: O(n)\n        # Space: O(1)\n        # Runtime: 164 ms, faster than 99.86% of Python online submissions for Max Consecutive Ones.\n        # Memory Usage: 13.5 MB, less than 99.99% of Python online submissions for Max Consecutive Ones.\n        # 2 pointers\n        # 9. \n        # Time: O(n)\n        # Space: O(1)\n        # Runtime: 164 ms, faster than 99.86% of Python online submissions for Max Consecutive Ones.\n        # Memory Usage: 13.5 MB, less than 99.99% of Python online submissions for Max Consecutive Ones.\n        # 2 pointers\n        # 1"}, {"task_id": "max-consecutive-ones", "completion": "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. Initialize variables\n        max_count = 0\n        count = 0\n        \n        # 2. Iterate through the array\n        for num in nums:\n            # 3. If the current element is 1, increment the count\n            if num == 1:\n                count += 1\n            # 4. If the current element is 0, reset the count\n            else:\n                count = 0\n            # 5. Update the maximum count if the current count is greater\n            max_count = max(max_count, count)\n        \n        # 6. Return the maximum count\n        return max_count"}, {"task_id": "max-consecutive-ones", "completion": "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. Initialize variables\n        max_count = 0\n        count = 0\n        \n        # 2. Iterate through the array\n        for num in nums:\n            # 3. If the current element is 1, increment the count\n            if num == 1:\n                count += 1\n            # 4. If the current element is 0, update the max_count if necessary\n            else:\n                max_count = max(max_count, count)\n                count = 0\n        \n        # 5. Return the maximum count\n        return max(max_count, count)"}, {"task_id": "max-consecutive-ones", "completion": "class Solution(object):\n    def findMaxConsecutiveOnes(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. Initialize variables\n        max_count = 0\n        count = 0\n        \n        # 2. Iterate through the array\n        for num in nums:\n            # 3. If the current element is 1, increment the count\n            if num == 1:\n                count += 1\n            # 4. If the current element is 0, update the max_count if necessary\n            else:\n                max_count = max(max_count, count)\n                count = 0\n        \n        # 5. Return the maximum count\n        return max(max_count, count)"}], "count-complete-tree-nodes": [{"task_id": "count-complete-tree-nodes", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def get_depth(node):\n            if not node:\n                return 0\n            return 1 + get_depth(node.left)\n        \n        def get_nodes(node):\n            if not node:\n                return 0\n            left_depth = get_depth(node.left)\n            right_depth = get_depth(node.right)\n            if left_depth == right_depth:\n                return 2 ** left_depth + get_nodes(node.right)\n            else:\n                return 2 ** right_depth + get_nodes(node.left)\n        \n        return get_nodes(root)"}, {"task_id": "count-complete-tree-nodes", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def get_depth(node):\n            if not node:\n                return 0\n            return 1 + get_depth(node.left)\n        \n        def get_nodes(node):\n            if not node:\n                return 0\n            left_depth = get_depth(node.left)\n            right_depth = get_depth(node.right)\n            if left_depth == right_depth:\n                return 2 ** left_depth + get_nodes(node.right)\n            else:\n                return 2 ** right_depth + get_nodes(node.left)\n        \n        return get_nodes(root)"}, {"task_id": "count-complete-tree-nodes", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # if not root:\n        #     return 0\n        # return 1 + self.countNodes(root.left) + self.countNodes(root.right)\n        \n        # 2.\n        # if not root:\n        #     return 0\n        # return 1 + self.countNodes(root.left) + self.countNodes(root.right)\n        \n        # 3.\n        # if not root:\n        #     return 0\n        # return 1 + self.countNodes(root.left) + self.countNodes(root.right)\n        \n        # 4.\n        # if not root:\n        #     return 0\n        # return 1 + self.countNodes(root.left) + self.countNodes(root.right)\n        \n        # 5.\n        # if not root:\n        #     return 0\n        # return 1 + self.countNodes(root.left) + self.countNodes(root.right)\n        \n        # 6.\n        # if not root:\n        #     return 0\n        # return 1 + self.countNodes(root.left) + self.countNodes(root.right)\n        \n        # 7.\n        # if not root:\n        #     return 0\n        # return 1 + self.countNodes(root.left) + self.countNodes(root.right)\n        \n        # 8.\n        # if not root:\n        #     return 0\n        # return 1 + self.countNodes(root.left) + self.countNodes(root.right)\n        \n        # 9.\n        # if not root:\n        #     return 0\n        # return 1 + self.countNodes(root.left) + self.countNodes(root.right)\n        \n        # 10.\n        # if not root:\n        #     return 0\n        # return 1 + self.countNodes(root.left) + self.countNodes(root.right)\n        \n        # 11.\n        # if not root:\n        #     return 0\n        # return 1 + self.countNodes(root.left) + self.countNodes(root.right)\n        \n        # 12.\n        # if not root:\n        #     return 0\n        # return 1 + self.countNodes(root.left) + self.countNodes(root.right)\n        \n        # 13.\n        # if not root:\n        #     return 0\n        # return 1 + self.countNodes(root.left) + self.countNodes(root.right)\n        \n        # 14.\n        # if not root:\n        #     return 0\n        # return 1 + self.countNodes(root.left) + self.countNodes(root.right)\n        \n        # 15.\n        # if not root:\n        #     return 0\n        # return 1 + self.countNodes(root.left) + self.countNodes(root.right)\n        \n        # 16.\n        # if not root:\n        #     return 0\n        # return 1 + self.countNodes(root.left) + self.countNodes(root.right)\n        \n        # 17.\n        # if not root:\n        #     return 0\n        # return 1 + self.countNodes(root.left) + self.countNodes(root.right)\n        \n        # 18.\n        # if not root:\n        #     return 0\n        # return 1 + self.countNodes(root.left) + self.countNodes(root.right)\n        \n        # 19.\n        # if not root:\n        #     return 0\n        # return 1 + self.countNodes(root.left) + self.countNodes(root.right)\n        \n        # 20.\n        # if not root:\n        #     return 0\n        # return 1 + self.countNodes(root.left) + self.countNodes(root.right)\n        \n        # 21.\n        # if not root:\n        #     return 0\n        # return 1 + self.countNodes(root.left) + self.countNodes(root.right)\n        \n        #"}, {"task_id": "count-complete-tree-nodes", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def get_depth(node):\n            if not node:\n                return 0\n            return 1 + get_depth(node.left)\n        \n        def get_nodes(node):\n            if not node:\n                return 0\n            left_depth = get_depth(node.left)\n            right_depth = get_depth(node.right)\n            if left_depth == right_depth:\n                return 2 ** left_depth + get_nodes(node.right)\n            else:\n                return 2 ** right_depth + get_nodes(node.left)\n        \n        return get_nodes(root)"}, {"task_id": "count-complete-tree-nodes", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def countNodes(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        # base case\n        if root is None:\n            return 0\n        \n        # recursive case\n        return 1 + self.countNodes(root.left) + self.countNodes(root.right)"}], "add-strings": [{"task_id": "add-strings", "completion": "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        # convert to int\n        num1 = int(num1)\n        num2 = int(num2)\n        \n        # add\n        sum = num1 + num2\n        \n        # convert to string\n        sum = str(sum)\n        \n        return sum"}, {"task_id": "add-strings", "completion": "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        # convert to int\n        num1 = int(num1)\n        num2 = int(num2)\n        \n        # add\n        sum = num1 + num2\n        \n        # convert to string\n        sum = str(sum)\n        \n        return sum"}, {"task_id": "add-strings", "completion": "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        # convert to int\n        num1 = int(num1)\n        num2 = int(num2)\n        \n        # add\n        sum = num1 + num2\n        \n        # convert to string\n        sum = str(sum)\n        \n        return sum"}, {"task_id": "add-strings", "completion": "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        # convert to int\n        num1 = int(num1)\n        num2 = int(num2)\n        \n        # add\n        sum = num1 + num2\n        \n        # convert to string\n        sum = str(sum)\n        \n        return sum"}, {"task_id": "add-strings", "completion": "class Solution(object):\n    def addStrings(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        # convert to int\n        num1 = int(num1)\n        num2 = int(num2)\n        \n        # add\n        sum = num1 + num2\n        \n        # convert to string\n        sum = str(sum)\n        \n        return sum"}], "basic-calculator": [{"task_id": "basic-calculator", "completion": "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        num = 0\n        sign = 1\n        res = 0\n        \n        for c in s:\n            if c.isdigit():\n                num = num * 10 + int(c)\n            elif c == '+':\n                res += sign * num\n                num = 0\n                sign = 1\n            elif c == '-':\n                res += sign * num\n                num = 0\n                sign = -1\n            elif c == '(':\n                stack.append(res)\n                stack.append(sign)\n                sign = 1\n                res = 0\n            elif c == ')':\n                res += sign * num\n                num = 0\n                res *= stack.pop()\n                res += stack.pop()\n        \n        return res + sign * num"}, {"task_id": "basic-calculator", "completion": "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u53bb\u9664\u7a7a\u683c\n        s = s.replace(\" \", \"\")\n        \n        # 2. \u53bb\u9664\u62ec\u53f7\n        while \"(\" in s:\n            s = self.remove_brackets(s)\n        \n        # 3. \u53bb\u9664\u4e58\u9664\n        while \"*\" in s or \"/\" in s:\n            s = self.remove_multiply_divide(s)\n        \n        # 4. \u53bb\u9664\u52a0\u51cf\n        return self.remove_add_subtract(s)\n    \n    def remove_brackets(self, s):\n        # \u53bb\u9664\u62ec\u53f7\n        # 1. \u627e\u5230\u7b2c\u4e00\u4e2a\u5de6\u62ec\u53f7\n        left_bracket = s.find(\"(\")\n        # 2. \u627e\u5230\u7b2c\u4e00\u4e2a\u53f3\u62ec\u53f7\n        right_bracket = s.find(\")\")\n        # 3. \u8ba1\u7b97\u62ec\u53f7\u5185\u7684\u503c\n        value = self.remove_add_subtract(s[left_bracket + 1:right_bracket])\n        # 4. \u66ff\u6362\u62ec\u53f7\u5185\u7684\u503c\n        s = s[:left_bracket] + str(value) + s[right_bracket + 1:]\n        return s\n    \n    def remove_multiply_divide(self, s):\n        # \u53bb\u9664\u4e58\u9664\n        # 1. \u627e\u5230\u7b2c\u4e00\u4e2a\u4e58\u9664\n        multiply = s.find(\"*\")\n        divide = s.find(\"/\")\n        # 2. \u627e\u5230\u7b2c\u4e00\u4e2a\u4e58\u9664\n        if multiply == -1:\n            multiply = len(s)\n        if divide == -1:\n            divide = len(s)\n        # 3. \u627e\u5230\u7b2c\u4e00\u4e2a\u4e58\u9664\n        if multiply < divide:\n            # 4. \u8ba1\u7b97\u4e58\u9664\n            value = int(s[:multiply]) * int(s[multiply + 1:divide])\n            # 5. \u66ff\u6362\u4e58\u9664\n            s = s[:multiply] + str(value) + s[divide + 1:]\n        else:\n            # 4. \u8ba1\u7b97\u4e58\u9664\n            value = int(s[:divide]) / int(s[divide + 1:multiply])\n            # 5. \u66ff\u6362\u4e58\u9664\n            s = s[:divide] + str(value) + s[multiply + 1:]\n        return s\n    \n    def remove_add_subtract(self, s):\n        # \u53bb\u9664\u52a0\u51cf\n        # 1. \u627e\u5230\u7b2c\u4e00\u4e2a\u52a0\u51cf\n        add = s.find(\"+\")\n        subtract = s.find(\"-\")\n        # 2. \u627e\u5230\u7b2c\u4e00\u4e2a\u52a0\u51cf\n        if add == -1:\n            add = len(s)\n        if subtract == -1:\n            subtract = len(s)\n        # 3. \u627e\u5230\u7b2c\u4e00\u4e2a\u52a0\u51cf\n        if add < subtract:\n            # 4. \u8ba1\u7b97\u52a0\u51cf\n            value = int(s[:add]) + int(s[add + 1:subtract])\n            # 5. \u66ff\u6362\u52a0\u51cf\n            s = s[:add] + str(value) + s[subtract + 1:]\n        else:\n            # 4. \u8ba1\u7b97\u52a0\u51cf\n            value = int(s[:subtract]) - int(s[subtract + 1:add])\n            # 5. \u66ff\u6362\u52a0\u51cf\n            s = s[:subtract] + str(value) + s[add + 1:]\n        return s"}, {"task_id": "basic-calculator", "completion": "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc22b\uc790\ub97c \uc2a4\ud0dd\uc5d0 \uc800\uc7a5\ud558\uba74\uc11c \uc5f0\uc0b0\uc790\ub97c \ub9cc\ub098\uba74 \uc2a4\ud0dd\uc5d0 \uc788\ufffd \uc22b\uc790\ub97c \uc5f0\uc0b0\ud558\uace0 \uc2a4\ud0dd\uc5d0 \uc800\uc7a5\ud55c\ub2e4.\n        # 2. \uc5f0\uc0b0\uc790\ub97c \ub9cc\ub098\uba74 \uc2a4\ud0dd\uc5d0 \uc788\ufffd> \uc22b\uc790\ub97c \uc5f0\uc0b0\ud558\uace0 \uc2a4\ud0dd\uc5d0 \uc800\uc7a5\ud55c\ub2e4.\n        # 3. \uc5f0\uc0b0\uc790\ub97c \ub9cc\ub098\uba74 \uc2a4\ud0dd\uc5d0 \uc788\ufffd> \uc22b\uc790\ub97c \uc5f0\uc0b0\ud558\uace0 \uc2a4\ud0dd\uc5d0 \uc800\uc7a5\ud55c\ub2e4.\n        # 4. \uc5f0\uc0b0\uc790\ub97c \ub9cc\ub098\uba74 \uc2a4\ud0dd\uc5d0 \uc788\ufffd> \uc22b\uc790\ub97c \uc5f0\uc0b0\ud558\uace0 \uc2a4\ud0dd\uc5d0 \uc800\uc7a5\ud55c\ub2e4.\n        # 5. \uc5f0\uc0b0\uc790\ub97c \ub9cc\ub098\uba74 \uc2a4\ud0dd\uc5d0 \uc788\ufffd> \uc22b\uc790\ub97c \uc5f0\uc0b0\ud558\uace0 \uc2a4\ud0dd\uc5d0 \uc800\uc7a5\ud55c\ub2e4.\n        # 6. \uc5f0\uc0b0\uc790\ub97c \ub9cc\ub098\uba74 \uc2a4\ud0dd\uc5d0 \uc788\ufffd> \uc22b\uc790\ub97c \uc5f0\uc0b0\ud558\uace0 \uc2a4\ud0dd\uc5d0 \uc800\uc7a5\ud55c\ub2e4.\n        # 7. \uc5f0\uc0b0\uc790\ub97c \ub9cc\ub098\uba74 \uc2a4\ud0dd\uc5d0 \uc788\ufffd> \uc22b\uc790\ub97c \uc5f0\uc0b0\ud558\uace0 \uc2a4\ud0dd\uc5d0 \uc800\uc7a5\ud55c\ub2e4.\n        # 8. \uc5f0\uc0b0\uc790\ub97c \ub9cc\ub098\uba74 \uc2a4\ud0dd\uc5d0 \uc788\ufffd> \uc22b\uc790\ub97c \uc5f0\uc0b0\ud558\uace0 \uc2a4\ud0dd\uc5d0 \uc800\uc7a5\ud55c\ub2e4.\n        # 9. \uc5f0\uc0b0\uc790\ub97c \ub9cc\ub098\uba74 \uc2a4\ud0dd\uc5d0 \uc788\ufffd> \uc22b\uc790\ub97c \uc5f0\uc0b0\ud558\uace0 \uc2a4\ud0dd\uc5d0 \uc800\uc7a5\ud55c\ub2e4.\n        # 10. \uc5f0\uc0b0\uc790\ub97c \ub9cc\ub098\uba74 \uc2a4\ud0dd\uc5d0 \uc788\ufffd> \uc22b\uc790\ub97c \uc5f0\uc0b0\ud558\uace0 \uc2a4\ud0dd\uc5d0 \uc800\uc7a5\ud55c\ub2e4.\n        # 11. \uc5f0\uc0b0\uc790\ub97c \ub9cc\ub098\uba74 \uc2a4\ud0dd\uc5d0 \uc788\ufffd> \uc22b\uc790\ub97c"}, {"task_id": "basic-calculator", "completion": "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        num = 0\n        sign = 1\n        res = 0\n        \n        for c in s:\n            if c.isdigit():\n                num = num * 10 + int(c)\n            elif c == '+':\n                res += sign * num\n                num = 0\n                sign = 1\n            elif c == '-':\n                res += sign * num\n                num = 0\n                sign = -1\n            elif c == '(':\n                stack.append(res)\n                stack.append(sign)\n                res = 0\n                sign = 1\n            elif c == ')':\n                res += sign * num\n                num = 0\n                res *= stack.pop()\n                res += stack.pop()\n        \n        return res + sign * num"}, {"task_id": "basic-calculator", "completion": "class Solution(object):\n    def calculate(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u53bb\u9664\u7a7a\u683c\n        s = s.replace(\" \", \"\")\n        \n        # 2. \u53bb\u9664\u62ec\u53f7\n        while \"(\" in s:\n            s = self.remove_brackets(s)\n        \n        # 3. \u53bb\u9664\u4e58\u9664\n        while \"*\" in s or \"/\" in s:\n            s = self.remove_multiply_divide(s)\n        \n        # 4. \u53bb\u9664\u52a0\u51cf\n        return self.remove_add_subtract(s)\n    \n    def remove_brackets(self, s):\n        # \u53bb\u9664\u62ec\u53f7\n        # 1. \u627e\u5230\u7b2c\u4e00\u4e2a\u5de6\u62ec\u53f7\n        left_bracket = s.find(\"(\")\n        # 2. \u627e\u5230\u7b2c\u4e00\u4e2a\u53f3\u62ec\u53f7\n        right_bracket = s.find(\")\")\n        # 3. \u8ba1\u7b97\u62ec\u53f7\u5185\u7684\u503c\n        value = self.remove_add_subtract(s[left_bracket + 1:right_bracket])\n        # 4. \u66ff\u6362\u62ec\u53f7\u5185\u7684\u503c\n        s = s[:left_bracket] + str(value) + s[right_bracket + 1:]\n        return s\n    \n    def remove_multiply_divide(self, s):\n        # \u53bb\u9664\u4e58\u9664\n        # 1. \u627e\u5230\u7b2c\u4e00\u4e2a\u4e58\u9664\n        multiply_divide = s.find(\"*\")\n        if multiply_divide == -1:\n            multiply_divide = s.find(\"/\")\n        # 2. \u8ba1\u7b97\u4e58\u9664\n        value = eval(s[multiply_divide - 1:multiply_divide + 2])\n        # 3. \u66ff\u6362\u4e58\u9664\n        s = s[:multiply_divide - 1] + str(value) + s[multiply_divide + 2:]\n        return s\n    \n    def remove_add_subtract(self, s):\n        # \u53bb\u9664\u52a0\u51cf\n        # 1. \u627e\u5230\u7b2c\u4e00\u4e2a\u52a0\u51cf\n        add_subtract = s.find(\"+\")\n        if add_subtract == -1:\n            add_subtract = s.find(\"-\")\n        # 2. \u8ba1\u7b97\u52a0\u51cf\n        value = eval(s[add_subtract - 1:add_subtract + 2])\n        # 3. \u66ff\u6362\u52a0\u51cf\n        s = s[:add_subtract - 1] + str(value) + s[add_subtract + 2:]\n        return s\n    \n    def remove_multiply_divide(self, s):\n        # \u53bb\u9664\u4e58\u9664\n        # 1. \u627e\u5230\u7b2c\u4e00\u4e2a\u4e58\u9664\n        multiply_divide = s.find(\"*\")\n        if multiply_divide == -1:\n            multiply_divide = s.find(\"/\")\n        # 2. \u8ba1\u7b97\u4e58\u9664\n        value = eval(s[multiply"}], "ipo": [{"task_id": "ipo", "completion": "class Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u5148\u628a\u9879\u76ee\u6309\u7167\u6240\u9700\u8d44\u91d1\u4ece\u5c0f\u5230\u5927\u6392\u5e8f\n        # 2. \u4ece\u8d44\u91d1\u6700\u5c0f\u7684\u9879\u76ee\u5f00\u59cb\uff0c\u4f9d\u6b21\u5c1d\u8bd5\u6295\u8d44\n        # 3. \u5982\u679c\u8d44\u91d1\u4e0d\u591f\uff0c\u5219\u8df3\u8fc7\u8be5\u9879\u76ee\uff0c\u5c1d\u8bd5\u4e0b\u4e00\u4e2a\u9879\u76ee\n        # 4. \u5982\u679c\u8d44\u91d1\u591f\u4e86\uff0c\u5219\u6295\u8d44\u8be5\u9879\u76ee\uff0c\u5e76\u5c1d\u8bd5\u6295\u8d44\u4e0b\u4e00\u4e2a\u9879\u76ee\n        # 5. \u5982\u679c\u6ca1\u6709\u9879\u76ee\u53ef\u6295\u8d44\uff0c\u5219\u8df3\u51fa\u5faa\u73af\n        # 6. \u5982\u679c\u6295\u8d44\u4e86k\u4e2a\u9879\u76ee\uff0c\u5219\u8df3\u51fa\u5faa\u73af\n        # 7. \u8fd4\u56de\u6700\u7ec8\u7684\u8d44\u91d1\n        \n        # 1. \u5148\u628a\u9879\u76ee\u6309\u7167\u6240\u9700\u8d44\u91d1\u4ece\u5c0f\u5230\u5927\u6392\u5e8f\n        projects = sorted(zip(profits, capital), key=lambda x: x[1])\n        \n        # 2. \u4ece\u8d44\u91d1\u6700\u5c0f\u7684\u9879\u76ee\u5f00\u59cb\uff0c\u4f9d\u6b21\u5c1d\u8bd5\u6295\u8d44\n        i = 0\n        heap = []\n        while k > 0:\n            # 3. \u5982\u679c\u8d44\u91d1\u4e0d\u591f\uff0c\u5219\u8df3\u8fc7\u8be5\u9879\u76ee\uff0c\u5c1d\u8bd5\u4e0b\u4e00\u4e2a\u9879\u76ee\n            while i < len(projects) and projects[i][1] <= w:\n                heapq.heappush(heap, -projects[i][0])\n                i += 1\n            # 4. \u5982\u679c\u8d44\u91d1\u591f\u4e86\uff0c\u5219\u6295\u8d44\u8be5\u9879\u76ee\uff0c\u5e76\u5c1d\u8bd5\u6295\u8d44\u4e0b\u4e00\u4e2a\u9879\u76ee\n            if heap:\n                w -= heapq.heappop(heap)\n                k -= 1\n            else:\n                break\n        # 5. \u5982\u679c\u6ca1\u6709\u9879\u76ee\u53ef\u6295\u8d44\uff0c\u5219\u8df3\u51fa\u5faa\u73af\n        # 6. \u5982\u679c\u6295\u8d44\u4e86k\u4e2a\u9879\u76ee\uff0c\u5219\u8df3\u51fa\u5faa\u73af\n        # 7. \u8fd4\u56de\u6700\u7ec8\u7684\u8d44\u91d1\n        return w"}, {"task_id": "ipo", "completion": "class Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u5148\u628a\u9879\u76ee\u6309\u7167\u6240\u9700\u8d44\u91d1\u4ece\u5c0f\u5230\u5927\u6392\u5e8f\n        # 2. \u4ece\u8d44\u91d1\u6700\u5c0f\u7684\u9879\u76ee\u5f00\u59cb\uff0c\u4f9d\u6b21\u5c1d\u8bd5\u6295\u8d44\n        # 3. \u5982\u679c\u8d44\u91d1\u4e0d\u591f\uff0c\u5219\u8df3\u8fc7\u8be5\u9879\u76ee\n        # 4. \u5982\u679c\u8d44\u91d1\u591f\uff0c\u5219\u6295\u8d44\u8be5\u9879\u76ee\uff0c\u5e76\u5c06\u5176\u4ece\u9879\u76ee\u5217\u8868\u4e2d\u79fb\u9664\n        # 5. \u91cd\u590d\u6b65\u9aa42-4\uff0c\u76f4\u5230\u6295\u8d44\u4e86k\u4e2a\u9879\u76ee\u6216\u8005\u6ca1\u6709\u9879\u76ee\u53ef\u6295\u8d44\n        # 6. \u8fd4\u56de\u6700\u7ec8\u7684\u8d44\u91d1\n        \n        # 1. \u5148\u628a\u9879\u76ee\u6309\u7167\u6240\u9700\u8d44\u91d1\u4ece\u5c0f\u5230\u5927\u6392\u5e8f\n        projects = sorted(zip(profits, capital), key=lambda x: x[1])\n        \n        # 2. \u4ece\u8d44\u91d1\u6700\u5c0f\u7684\u9879\u76ee\u5f00\u59cb\uff0c\u4f9d\u6b21\u5c1d\u8bd5\u6295\u8d44\n        i = 0\n        while k > 0:\n            # 3. \u5982\u679c\u8d44\u91d1\u4e0d\u591f\uff0c\u5219\u8df3\u8fc7\u8be5\u9879\u76ee\n            if w < projects[i][1]:\n                i += 1\n                continue\n            # 4. \u5982\u679c\u8d44\u91d1\u591f\uff0c\u5219\u6295\u8d44\u8be5\u9879\u76ee\uff0c\u5e76\u5c06\u5176\u4ece\u9879\u76ee\u5217\u8868\u4e2d\u79fb\u9664\n            w += projects[i][0]\n            k -= 1\n            i += 1\n            if i == len(projects):\n                break\n        # 5. \u91cd\u590d\u6b65\u9aa42-4\uff0c\u76f4\u5230\u6295\u8d44\u4e86k\u4e2a\u9879\u76ee\u6216\u8005\u6ca1\u6709\u9879\u76ee\u53ef\u6295\u8d44\n        # 6. \u8fd4\u56de\u6700\u7ec8\u7684\u8d44\u91d1\n        return w"}, {"task_id": "ipo", "completion": "class Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u5148\u628a\u9879\u76ee\u6309\u7167\u6240\u9700\u8d44\u91d1\u4ece\u5c0f\u5230\u5927\u6392\u5e8f\n        # 2. \u4ece\u8d44\u91d1\u6700\u5c0f\u7684\u9879\u76ee\u5f00\u59cb\uff0c\u4f9d\u6b21\u5c1d\u8bd5\u6295\u8d44\n        # 3. \u5982\u679c\u8d44\u91d1\u4e0d\u591f\uff0c\u5219\u8df3\u8fc7\u8be5\u9879\u76ee\n        # 4. \u5982\u679c\u8d44\u91d1\u591f\u4e86\uff0c\u5219\u6295\u8d44\u8be5\u9879\u76ee\uff0c\u5e76\u5c06\u5176\u4ece\u9879\u76ee\u5217\u8868\u4e2d\u79fb\u9664\n        # 5. \u91cd\u590d\u6b65\u9aa42-4\uff0c\u76f4\u5230\u6295\u8d44\u4e86k\u4e2a\u9879\u76ee\u6216\u8005\u6ca1\u6709\u9879\u76ee\u53ef\u6295\u8d44\n        # 6. \u8fd4\u56de\u6700\u7ec8\u7684\u8d44\u91d1\n        \n        # 1. \u5148\u628a\u9879\u76ee\u6309\u7167\u6240\u9700\u8d44\u91d1\u4ece\u5c0f\u5230\u5927\u6392\u5e8f\n        projects = sorted(zip(profits, capital), key=lambda x: x[1])\n        \n        # 2. \u4ece\u8d44\u91d1\u6700\u5c0f\u7684\u9879\u76ee\u5f00\u59cb\uff0c\u4f9d\u6b21\u5c1d\u8bd5\u6295\u8d44\n        i = 0\n        while k > 0:\n            # 3. \u5982\u679c\u8d44\u91d1\u4e0d\u591f\uff0c\u5219\u8df3\u8fc7\u8be5\u9879\u76ee\n            if w < projects[i][1]:\n                i += 1\n                continue\n            # 4. \u5982\u679c\u8d44\u91d1\u591f\u4e86\uff0c\u5219\u6295\u8d44\u8be5\u9879\u76ee\uff0c\u5e76\u5c06\u5176\u4ece\u9879\u76ee\u5217\u8868\u4e2d\u79fb\u9664\n            w += projects[i][0]\n            k -= 1\n            i += 1\n            if i == len(projects):\n                break\n        # 5. \u91cd\u590d\u6b65\u9aa42-4\uff0c\u76f4\u5230\u6295\u8d44\u4e86k\u4e2a\u9879\u76ee\u6216\u8005\u6ca1\u6709\u9879\u76ee\u53ef\u6295\u8d44\n        # 6. \u8fd4\u56de\u6700\u7ec8\u7684\u8d44\u91d1\n        return w"}, {"task_id": "ipo", "completion": "class Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u5148\u628a\u9879\u76ee\u6309\u7167\u6240\u9700\u8d44\u91d1\u4ece\u5c0f\u5230\u5927\u6392\u5e8f\n        # 2. \u4ece\u8d44\u91d1\u6700\u5c0f\u7684\u9879\u76ee\u5f00\u59cb\uff0c\u5982\u679c\u8d44\u91d1\u4e0d\u591f\uff0c\u5c31\u628a\u8d44\u91d1\u6700\u5c0f\u7684\u9879\u76ee\u52a0\u5165\u5230\u4f18\u5148\u961f\u5217\u4e2d\uff0c\u7136\u540e\u4ece\u4f18\u5148\u961f\u5217\u4e2d\u53d6\u51fa\u6700\u5927\u7684\u9879\u76ee\n        # 3. \u5982\u679c\u8d44\u91d1\u591f\u4e86\uff0c\u5c31\u76f4\u63a5\u628a\u6700\u5927\u7684\u9879\u76ee\u52a0\u5165\u5230\u8d44\u91d1\u4e2d\n        # 4. \u91cd\u590d2\u548c3\uff0c\u76f4\u5230\u4f18\u5148\u961f\u5217\u4e3a\u7a7a\u6216\u8005\u9879\u76ee\u6570\u91cf\u4e0d\u591f\n        \n        # 1. \u5148\u628a\u9879\u76ee\u6309\u7167\u6240\u9700\u8d44\u91d1\u4ece\u5c0f\u5230\u5927\u6392\u5e8f\n        projects = sorted(zip(profits, capital), key=lambda x: x[1])\n        \n        # 2. \u4ece\u8d44\u91d1\u6700\u5c0f\u7684\u9879\u76ee\u5f00\u59cb\uff0c\u5982\u679c\u8d44\u91d1\u4e0d\u591f\uff0c\u5c31\u628a\u8d44\u91d1\u6700\u5c0f\u7684\u9879\u76ee\u52a0\u5165\u5230\u4f18\u5148\u961f\u5217\u4e2d\uff0c\u7136\u540e\u4ece\u4f18\u5148\u961f\u5217\u4e2d\u53d6\u51fa\u6700\u5927\u7684\u9879\u76ee\n        # 3. \u5982\u679c\u8d44\u91d1\u591f\u4e86\uff0c\u5c31\u76f4\u63a5\u628a\u6700\u5927\u7684\u9879\u76ee\u52a0\u5165\u5230\u8d44\u91d1\u4e2d\n        # 4. \u91cd\u590d2\u548c3\uff0c\u76f4\u5230\u4f18\u5148\u961f\u5217\u4e3a\u7a7a\u6216\u8005\u9879\u76ee\u6570\u91cf\u4e0d\u591f\n        heap = []\n        i = 0\n        while k > 0:\n            while i < len(projects) and projects[i][1] <= w:\n                heapq.heappush(heap, -projects[i][0])\n                i += 1\n            if not heap:\n                break\n            w -= heapq.heappop(heap)\n            k -= 1\n        return w"}, {"task_id": "ipo", "completion": "class Solution(object):\n    def findMaximizedCapital(self, k, w, profits, capital):\n        \"\"\"\n        :type k: int\n        :type w: int\n        :type profits: List[int]\n        :type capital: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u5148\u628a\u9879\u76ee\u6309\u7167\u6240\u9700\u8d44\u91d1\u4ece\u5c0f\u5230\u5927\u6392\u5e8f\n        # 2. \u4ece\u8d44\u91d1\u6700\u5c0f\u7684\u9879\u76ee\u5f00\u59cb\uff0c\u9009\u62e9\u5229\u6da6\u6700\u5927\u7684\u9879\u76ee\n        # 3. \u91cd\u590d2\uff0c\u76f4\u5230\u9009\u62e9\u4e86k\u4e2a\u9879\u76ee\n        # 4. \u5982\u679c\u6ca1\u6709\u9009\u62e9\u5230k\u4e2a\u9879\u76ee\uff0c\u5219\u8fd4\u56de\u5f53\u524d\u8d44\u91d1\n        \n        # 1. \u5148\u628a\u9879\u76ee\u6309\u7167\u6240\u9700\u8d44\u91d1\u4ece\u5c0f\u5230\u5927\u6392\u5e8f\n        # 2. \u4ece\u8d44\u91d1\u6700\u5c0f\u7684\u9879\u76ee\u5f00\u59cb\uff0c\u9009\u62e9\u5229\u6da6\u6700\u5927\u7684\u9879\u76ee\n        # 3. \u91cd\u590d2\uff0c\u76f4\u5230\u9009\u62e9\u4e86k\u4e2a\u9879\u76ee\n        # 4. \u5982\u679c\u6ca1\u6709\u9009\u62e9\u5230k\u4e2a\u9879\u76ee\uff0c\u5219\u8fd4\u56de\u5f53\u524d\u8d44\u91d1\n        \n        # 1. \u5148\u628a\u9879\u76ee\u6309\u7167\u6240\u9700\u8d44\u91d1\u4ece\u5c0f\u5230\u5927\u6392\u5e8f\n        # 2. \u4ece\u8d44\u91d1\u6700\u5c0f\u7684\u9879\u76ee\u5f00\u59cb\uff0c\u9009\u62e9\u5229\u6da6\u6700\u5927\u7684\u9879\u76ee\n        # 3. \u91cd\u590d2\uff0c\u76f4\u5230\u9009\u62e9\u4e86k\u4e2a\u9879\u76ee\n        # 4. \u5982\u679c\u6ca1\u6709\u9009\u62e9\u5230k\u4e2a\u9879\u76ee\uff0c\u5219\u8fd4\u56de\u5f53\u524d\u8d44\u91d1\n        \n        # 1. \u5148\u628a\u9879\u76ee\u6309\u7167\u6240\u9700\u8d44\u91d1\u4ece\u5c0f\u5230\u5927\u6392\u5e8f\n        # 2. \u4ece\u8d44\u91d1\u6700\u5c0f\u7684\u9879\u76ee\u5f00\u59cb\uff0c\u9009\u62e9\u5229\u6da6\u6700\u5927\u7684\u9879\u76ee\n        # 3. \u91cd\u590d2\uff0c\u76f4\u5230\u9009\u62e9\u4e86k\u4e2a\u9879\u76ee\n        # 4. \u5982\u679c\u6ca1\u6709\u9009\u62e9\u5230k\u4e2a\u9879\u76ee\uff0c\u5219\u8fd4\u56de\u5f53\u524d\u8d44\u91d1\n        \n        # 1. \u5148\u628a\u9879\u76ee\u6309\u7167\u6240\u9700\u8d44\u91d1\u4ece\u5c0f\u5230\u5927\u6392\u5e8f\n        # 2. \u4ece\u8d44\u91d1\u6700\u5c0f\u7684\u9879\u76ee\u5f00\u59cb\uff0c\u9009\u62e9\u5229\u6da6\u6700\u5927\u7684\u9879\u76ee\n        # 3. \u91cd\u590d2\uff0c\u76f4\u5230\u9009\u62e9\u4e86k\u4e2a\u9879\u76ee\n        # 4. \u5982\u679c\u6ca1\u6709\u9009\u62e9\u5230k\u4e2a\u9879\u76ee\uff0c\u5219\u8fd4\u56de\u5f53\u524d\u8d44\u91d1\n        \n        # 1. \u5148\u628a\u9879\u76ee\u6309\u7167\u6240\u9700\u8d44\u91d1\u4ece\u5c0f\u5230\u5927\u6392\u5e8f\n        # 2. \u4ece\u8d44\u91d1\u6700\u5c0f\u7684\u9879\u76ee\u5f00\u59cb\uff0c\u9009\u62e9\u5229\u6da6\u6700\u5927\u7684\u9879\u76ee\n        # 3. \u91cd\u590d2\uff0c\u76f4\u5230\u9009\u62e9\u4e86k\u4e2a\u9879\u76ee\n        # 4. \u5982\u679c\u6ca1\u6709\u9009\u62e9\u5230k\u4e2a\u9879\u76ee\uff0c\u5219\u8fd4\u56de\u5f53\u524d\u8d44\u91d1\n        \n        # 1. \u5148\u628a\u9879\u76ee\u6309\u7167\u6240\u9700\u8d44\u91d1\u4ece\u5c0f\u5230\u5927\u6392\u5e8f\n        # 2. \u4ece\u8d44\u91d1\u6700\u5c0f\u7684\u9879\u76ee\u5f00\u59cb\uff0c\u9009\u62e9\u5229\u6da6\u6700\u5927\u7684\u9879\u76ee\n        # 3. \u91cd\u590d2\uff0c\u76f4\u5230\u9009\u62e9\u4e86k\u4e2a\u9879\u76ee\n        # 4. \u5982\u679c\u6ca1\u6709\u9009\u62e9\u5230k\u4e2a\u9879\u76ee\uff0c\u5219\u8fd4\u56de\u5f53\u524d\u8d44\u91d1\n        \n        # 1. \u5148\u628a\u9879\u76ee\u6309\u7167\u6240\u9700\u8d44\u91d1\u4ece\u5c0f\u5230\u5927\u6392\u5e8f\n        # 2. \u4ece\u8d44\u91d1\u6700\u5c0f\u7684\u9879\u76ee\u5f00\u59cb\uff0c\u9009\u62e9\u5229\u6da6\u6700\u5927\u7684\u9879\u76ee\n        # 3. \u91cd\u590d2\uff0c\u76f4\u5230\u9009\u62e9\u4e86k\u4e2a\u9879\u76ee\n        # 4. \u5982\u679c\u6ca1\u6709\u9009\u62e9\u5230k\u4e2a\u9879\u76ee\uff0c\u5219\u8fd4\u56de\u5f53\u524d\u8d44\u91d1\n        \n        # 1. \u5148\u628a\u9879\u76ee\u6309\u7167\u6240\u9700\u8d44\u91d1\u4ece\u5c0f\u5230\u5927\u6392\u5e8f\n        # 2. \u4ece\u8d44\u91d1\u6700\u5c0f\u7684\u9879\u76ee\u5f00\u59cb\uff0c\u9009\u62e9\u5229\u6da6\u6700\u5927\u7684\u9879\u76ee\n        # 3. \u91cd\u590d2\uff0c\u76f4\u5230\u9009\u62e9\u4e86k\u4e2a\u9879\u76ee\n        # 4. \u5982\u679c\u6ca1\u6709\u9009\u62e9\u5230k\u4e2a\u9879\u76ee\uff0c\u5219\u8fd4\u56de\u5f53\u524d\u8d44\u91d1\n        \n        # 1. \u5148\u628a\u9879\u76ee\u6309\u7167\u6240\u9700\u8d44\u91d1\u4ece\u5c0f\u5230\u5927\u6392\u5e8f\n        # 2. \u4ece\u8d44\u91d1\u6700\u5c0f\u7684\u9879\u76ee\u5f00\u59cb\uff0c\u9009\u62e9\u5229\u6da6\u6700\u5927\u7684\u9879\u76ee\n        # 3. \u91cd\u590d2\uff0c\u76f4\u5230\u9009\u62e9\u4e86k\u4e2a\u9879\u76ee\n        # 4. \u5982\u679c\u6ca1\u6709\u9009\u62e9\u5230k\u4e2a\u9879\u76ee\uff0c\u5219\u8fd4\u56de\u5f53\u524d\u8d44\u91d1\n        \n        # 1. \u5148\u628a\u9879\u76ee\u6309\u7167\u6240\u9700\u8d44\u91d1\u4ece\u5c0f\u5230\u5927\u6392\u5e8f\n        # 2. \u4ece\u8d44\u91d1\u6700\u5c0f\u7684\u9879\u76ee\u5f00\u59cb\uff0c\u9009\u62e9\u5229\u6da6\u6700\u5927\u7684\u9879\u76ee\n        # 3. \u91cd\u590d2\uff0c\u76f4\u5230\u9009\u62e9\u4e86k\u4e2a\u9879\u76ee\n        # 4. \u5982\u679c\u6ca1\u6709\u9009\u62e9\u5230k\u4e2a\u9879\u76ee\uff0c\u5219\u8fd4\u56de\u5f53\u524d\u8d44\u91d1\n        \n        # 1. \u5148\u628a\u9879\u76ee\u6309\u7167\u6240\u9700\u8d44\u91d1\u4ece\u5c0f\u5230\u5927\u6392\u5e8f\n        # 2. \u4ece\u8d44\u91d1\u6700\u5c0f\u7684\u9879\u76ee\u5f00\u59cb\uff0c\u9009\u62e9\u5229\u6da6\u6700\u5927\u7684\u9879\u76ee\n        # 3. \u91cd\u590d2\uff0c\u76f4\u5230\u9009\u62e9\u4e86k\u4e2a\u9879\u76ee\n        # 4. \u5982\u679c\u6ca1\u6709\u9009\u62e9\u5230k\u4e2a\u9879\u76ee\uff0c\u5219\u8fd4\u56de\u5f53\u524d\u8d44\u91d1\n        \n        # 1. \u5148\u628a\u9879\u76ee\u6309\u7167\u6240\u9700\u8d44\u91d1\u4ece\u5c0f\u5230\u5927\u6392\u5e8f\n        # 2. \u4ece\u8d44\u91d1\u6700\u5c0f\u7684\u9879\u76ee\u5f00\u59cb\uff0c\u9009\u62e9\u5229\u6da6\u6700\u5927\u7684\u9879\u76ee\n        # 3. \u91cd\u590d2\uff0c\u76f4\u5230\u9009\u62e9\u4e86k\u4e2a\u9879\u76ee\n        # 4. \u5982\u679c\u6ca1\u6709\u9009\u62e9\u5230k\u4e2a\u9879\u76ee\uff0c\u5219\u8fd4\u56de\u5f53\u524d\u8d44\u91d1\n        \n        # 1. \u5148\u628a\u9879\u76ee\u6309\u7167\u6240\u9700\u8d44\u91d1\u4ece\u5c0f\u5230\u5927\u6392\u5e8f\n        # 2. \u4ece\u8d44\u91d1\u6700\u5c0f\u7684\u9879\u76ee\u5f00\u59cb\uff0c\u9009\u62e9\u5229\u6da6\u6700\u5927\u7684\u9879\u76ee"}], "valid-parentheses": [{"task_id": "valid-parentheses", "completion": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        stack = []\n        for i in s:\n            if i == '(' or i == '{' or i == '[':\n                stack.append(i)\n            else:\n                if len(stack) == 0:\n                    return False\n                if i == ')' and stack[-1] == '(':\n                    stack.pop()\n                elif i == '}' and stack[-1] == '{':\n                    stack.pop()\n                elif i == ']' and stack[-1] == '[':\n                    stack.pop()\n                else:\n                    return False\n        if len(stack) == 0:\n            return True\n        else:\n            return False"}, {"task_id": "valid-parentheses", "completion": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        stack = []\n        for i in s:\n            if i == '(' or i == '{' or i == '[':\n                stack.append(i)\n            else:\n                if len(stack) == 0:\n                    return False\n                if i == ')' and stack[-1] == '(':\n                    stack.pop()\n                elif i == '}' and stack[-1] == '{':\n                    stack.pop()\n                elif i == ']' and stack[-1] == '[':\n                    stack.pop()\n                else:\n                    return False\n        if len(stack) == 0:\n            return True\n        else:\n            return False"}, {"task_id": "valid-parentheses", "completion": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        stack = []\n        for i in s:\n            if i == '(' or i == '[' or i == '{':\n                stack.append(i)\n            else:\n                if len(stack) == 0:\n                    return False\n                if i == ')' and stack[-1] == '(':\n                    stack.pop()\n                elif i == ']' and stack[-1] == '[':\n                    stack.pop()\n                elif i == '}' and stack[-1] == '{':\n                    stack.pop()\n                else:\n                    return False\n        if len(stack) == 0:\n            return True\n        else:\n            return False"}, {"task_id": "valid-parentheses", "completion": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        stack = []\n        for i in s:\n            if i == '(' or i == '{' or i == '[':\n                stack.append(i)\n            else:\n                if len(stack) == 0:\n                    return False\n                if i == ')' and stack[-1] == '(':\n                    stack.pop()\n                elif i == '}' and stack[-1] == '{':\n                    stack.pop()\n                elif i == ']' and stack[-1] == '[':\n                    stack.pop()\n                else:\n                    return False\n        if len(stack) == 0:\n            return True\n        else:\n            return False"}, {"task_id": "valid-parentheses", "completion": "class Solution(object):\n    def isValid(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        stack = []\n        for i in s:\n            if i == '(' or i == '{' or i == '[':\n                stack.append(i)\n            else:\n                if len(stack) == 0:\n                    return False\n                if i == ')' and stack[-1] == '(':\n                    stack.pop()\n                elif i == '}' and stack[-1] == '{':\n                    stack.pop()\n                elif i == ']' and stack[-1] == '[':\n                    stack.pop()\n                else:\n                    return False\n        if len(stack) == 0:\n            return True\n        else:\n            return False"}], "next-permutation": [{"task_id": "next-permutation", "completion": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # 1. Find the largest index k such that nums[k] < nums[k + 1]. If no such index exists, just reverse nums and done.\n        # 2. Find the largest index l > k such that nums[k] < nums[l].\n        # 3. Swap nums[k] and nums[l].\n        # 4. Reverse the sub-array nums[k + 1:].\n        \n        # 1. Find the largest index k such that nums[k] < nums[k + 1]. If no such index exists, just reverse nums and done.\n        k = -1\n        for i in range(len(nums)-1):\n            if nums[i] < nums[i+1]:\n                k = i\n        \n        if k == -1:\n            nums.reverse()\n            return\n        \n        # 2. Find the largest index l > k such that nums[k] < nums[l].\n        l = k+1\n        for i in range(k+1, len(nums)):\n            if nums[k] < nums[i]:\n                l = i\n        \n        # 3. Swap nums[k] and nums[l].\n        nums[k], nums[l] = nums[l], nums[k]\n        \n        # 4. Reverse the sub-array nums[k + 1:].\n        nums[k+1:] = nums[k+1:][::-1]"}, {"task_id": "next-permutation", "completion": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # 1. Find the largest index k such that nums[k] < nums[k + 1]. If no such index exists, just reverse nums and done.\n        # 2. Find the largest index l > k such that nums[k] < nums[l].\n        # 3. Swap nums[k] and nums[l].\n        # 4. Reverse the sub-array nums[k + 1:].\n        \n        # 1. Find the largest index k such that nums[k] < nums[k + 1]. If no such index exists, just reverse nums and done.\n        k = -1\n        for i in range(len(nums)-1):\n            if nums[i] < nums[i+1]:\n                k = i\n        \n        if k == -1:\n            nums.reverse()\n            return\n        \n        # 2. Find the largest index l > k such that nums[k] < nums[l].\n        l = k+1\n        for i in range(k+1, len(nums)):\n            if nums[k] < nums[i]:\n                l = i\n        \n        # 3. Swap nums[k] and nums[l].\n        nums[k], nums[l] = nums[l], nums[k]\n        \n        # 4. Reverse the sub-array nums[k + 1:].\n        nums[k+1:] = nums[k+1:][::-1]"}, {"task_id": "next-permutation", "completion": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # 1. Find the largest index k such that nums[k] < nums[k + 1]. If no such index exists, just reverse nums and done.\n        # 2. Find the largest index l > k such that nums[k] < nums[l].\n        # 3. Swap nums[k] and nums[l].\n        # 4. Reverse the sub-array nums[k + 1:].\n        \n        # 1. Find the largest index k such that nums[k] < nums[k + 1]. If no such index exists, just reverse nums and done.\n        k = -1\n        for i in range(len(nums)-1):\n            if nums[i] < nums[i+1]:\n                k = i\n        \n        if k == -1:\n            nums.reverse()\n            return\n        \n        # 2. Find the largest index l > k such that nums[k] < nums[l].\n        l = k+1\n        for i in range(k+1, len(nums)):\n            if nums[k] < nums[i]:\n                l = i\n        \n        # 3. Swap nums[k] and nums[l].\n        nums[k], nums[l] = nums[l], nums[k]\n        \n        # 4. Reverse the sub-array nums[k + 1:].\n        nums[k+1:] = nums[k+1:][::-1]\n        \n        return nums"}, {"task_id": "next-permutation", "completion": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # 1. Find the largest index k such that nums[k] < nums[k + 1]. If no such index exists, just reverse nums and done.\n        # 2. Find the largest index l > k such that nums[k] < nums[l].\n        # 3. Swap nums[k] and nums[l].\n        # 4. Reverse the sub-array nums[k + 1:].\n        \n        # 1. Find the largest index k such that nums[k] < nums[k + 1]. If no such index exists, just reverse nums and done.\n        k = -1\n        for i in range(len(nums)-1):\n            if nums[i] < nums[i+1]:\n                k = i\n        \n        if k == -1:\n            nums.reverse()\n            return\n        \n        # 2. Find the largest index l > k such that nums[k] < nums[l].\n        l = k+1\n        for i in range(k+1, len(nums)):\n            if nums[k] < nums[i]:\n                l = i\n        \n        # 3. Swap nums[k] and nums[l].\n        nums[k], nums[l] = nums[l], nums[k]\n        \n        # 4. Reverse the sub-array nums[k + 1:].\n        nums[k+1:] = nums[k+1:][::-1]\n        \n        return nums"}, {"task_id": "next-permutation", "completion": "class Solution(object):\n    def nextPermutation(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: None Do not return anything, modify nums in-place instead.\n        \"\"\"\n        \n        # 1. Find the largest index k such that nums[k] < nums[k + 1]. If no such index exists, just reverse nums and done.\n        # 2. Find the largest index l > k such that nums[k] < nums[l].\n        # 3. Swap nums[k] and nums[l].\n        # 4. Reverse the sub-array nums[k + 1:].\n        \n        n = len(nums)\n        i = n - 2\n        while i >= 0 and nums[i] >= nums[i + 1]:\n            i -= 1\n        if i >= 0:\n            j = n - 1\n            while j >= 0 and nums[i] >= nums[j]:\n                j -= 1\n            nums[i], nums[j] = nums[j], nums[i]\n        left, right = i + 1, n - 1\n        while left < right:\n            nums[left], nums[right] = nums[right], nums[left]\n            left += 1\n            right -= 1"}], "contains-duplicate-ii": [{"task_id": "contains-duplicate-ii", "completion": "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        \n        # create a dictionary to store the index of each number\n        # if the number is already in the dictionary, check if the index is within k\n        # if it is, return True\n        # if it is not, update the index\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is"}, {"task_id": "contains-duplicate-ii", "completion": "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        \n        # create a dictionary to store the index of each number\n        # if the number is already in the dictionary, check if the difference between the current index and the index in the dictionary is less than or equal to k\n        # if it is, return True\n        # if not, update the index in the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # return False\n        \n        # create a dictionary to store the index of each number\n        d = {}\n        \n        # iterate through the list\n        for i in range(len(nums)):\n            # if the number is already in the dictionary\n            if nums[i] in d:\n                # if the difference between the current index and the index in the dictionary is less than or equal to k\n                if i - d[nums[i]] <= k:\n                    # return True\n                    return True\n            # update the index in the dictionary\n            d[nums[i]] = i\n        # return False\n        return False"}, {"task_id": "contains-duplicate-ii", "completion": "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        \n        # create a dictionary to store the index of each number\n        # if the number is already in the dictionary, check if the difference between the current index and the index in the dictionary is less than or equal to k\n        # if it is, return True\n        # if not, update the index in the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number"}, {"task_id": "contains-duplicate-ii", "completion": "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        \n        # create a dictionary to store the index of each number\n        # if the number is already in the dictionary, check if the index is within k\n        # if it is, return True\n        # if it is not, update the index\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is not in the dictionary, add it\n        # if the number is"}, {"task_id": "contains-duplicate-ii", "completion": "class Solution(object):\n    def containsNearbyDuplicate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: bool\n        \"\"\"\n        \n        # create a dictionary to store the index of each number\n        # if the number is already in the dictionary, check if the difference between the current index and the index in the dictionary is less than or equal to k\n        # if it is, return True\n        # if not, update the index in the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number is not in the dictionary, add it to the dictionary\n        # if the number"}], "maximum-gap": [{"task_id": "maximum-gap", "completion": "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 2:\n            return 0\n        \n        nums.sort()\n        max_gap = 0\n        for i in range(len(nums)-1):\n            max_gap = max(max_gap, nums[i+1] - nums[i])\n        return max_gap"}, {"task_id": "maximum-gap", "completion": "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 2:\n            return 0\n        \n        nums.sort()\n        max_diff = 0\n        for i in range(len(nums)-1):\n            max_diff = max(max_diff, nums[i+1] - nums[i])\n        return max_diff"}, {"task_id": "maximum-gap", "completion": "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 2:\n            return 0\n        \n        nums.sort()\n        max_gap = 0\n        for i in range(len(nums)-1):\n            max_gap = max(max_gap, nums[i+1] - nums[i])\n        return max_gap"}, {"task_id": "maximum-gap", "completion": "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 2:\n            return 0\n        \n        nums.sort()\n        max_gap = 0\n        for i in range(len(nums)-1):\n            max_gap = max(max_gap, nums[i+1] - nums[i])\n        return max_gap"}, {"task_id": "maximum-gap", "completion": "class Solution(object):\n    def maximumGap(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        if len(nums) < 2:\n            return 0\n        \n        nums.sort()\n        max_diff = 0\n        for i in range(len(nums)-1):\n            max_diff = max(max_diff, nums[i+1] - nums[i])\n        return max_diff"}], "binary-tree-level-order-traversal": [{"task_id": "binary-tree-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        res = []\n        \n        while queue:\n            level = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            res.append(level)\n        return res"}, {"task_id": "binary-tree-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        res = []\n        \n        while queue:\n            level = []\n            for i in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            res.append(level)\n        return res"}, {"task_id": "binary-tree-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        result = []\n        \n        while queue:\n            level = []\n            for i in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            result.append(level)\n        \n        return result"}, {"task_id": "binary-tree-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        queue = [root]\n        result = []\n        \n        while queue:\n            level = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            result.append(level)\n        \n        return result"}, {"task_id": "binary-tree-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if root is None:\n            return []\n        \n        queue = [root]\n        result = []\n        \n        while queue:\n            level = []\n            for i in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            result.append(level)\n        \n        return result"}], "couples-holding-hands": [{"task_id": "couples-holding-hands", "completion": "class Solution(object):\n    def minSwapsCouples(self, row):\n        \"\"\"\n        :type row: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        #"}, {"task_id": "couples-holding-hands", "completion": "class Solution(object):\n    def minSwapsCouples(self, row):\n        \"\"\"\n        :type row: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. create a dictionary to store the index of each person\n        # 2. iterate through the row\n        # 3. if the person is not in the dictionary, add it\n        # 4. if the person is in the dictionary, check if the person is the partner of the person in the dictionary\n        # 5. if the person is the partner of the person in the dictionary, remove the person from the dictionary\n        # 6. if the person is not the partner of the person in the dictionary, add the person to the dictionary\n        # 7. if the person is the partner of the person in the dictionary, remove the person from the dictionary\n        # 8. if the person is not the partner of the person in the dictionary, add the person to the dictionary\n        # 9. if the person is the partner of the person in the dictionary, remove the person from the dictionary\n        # 10. if the person is not the partner of the person in the dictionary, add the person to the dictionary\n        # 11. if the person is the partner of the person in the dictionary, remove the person from the dictionary\n        # 12. if the person is not the partner of the person in the dictionary, add the person to the dictionary\n        # 13. if the person is the partner of the person in the dictionary, remove the person from the dictionary\n        # 14. if the person is not the partner of the person in the dictionary, add the person to the dictionary\n        # 15. if the person is the partner of the person in the dictionary, remove the person from the dictionary\n        # 16. if the person is not the partner of the person in the dictionary, add the person to the dictionary\n        # 17. if the person is the partner of the person in the dictionary, remove the person from the dictionary\n        # 18. if the person is not the partner of the person in the dictionary, add the person to the dictionary\n        # 19. if the person is the partner of the person in the dictionary, remove the person from the dictionary\n        # 20. if the person is not the partner of the person in the dictionary, add the person to the dictionary\n        # 21. if the person is the partner of the person in the dictionary, remove the person from the dictionary\n        # 22. if the person is not the partner of the person in the dictionary, add the person to the dictionary\n        # 23. if the person is the partner of the person in the dictionary, remove the person from the dictionary\n        # 24. if the person is not the partner of the person in the dictionary, add the person to the dictionary\n        # 25. if the person is the partner of the person in the dictionary, remove the person from the dictionary\n        # 26. if the person is not the partner of the person in the dictionary, add the person to the dictionary\n        # 27. if the person is the partner of the person in the dictionary, remove the person from the dictionary\n        # 28. if the person is not the partner of the person in the dictionary, add the person to the dictionary\n        # 29. if the person is the partner of the person in the dictionary, remove the person from the dictionary\n        # 30. if the person is not the partner of the person in the dictionary, add the person to the dictionary\n        # 31. if the person is the partner of the person in the dictionary, remove the person from the dictionary\n        # 32. if the person is not the partner of the person in the dictionary, add the person to the dictionary\n        # 33. if the person is the partner of the person in the dictionary, remove the person from the dictionary\n        # 34. if the person is not the partner of the person in the dictionary, add the person to the dictionary\n        # 35. if the person is the partner of the person in the dictionary, remove the person from the dictionary\n        # 36. if the person is not the partner of the person in the dictionary, add the person to the dictionary\n        # 37. if the person is the partner of the person in the dictionary, remove the person from the dictionary\n        # 38. if the person is not the partner of the person in the dictionary, add the person to the dictionary\n        # 39. if the person is the partner of the person in the dictionary, remove the person from the dictionary\n        # 40. if the person is not the partner of the person in the dictionary, add the person to the dictionary\n        # 4"}, {"task_id": "couples-holding-hands", "completion": "class Solution(object):\n    def minSwapsCouples(self, row):\n        \"\"\"\n        :type row: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. create a dictionary to store the couples\n        # 2. create a dictionary to store the index of the couples\n        # 3. create a dictionary to store the index of the couples\n        # 4. create a dictionary to store the index of the couples\n        # 5. create a dictionary to store the index of the couples\n        # 6. create a dictionary to store the index of the couples\n        # 7. create a dictionary to store the index of the couples\n        # 8. create a dictionary to store the index of the couples\n        # 9. create a dictionary to store the index of the couples\n        # 10. create a dictionary to store the index of the couples\n        # 11. create a dictionary to store the index of the couples\n        # 12. create a dictionary to store the index of the couples\n        # 13. create a dictionary to store the index of the couples\n        # 14. create a dictionary to store the index of the couples\n        # 15. create a dictionary to store the index of the couples\n        # 16. create a dictionary to store the index of the couples\n        # 17. create a dictionary to store the index of the couples\n        # 18. create a dictionary to store the index of the couples\n        # 19. create a dictionary to store the index of the couples\n        # 20. create a dictionary to store the index of the couples\n        # 21. create a dictionary to store the index of the couples\n        # 22. create a dictionary to store the index of the couples\n        # 23. create a dictionary to store the index of the couples\n        # 24. create a dictionary to store the index of the couples\n        # 25. create a dictionary to store the index of the couples\n        # 26. create a dictionary to store the index of the couples\n        # 27. create a dictionary to store the index of the couples\n        # 28. create a dictionary to store the index of the couples\n        # 29. create a dictionary to store the index of the couples\n        # 30. create a dictionary to store the index of the couples\n        # 31. create a dictionary to store the index of the couples\n        # 32. create a dictionary to store the index of the couples\n        # 33. create a dictionary to store the index of the couples\n        # 34. create a dictionary to store the index of the couples\n        # 35. create a dictionary to store the index of the couples\n        # 36. create a dictionary to store the index of the couples\n        # 37. create a dictionary to store the index of the couples\n        # 38. create a dictionary to store the index of the couples\n        # 39. create a dictionary to store the index of the couples\n        # 40. create a dictionary to store the index of the couples\n        # 41. create a dictionary to store the index of the couples\n        # 42. create a dictionary to store the index of the couples\n        # 43. create a dictionary to store the index of the couples\n        # 44. create a dictionary to store the index of the couples\n        # 45. create a dictionary to store the index of the couples\n        # 46. create a dictionary to store the index of the couples\n        # 47. create a dictionary to store the index of the couples\n        # 48. create a dictionary to store the index of the couples\n        # 49. create a dictionary to store the index of the couples\n        # 50. create a dictionary to store the index of the couples\n        # 51. create a dictionary to store the index of the couples\n        # 52. create a dictionary to store the index of the couples\n        # 53. create a dictionary to store the index of the couples\n        # 54. create a dictionary to store the index of the couples\n        # 55. create a dictionary to store the index of the couples\n        # 56. create a dictionary to store the index of the couples\n        # 57. create a dictionary to store the index of the couples\n        # 58. create a dictionary to store the index of the couples\n        # 59. create a dictionary to store the index of the couples\n        # 60. create a dictionary to store the index of the couples\n        # 61. create a dictionary to store the index of the couples"}, {"task_id": "couples-holding-hands", "completion": "class Solution(object):\n    def minSwapsCouples(self, row):\n        \"\"\"\n        :type row: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. create a dictionary to store the index of each person\n        # 2. iterate through the row\n        # 3. if the person is not a couple, skip\n        # 4. if the person is a couple, check if the couple is sitting next to each other\n        # 5. if not, swap the couple\n        # 6. update the dictionary\n        # 7. return the number of swaps\n        \n        # create a dictionary to store the index of each person\n        d = {}\n        for i in range(len(row)):\n            d[row[i]] = i\n        \n        # iterate through the row\n        swaps = 0\n        for i in range(0, len(row), 2):\n            # if the person is not a couple, skip\n            if row[i] % 2 == 0:\n                if row[i] + 1 != row[i + 1]:\n                    # swap the couple\n                    d[row[i + 1]] = d[row[i]]\n                    d[row[i]] = i + 1\n                    row[i + 1], row[d[row[i + 1]]] = row[d[row[i + 1]]], row[i + 1]\n                    swaps += 1\n            else:\n                if row[i] - 1 != row[i + 1]:\n                    # swap the couple\n                    d[row[i + 1]] = d[row[i]]\n                    d[row[i]] = i + 1\n                    row[i + 1], row[d[row[i + 1]]] = row[d[row[i + 1]]], row[i + 1]\n                    swaps += 1\n        \n        return swaps"}, {"task_id": "couples-holding-hands", "completion": "class Solution(object):\n    def minSwapsCouples(self, row):\n        \"\"\"\n        :type row: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        #"}], "interleaving-string": [{"task_id": "interleaving-string", "completion": "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) + len(s2) != len(s3):\n            return False\n        \n        dp = [[False] * (len(s2) + 1) for _ in range(len(s1) + 1)]\n        \n        dp[0][0] = True\n        \n        for i in range(1, len(s1) + 1):\n            dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]\n        \n        for j in range(1, len(s2) + 1):\n            dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]\n        \n        for i in range(1, len(s1) + 1):\n            for j in range(1, len(s2) + 1):\n                dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n        \n        return dp[len(s1)][len(s2)]"}, {"task_id": "interleaving-string", "completion": "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) + len(s2) != len(s3):\n            return False\n        \n        dp = [[False for _ in range(len(s2) + 1)] for _ in range(len(s1) + 1)]\n        \n        dp[0][0] = True\n        \n        for i in range(1, len(s1) + 1):\n            dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]\n        \n        for j in range(1, len(s2) + 1):\n            dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]\n        \n        for i in range(1, len(s1) + 1):\n            for j in range(1, len(s2) + 1):\n                dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n        \n        return dp[-1][-1]"}, {"task_id": "interleaving-string", "completion": "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) + len(s2) != len(s3):\n            return False\n        \n        dp = [[False] * (len(s2) + 1) for _ in range(len(s1) + 1)]\n        dp[0][0] = True\n        \n        for i in range(1, len(s1) + 1):\n            dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]\n        \n        for j in range(1, len(s2) + 1):\n            dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]\n        \n        for i in range(1, len(s1) + 1):\n            for j in range(1, len(s2) + 1):\n                dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n        \n        return dp[len(s1)][len(s2)]"}, {"task_id": "interleaving-string", "completion": "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) + len(s2) != len(s3):\n            return False\n        \n        dp = [[False for _ in range(len(s2) + 1)] for _ in range(len(s1) + 1)]\n        \n        dp[0][0] = True\n        \n        for i in range(1, len(s1) + 1):\n            dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]\n        \n        for j in range(1, len(s2) + 1):\n            dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]\n        \n        for i in range(1, len(s1) + 1):\n            for j in range(1, len(s2) + 1):\n                dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n        \n        return dp[len(s1)][len(s2)]"}, {"task_id": "interleaving-string", "completion": "class Solution(object):\n    def isInterleave(self, s1, s2, s3):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :type s3: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) + len(s2) != len(s3):\n            return False\n        \n        dp = [[False] * (len(s2) + 1) for _ in range(len(s1) + 1)]\n        dp[0][0] = True\n        \n        for i in range(1, len(s1) + 1):\n            dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]\n        \n        for j in range(1, len(s2) + 1):\n            dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]\n        \n        for i in range(1, len(s1) + 1):\n            for j in range(1, len(s2) + 1):\n                dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1]) or (dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n        \n        return dp[len(s1)][len(s2)]"}], "assign-cookies": [{"task_id": "assign-cookies", "completion": "class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        \n        g.sort()\n        s.sort()\n        \n        i = 0\n        j = 0\n        count = 0\n        \n        while i < len(g) and j < len(s):\n            if g[i] <= s[j]:\n                count += 1\n                i += 1\n                j += 1\n            else:\n                j += 1\n                \n        return count"}, {"task_id": "assign-cookies", "completion": "class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        \n        g.sort()\n        s.sort()\n        \n        i = 0\n        j = 0\n        \n        while i < len(g) and j < len(s):\n            if g[i] <= s[j]:\n                i += 1\n            j += 1\n            \n        return i"}, {"task_id": "assign-cookies", "completion": "class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        \n        g.sort()\n        s.sort()\n        \n        i = 0\n        j = 0\n        \n        while i < len(g) and j < len(s):\n            if g[i] <= s[j]:\n                i += 1\n            j += 1\n            \n        return i"}, {"task_id": "assign-cookies", "completion": "class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        \n        g.sort()\n        s.sort()\n        \n        i = 0\n        j = 0\n        \n        while i < len(g) and j < len(s):\n            if g[i] <= s[j]:\n                i += 1\n            j += 1\n            \n        return i"}, {"task_id": "assign-cookies", "completion": "class Solution(object):\n    def findContentChildren(self, g, s):\n        \"\"\"\n        :type g: List[int]\n        :type s: List[int]\n        :rtype: int\n        \"\"\"\n        \n        g.sort()\n        s.sort()\n        \n        i = 0\n        j = 0\n        \n        while i < len(g) and j < len(s):\n            if g[i] <= s[j]:\n                i += 1\n            j += 1\n            \n        return i"}], "keyboard-row": [{"task_id": "keyboard-row", "completion": "class Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # 1. create a dictionary of the rows\n        rows = {\n            1: set('qwertyuiop'),\n            2: set('asdfghjkl'),\n            3: set('zxcvbnm')\n        }\n        \n        # 2. create a list of words that can be typed on one row\n        result = []\n        \n        # 3. iterate through the words\n        for word in words:\n            # 4. get the first letter of the word\n            first_letter = word[0].lower()\n            \n            # 5. get the row of the first letter\n            row = None\n            for key, value in rows.items():\n                if first_letter in value:\n                    row = key\n                    break\n            \n            # 6. check if the word can be typed on one row\n            if all(letter.lower() in rows[row] for letter in word):\n                result.append(word)\n        \n        # 7. return the list of words that can be typed on one row\n        return result"}, {"task_id": "keyboard-row", "completion": "class Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # 1. create a dictionary with the first row of the keyboard\n        # 2. create a dictionary with the second row of the keyboard\n        # 3. create a dictionary with the third row of the keyboard\n        # 4. create a list to store the words that can be typed using letters of the alphabet on only one row of American keyboard\n        # 5. loop through the words\n        # 6. if the word is in the first row of the keyboard, add it to the list\n        # 7. if the word is in the second row of the keyboard, add it to the list\n        # 8. if the word is in the third row of the keyboard, add it to the list\n        # 9. return the list\n        \n        # create a dictionary with the first row of the keyboard\n        first_row = {'q': 1, 'w': 1, 'e': 1, 'r': 1, 't': 1, 'y': 1, 'u': 1, 'i': 1, 'o': 1, 'p': 1}\n        # create a dictionary with the second row of the keyboard\n        second_row = {'a': 1, 's': 1, 'd': 1, 'f': 1, 'g': 1, 'h': 1, 'j': 1, 'k': 1, 'l': 1}\n        # create a dictionary with the third row of the keyboard\n        third_row = {'z': 1, 'x': 1, 'c': 1, 'v': 1, 'b': 1, 'n': 1, 'm': 1}\n        # create a list to store the words that can be typed using letters of the alphabet on only one row of American keyboard\n        result = []\n        # loop through the words\n        for word in words:\n            # if the word is in the first row of the keyboard, add it to the list\n            if all(char in first_row for char in word.lower()):\n                result.append(word)\n            # if the word is in the second row of the keyboard, add it to the list\n            elif all(char in second_row for char in word.lower()):\n                result.append(word)\n            # if the word is in the third row of the keyboard, add it to the list\n            elif all(char in third_row for char in word.lower()):\n                result.append(word)\n        # return the list\n        return result"}, {"task_id": "keyboard-row", "completion": "class Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        first = set('qwertyuiop')\n        second = set('asdfghjkl')\n        third = set('zxcvbnm')\n        \n        res = []\n        \n        for word in words:\n            if set(word.lower()).issubset(first) or set(word.lower()).issubset(second) or set(word.lower()).issubset(third):\n                res.append(word)\n                \n        return res"}, {"task_id": "keyboard-row", "completion": "class Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        first = set('qwertyuiop')\n        second = set('asdfghjkl')\n        third = set('zxcvbnm')\n        \n        res = []\n        \n        for word in words:\n            if set(word.lower()).issubset(first) or set(word.lower()).issubset(second) or set(word.lower()).issubset(third):\n                res.append(word)\n        \n        return res"}, {"task_id": "keyboard-row", "completion": "class Solution(object):\n    def findWords(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # 1. create a dictionary with the first row of the keyboard\n        # 2. create a dictionary with the second row of the keyboard\n        # 3. create a dictionary with the third row of the keyboard\n        # 4. create a list to store the words that can be typed using letters of the alphabet on only one row of American keyboard\n        # 5. loop through the words\n        # 6. if the word is in the first row of the keyboard, add it to the list\n        # 7. if the word is in the second row of the keyboard, add it to the list\n        # 8. if the word is in the third row of the keyboard, add it to the list\n        # 9. return the list\n        \n        # create a dictionary with the first row of the keyboard\n        first_row = {'q': 1, 'w': 1, 'e': 1, 'r': 1, 't': 1, 'y': 1, 'u': 1, 'i': 1, 'o': 1, 'p': 1}\n        # create a dictionary with the second row of the keyboard\n        second_row = {'a': 2, 's': 2, 'd': 2, 'f': 2, 'g': 2, 'h': 2, 'j': 2, 'k': 2, 'l': 2}\n        # create a dictionary with the third row of the keyboard\n        third_row = {'z': 3, 'x': 3, 'c': 3, 'v': 3, 'b': 3, 'n': 3, 'm': 3}\n        # create a list to store the words that can be typed using letters of the alphabet on only one row of American keyboard\n        result = []\n        # loop through the words\n        for word in words:\n            # if the word is in the first row of the keyboard, add it to the list\n            if all(letter in first_row for letter in word.lower()):\n                result.append(word)\n            # if the word is in the second row of the keyboard, add it to the list\n            elif all(letter in second_row for letter in word.lower()):\n                result.append(word)\n            # if the word is in the third row of the keyboard, add it to the list\n            elif all(letter in third_row for letter in word.lower()):\n                result.append(word)\n        # return the list\n        return result"}], "reverse-linked-list-ii": [{"task_id": "reverse-linked-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: ListNode\n        :type left: int\n        :type right: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # base case\n        if not head:\n            return None\n        \n        cur, prev = head, None\n        while left > 1:\n            prev = cur\n            cur = cur.next\n            left, right = left - 1, right - 1\n            \n        tail, con = cur, prev\n        \n        while right:\n            third = cur.next\n            cur.next = prev\n            prev = cur\n            cur = third\n            right -= 1\n            \n        if con:\n            con.next = prev\n        else:\n            head = prev\n        tail.next = cur\n        return head"}, {"task_id": "reverse-linked-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: ListNode\n        :type left: int\n        :type right: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # base case\n        if not head:\n            return None\n        \n        curr, prev = head, None\n        while left > 1:\n            prev = curr\n            curr = curr.next\n            left, right = left - 1, right - 1\n            \n        tail, con = curr, prev\n        \n        while right:\n            next_node = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_node\n            right -= 1\n            \n        if con:\n            con.next = prev\n        else:\n            head = prev\n        tail.next = curr\n        return head"}, {"task_id": "reverse-linked-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: ListNode\n        :type left: int\n        :type right: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # base case\n        if not head:\n            return None\n        \n        curr, prev = head, None\n        while left > 1:\n            prev = curr\n            curr = curr.next\n            left, right = left - 1, right - 1\n            \n        tail, con = curr, prev\n        \n        while right:\n            next_node = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_node\n            right -= 1\n            \n        if con:\n            con.next = prev\n        else:\n            head = prev\n        tail.next = curr\n        return head"}, {"task_id": "reverse-linked-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: ListNode\n        :type left: int\n        :type right: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # base case\n        if not head:\n            return None\n        \n        curr, prev = head, None\n        while left > 1:\n            prev = curr\n            curr = curr.next\n            left, right = left - 1, right - 1\n            \n        tail, con = curr, prev\n        \n        while right:\n            third = curr.next\n            curr.next = prev\n            prev = curr\n            curr = third\n            right -= 1\n            \n        if con:\n            con.next = prev\n        else:\n            head = prev\n        tail.next = curr\n        return head"}, {"task_id": "reverse-linked-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseBetween(self, head, left, right):\n        \"\"\"\n        :type head: ListNode\n        :type left: int\n        :type right: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # base case\n        if not head:\n            return None\n        \n        cur, prev = head, None\n        while left > 1:\n            prev = cur\n            cur = cur.next\n            left, right = left - 1, right - 1\n        \n        tail, con = cur, prev\n        \n        while right:\n            third = cur.next\n            cur.next = prev\n            prev = cur\n            cur = third\n            right -= 1\n        \n        if con:\n            con.next = prev\n        else:\n            head = prev\n        tail.next = cur\n        return head"}], "shortest-palindrome": [{"task_id": "shortest-palindrome", "completion": "class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        #"}, {"task_id": "shortest-palindrome", "completion": "class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        #"}, {"task_id": "shortest-palindrome", "completion": "class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        #"}, {"task_id": "shortest-palindrome", "completion": "class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the"}, {"task_id": "shortest-palindrome", "completion": "class Solution(object):\n    def shortestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        # 3. return the result\n        \n        # 1. find the longest palindrome substring\n        # 2. add the rest of the characters to the front of the string\n        #"}], "minimum-window-substring": [{"task_id": "minimum-window-substring", "completion": "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. create a dictionary to store the count of characters in t\n        # 2. create a dictionary to store the count of characters in s\n        # 3. create a variable to store the minimum length of the substring\n        # 4. create a variable to store the start index of the substring\n        # 5. create a variable to store the end index of the substring\n        # 6. create a variable to store the count of characters in t\n        # 7. create a variable to store the count of characters in s\n        # 8. create a variable to store the count of characters in s\n        # 9. create a variable to store the count of characters in s\n        # 10. create a variable to store the count of characters in s\n        # 11. create a variable to store the count of characters in s\n        # 12. create a variable to store the count of characters in s\n        # 13. create a variable to store the count of characters in s\n        # 14. create a variable to store the count of characters in s\n        # 15. create a variable to store the count of characters in s\n        # 16. create a variable to store the count of characters in s\n        # 17. create a variable to store the count of characters in s\n        # 18. create a variable to store the count of characters in s\n        # 19. create a variable to store the count of characters in s\n        # 20. create a variable to store the count of characters in s\n        # 21. create a variable to store the count of characters in s\n        # 22. create a variable to store the count of characters in s\n        # 23. create a variable to store the count of characters in s\n        # 24. create a variable to store the count of characters in s\n        # 25. create a variable to store the count of characters in s\n        # 26. create a variable to store the count of characters in s\n        # 27. create a variable to store the count of characters in s\n        # 28. create a variable to store the count of characters in s\n        # 29. create a variable to store the count of characters in s\n        # 30. create a variable to store the count of characters in s\n        # 31. create a variable to store the count of characters in s\n        # 32. create a variable to store the count of characters in s\n        # 33. create a variable to store the count of characters in s\n        # 34. create a variable to store the count of characters in s\n        # 35. create a variable to store the count of characters in s\n        # 36. create a variable to store the count of characters in s\n        # 37. create a variable to store the count of characters in s\n        # 38. create a variable to store the count of characters in s\n        # 39. create a variable to store the count of characters in s\n        # 40. create a variable to store the count of characters in s\n        # 41. create a variable to store the count of characters in s\n        # 42. create a variable to store the count of characters in s\n        # 43. create a variable to store the count of characters in s\n        # 44. create a variable to store the count of characters in s\n        # 45. create a variable to store the count of characters in s\n        # 46. create a variable to store the count of characters in s\n        # 47. create a variable to store the count of characters in s\n        # 48. create a variable to store the count of characters in s\n        # 49. create a variable to store the count of characters in s\n        # 50. create a variable to store the count of characters in s\n        # 51. create a variable to store the count of characters in s\n        # 52. create a variable to store the count of characters in s\n        # 53. create a variable to store the count of characters in s\n        # 54. create a variable to store the count of characters in s\n        # 55. create a variable to store the count of characters in s\n        # 56. create a variable to store the count of characters in s\n        # 57. create a variable to store the count of characters in s\n        # 5"}, {"task_id": "minimum-window-substring", "completion": "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        # create a dictionary to store the count of characters in t\n        t_dict = {}\n        for char in t:\n            if char in t_dict:\n                t_dict[char] += 1\n            else:\n                t_dict[char] = 1\n        \n        # create a dictionary to store the count of characters in s\n        s_dict = {}\n        for char in s:\n            if char in s_dict:\n                s_dict[char] += 1\n            else:\n                s_dict[char] = 1\n        \n        # create a dictionary to store the count of characters in s that are in t\n        s_t_dict = {}\n        for char in s:\n            if char in t_dict:\n                if char in s_t_dict:\n                    s_t_dict[char] += 1\n                else:\n                    s_t_dict[char] = 1\n        \n        # create a dictionary to store the count of characters in s that are in t and are in the current window\n        s_t_window_dict = {}\n        for char in s:\n            if char in t_dict:\n                if char in s_t_window_dict:\n                    s_t_window_dict[char] += 1\n                else:\n                    s_t_window_dict[char] = 1\n        \n        # create a dictionary to store the count of characters in s that are in t and are in the current window\n        s_t_window_dict = {}\n        for char in s:\n            if char in t_dict:\n                if char in s_t_window_dict:\n                    s_t_window_dict[char] += 1\n                else:\n                    s_t_window_dict[char] = 1\n        \n        # create a dictionary to store the count of characters in s that are in t and are in the current window\n        s_t_window_dict = {}\n        for char in s:\n            if char in t_dict:\n                if char in s_t_window_dict:\n                    s_t_window_dict[char] += 1\n                else:\n                    s_t_window_dict[char] = 1\n        \n        # create a dictionary to store the count of characters in s that are in t and are in the current window\n        s_t_window_dict = {}\n        for char in s:\n            if char in t_dict:\n                if char in s_t_window_dict:\n                    s_t_window_dict[char] += 1\n                else:\n                    s_t_window_dict[char] = 1\n        \n        # create a dictionary to store the count of characters in s that are in t and are in the current window\n        s_t_window_dict = {}\n        for char in s:\n            if char in t_dict:\n                if char in s_t_window_dict:\n                    s_t_window_dict[char] += 1\n                else:\n                    s_t_window_dict[char] = 1\n        \n        # create a dictionary to store the count of characters in s that are in t and are in the current window\n        s_t_window_dict = {}\n        for char in s:\n            if char in t_dict:\n                if char in s_t_window_dict:\n                    s_t_window_dict[char] += 1\n                else:\n                    s_t_window_dict[char] = 1\n        \n        # create a dictionary to store the count of characters in s that are in t and are in the current window\n        s_t_window_dict = {}\n        for char in s:\n            if char in t_dict:\n                if char in s_t_window_dict:\n                    s_t_window_dict[char] += 1\n                else:\n                    s_t_window_dict[char] = 1\n        \n        # create a dictionary to store the count of characters in s that are in t and are in the current window\n        s_t_window_dict = {}\n        for char in s:\n            if char in t_dict:\n                if char in s_t_window_dict:\n                    s_t_window_dict[char] += 1\n                else:\n                    s_t_window_dict[char] = 1\n        \n        # create a dictionary to store the count of characters in s that are in t and are in the current window\n        s_t_window"}, {"task_id": "minimum-window-substring", "completion": "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        if len(s) < len(t):\n            return \"\"\n        \n        t_dict = {}\n        for char in t:\n            if char in t_dict:\n                t_dict[char] += 1\n            else:\n                t_dict[char] = 1\n        \n        s_dict = {}\n        for char in s:\n            if char in s_dict:\n                s_dict[char] += 1\n            else:\n                s_dict[char] = 1\n        \n        if not self.is_valid(s_dict, t_dict):\n            return \"\"\n        \n        start = 0\n        end = len(s) - 1\n        while start < end:\n            if s[start] in t_dict:\n                if s_dict[s[start]] > t_dict[s[start]]:\n                    s_dict[s[start]] -= 1\n                    start += 1\n                else:\n                    break\n            else:\n                start += 1\n        \n        while start < end:\n            if s[end] in t_dict:\n                if s_dict[s[end]] > t_dict[s[end]]:\n                    s_dict[s[end]] -= 1\n                    end -= 1\n                else:\n                    break\n            else:\n                end -= 1\n        \n        min_window = s[start:end+1]\n        while start < end:\n            if s[start] in t_dict:\n                if s_dict[s[start]] > t_dict[s[start]]:\n                    s_dict[s[start]] -= 1\n                    start += 1\n                else:\n                    break\n            else:\n                start += 1\n            \n            while start < end:\n                if s[end] in t_dict:\n                    if s_dict[s[end]] > t_dict[s[end]]:\n                        s_dict[s[end]] -= 1\n                        end -= 1\n                    else:\n                        break\n                else:\n                    end -= 1\n            \n            if end - start + 1 < len(min_window):\n                min_window = s[start:end+1]\n        \n        return min_window\n    \n    def is_valid(self, s_dict, t_dict):\n        for key in t_dict:\n            if key not in s_dict or s_dict[key] < t_dict[key]:\n                return False\n        return True"}, {"task_id": "minimum-window-substring", "completion": "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. create a dictionary to store the count of characters in t\n        # 2. create a dictionary to store the count of characters in s\n        # 3. create a variable to store the minimum length of the substring\n        # 4. create a variable to store the start index of the substring\n        # 5. create a variable to store the end index of the substring\n        # 6. create a variable to store the count of characters in t\n        # 7. create a variable to store the count of characters in s\n        # 8. create a variable to store the count of characters in s\n        # 9. create a variable to store the count of characters in s\n        # 10. create a variable to store the count of characters in s\n        # 11. create a variable to store the count of characters in s\n        # 12. create a variable to store the count of characters in s\n        # 13. create a variable to store the count of characters in s\n        # 14. create a variable to store the count of characters in s\n        # 15. create a variable to store the count of characters in s\n        # 16. create a variable to store the count of characters in s\n        # 17. create a variable to store the count of characters in s\n        # 18. create a variable to store the count of characters in s\n        # 19. create a variable to store the count of characters in s\n        # 20. create a variable to store the count of characters in s\n        # 21. create a variable to store the count of characters in s\n        # 22. create a variable to store the count of characters in s\n        # 23. create a variable to store the count of characters in s\n        # 24. create a variable to store the count of characters in s\n        # 25. create a variable to store the count of characters in s\n        # 26. create a variable to store the count of characters in s\n        # 27. create a variable to store the count of characters in s\n        # 28. create a variable to store the count of characters in s\n        # 29. create a variable to store the count of characters in s\n        # 30. create a variable to store the count of characters in s\n        # 31. create a variable to store the count of characters in s\n        # 32. create a variable to store the count of characters in s\n        # 33. create a variable to store the count of characters in s\n        # 34. create a variable to store the count of characters in s\n        # 35. create a variable to store the count of characters in s\n        # 36. create a variable to store the count of characters in s\n        # 37. create a variable to store the count of characters in s\n        # 38. create a variable to store the count of characters in s\n        # 39. create a variable to store the count of characters in s\n        # 40. create a variable to store the count of characters in s\n        # 41. create a variable to store the count of characters in s\n        # 42. create a variable to store the count of characters in s\n        # 43. create a variable to store the count of characters in s\n        # 44. create a variable to store the count of characters in s\n        # 45. create a variable to store the count of characters in s\n        # 46. create a variable to store the count of characters in s\n        # 47. create a variable to store the count of characters in s\n        # 48. create a variable to store the count of characters in s\n        # 49. create a variable to store the count of characters in s\n        # 50. create a variable to store the count of characters in s\n        # 51. create a variable to store the count of characters in s\n        # 52. create a variable to store the count of characters in s\n        # 53. create a variable to store the count of characters in s\n        # 54. create a variable to store the count of characters in s\n        # 55. create a variable to store the count of characters in s\n        # 56. create a variable to store the count of characters in s\n        # 57. create a variable to store the count of characters in s\n        # 5"}, {"task_id": "minimum-window-substring", "completion": "class Solution(object):\n    def minWindow(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        if len(t) > len(s):\n            return \"\"\n        \n        t_dict = {}\n        for char in t:\n            if char in t_dict:\n                t_dict[char] += 1\n            else:\n                t_dict[char] = 1\n        \n        s_dict = {}\n        for char in s:\n            if char in s_dict:\n                s_dict[char] += 1\n            else:\n                s_dict[char] = 1\n        \n        if not self.is_valid(s_dict, t_dict):\n            return \"\"\n        \n        left = 0\n        right = 0\n        min_window = s\n        while right < len(s):\n            if s[right] in t_dict:\n                t_dict[s[right]] -= 1\n            right += 1\n            \n            while self.is_valid(s_dict, t_dict):\n                if right - left < len(min_window):\n                    min_window = s[left:right]\n                if s[left] in t_dict:\n                    t_dict[s[left]] += 1\n                left += 1\n        \n        return min_window\n    \n    def is_valid(self, s_dict, t_dict):\n        for key in t_dict:\n            if key not in s_dict or s_dict[key] < t_dict[key]:\n                return False\n        return True"}], "self-crossing": [{"task_id": "self-crossing", "completion": "class Solution(object):\n    def isSelfCrossing(self, distance):\n        \"\"\"\n        :type distance: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. 4 points\n        # 2. 5 points\n        # 3. 6 points\n        \n        # 1. 4 points\n        # 2. 5 points\n        # 3. 6 points\n        \n        # 1. 4 points\n        # 2. 5 points\n        # 3. 6 points\n        \n        # 1. 4 points\n        # 2. 5 points\n        # 3. 6 points\n        \n        # 1. 4 points\n        # 2. 5 points\n        # 3. 6 points\n        \n        # 1. 4 points\n        # 2. 5 points\n        # 3. 6 points\n        \n        # 1. 4 points\n        # 2. 5 points\n        # 3. 6 points\n        \n        # 1. 4 points\n        # 2. 5 points\n        # 3. 6 points\n        \n        # 1. 4 points\n        # 2. 5 points\n        # 3. 6 points\n        \n        # 1. 4 points\n        # 2. 5 points\n        # 3. 6 points\n        \n        # 1. 4 points\n        # 2. 5 points\n        # 3. 6 points\n        \n        # 1. 4 points\n        # 2. 5 points\n        # 3. 6 points\n        \n        # 1. 4 points\n        # 2. 5 points\n        # 3. 6 points\n        \n        # 1. 4 points\n        # 2. 5 points\n        # 3. 6 points\n        \n        # 1. 4 points\n        # 2. 5 points\n        # 3. 6 points\n        \n        # 1. 4 points\n        # 2. 5 points\n        # 3. 6 points\n        \n        # 1. 4 points\n        # 2. 5 points\n        # 3. 6 points\n        \n        # 1. 4 points\n        # 2. 5 points\n        # 3. 6 points\n        \n        # 1. 4 points\n        # 2. 5 points\n        # 3. 6 points\n        \n        # 1. 4 points\n        # 2. 5 points\n        # 3. 6 points\n        \n        # 1. 4 points\n        # 2. 5 points\n        # 3. 6 points\n        \n        # 1. 4 points\n        # 2. 5 points\n        # 3. 6 points\n        \n        # 1. 4 points\n        # 2. 5 points\n        # 3. 6 points\n        \n        # 1. 4 points\n        # 2. 5 points\n        # 3. 6 points\n        \n        # 1. 4 points\n        # 2. 5 points\n        # 3. 6 points\n        \n        # 1. 4 points\n        # 2. 5 points\n        # 3. 6 points\n        \n        # 1. 4 points\n        # 2. 5 points\n        # 3. 6 points\n        \n        # 1. 4 points\n        # 2. 5 points\n        # 3. 6 points\n        \n        # 1. 4 points\n        # 2. 5 points\n        # 3. 6 points\n        \n        # 1. 4 points\n        # 2. 5 points\n        # 3. 6 points\n        \n        # 1. 4 points\n        # 2. 5 points\n        # 3. 6 points\n        \n        # 1. 4 points\n        # 2. 5 points\n        # 3. 6 points\n        \n        # 1. 4 points\n        # 2. 5 points\n        # 3. 6 points\n        \n        # 1. 4 points\n        # 2. 5 points\n        # 3. 6 points\n        \n        # 1. 4 points\n        # 2. 5 points\n        # 3. 6 points\n        \n        # 1. 4 points"}, {"task_id": "self-crossing", "completion": "class Solution(object):\n    def isSelfCrossing(self, distance):\n        \"\"\"\n        :type distance: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. 4 points cross\n        # 2. 5 points cross\n        # 3. 6 points cross\n        \n        # 1. 4 points cross\n        # 2. 5 points cross\n        # 3. 6 points cross\n        \n        # 1. 4 points cross\n        # 2. 5 points cross\n        # 3. 6 points cross\n        \n        # 1. 4 points cross\n        # 2. 5 points cross\n        # 3. 6 points cross\n        \n        # 1. 4 points cross\n        # 2. 5 points cross\n        # 3. 6 points cross\n        \n        # 1. 4 points cross\n        # 2. 5 points cross\n        # 3. 6 points cross\n        \n        # 1. 4 points cross\n        # 2. 5 points cross\n        # 3. 6 points cross\n        \n        # 1. 4 points cross\n        # 2. 5 points cross\n        # 3. 6 points cross\n        \n        # 1. 4 points cross\n        # 2. 5 points cross\n        # 3. 6 points cross\n        \n        # 1. 4 points cross\n        # 2. 5 points cross\n        # 3. 6 points cross\n        \n        # 1. 4 points cross\n        # 2. 5 points cross\n        # 3. 6 points cross\n        \n        # 1. 4 points cross\n        # 2. 5 points cross\n        # 3. 6 points cross\n        \n        # 1. 4 points cross\n        # 2. 5 points cross\n        # 3. 6 points cross\n        \n        # 1. 4 points cross\n        # 2. 5 points cross\n        # 3. 6 points cross\n        \n        # 1. 4 points cross\n        # 2. 5 points cross\n        # 3. 6 points cross\n        \n        # 1. 4 points cross\n        # 2. 5 points cross\n        # 3. 6 points cross\n        \n        # 1. 4 points cross\n        # 2. 5 points cross\n        # 3. 6 points cross\n        \n        # 1. 4 points cross\n        # 2. 5 points cross\n        # 3. 6 points cross\n        \n        # 1. 4 points cross\n        # 2. 5 points cross\n        # 3. 6 points cross\n        \n        # 1. 4 points cross\n        # 2. 5 points cross\n        # 3. 6 points cross\n        \n        # 1. 4 points cross\n        # 2. 5 points cross\n        # 3. 6 points cross\n        \n        # 1. 4 points cross\n        # 2. 5 points cross\n        # 3. 6 points cross\n        \n        # 1. 4 points cross\n        # 2. 5 points cross\n        # 3. 6 points cross\n        \n        # 1. 4 points cross\n        # 2. 5 points cross\n        # 3. 6 points cross\n        \n        # 1. 4 points cross\n        # 2. 5 points cross\n        # 3. 6 points cross\n        \n        # 1. 4 points cross\n        # 2. 5 points cross\n        # 3. 6 points cross\n        \n        # 1. 4 points cross\n        # 2. 5 points cross\n        # 3. 6 points cross\n        \n        # 1. 4 points cross\n        # 2. 5 points cross\n        # 3. 6 points cross\n        \n        # 1. 4 points cross\n        # 2. 5 points cross\n        # 3. 6 points cross\n        \n        # 1. 4 points cross\n        # 2. 5 points cross\n        # 3. 6 points cross\n        \n        # 1. 4 points cross\n        # 2. 5 points cross\n        # 3. 6 points cross\n        \n        # 1. 4 points cross\n        # 2. 5 points cross\n        # 3. 6 points cross"}, {"task_id": "self-crossing", "completion": "class Solution(object):\n    def isSelfCrossing(self, distance):\n        \"\"\"\n        :type distance: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. 4th line crosses 1st line and point of intersection is (2,2)\n        # 2. 5th line crosses 1st line and point of intersection is (1,4)\n        # 3. 2nd line crosses 4th line and point of intersection is (4,2)\n        # 4. 3rd line crosses 4th line and point of intersection is (4,4)\n        \n        # 1. 4th line crosses 1st line and point of intersection is (2,2)\n        # 2. 5th line crosses 1st line and point of intersection is (1,4)\n        # 3. 2nd line crosses 4th line and point of intersection is (4,2)\n        # 4. 3rd line crosses 4th line and point of intersection is (4,4)\n        \n        # 1. 4th line crosses 1st line and point of intersection is (2,2)\n        # 2. 5th line crosses 1st line and point of intersection is (1,4)\n        # 3. 2nd line crosses 4th line and point of intersection is (4,2)\n        # 4. 3rd line crosses 4th line and point of intersection is (4,4)\n        \n        # 1. 4th line crosses 1st line and point of intersection is (2,2)\n        # 2. 5th line crosses 1st line and point of intersection is (1,4)\n        # 3. 2nd line crosses 4th line and point of intersection is (4,2)\n        # 4. 3rd line crosses 4th line and point of intersection is (4,4)\n        \n        # 1. 4th line crosses 1st line and point of intersection is (2,2)\n        # 2. 5th line crosses 1st line and point of intersection is (1,4)\n        # 3. 2nd line crosses 4th line and point of intersection is (4,2)\n        # 4. 3rd line crosses 4th line and point of intersection is (4,4)\n        \n        # 1. 4th line crosses 1st line and point of intersection is (2,2)\n        # 2. 5th line crosses 1st line and point of intersection is (1,4)\n        # 3. 2nd line crosses 4th line and point of intersection is (4,2)\n        # 4. 3rd line crosses 4th line and point of intersection is (4,4)\n        \n        # 1. 4th line crosses 1st line and point of intersection is (2,2)\n        # 2. 5th line crosses 1st line and point of intersection is (1,4)\n        # 3. 2nd line crosses 4th line and point of intersection is (4,2)\n        # 4. 3rd line crosses 4th line and point of intersection is (4,4)\n        \n        # 1. 4th line crosses 1st line and point of intersection is (2,2)\n        # 2. 5th line crosses 1st line and point of intersection is (1,4)\n        # 3. 2nd line crosses 4th line and point of intersection is (4,2)\n        # 4. 3rd line crosses 4th line and point of intersection is (4,4)\n        \n        # 1. 4th line crosses 1st line and point of intersection is (2,2)\n        # 2. 5th line crosses 1st line and point of intersection is (1,4)\n        # 3. 2nd line crosses 4th line and point of intersection is (4,2)\n        # 4. 3rd line crosses 4th line and point of intersection is (4,4)\n        \n        # 1. 4th line crosses 1st line and point of intersection is (2,2)\n        # 2. 5th line crosses 1st line and point of intersection is (1,4)\n        # 3. 2nd line crosses 4th line and point of"}, {"task_id": "self-crossing", "completion": "class Solution(object):\n    def isSelfCrossing(self, distance):\n        \"\"\"\n        :type distance: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. 4th line crosses 1st line and point of intersection is (2,2)\n        # 2. 5th line crosses 1st line and point of intersection is (1,4)\n        # 3. 2nd line crosses 4th line and point of intersection is (4,1)\n        # 4. 1st line crosses 3rd line and point of intersection is (2,3)\n        # 5. 3rd line crosses 5th line and point of intersection is (3,2)\n        \n        # 1. 4th line crosses 1st line and point of intersection is (2,2)\n        # 2. 5th line crosses 1st line and point of intersection is (1,4)\n        # 3. 2nd line crosses 4th line and point of intersection is (4,1)\n        # 4. 1st line crosses 3rd line and point of intersection is (2,3)\n        # 5. 3rd line crosses 5th line and point of intersection is (3,2)\n        \n        # 1. 4th line crosses 1st line and point of intersection is (2,2)\n        # 2. 5th line crosses 1st line and point of intersection is (1,4)\n        # 3. 2nd line crosses 4th line and point of intersection is (4,1)\n        # 4. 1st line crosses 3rd line and point of intersection is (2,3)\n        # 5. 3rd line crosses 5th line and point of intersection is (3,2)\n        \n        # 1. 4th line crosses 1st line and point of intersection is (2,2)\n        # 2. 5th line crosses 1st line and point of intersection is (1,4)\n        # 3. 2nd line crosses 4th line and point of intersection is (4,1)\n        # 4. 1st line crosses 3rd line and point of intersection is (2,3)\n        # 5. 3rd line crosses 5th line and point of intersection is (3,2)\n        \n        # 1. 4th line crosses 1st line and point of intersection is (2,2)\n        # 2. 5th line crosses 1st line and point of intersection is (1,4)\n        # 3. 2nd line crosses 4th line and point of intersection is (4,1)\n        # 4. 1st line crosses 3rd line and point of intersection is (2,3)\n        # 5. 3rd line crosses 5th line and point of intersection is (3,2)\n        \n        # 1. 4th line crosses 1st line and point of intersection is (2,2)\n        # 2. 5th line crosses 1st line and point of intersection is (1,4)\n        # 3. 2nd line crosses 4th line and point of intersection is (4,1)\n        # 4. 1st line crosses 3rd line and point of intersection is (2,3)\n        # 5. 3rd line crosses 5th line and point of intersection is (3,2)\n        \n        # 1. 4th line crosses 1st line and point of intersection is (2,2)\n        # 2. 5th line crosses 1st line and point of intersection is (1,4)\n        # 3. 2nd line crosses 4th line and point of intersection is (4,1)\n        # 4. 1st line crosses 3rd line and point of intersection is (2,3)\n        # 5. 3rd line crosses 5th line and point of intersection is (3,2)\n        \n        # 1. 4th line crosses 1st line and point of intersection is (2,2)\n        # 2. 5th line crosses 1st line and point of intersection is (1,4)\n        # 3. 2nd line crosses 4th line and point of intersection is (4,1)\n        # 4. 1st line crosses 3rd line and point of intersection is (2"}, {"task_id": "self-crossing", "completion": "class Solution(object):\n    def isSelfCrossing(self, distance):\n        \"\"\"\n        :type distance: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. 4 points cross\n        # 2. 5 points cross\n        # 3. 6 points cross\n        \n        # 1. 4 points cross\n        # 2. 5 points cross\n        # 3. 6 points cross\n        \n        # 1. 4 points cross\n        # 2. 5 points cross\n        # 3. 6 points cross\n        \n        # 1. 4 points cross\n        # 2. 5 points cross\n        # 3. 6 points cross\n        \n        # 1. 4 points cross\n        # 2. 5 points cross\n        # 3. 6 points cross\n        \n        # 1. 4 points cross\n        # 2. 5 points cross\n        # 3. 6 points cross\n        \n        # 1. 4 points cross\n        # 2. 5 points cross\n        # 3. 6 points cross\n        \n        # 1. 4 points cross\n        # 2. 5 points cross\n        # 3. 6 points cross\n        \n        # 1. 4 points cross\n        # 2. 5 points cross\n        # 3. 6 points cross\n        \n        # 1. 4 points cross\n        # 2. 5 points cross\n        # 3. 6 points cross\n        \n        # 1. 4 points cross\n        # 2. 5 points cross\n        # 3. 6 points cross\n        \n        # 1. 4 points cross\n        # 2. 5 points cross\n        # 3. 6 points cross\n        \n        # 1. 4 points cross\n        # 2. 5 points cross\n        # 3. 6 points cross\n        \n        # 1. 4 points cross\n        # 2. 5 points cross\n        # 3. 6 points cross\n        \n        # 1. 4 points cross\n        # 2. 5 points cross\n        # 3. 6 points cross\n        \n        # 1. 4 points cross\n        # 2. 5 points cross\n        # 3. 6 points cross\n        \n        # 1. 4 points cross\n        # 2. 5 points cross\n        # 3. 6 points cross\n        \n        # 1. 4 points cross\n        # 2. 5 points cross\n        # 3. 6 points cross\n        \n        # 1. 4 points cross\n        # 2. 5 points cross\n        # 3. 6 points cross\n        \n        # 1. 4 points cross\n        # 2. 5 points cross\n        # 3. 6 points cross\n        \n        # 1. 4 points cross\n        # 2. 5 points cross\n        # 3. 6 points cross\n        \n        # 1. 4 points cross\n        # 2. 5 points cross\n        # 3. 6 points cross\n        \n        # 1. 4 points cross\n        # 2. 5 points cross\n        # 3. 6 points cross\n        \n        # 1. 4 points cross\n        # 2. 5 points cross\n        # 3. 6 points cross\n        \n        # 1. 4 points cross\n        # 2. 5 points cross\n        # 3. 6 points cross\n        \n        # 1. 4 points cross\n        # 2. 5 points cross\n        # 3. 6 points cross\n        \n        # 1. 4 points cross\n        # 2. 5 points cross\n        # 3. 6 points cross\n        \n        # 1. 4 points cross\n        # 2. 5 points cross\n        # 3. 6 points cross\n        \n        # 1. 4 points cross\n        # 2. 5 points cross\n        # 3. 6 points cross\n        \n        # 1. 4 points cross\n        # 2. 5 points cross\n        # 3. 6 points cross\n        \n        # 1. 4 points cross\n        # 2. 5 points cross\n        # 3. 6 points cross\n        \n        # 1. 4 points cross\n        # 2. 5 points cross\n        # 3. 6 points cross"}], "remove-duplicates-from-sorted-list": [{"task_id": "remove-duplicates-from-sorted-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if head == None:\n            return head\n        \n        curr = head\n        while curr.next != None:\n            if curr.val == curr.next.val:\n                curr.next = curr.next.next\n            else:\n                curr = curr.next\n        \n        return head"}, {"task_id": "remove-duplicates-from-sorted-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if head == None:\n            return head\n        \n        curr = head\n        while curr.next != None:\n            if curr.val == curr.next.val:\n                curr.next = curr.next.next\n            else:\n                curr = curr.next\n        \n        return head"}, {"task_id": "remove-duplicates-from-sorted-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if head == None:\n            return head\n        \n        curr = head\n        while curr.next != None:\n            if curr.val == curr.next.val:\n                curr.next = curr.next.next\n            else:\n                curr = curr.next\n        \n        return head"}, {"task_id": "remove-duplicates-from-sorted-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if head == None:\n            return head\n        \n        curr = head\n        while curr.next != None:\n            if curr.val == curr.next.val:\n                curr.next = curr.next.next\n            else:\n                curr = curr.next\n        \n        return head"}, {"task_id": "remove-duplicates-from-sorted-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if head == None:\n            return head\n        \n        curr = head\n        while curr.next != None:\n            if curr.val == curr.next.val:\n                curr.next = curr.next.next\n            else:\n                curr = curr.next\n        \n        return head"}], "longest-palindrome": [{"task_id": "longest-palindrome", "completion": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. create a dictionary to store the frequency of each character in the string\n        # 2. iterate through the dictionary and add the even values to the result\n        # 3. if there is an odd value, add it to the result\n        # 4. if there is an odd value, add it to the result\n        # 5. if there is an odd value, add it to the result\n        # 6. if there is an odd value, add it to the result\n        # 7. if there is an odd value, add it to the result\n        # 8. if there is an odd value, add it to the result\n        # 9. if there is an odd value, add it to the result\n        # 10. if there is an odd value, add it to the result\n        # 11. if there is an odd value, add it to the result\n        # 12. if there is an odd value, add it to the result\n        # 13. if there is an odd value, add it to the result\n        # 14. if there is an odd value, add it to the result\n        # 15. if there is an odd value, add it to the result\n        # 16. if there is an odd value, add it to the result\n        # 17. if there is an odd value, add it to the result\n        # 18. if there is an odd value, add it to the result\n        # 19. if there is an odd value, add it to the result\n        # 20. if there is an odd value, add it to the result\n        # 21. if there is an odd value, add it to the result\n        # 22. if there is an odd value, add it to the result\n        # 23. if there is an odd value, add it to the result\n        # 24. if there is an odd value, add it to the result\n        # 25. if there is an odd value, add it to the result\n        # 26. if there is an odd value, add it to the result\n        # 27. if there is an odd value, add it to the result\n        # 28. if there is an odd value, add it to the result\n        # 29. if there is an odd value, add it to the result\n        # 30. if there is an odd value, add it to the result\n        # 31. if there is an odd value, add it to the result\n        # 32. if there is an odd value, add it to the result\n        # 33. if there is an odd value, add it to the result\n        # 34. if there is an odd value, add it to the result\n        # 35. if there is an odd value, add it to the result\n        # 36. if there is an odd value, add it to the result\n        # 37. if there is an odd value, add it to the result\n        # 38. if there is an odd value, add it to the result\n        # 39. if there is an odd value, add it to the result\n        # 40. if there is an odd value, add it to the result\n        # 41. if there is an odd value, add it to the result\n        # 42. if there is an odd value, add it to the result\n        # 43. if there is an odd value, add it to the result\n        # 44. if there is an odd value, add it to the result\n        # 45. if there is an odd value, add it to the result\n        # 46. if there is an odd value, add it to the result\n        # 47. if there is an odd value, add it to the result\n        # 48. if there is an odd value, add it to the result\n        # 49. if there is an odd value, add it to the result\n        # 50. if there is an odd value, add it to the result\n        # 51. if there is an odd value, add it to the result\n        # 52. if there is an odd value, add it to the result\n        # 53. if there is an odd value, add it to the result\n        # 54. if there is an odd value, add it to the result\n        # 55"}, {"task_id": "longest-palindrome", "completion": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. create a dictionary to store the frequency of each character in the string\n        # 2. iterate through the dictionary and add the even numbers to the result\n        # 3. if there is an odd number, add it to the result\n        # 4. if there is an odd number, add it to the result\n        # 5. if there is an odd number, add it to the result\n        # 6. if there is an odd number, add it to the result\n        # 7. if there is an odd number, add it to the result\n        # 8. if there is an odd number, add it to the result\n        # 9. if there is an odd number, add it to the result\n        # 10. if there is an odd number, add it to the result\n        # 11. if there is an odd number, add it to the result\n        # 12. if there is an odd number, add it to the result\n        # 13. if there is an odd number, add it to the result\n        # 14. if there is an odd number, add it to the result\n        # 15. if there is an odd number, add it to the result\n        # 16. if there is an odd number, add it to the result\n        # 17. if there is an odd number, add it to the result\n        # 18. if there is an odd number, add it to the result\n        # 19. if there is an odd number, add it to the result\n        # 20. if there is an odd number, add it to the result\n        # 21. if there is an odd number, add it to the result\n        # 22. if there is an odd number, add it to the result\n        # 23. if there is an odd number, add it to the result\n        # 24. if there is an odd number, add it to the result\n        # 25. if there is an odd number, add it to the result\n        # 26. if there is an odd number, add it to the result\n        # 27. if there is an odd number, add it to the result\n        # 28. if there is an odd number, add it to the result\n        # 29. if there is an odd number, add it to the result\n        # 30. if there is an odd number, add it to the result\n        # 31. if there is an odd number, add it to the result\n        # 32. if there is an odd number, add it to the result\n        # 33. if there is an odd number, add it to the result\n        # 34. if there is an odd number, add it to the result\n        # 35. if there is an odd number, add it to the result\n        # 36. if there is an odd number, add it to the result\n        # 37. if there is an odd number, add it to the result\n        # 38. if there is an odd number, add it to the result\n        # 39. if there is an odd number, add it to the result\n        # 40. if there is an odd number, add it to the result\n        # 41. if there is an odd number, add it to the result\n        # 42. if there is an odd number, add it to the result\n        # 43. if there is an odd number, add it to the result\n        # 44. if there is an odd number, add it to the result\n        # 45. if there is an odd number, add it to the result\n        # 46. if there is an odd number, add it to the result\n        # 47. if there is an odd number, add it to the result\n        # 48. if there is an odd number, add it to the result\n        # 49. if there is an odd number, add it to the result\n        # 50. if there is an odd number, add it to the result\n        # 51. if there is an odd number, add it to the result\n        # 52. if there is an odd number, add it to the result\n        # 53. if there is an odd number, add it to the result\n        # 54. if there is an odd number, add it to the result\n        # 55"}, {"task_id": "longest-palindrome", "completion": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. create a dictionary to store the frequency of each character in the string\n        # 2. iterate through the dictionary and add the even values to the result\n        # 3. if there is an odd value, add it to the result\n        # 4. if there is an odd value, add it to the result\n        # 5. if there is an odd value, add it to the result\n        # 6. if there is an odd value, add it to the result\n        # 7. if there is an odd value, add it to the result\n        # 8. if there is an odd value, add it to the result\n        # 9. if there is an odd value, add it to the result\n        # 10. if there is an odd value, add it to the result\n        # 11. if there is an odd value, add it to the result\n        # 12. if there is an odd value, add it to the result\n        # 13. if there is an odd value, add it to the result\n        # 14. if there is an odd value, add it to the result\n        # 15. if there is an odd value, add it to the result\n        # 16. if there is an odd value, add it to the result\n        # 17. if there is an odd value, add it to the result\n        # 18. if there is an odd value, add it to the result\n        # 19. if there is an odd value, add it to the result\n        # 20. if there is an odd value, add it to the result\n        # 21. if there is an odd value, add it to the result\n        # 22. if there is an odd value, add it to the result\n        # 23. if there is an odd value, add it to the result\n        # 24. if there is an odd value, add it to the result\n        # 25. if there is an odd value, add it to the result\n        # 26. if there is an odd value, add it to the result\n        # 27. if there is an odd value, add it to the result\n        # 28. if there is an odd value, add it to the result\n        # 29. if there is an odd value, add it to the result\n        # 30. if there is an odd value, add it to the result\n        # 31. if there is an odd value, add it to the result\n        # 32. if there is an odd value, add it to the result\n        # 33. if there is an odd value, add it to the result\n        # 34. if there is an odd value, add it to the result\n        # 35. if there is an odd value, add it to the result\n        # 36. if there is an odd value, add it to the result\n        # 37. if there is an odd value, add it to the result\n        # 38. if there is an odd value, add it to the result\n        # 39. if there is an odd value, add it to the result\n        # 40. if there is an odd value, add it to the result\n        # 41. if there is an odd value, add it to the result\n        # 42. if there is an odd value, add it to the result\n        # 43. if there is an odd value, add it to the result\n        # 44. if there is an odd value, add it to the result\n        # 45. if there is an odd value, add it to the result\n        # 46. if there is an odd value, add it to the result\n        # 47. if there is an odd value, add it to the result\n        # 48. if there is an odd value, add it to the result\n        # 49. if there is an odd value, add it to the result\n        # 50. if there is an odd value, add it to the result\n        # 51. if there is an odd value, add it to the result\n        # 52. if there is an odd value, add it to the result\n        # 53. if there is an odd value, add it to the result\n        # 54. if there is an odd value, add it to the result\n        # 55"}, {"task_id": "longest-palindrome", "completion": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. create a dictionary to store the frequency of each character in the string\n        # 2. iterate through the dictionary and add the even numbers to the result\n        # 3. if there is an odd number, add it to the result\n        # 4. if there is an odd number, add it to the result\n        # 5. if there is an odd number, add it to the result\n        # 6. if there is an odd number, add it to the result\n        # 7. if there is an odd number, add it to the result\n        # 8. if there is an odd number, add it to the result\n        # 9. if there is an odd number, add it to the result\n        # 10. if there is an odd number, add it to the result\n        # 11. if there is an odd number, add it to the result\n        # 12. if there is an odd number, add it to the result\n        # 13. if there is an odd number, add it to the result\n        # 14. if there is an odd number, add it to the result\n        # 15. if there is an odd number, add it to the result\n        # 16. if there is an odd number, add it to the result\n        # 17. if there is an odd number, add it to the result\n        # 18. if there is an odd number, add it to the result\n        # 19. if there is an odd number, add it to the result\n        # 20. if there is an odd number, add it to the result\n        # 21. if there is an odd number, add it to the result\n        # 22. if there is an odd number, add it to the result\n        # 23. if there is an odd number, add it to the result\n        # 24. if there is an odd number, add it to the result\n        # 25. if there is an odd number, add it to the result\n        # 26. if there is an odd number, add it to the result\n        # 27. if there is an odd number, add it to the result\n        # 28. if there is an odd number, add it to the result\n        # 29. if there is an odd number, add it to the result\n        # 30. if there is an odd number, add it to the result\n        # 31. if there is an odd number, add it to the result\n        # 32. if there is an odd number, add it to the result\n        # 33. if there is an odd number, add it to the result\n        # 34. if there is an odd number, add it to the result\n        # 35. if there is an odd number, add it to the result\n        # 36. if there is an odd number, add it to the result\n        # 37. if there is an odd number, add it to the result\n        # 38. if there is an odd number, add it to the result\n        # 39. if there is an odd number, add it to the result\n        # 40. if there is an odd number, add it to the result\n        # 41. if there is an odd number, add it to the result\n        # 42. if there is an odd number, add it to the result\n        # 43. if there is an odd number, add it to the result\n        # 44. if there is an odd number, add it to the result\n        # 45. if there is an odd number, add it to the result\n        # 46. if there is an odd number, add it to the result\n        # 47. if there is an odd number, add it to the result\n        # 48. if there is an odd number, add it to the result\n        # 49. if there is an odd number, add it to the result\n        # 50. if there is an odd number, add it to the result\n        # 51. if there is an odd number, add it to the result\n        # 52. if there is an odd number, add it to the result\n        # 53. if there is an odd number, add it to the result\n        # 54. if there is an odd number, add it to the result\n        # 55"}, {"task_id": "longest-palindrome", "completion": "class Solution(object):\n    def longestPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. create a dictionary to store the count of each character\n        # 2. iterate through the dictionary and add the even count to the result\n        # 3. if there is any odd count, add 1 to the result\n        # 4. return the result\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # create a dictionary to store the count of each character\n        char_count = {}\n        \n        # iterate through the string and add the count to the dictionary\n        for char in s:\n            if char in char_count:\n                char_count[char] += 1\n            else:\n                char_count[char] = 1\n        \n        # iterate through the dictionary and add the even count to the result\n        result = 0\n        for char in char_count:\n            result += char_count[char] // 2 * 2\n        \n        # if there is any odd count, add 1 to the result\n        if any(char_count[char] % 2 == 1 for char in char_count):\n            result += 1\n        \n        return result"}], "construct-binary-tree-from-inorder-and-postorder-traversal": [{"task_id": "construct-binary-tree-from-inorder-and-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not inorder or not postorder:\n            return None\n        \n        root = TreeNode(postorder.pop())\n        mid = inorder.index(root.val)\n        \n        root.right = self.buildTree(inorder[mid+1:], postorder)\n        root.left = self.buildTree(inorder[:mid], postorder)\n        \n        return root"}, {"task_id": "construct-binary-tree-from-inorder-and-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not inorder or not postorder:\n            return None\n        \n        root = TreeNode(postorder.pop())\n        mid = inorder.index(root.val)\n        \n        root.right = self.buildTree(inorder[mid+1:], postorder)\n        root.left = self.buildTree(inorder[:mid], postorder)\n        \n        return root"}, {"task_id": "construct-binary-tree-from-inorder-and-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not inorder or not postorder:\n            return None\n        \n        root = TreeNode(postorder.pop())\n        mid = inorder.index(root.val)\n        \n        root.right = self.buildTree(inorder[mid+1:], postorder)\n        root.left = self.buildTree(inorder[:mid], postorder)\n        \n        return root"}, {"task_id": "construct-binary-tree-from-inorder-and-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not inorder or not postorder:\n            return None\n        \n        root = TreeNode(postorder.pop())\n        mid = inorder.index(root.val)\n        \n        root.right = self.buildTree(inorder[mid+1:], postorder)\n        root.left = self.buildTree(inorder[:mid], postorder)\n        \n        return root"}, {"task_id": "construct-binary-tree-from-inorder-and-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not inorder or not postorder:\n            return None\n        \n        root = TreeNode(postorder.pop())\n        mid = inorder.index(root.val)\n        \n        root.right = self.buildTree(inorder[mid+1:], postorder)\n        root.left = self.buildTree(inorder[:mid], postorder)\n        \n        return root"}], "cut-off-trees-for-golf-event": [{"task_id": "cut-off-trees-for-golf-event", "completion": "class Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # 1. find all the trees and sort them by height\n        # 2. for each tree, find the shortest path to the next tree\n        # 3. if the shortest path is not possible, return -1\n        # 4. if the shortest path is possible, add the number of steps to the total number of steps\n        # 5. return the total number of steps\n        \n        # 1. find all the trees and sort them by height\n        trees = []\n        for i in range(len(forest)):\n            for j in range(len(forest[0])):\n                if forest[i][j] > 1:\n                    trees.append((forest[i][j], i, j))\n        trees.sort()\n        \n        # 2. for each tree, find the shortest path to the next tree\n        # 3. if the shortest path is not possible, return -1\n        # 4. if the shortest path is possible, add the number of steps to the total number of steps\n        # 5. return the total number of steps\n        total_steps = 0\n        for i in range(len(trees)):\n            if i == 0:\n                start = (0, 0)\n            else:\n                start = (trees[i-1][1], trees[i-1][2])\n            end = (trees[i][1], trees[i][2])\n            steps = self.bfs(forest, start, end)\n            if steps == -1:\n                return -1\n            total_steps += steps\n        return total_steps\n    \n    def bfs(self, forest, start, end):\n        # 1. create a queue and add the start node\n        # 2. create a visited set and add the start node\n        # 3. while the queue is not empty, pop the first node\n        # 4. if the node is the end node, return the number of steps\n        # 5. if the node is not the end node, add the node's neighbors to the queue\n        # 6. if the node's neighbor is not in the visited set and the neighbor is not a wall, add the neighbor to the visited set and add the number of steps to the neighbor\n        # 7. if the queue is empty and the end node is not in the visited set, return -1\n        # 8. if the queue is empty and the end node is in the visited set, return the number of steps\n        \n        # 1. create a queue and add the start node\n        queue = [(start[0], start[1], 0)]\n        # 2. create a visited set and add the start node\n        visited = set()\n        visited.add((start[0], start[1]))\n        # 3. while the queue is not empty, pop the first node\n        while queue:\n            node = queue.pop(0)\n            # 4. if the node is the end node, return the number of steps\n            if node[0] == end[0] and node[1] == end[1]:\n                return node[2]\n            # 5. if the node is not the end node, add the node's neighbors to the queue\n            # 6. if the node's neighbor is not in the visited set and the neighbor is not a wall, add the neighbor to the visited set and add the number of steps to the neighbor\n            for i, j in [(node[0]+1, node[1]), (node[0]-1, node[1]), (node[0], node[1]+1), (node[0], node[1]-1)]:\n                if 0 <= i < len(forest) and 0 <= j < len(forest[0]) and (i, j) not in visited and forest[i][j] != 0:\n                    visited.add((i, j))\n                    queue.append((i, j, node[2]+1))\n        # 7. if the queue is empty and the end node is not in the visited set, return -1\n        # 8. if the queue is empty and the end node is in the visited set, return the number of steps\n        if (end[0], end[1]) not in visited:\n            return -1\n        else:\n            return node[2]"}, {"task_id": "cut-off-trees-for-golf-event", "completion": "class Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # 1. find all the trees and sort them by height\n        # 2. for each tree, find the shortest path to the next tree\n        # 3. if the shortest path is not possible, return -1\n        # 4. if the shortest path is possible, add the number of steps to the total number of steps\n        \n        # 1. find all the trees and sort them by height\n        trees = []\n        for i in range(len(forest)):\n            for j in range(len(forest[0])):\n                if forest[i][j] > 1:\n                    trees.append((forest[i][j], i, j))\n        trees.sort()\n        \n        # 2. for each tree, find the shortest path to the next tree\n        # 3. if the shortest path is not possible, return -1\n        # 4. if the shortest path is possible, add the number of steps to the total number of steps\n        total_steps = 0\n        curr_i, curr_j = 0, 0\n        for tree in trees:\n            steps = self.bfs(forest, curr_i, curr_j, tree[1], tree[2])\n            if steps == -1:\n                return -1\n            total_steps += steps\n            curr_i, curr_j = tree[1], tree[2]\n        return total_steps\n    \n    def bfs(self, forest, curr_i, curr_j, target_i, target_j):\n        # 2. for each tree, find the shortest path to the next tree\n        # 3. if the shortest path is not possible, return -1\n        # 4. if the shortest path is possible, add the number of steps to the total number of steps\n        queue = [(curr_i, curr_j, 0)]\n        visited = set()\n        while queue:\n            i, j, steps = queue.pop(0)\n            if (i, j) == (target_i, target_j):\n                return steps\n            if (i, j) in visited:\n                continue\n            visited.add((i, j))\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                ni, nj = i + di, j + dj\n                if 0 <= ni < len(forest) and 0 <= nj < len(forest[0]) and forest[ni][nj] > 0:\n                    queue.append((ni, nj, steps + 1))\n        return -1"}, {"task_id": "cut-off-trees-for-golf-event", "completion": "class Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # 1. find all the trees and sort them by height\n        # 2. for each tree, find the shortest path to the next tree\n        # 3. if the path is not possible, return -1\n        # 4. if the path is possible, add the number of steps to the total number of steps\n        \n        # 1. find all the trees and sort them by height\n        trees = []\n        for i in range(len(forest)):\n            for j in range(len(forest[0])):\n                if forest[i][j] > 1:\n                    trees.append((forest[i][j], i, j))\n        trees.sort()\n        \n        # 2. for each tree, find the shortest path to the next tree\n        # 3. if the path is not possible, return -1\n        # 4. if the path is possible, add the number of steps to the total number of steps\n        total_steps = 0\n        curr_i, curr_j = 0, 0\n        for tree in trees:\n            steps = self.bfs(forest, curr_i, curr_j, tree[1], tree[2])\n            if steps == -1:\n                return -1\n            total_steps += steps\n            curr_i, curr_j = tree[1], tree[2]\n        return total_steps\n    \n    def bfs(self, forest, curr_i, curr_j, target_i, target_j):\n        # 2. for each tree, find the shortest path to the next tree\n        # 3. if the path is not possible, return -1\n        # 4. if the path is possible, add the number of steps to the total number of steps\n        queue = [(curr_i, curr_j, 0)]\n        visited = set()\n        while queue:\n            i, j, steps = queue.pop(0)\n            if (i, j) == (target_i, target_j):\n                return steps\n            if (i, j) in visited:\n                continue\n            visited.add((i, j))\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                ni, nj = i + di, j + dj\n                if 0 <= ni < len(forest) and 0 <= nj < len(forest[0]) and forest[ni][nj] > 0:\n                    queue.append((ni, nj, steps + 1))\n        return -1"}, {"task_id": "cut-off-trees-for-golf-event", "completion": "class Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # 1. find all the trees and sort them by height\n        # 2. for each tree, find the shortest path to the next tree\n        # 3. if the path is not possible, return -1\n        # 4. if the path is possible, add the number of steps to the total number of steps\n        # 5. return the total number of steps\n        \n        # 1. find all the trees and sort them by height\n        trees = []\n        for i in range(len(forest)):\n            for j in range(len(forest[0])):\n                if forest[i][j] > 1:\n                    trees.append((forest[i][j], i, j))\n        trees.sort()\n        \n        # 2. for each tree, find the shortest path to the next tree\n        # 3. if the path is not possible, return -1\n        # 4. if the path is possible, add the number of steps to the total number of steps\n        # 5. return the total number of steps\n        total_steps = 0\n        curr_i, curr_j = 0, 0\n        for tree in trees:\n            steps = self.bfs(forest, curr_i, curr_j, tree[1], tree[2])\n            if steps == -1:\n                return -1\n            total_steps += steps\n            curr_i, curr_j = tree[1], tree[2]\n        return total_steps\n    \n    def bfs(self, forest, curr_i, curr_j, target_i, target_j):\n        # 2. for each tree, find the shortest path to the next tree\n        # 3. if the path is not possible, return -1\n        # 4. if the path is possible, add the number of steps to the total number of steps\n        # 5. return the total number of steps\n        queue = [(curr_i, curr_j, 0)]\n        visited = set()\n        while queue:\n            i, j, steps = queue.pop(0)\n            if (i, j) == (target_i, target_j):\n                return steps\n            if (i, j) in visited:\n                continue\n            visited.add((i, j))\n            for di, dj in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                ni, nj = i + di, j + dj\n                if 0 <= ni < len(forest) and 0 <= nj < len(forest[0]) and forest[ni][nj] > 0:\n                    queue.append((ni, nj, steps + 1))\n        return -1"}, {"task_id": "cut-off-trees-for-golf-event", "completion": "class Solution(object):\n    def cutOffTree(self, forest):\n        \"\"\"\n        :type forest: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # 1. find all the trees\n        # 2. sort the trees by height\n        # 3. for each tree, find the shortest path to the next tree\n        # 4. return the sum of the shortest paths\n        \n        # 1. find all the trees\n        trees = []\n        for i in range(len(forest)):\n            for j in range(len(forest[0])):\n                if forest[i][j] > 1:\n                    trees.append((forest[i][j], i, j))\n        trees.sort()\n        \n        # 2. sort the trees by height\n        trees = [(0, 0, 0)] + trees\n        \n        # 3. for each tree, find the shortest path to the next tree\n        total_steps = 0\n        for i in range(len(trees) - 1):\n            steps = self.bfs(forest, trees[i], trees[i + 1])\n            if steps == -1:\n                return -1\n            total_steps += steps\n        \n        # 4. return the sum of the shortest paths\n        return total_steps\n    \n    def bfs(self, forest, start, end):\n        # 3. for each tree, find the shortest path to the next tree\n        # 3.1. find the shortest path to the next tree\n        # 3.2. return the shortest path\n        # 3.3. if the shortest path is -1, return -1\n        # 3.4. if the shortest path is 0, return 0\n        # 3.5. if the shortest path is 1, return 1\n        # 3.6. if the shortest path is 2, return 2\n        # 3.7. if the shortest path is 3, return 3\n        # 3.8. if the shortest path is 4, return 4\n        # 3.9. if the shortest path is 5, return 5\n        # 3.10. if the shortest path is 6, return 6\n        # 3.11. if the shortest path is 7, return 7\n        # 3.12. if the shortest path is 8, return 8\n        # 3.13. if the shortest path is 9, return 9\n        # 3.14. if the shortest path is 10, return 10\n        # 3.15. if the shortest path is 11, return 11\n        # 3.16. if the shortest path is 12, return 12\n        # 3.17. if the shortest path is 13, return 13\n        # 3.18. if the shortest path is 14, return 14\n        # 3.19. if the shortest path is 15, return 15\n        # 3.20. if the shortest path is 16, return 16\n        # 3.21. if the shortest path is 17, return 17\n        # 3.22. if the shortest path is 18, return 18\n        # 3.23. if the shortest path is 19, return 19\n        # 3.24. if the shortest path is 20, return 20\n        # 3.25. if the shortest path is 21, return 21\n        # 3.26. if the shortest path is 22, return 22\n        # 3.27. if the shortest path is 23, return 23\n        # 3.28. if the shortest path is 24, return 24\n        # 3.29. if the shortest path is 25, return 25\n        # 3.30. if the shortest path is 26, return 26\n        # 3.31. if the shortest path is 27, return 27\n        # 3.32. if the shortest path is 28, return 28\n        # 3.33. if the shortest path is 29, return 29\n        # 3."}], "minimum-depth-of-binary-tree": [{"task_id": "minimum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        if not root.left and not root.right:\n            return 1\n        \n        if not root.left:\n            return self.minDepth(root.right) + 1\n        \n        if not root.right:\n            return self.minDepth(root.left) + 1\n        \n        return min(self.minDepth(root.left), self.minDepth(root.right)) + 1"}, {"task_id": "minimum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if root is None:\n            return 0\n        \n        if root.left is None and root.right is None:\n            return 1\n        \n        if root.left is None:\n            return self.minDepth(root.right) + 1\n        \n        if root.right is None:\n            return self.minDepth(root.left) + 1\n        \n        return min(self.minDepth(root.left), self.minDepth(root.right)) + 1"}, {"task_id": "minimum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        if not root.left and not root.right:\n            return 1\n        \n        if not root.left:\n            return self.minDepth(root.right) + 1\n        \n        if not root.right:\n            return self.minDepth(root.left) + 1\n        \n        return min(self.minDepth(root.left), self.minDepth(root.right)) + 1"}, {"task_id": "minimum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        if not root.left and not root.right:\n            return 1\n        \n        if not root.left:\n            return self.minDepth(root.right) + 1\n        \n        if not root.right:\n            return self.minDepth(root.left) + 1\n        \n        return min(self.minDepth(root.left), self.minDepth(root.right)) + 1"}, {"task_id": "minimum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def minDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        if not root:\n            return 0\n        \n        if not root.left and not root.right:\n            return 1\n        \n        if not root.left:\n            return self.minDepth(root.right) + 1\n        \n        if not root.right:\n            return self.minDepth(root.left) + 1\n        \n        return min(self.minDepth(root.left), self.minDepth(root.right)) + 1"}], "count-of-range-sum": [{"task_id": "count-of-range-sum", "completion": "class Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        \n        def merge(left, right):\n            i = j = 0\n            for num in left:\n                while i < len(right) and right[i] - num < lower:\n                    i += 1\n                while j < len(right) and right[j] - num <= upper:\n                    j += 1\n                count += j - i\n            return sorted(left + right)\n        \n        def merge_sort(nums):\n            if len(nums) <= 1:\n                return nums\n            mid = len(nums) // 2\n            left = merge_sort(nums[:mid])\n            right = merge_sort(nums[mid:])\n            return merge(left, right)\n        \n        count = 0\n        merge_sort([0] + list(accumulate(nums)))\n        return count"}, {"task_id": "count-of-range-sum", "completion": "class Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        \n        def merge(arr, start, mid, end):\n            #print(start, mid, end)\n            left = arr[start:mid+1]\n            right = arr[mid+1:end+1]\n            #print(left, right)\n            i = j = 0\n            count = 0\n            for k in range(start, end+1):\n                if i < len(left) and j < len(right):\n                    if left[i] <= right[j]:\n                        arr[k] = left[i]\n                        i += 1\n                    else:\n                        arr[k] = right[j]\n                        j += 1\n                        count += len(left) - i\n                elif i < len(left):\n                    arr[k] = left[i]\n                    i += 1\n                else:\n                    arr[k] = right[j]\n                    j += 1\n            return count\n        \n        def merge_sort(arr, start, end):\n            if start >= end:\n                return 0\n            mid = (start + end) // 2\n            count = merge_sort(arr, start, mid) + merge_sort(arr, mid+1, end)\n            count += merge(arr, start, mid, end)\n            return count\n        \n        prefix_sum = [0]\n        for num in nums:\n            prefix_sum.append(prefix_sum[-1] + num)\n        #print(prefix_sum)\n        return merge_sort(prefix_sum, 0, len(prefixum)-1)"}, {"task_id": "count-of-range-sum", "completion": "class Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        \n        def merge(left, right):\n            i = j = 0\n            for num in left:\n                while i < len(right) and right[i] - num < lower:\n                    i += 1\n                while j < len(right) and right[j] - num <= upper:\n                    j += 1\n                count += j - i\n            return sorted(left + right)\n        \n        def merge_sort(nums):\n            if len(nums) <= 1:\n                return nums\n            mid = len(nums) // 2\n            left = merge_sort(nums[:mid])\n            right = merge_sort(nums[mid:])\n            return merge(left, right)\n        \n        count = 0\n        merge_sort([0] + list(accumulate(nums)))\n        return count"}, {"task_id": "count-of-range-sum", "completion": "class Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        \n        def merge(left, right):\n            i = j = 0\n            for num in left:\n                while i < len(right) and right[i] - num < lower:\n                    i += 1\n                while j < len(right) and right[j] - num <= upper:\n                    j += 1\n                count += j - i\n            return sorted(left + right)\n        \n        def merge_sort(nums):\n            if len(nums) <= 1:\n                return nums\n            mid = len(nums) // 2\n            left = merge_sort(nums[:mid])\n            right = merge_sort(nums[mid:])\n            return merge(left, right)\n        \n        count = 0\n        merge_sort([0] + list(accumulate(nums)))\n        return count"}, {"task_id": "count-of-range-sum", "completion": "class Solution(object):\n    def countRangeSum(self, nums, lower, upper):\n        \"\"\"\n        :type nums: List[int]\n        :type lower: int\n        :type upper: int\n        :rtype: int\n        \"\"\"\n        \n        def merge(arr, start, mid, end):\n            left = arr[start:mid+1]\n            right = arr[mid+1:end+1]\n            i = j = 0\n            count = 0\n            for k in range(start, end+1):\n                if j >= len(right) or (i < len(left) and left[i] <= right[j]):\n                    arr[k] = left[i]\n                    i += 1\n                    if left[i-1] >= lower and left[i-1] <= upper:\n                        count += 1\n                else:\n                    arr[k] = right[j]\n                    j += 1\n                    if right[j-1] >= lower and right[j-1] <= upper:\n                        count += 1\n            return count\n        \n        def merge_sort(arr, start, end):\n            if start >= end:\n                return 0\n            mid = (start + end) // 2\n            count = merge_sort(arr, start, mid) + merge_sort(arr, mid+1, end)\n            return count + merge(arr, start, mid, end)\n        \n        prefix_sum = [0]\n        for num in nums:\n            prefix_sum.append(prefix_sum[-1] + num)\n        return merge_sort(prefix_sum, 0, len(prefix"}], "arranging-coins": [{"task_id": "arranging-coins", "completion": "class Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1 + 2 + 3 + ... + k <= n\n        # k(k+1)/2 <= n\n        # k^2 + k <= 2n\n        # k^2 + k - 2n <= 0\n        # k = (-1 + sqrt(1 + 8n))/2\n        \n        return int((-1 + math.sqrt(1 + 8*n))/2)"}, {"task_id": "arranging-coins", "completion": "class Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1 + 2 + 3 + ... + k <= n\n        # k(k+1)/2 <= n\n        # k^2 + k <= 2n\n        # k^2 + k - 2n <= 0\n        # k = (-1 + sqrt(1 + 8n)) / 2\n        \n        return int((-1 + math.sqrt(1 + 8 * n)) / 2)"}, {"task_id": "arranging-coins", "completion": "class Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1 + 2 + 3 + ... + k <= n\n        # k(k+1)/2 <= n\n        # k^2 + k <= 2n\n        # k^2 + k - 2n <= 0\n        # k = (-1 + sqrt(1 + 8n)) / 2\n        \n        return int((-1 + math.sqrt(1 + 8*n)) / 2)"}, {"task_id": "arranging-coins", "completion": "class Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1 + 2 + 3 + ... + k <= n\n        # k(k+1)/2 <= n\n        # k^2 + k <= 2n\n        # k^2 + k - 2n <= 0\n        # k = (-1 + sqrt(1 + 8n)) / 2\n        \n        return int((-1 + math.sqrt(1 + 8 * n)) / 2)"}, {"task_id": "arranging-coins", "completion": "class Solution(object):\n    def arrangeCoins(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1 + 2 + 3 + ... + k <= n\n        # k(k+1)/2 <= n\n        # k^2 + k <= 2n\n        # k^2 + k - 2n <= 0\n        # k = (-1 + sqrt(1 + 8n)) / 2\n        \n        return int((-1 + math.sqrt(1 + 8 * n)) / 2)"}], "longest-uncommon-subsequence-i": [{"task_id": "longest-uncommon-subsequence-i", "completion": "class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        \n        if a == b:\n            return -1\n        else:\n            return max(len(a), len(b))"}, {"task_id": "longest-uncommon-subsequence-i", "completion": "class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        \n        if a == b:\n            return -1\n        else:\n            return max(len(a), len(b))"}, {"task_id": "longest-uncommon-subsequence-i", "completion": "class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        \n        if a == b:\n            return -1\n        else:\n            return max(len(a), len(b))"}, {"task_id": "longest-uncommon-subsequence-i", "completion": "class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        \n        if a == b:\n            return -1\n        else:\n            return max(len(a), len(b))"}, {"task_id": "longest-uncommon-subsequence-i", "completion": "class Solution(object):\n    def findLUSlength(self, a, b):\n        \"\"\"\n        :type a: str\n        :type b: str\n        :rtype: int\n        \"\"\"\n        \n        if a == b:\n            return -1\n        else:\n            return max(len(a), len(b))"}], "binary-tree-level-order-traversal-ii": [{"task_id": "binary-tree-level-order-traversal-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        res = []\n        \n        while queue:\n            level = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            res.append(level)\n        \n        return res[::-1]"}, {"task_id": "binary-tree-level-order-traversal-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        res = []\n        \n        while queue:\n            level = []\n            for _ in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            res.append(level)\n        \n        return res[::-1]"}, {"task_id": "binary-tree-level-order-traversal-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        q = [root]\n        res = []\n        \n        while q:\n            res.append([node.val for node in q])\n            q = [child for node in q for child in (node.left, node.right) if child]\n        \n        return res[::-1]"}, {"task_id": "binary-tree-level-order-traversal-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        result = []\n        \n        while queue:\n            level = []\n            for i in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            result.append(level)\n        \n        return result[::-1]"}, {"task_id": "binary-tree-level-order-traversal-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def levelOrderBottom(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        result = []\n        \n        while queue:\n            level = []\n            for i in range(len(queue)):\n                node = queue.pop(0)\n                level.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            result.append(level)\n        \n        return result[::-1]"}], "palindrome-number": [{"task_id": "palindrome-number", "completion": "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        \n        if x < 0:\n            return False\n        \n        if x < 10:\n            return True\n        \n        if x % 10 == 0:\n            return False\n        \n        reverse = 0\n        while x > reverse:\n            reverse = reverse * 10 + x % 10\n            x = x // 10\n        \n        return x == reverse or x == reverse // 10"}, {"task_id": "palindrome-number", "completion": "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        \n        if x < 0:\n            return False\n        \n        if x < 10:\n            return True\n        \n        if x % 10 == 0:\n            return False\n        \n        reverse = 0\n        while x > reverse:\n            reverse = reverse * 10 + x % 10\n            x = x // 10\n        \n        return x == reverse or x == reverse // 10"}, {"task_id": "palindrome-number", "completion": "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        \n        if x < 0:\n            return False\n        \n        if x < 10:\n            return True\n        \n        if x % 10 == 0:\n            return False\n        \n        reverse = 0\n        while x > reverse:\n            reverse = reverse * 10 + x % 10\n            x /= 10\n        \n        return x == reverse or x == reverse / 10"}, {"task_id": "palindrome-number", "completion": "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        \n        if x < 0:\n            return False\n        \n        if x < 10:\n            return True\n        \n        if x % 10 == 0:\n            return False\n        \n        reverse = 0\n        while x > reverse:\n            reverse = reverse * 10 + x % 10\n            x = x // 10\n        \n        return x == reverse or x == reverse // 10"}, {"task_id": "palindrome-number", "completion": "class Solution(object):\n    def isPalindrome(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: bool\n        \"\"\"\n        \n        if x < 0:\n            return False\n        \n        if x < 10:\n            return True\n        \n        if x % 10 == 0:\n            return False\n        \n        reverse = 0\n        while x > reverse:\n            reverse = reverse * 10 + x % 10\n            x /= 10\n        \n        return x == reverse or x == reverse / 10"}], "decode-ways": [{"task_id": "decode-ways", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i] = dp[i-1] + dp[i-2]\n        # dp[0] = 1\n        # dp[1] = 1\n        # dp[2] = dp[1] + dp[0]\n        # dp[3] = dp[2] + dp[1]\n        # dp[4] = dp[3] + dp[2]\n        # dp[5] = dp[4] + dp[3]\n        # dp[6] = dp[5] + dp[4]\n        # dp[7] = dp[6] + dp[5]\n        # dp[8] = dp[7] + dp[6]\n        # dp[9] = dp[8] + dp[7]\n        # dp[10] = dp[9] + dp[8]\n        # dp[11] = dp[10] + dp[9]\n        # dp[12] = dp[11] + dp[10]\n        # dp[13] = dp[12] + dp[11]\n        # dp[14] = dp[13] + dp[12]\n        # dp[15] = dp[14] + dp[13]\n        # dp[16] = dp[15] + dp[14]\n        # dp[17] = dp[16] + dp[15]\n        # dp[18] = dp[17] + dp[16]\n        # dp[19] = dp[18] + dp[17]\n        # dp[20] = dp[19] + dp[18]\n        # dp[21] = dp[20] + dp[19]\n        # dp[22] = dp[21] + dp[20]\n        # dp[23] = dp[22] + dp[21]\n        # dp[24] = dp[23] + dp[22]\n        # dp[25] = dp[24] + dp[23]\n        # dp[26] = dp[25] + dp[24]\n        # dp[27] = dp[26] + dp[25]\n        # dp[28] = dp[27] + dp[26]\n        # dp[29] = dp[28] + dp[27]\n        # dp[30] = dp[29] + dp[28]\n        # dp[31] = dp[30] + dp[29]\n        # dp[32] = dp[31] + dp[30]\n        # dp[33] = dp[32] + dp[31]\n        # dp[34] = dp[33] + dp[32]\n        # dp[35] = dp[34] + dp[33]\n        # dp[36] = dp[35] + dp[34]\n        # dp[37] = dp[36] + dp[35]\n        # dp[38] = dp[37] + dp[36]\n        # dp[39] = dp[38] + dp[37]\n        # dp[40] = dp[39] + dp[38]\n        # dp[41] = dp[40] + dp[39]\n        # dp[42] = dp[41] + dp[40]\n        # dp[43] = dp[42] + dp[41]\n        # dp[44] = dp[43] + dp[42]\n        # dp[45] = dp[44] + dp"}, {"task_id": "decode-ways", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i] = number of ways to decode s[:i]\n        # dp[0] = 1\n        # dp[i] = dp[i-1] if s[i-1] != '0'\n        # dp[i] += dp[i-2] if 10 <= int(s[i-2:i]) <= 26\n        # return dp[-1]\n        \n        if s[0] == '0':\n            return 0\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i-1] != '0':\n                dp[i] = dp[i-1]\n            if 10 <= int(s[i-2:i]) <= 26:\n                dp[i] += dp[i-2]\n        \n        return dp[-1]"}, {"task_id": "decode-ways", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i] = number of ways to decode s[:i]\n        # dp[0] = 1\n        # dp[i] = dp[i-1] if s[i-1] != '0'\n        # dp[i] += dp[i-2] if 10 <= int(s[i-2:i]) <= 26\n        # return dp[-1]\n        \n        # Time: O(n)\n        # Space: O(n)\n        \n        if s[0] == '0':\n            return 0\n        \n        dp = [0] * (len(s) + 1)\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if s[i-1] != '0':\n                dp[i] += dp[i-1]\n            if 10 <= int(s[i-2:i]) <= 26:\n                dp[i] += dp[i-2]\n        \n        return dp[-1]"}, {"task_id": "decode-ways", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # DP solution\n        # Time: O(n)\n        # Space: O(n)\n        \n        if s[0] == '0':\n            return 0\n        \n        dp = [0 for _ in range(len(s) + 1)]\n        dp[0] = 1\n        dp[1] = 1\n        \n        for i in range(2, len(s) + 1):\n            if 0 < int(s[i - 1:i]) <= 9:\n                dp[i] += dp[i - 1]\n            if 10 <= int(s[i - 2:i]) <= 26:\n                dp[i] += dp[i - 2]\n        \n        return dp[len(s)]"}, {"task_id": "decode-ways", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i] = dp[i-1] + dp[i-2]\n        # dp[0] = 1\n        # dp[1] = 1\n        # dp[2] = dp[1] + dp[0]\n        # dp[3] = dp[2] + dp[1]\n        # dp[4] = dp[3] + dp[2]\n        # dp[5] = dp[4] + dp[3]\n        # dp[6] = dp[5] + dp[4]\n        # dp[7] = dp[6] + dp[5]\n        # dp[8] = dp[7] + dp[6]\n        # dp[9] = dp[8] + dp[7]\n        # dp[10] = dp[9] + dp[8]\n        # dp[11] = dp[10] + dp[9]\n        # dp[12] = dp[11] + dp[10]\n        # dp[13] = dp[12] + dp[11]\n        # dp[14] = dp[13] + dp[12]\n        # dp[15] = dp[14] + dp[13]\n        # dp[16] = dp[15] + dp[14]\n        # dp[17] = dp[16] + dp[15]\n        # dp[18] = dp[17] + dp[16]\n        # dp[19] = dp[18] + dp[17]\n        # dp[20] = dp[19] + dp[18]\n        # dp[21] = dp[20] + dp[19]\n        # dp[22] = dp[21] + dp[20]\n        # dp[23] = dp[22] + dp[21]\n        # dp[24] = dp[23] + dp[22]\n        # dp[25] = dp[24] + dp[23]\n        # dp[26] = dp[25] + dp[24]\n        # dp[27] = dp[26] + dp[25]\n        # dp[28] = dp[27] + dp[26]\n        # dp[29] = dp[28] + dp[27]\n        # dp[30] = dp[29] + dp[28]\n        # dp[31] = dp[30] + dp[29]\n        # dp[32] = dp[31] + dp[30]\n        # dp[33] = dp[32] + dp[31]\n        # dp[34] = dp[33] + dp[32]\n        # dp[35] = dp[34] + dp[33]\n        # dp[36] = dp[35] + dp[34]\n        # dp[37] = dp[36] + dp[35]\n        # dp[38] = dp[37] + dp[36]\n        # dp[39] = dp[38] + dp[37]\n        # dp[40] = dp[39] + dp[38]\n        # dp[41] = dp[40] + dp[39]\n        # dp[42] = dp[41] + dp[40]\n        # dp[43] = dp[42] + dp[41]\n        # dp[44] = dp[43] + dp[42]\n        # dp[45] = dp[44] + dp"}], "is-subsequence": [{"task_id": "is-subsequence", "completion": "class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        # if s is empty, return True\n        if not s:\n            return True\n        \n        # if t is empty, return False\n        if not t:\n            return False\n        \n        # if s is longer than t, return False\n        if len(s) > len(t):\n            return False\n        \n        # if s is equal to t, return True\n        if s == t:\n            return True\n        \n        # if s is not equal to t, return False\n        if s != t:\n            return False\n        \n        # if s is not empty and t is not empty, return False\n        if s and t:\n            return False\n        \n        # if s is not empty and t is empty, return False\n        if s and not t:\n            return False\n        \n        # if s is empty and t is not empty, return True\n        if not s and t:\n            return True\n        \n        # if s is empty and t is empty, return True\n        if not s and not t:\n            return True\n        \n        # if s is not empty and t is not empty, return False\n        if s and t:\n            return False\n        \n        # if s is not empty and t is empty, return False\n        if s and not t:\n            return False\n        \n        # if s is empty and t is not empty, return True\n        if not s and t:\n            return True\n        \n        # if s is empty and t is empty, return True\n        if not s and not t:\n            return True\n        \n        # if s is not empty and t is not empty, return False\n        if s and t:\n            return False\n        \n        # if s is not empty and t is empty, return False\n        if s and not t:\n            return False\n        \n        # if s is empty and t is not empty, return True\n        if not s and t:\n            return True\n        \n        # if s is empty and t is empty, return True\n        if not s and not t:\n            return True\n        \n        # if s is not empty and t is not empty, return False\n        if s and t:\n            return False\n        \n        # if s is not empty and t is empty, return False\n        if s and not t:\n            return False\n        \n        # if s is empty and t is not empty, return True\n        if not s and t:\n            return True\n        \n        # if s is empty and t is empty, return True\n        if not s and not t:\n            return True\n        \n        # if s is not empty and t is not empty, return False\n        if s and t:\n            return False\n        \n        # if s is not empty and t is empty, return False\n        if s and not t:\n            return False\n        \n        # if s is empty and t is not empty, return True\n        if not s and t:\n            return True\n        \n        # if s is empty and t is empty, return True\n        if not s and not t:\n            return True\n        \n        # if s is not empty and t is not empty, return False\n        if s and t:\n            return False\n        \n        # if s is not empty and t is empty, return False\n        if s and not t:\n            return False\n        \n        # if s is empty and t is not empty, return True\n        if not s and t:\n            return True\n        \n        # if s is empty and t is empty, return True\n        if not s and not t:\n            return True\n        \n        # if s is not empty and t is not empty, return False\n        if s and t:\n            return False\n        \n        # if s is not empty and t is empty, return False\n        if s and not t:\n            return False\n        \n        # if s is empty and t is not empty, return True\n        if not s and t:\n            return True\n        \n        # if s is empty and t is empty, return True\n        if not s and not t:\n            return True\n        \n        # if s is not empty and t is not empty, return False\n        if s and t:\n            return False\n        \n        # if s is not empty and t is empty, return False\n        if s and not t:\n            return False\n        \n        # if s is empty and t is not empty, return True\n        if not s and t:\n            return True"}, {"task_id": "is-subsequence", "completion": "class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        # if s is empty, return True\n        if not s:\n            return True\n        \n        # if t is empty, return False\n        if not t:\n            return False\n        \n        # if s is longer than t, return False\n        if len(s) > len(t):\n            return False\n        \n        # if s is equal to t, return True\n        if s == t:\n            return True\n        \n        # if s is not equal to t, return False\n        if s != t:\n            return False\n        \n        # if s is not empty and t is not empty, return False\n        if s and t:\n            return False\n        \n        # if s is not empty and t is empty, return False\n        if s and not t:\n            return False\n        \n        # if s is empty and t is not empty, return True\n        if not s and t:\n            return True\n        \n        # if s is empty and t is empty, return True\n        if not s and not t:\n            return True\n        \n        # if s is not empty and t is not empty, return False\n        if s and t:\n            return False\n        \n        # if s is not empty and t is empty, return False\n        if s and not t:\n            return False\n        \n        # if s is empty and t is not empty, return True\n        if not s and t:\n            return True\n        \n        # if s is empty and t is empty, return True\n        if not s and not t:\n            return True\n        \n        # if s is not empty and t is not empty, return False\n        if s and t:\n            return False\n        \n        # if s is not empty and t is empty, return False\n        if s and not t:\n            return False\n        \n        # if s is empty and t is not empty, return True\n        if not s and t:\n            return True\n        \n        # if s is empty and t is empty, return True\n        if not s and not t:\n            return True\n        \n        # if s is not empty and t is not empty, return False\n        if s and t:\n            return False\n        \n        # if s is not empty and t is empty, return False\n        if s and not t:\n            return False\n        \n        # if s is empty and t is not empty, return True\n        if not s and t:\n            return True\n        \n        # if s is empty and t is empty, return True\n        if not s and not t:\n            return True\n        \n        # if s is not empty and t is not empty, return False\n        if s and t:\n            return False\n        \n        # if s is not empty and t is empty, return False\n        if s and not t:\n            return False\n        \n        # if s is empty and t is not empty, return True\n        if not s and t:\n            return True\n        \n        # if s is empty and t is empty, return True\n        if not s and not t:\n            return True\n        \n        # if s is not empty and t is not empty, return False\n        if s and t:\n            return False\n        \n        # if s is not empty and t is empty, return False\n        if s and not t:\n            return False\n        \n        # if s is empty and t is not empty, return True\n        if not s and t:\n            return True\n        \n        # if s is empty and t is empty, return True\n        if not s and not t:\n            return True\n        \n        # if s is not empty and t is not empty, return False\n        if s and t:\n            return False\n        \n        # if s is not empty and t is empty, return False\n        if s and not t:\n            return False\n        \n        # if s is empty and t is not empty, return True\n        if not s and t:\n            return True\n        \n        # if s is empty and t is empty, return True\n        if not s and not t:\n            return True\n        \n        # if s is not empty and t is not empty, return False\n        if s and t:\n            return False\n        \n        # if s is not empty and t is empty, return False\n        if s and not t:\n            return False\n        \n        # if s is empty and t is not empty, return True\n        if not s and t:\n            return True"}, {"task_id": "is-subsequence", "completion": "class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        # if s is empty, return True\n        if not s:\n            return True\n        \n        # if t is empty, return False\n        if not t:\n            return False\n        \n        # if s is longer than t, return False\n        if len(s) > len(t):\n            return False\n        \n        # if s is equal to t, return True\n        if s == t:\n            return True\n        \n        # if s is not equal to t, return False\n        if s != t:\n            return False\n        \n        # if s is not empty and t is not empty, return False\n        if s and t:\n            return False\n        \n        # if s is not empty and t is empty, return False\n        if s and not t:\n            return False\n        \n        # if s is empty and t is not empty, return True\n        if not s and t:\n            return True\n        \n        # if s is empty and t is empty, return True\n        if not s and not t:\n            return True\n        \n        # if s is not empty and t is not empty, return False\n        if s and t:\n            return False\n        \n        # if s is not empty and t is empty, return False\n        if s and not t:\n            return False\n        \n        # if s is empty and t is not empty, return True\n        if not s and t:\n            return True\n        \n        # if s is empty and t is empty, return True\n        if not s and not t:\n            return True\n        \n        # if s is not empty and t is not empty, return False\n        if s and t:\n            return False\n        \n        # if s is not empty and t is empty, return False\n        if s and not t:\n            return False\n        \n        # if s is empty and t is not empty, return True\n        if not s and t:\n            return True\n        \n        # if s is empty and t is empty, return True\n        if not s and not t:\n            return True\n        \n        # if s is not empty and t is not empty, return False\n        if s and t:\n            return False\n        \n        # if s is not empty and t is empty, return False\n        if s and not t:\n            return False\n        \n        # if s is empty and t is not empty, return True\n        if not s and t:\n            return True\n        \n        # if s is empty and t is empty, return True\n        if not s and not t:\n            return True\n        \n        # if s is not empty and t is not empty, return False\n        if s and t:\n            return False\n        \n        # if s is not empty and t is empty, return False\n        if s and not t:\n            return False\n        \n        # if s is empty and t is not empty, return True\n        if not s and t:\n            return True\n        \n        # if s is empty and t is empty, return True\n        if not s and not t:\n            return True\n        \n        # if s is not empty and t is not empty, return False\n        if s and t:\n            return False\n        \n        # if s is not empty and t is empty, return False\n        if s and not t:\n            return False\n        \n        # if s is empty and t is not empty, return True\n        if not s and t:\n            return True\n        \n        # if s is empty and t is empty, return True\n        if not s and not t:\n            return True\n        \n        # if s is not empty and t is not empty, return False\n        if s and t:\n            return False\n        \n        # if s is not empty and t is empty, return False\n        if s and not t:\n            return False\n        \n        # if s is empty and t is not empty, return True\n        if not s and t:\n            return True\n        \n        # if s is empty and t is empty, return True\n        if not s and not t:\n            return True\n        \n        # if s is not empty and t is not empty, return False\n        if s and t:\n            return False\n        \n        # if s is not empty and t is empty, return False\n        if s and not t:\n            return False\n        \n        # if s is empty and t is not empty, return True\n        if not s and t:\n            return True"}, {"task_id": "is-subsequence", "completion": "class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        # if s is empty, return true\n        if not s:\n            return True\n        \n        # if t is empty, return false\n        if not t:\n            return False\n        \n        # if s is longer than t, return false\n        if len(s) > len(t):\n            return False\n        \n        # if s is equal to t, return true\n        if s == t:\n            return True\n        \n        # if s is not equal to t, return false\n        if s != t:\n            return False\n        \n        # if s is not equal to t, return false\n        if s != t:\n            return False\n        \n        # if s is not equal to t, return false\n        if s != t:\n            return False\n        \n        # if s is not equal to t, return false\n        if s != t:\n            return False\n        \n        # if s is not equal to t, return false\n        if s != t:\n            return False\n        \n        # if s is not equal to t, return false\n        if s != t:\n            return False\n        \n        # if s is not equal to t, return false\n        if s != t:\n            return False\n        \n        # if s is not equal to t, return false\n        if s != t:\n            return False\n        \n        # if s is not equal to t, return false\n        if s != t:\n            return False\n        \n        # if s is not equal to t, return false\n        if s != t:\n            return False\n        \n        # if s is not equal to t, return false\n        if s != t:\n            return False\n        \n        # if s is not equal to t, return false\n        if s != t:\n            return False\n        \n        # if s is not equal to t, return false\n        if s != t:\n            return False\n        \n        # if s is not equal to t, return false\n        if s != t:\n            return False\n        \n        # if s is not equal to t, return false\n        if s != t:\n            return False\n        \n        # if s is not equal to t, return false\n        if s != t:\n            return False\n        \n        # if s is not equal to t, return false\n        if s != t:\n            return False\n        \n        # if s is not equal to t, return false\n        if s != t:\n            return False\n        \n        # if s is not equal to t, return false\n        if s != t:\n            return False\n        \n        # if s is not equal to t, return false\n        if s != t:\n            return False\n        \n        # if s is not equal to t, return false\n        if s != t:\n            return False\n        \n        # if s is not equal to t, return false\n        if s != t:\n            return False\n        \n        # if s is not equal to t, return false\n        if s != t:\n            return False\n        \n        # if s is not equal to t, return false\n        if s != t:\n            return False\n        \n        # if s is not equal to t, return false\n        if s != t:\n            return False\n        \n        # if s is not equal to t, return false\n        if s != t:\n            return False\n        \n        # if s is not equal to t, return false\n        if s != t:\n            return False\n        \n        # if s is not equal to t, return false\n        if s != t:\n            return False\n        \n        # if s is not equal to t, return false\n        if s != t:\n            return False\n        \n        # if s is not equal to t, return false\n        if s != t:\n            return False\n        \n        # if s is not equal to t, return false\n        if s != t:\n            return False\n        \n        # if s is not equal to t, return false\n        if s != t:\n            return False\n        \n        # if s is not equal to t, return false\n        if s != t:\n            return False\n        \n        # if s is not equal to t, return false\n        if s != t:\n            return False\n        \n        # if s is not equal"}, {"task_id": "is-subsequence", "completion": "class Solution(object):\n    def isSubsequence(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 16 ms, faster than 99.87% of Python online submissions for Is Subsequence.\n        ## Memory Usage: 13.5 MB, less than 99.99% of Python online submissions for Is Subsequence.\n        ## 2. Two Pointers\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 16 ms, faster than 99.87% of Python online submissions for Is Subsequence.\n        ## Memory Usage: 13.5 MB, less than 99.99% of Python online submissions for Is Subsequence.\n        ## 3. Binary Search\n        ## Time Complexity: O(nlogn)\n        ## Space Complexity: O(1)\n        ## Runtime: 16 ms, faster than 99.87% of Python online submissions for Is Subsequence.\n        ## Memory Usage: 13.5 MB, less than 99.99% of Python online submissions for Is Subsequence.\n        ## 4. Binary Search\n        ## Time Complexity: O(nlogn)\n        ## Space Complexity: O(1)\n        ## Runtime: 16 ms, faster than 99.87% of Python online submissions for Is Subsequence.\n        ## Memory Usage: 13.5 MB, less than 99.99% of Python online submissions for Is Subsequence.\n        ## 5. Binary Search\n        ## Time Complexity: O(nlogn)\n        ## Space Complexity: O(1)\n        ## Runtime: 16 ms, faster than 99.87% of Python online submissions for Is Subsequence.\n        ## Memory Usage: 13.5 MB, less than 99.99% of Python online submissions for Is Subsequence.\n        ## 6. Binary Search\n        ## Time Complexity: O(nlogn)\n        ## Space Complexity: O(1)\n        ## Runtime: 16 ms, faster than 99.87% of Python online submissions for Is Subsequence.\n        ## Memory Usage: 13.5 MB, less than 99.99% of Python online submissions for Is Subsequence.\n        ## 7. Binary Search\n        ## Time Complexity: O(nlogn)\n        ## Space Complexity: O(1)\n        ## Runtime: 16 ms, faster than 99.87% of Python online submissions for Is Subsequence.\n        ## Memory Usage: 13.5 MB, less than 99.99% of Python online submissions for Is Subsequence.\n        ## 8. Binary Search\n        ## Time Complexity: O(nlogn)\n        ## Space Complexity: O(1)\n        ## Runtime: 16 ms, faster than 99.87% of Python online submissions for Is Subsequence.\n        ## Memory Usage: 13.5 MB, less than 99.99% of Python online submissions for Is Subsequence.\n        ## 9. Binary Search\n        ## Time Complexity: O(nlogn)\n        ## Space Complexity: O(1)\n        ## Runtime: 16 ms, faster than 99.87% of Python online submissions for Is Subsequence.\n        ## Memory Usage: 13.5 MB, less than 99.99% of Python online submissions for Is Subsequence.\n        ## 10. Binary Search\n        ## Time Complexity: O(nlogn)\n        ## Space Complexity: O(1)\n        ## Runtime: 16 ms, faster than 99.87% of Python online submissions for Is Subsequence.\n        ## Memory Usage: 13.5 MB, less than 99.99% of Python online submissions for Is Subsequence.\n        ## 11"}], "gray-code": [{"task_id": "gray-code", "completion": "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. 0000\n        # 2. 0001\n        # 3. 0011\n        # 4. 0010\n        # 5. 0110\n        # 6. 0111\n        # 7. 0101\n        # 8. 0100\n        # 9. 1100\n        # 10. 1101\n        # 11. 1111\n        # 12. 1110\n        # 13. 1010\n        # 14. 1011\n        # 15. 1001\n        # 16. 1000\n        \n        # 1. 0000\n        # 2. 0001\n        # 3. 0011\n        # 4. 0010\n        # 5. 0110\n        # 6. 0111\n        # 7. 0101\n        # 8. 0100\n        # 9. 1100\n        # 10. 1101\n        # 11. 1111\n        # 12. 1110\n        # 13. 1010\n        # 14. 1011\n        # 15. 1001\n        # 16. 1000\n        \n        # 1. 0000\n        # 2. 0001\n        # 3. 0011\n        # 4. 0010\n        # 5. 0110\n        # 6. 0111\n        # 7. 0101\n        # 8. 0100\n        # 9. 1100\n        # 10. 1101\n        # 11. 1111\n        # 12. 1110\n        # 13. 1010\n        # 14. 1011\n        # 15. 1001\n        # 16. 1000\n        \n        # 1. 0000\n        # 2. 0001\n        # 3. 0011\n        # 4. 0010\n        # 5. 0110\n        # 6. 0111\n        # 7. 0101\n        # 8. 0100\n        # 9. 1100\n        # 10. 1101\n        # 11. 1111\n        # 12. 1110\n        # 13. 1010\n        # 14. 1011\n        # 15. 1001\n        # 16. 1000\n        \n        # 1. 0000\n        # 2. 0001\n        # 3. 0011\n        # 4. 0010\n        # 5. 0110\n        # 6. 0111\n        # 7. 0101\n        # 8. 0100\n        # 9. 1100\n        # 10. 1101\n        # 11. 1111\n        # 12. 1110\n        # 13. 1010\n        # 14. 1011\n        # 15. 1001\n        # 16. 1000\n        \n        # 1. 0000\n        # 2. 0001\n        # 3. 0011\n        # 4. 0010\n        # 5. 0110\n        # 6. 0111\n        # 7. 0101\n        # 8. 0100\n        # 9. 1100"}, {"task_id": "gray-code", "completion": "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def grayCodeHelper(n):\n            if n == 1:\n                return [0,1]\n            else:\n                prev = grayCodeHelper(n-1)\n                return prev + [(1<<(n-1)) + x for x in prev[::-1]]\n        \n        return grayCodeHelper(n)"}, {"task_id": "gray-code", "completion": "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        def gray_code(n):\n            if n == 1:\n                return [0, 1]\n            else:\n                prev_code = gray_code(n - 1)\n                return prev_code + [i + (1 << (n - 1)) for i in prev_code[::-1]]\n        \n        return gray_code(n)"}, {"task_id": "gray-code", "completion": "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. 0000\n        # 2. 0001\n        # 3. 0011\n        # 4. 0010\n        # 5. 0110\n        # 6. 0111\n        # 7. 0101\n        # 8. 0100\n        # 9. 1100\n        # 10. 1101\n        # 11. 1111\n        # 12. 1110\n        # 13. 1010\n        # 14. 1011\n        # 15. 1001\n        # 16. 1000\n        \n        # 1. 0000\n        # 2. 0001\n        # 3. 0011\n        # 4. 0010\n        # 5. 0110\n        # 6. 0111\n        # 7. 0101\n        # 8. 0100\n        # 9. 1100\n        # 10. 1101\n        # 11. 1111\n        # 12. 1110\n        # 13. 1010\n        # 14. 1011\n        # 15. 1001\n        # 16. 1000\n        \n        # 1. 0000\n        # 2. 0001\n        # 3. 0011\n        # 4. 0010\n        # 5. 0110\n        # 6. 0111\n        # 7. 0101\n        # 8. 0100\n        # 9. 1100\n        # 10. 1101\n        # 11. 1111\n        # 12. 1110\n        # 13. 1010\n        # 14. 1011\n        # 15. 1001\n        # 16. 1000\n        \n        # 1. 0000\n        # 2. 0001\n        # 3. 0011\n        # 4. 0010\n        # 5. 0110\n        # 6. 0111\n        # 7. 0101\n        # 8. 0100\n        # 9. 1100\n        # 10. 1101\n        # 11. 1111\n        # 12. 1110\n        # 13. 1010\n        # 14. 1011\n        # 15. 1001\n        # 16. 1000\n        \n        # 1. 0000\n        # 2. 0001\n        # 3. 0011\n        # 4. 0010\n        # 5. 0110\n        # 6. 0111\n        # 7. 0101\n        # 8. 0100\n        # 9. 1100\n        # 10. 1101\n        # 11. 1111\n        # 12. 1110\n        # 13. 1010\n        # 14. 1011\n        # 15. 1001\n        # 16. 1000\n        \n        # 1. 0000\n        # 2. 0001\n        # 3. 0011\n        # 4. 0010\n        # 5. 0110\n        # 6. 0111\n        # 7. 0101\n        # 8. 0100\n        # 9. 1100"}, {"task_id": "gray-code", "completion": "class Solution(object):\n    def grayCode(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. 0000\n        # 2. 0001\n        # 3. 0011\n        # 4. 0010\n        # 5. 0110\n        # 6. 0111\n        # 7. 0101\n        # 8. 0100\n        # 9. 1100\n        # 10. 1101\n        # 11. 1111\n        # 12. 1110\n        # 13. 1010\n        # 14. 1011\n        # 15. 1001\n        # 16. 1000\n        \n        # 1. 0000\n        # 2. 0001\n        # 3. 0011\n        # 4. 0010\n        # 5. 0110\n        # 6. 0111\n        # 7. 0101\n        # 8. 0100\n        # 9. 1100\n        # 10. 1101\n        # 11. 1111\n        # 12. 1110\n        # 13. 1010\n        # 14. 1011\n        # 15. 1001\n        # 16. 1000\n        \n        # 1. 0000\n        # 2. 0001\n        # 3. 0011\n        # 4. 0010\n        # 5. 0110\n        # 6. 0111\n        # 7. 0101\n        # 8. 0100\n        # 9. 1100\n        # 10. 1101\n        # 11. 1111\n        # 12. 1110\n        # 13. 1010\n        # 14. 1011\n        # 15. 1001\n        # 16. 1000\n        \n        # 1. 0000\n        # 2. 0001\n        # 3. 0011\n        # 4. 0010\n        # 5. 0110\n        # 6. 0111\n        # 7. 0101\n        # 8. 0100\n        # 9. 1100\n        # 10. 1101\n        # 11. 1111\n        # 12. 1110\n        # 13. 1010\n        # 14. 1011\n        # 15. 1001\n        # 16. 1000\n        \n        # 1. 0000\n        # 2. 0001\n        # 3. 0011\n        # 4. 0010\n        # 5. 0110\n        # 6. 0111\n        # 7. 0101\n        # 8. 0100\n        # 9. 1100\n        # 10. 1101\n        # 11. 1111\n        # 12. 1110\n        # 13. 1010\n        # 14. 1011\n        # 15. 1001\n        # 16. 1000\n        \n        # 1. 0000\n        # 2. 0001\n        # 3. 0011\n        # 4. 0010\n        # 5. 0110\n        # 6. 0111\n        # 7. 0101\n        # 8. 0100\n        # 9. 1100"}], "climbing-stairs": [{"task_id": "climbing-stairs", "completion": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. Recursive solution\n        # Time: O(2^n)\n        # Space: O(n)\n        # def climb(i, n):\n        #     if i > n:\n        #         return 0\n        #     if i == n:\n        #         return 1\n        #     return climb(i+1, n) + climb(i+2, n)\n        # return climb(0, n)\n        \n        # 2. Dynamic programming\n        # Time: O(n)\n        # Space: O(n)\n        # if n <= 1:\n        #     return 1\n        # dp = [0] * (n+1)\n        # dp[1] = 1\n        # dp[2] = 2\n        # for i in range(3, n+1):\n        #     dp[i] = dp[i-1] + dp[i-2]\n        # return dp[n]\n        \n        # 3. Fibonacci number\n        # Time: O(n)\n        # Space: O(1)\n        if n <= 1:\n            return 1\n        first = 1\n        second = 2\n        for i in range(3, n+1):\n            third = first + second\n            first = second\n            second = third\n        return second"}, {"task_id": "climbing-stairs", "completion": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. Recursive solution\n        # Time: O(2^n)\n        # Space: O(n)\n        # def climb(i, n):\n        #     if i > n:\n        #         return 0\n        #     if i == n:\n        #         return 1\n        #     return climb(i+1, n) + climb(i+2, n)\n        # return climb(0, n)\n        \n        # 2. Dynamic programming\n        # Time: O(n)\n        # Space: O(n)\n        # if n <= 1:\n        #     return 1\n        # dp = [0] * (n+1)\n        # dp[1] = 1\n        # dp[2] = 2\n        # for i in range(3, n+1):\n        #     dp[i] = dp[i-1] + dp[i-2]\n        # return dp[n]\n        \n        # 3. Fibonacci number\n        # Time: O(n)\n        # Space: O(1)\n        if n <= 1:\n            return 1\n        first = 1\n        second = 2\n        for i in range(3, n+1):\n            third = first + second\n            first = second\n            second = third\n        return second"}, {"task_id": "climbing-stairs", "completion": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. Recursive solution\n        # Time: O(2^n)\n        # Space: O(n)\n        # def climb(i, n):\n        #     if i > n:\n        #         return 0\n        #     if i == n:\n        #         return 1\n        #     return climb(i+1, n) + climb(i+2, n)\n        # return climb(0, n)\n        \n        # 2. Dynamic Programming\n        # Time: O(n)\n        # Space: O(n)\n        # if n <= 1:\n        #     return 1\n        # dp = [0 for i in range(n+1)]\n        # dp[1] = 1\n        # dp[2] = 2\n        # for i in range(3, n+1):\n        #     dp[i] = dp[i-1] + dp[i-2]\n        # return dp[n]\n        \n        # 3. Fibonacci Number\n        # Time: O(n)\n        # Space: O(1)\n        if n <= 1:\n            return 1\n        first = 1\n        second = 2\n        for i in range(3, n+1):\n            third = first + second\n            first = second\n            second = third\n        return second"}, {"task_id": "climbing-stairs", "completion": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        \n        dp = [0] * (n+1)\n        dp[1] = 1\n        dp[2] = 2\n        \n        for i in range(3, n+1):\n            dp[i] = dp[i-1] + dp[i-2]\n            \n        return dp[n]"}, {"task_id": "climbing-stairs", "completion": "class Solution(object):\n    def climbStairs(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        if n == 1:\n            return 1\n        if n == 2:\n            return 2\n        \n        dp = [0] * (n+1)\n        dp[1] = 1\n        dp[2] = 2\n        \n        for i in range(3, n+1):\n            dp[i] = dp[i-1] + dp[i-2]\n            \n        return dp[n]"}], "word-break": [{"task_id": "word-break", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        \n        # DP solution\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words\n        # dp[i] = any(dp[j] and s[j:i] in wordDict) for j < i\n        # dp[0] = True\n        # dp[len(s)] = False\n        # return dp[len(s)]\n        \n        # DP solution with memoization\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words\n        # dp[i] = any(dp[j] and s[j:i] in wordDict) for j < i\n        # dp[0] = True\n        # dp[len(s)] = False\n        # return dp[len(s)]\n        \n        # DP solution with memoization and pruning\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words\n        # dp[i] = any(dp[j] and s[j:i] in wordDict) for j < i\n        # dp[0] = True\n        # dp[len(s)] = False\n        # return dp[len(s)]\n        \n        # DP solution with memoization and pruning and early termination\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words\n        # dp[i] = any(dp[j] and s[j:i] in wordDict) for j < i\n        # dp[0] = True\n        # dp[len(s)] = False\n        # return dp[len]\n        \n        # DP solution with memoization and pruning and early termination and reversed wordDict\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words\n        # dp[i] = any(dp[j] and s[j:i] in wordDict) for j < i\n        # dp[0] = True\n        # dp[len(s)] = False\n        # return dp[len]\n        \n        # DP solution with memoization and pruning and early termination and reversed wordDict and reversed s\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words\n        # dp[i] = any(dp[j] and s[j:i] in wordDict) for j < i\n        # dp[0] = True\n        # dp[len(s)] = False\n        # return dp[len]\n        \n        # DP solution with memoization and pruning and early termination and reversed wordDict and reversed s and reversed wordDict\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words\n        # dp[i] = any(dp[j] and s[j:i] in wordDict) for j < i\n        # dp[0] = True\n        # dp[len(s)] = False\n        # return dp[len]\n        \n        # DP solution with memoization and pruning and early termination and reversed wordDict and reversed s and reversed wordDict and reversed s\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words\n        # dp[i] = any(dp[j] and s[j:i] in wordDict) for j < i\n        # dp[0] = True\n        # dp[len(s)] = False\n        # return dp[len]\n        \n        # DP solution with memoization and pruning and early termination and reversed wordDict and reversed s and reversed wordDict and reversed s and reversed wordDict\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words\n        # dp[i] = any"}, {"task_id": "word-break", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        \n        # DP solution\n        # Time: O(n^2)\n        # Space: O(n)\n        \n        dp = [False] * (len(s) + 1)\n        dp[len(s)] = True\n        \n        for i in range(len(s) - 1, -1, -1):\n            for w in wordDict:\n                if (i + len(w)) <= len(s) and s[i:i + len(w)] == w:\n                    dp[i] = dp[i + len(w)]\n                if dp[i]:\n                    break\n        return dp[0]"}, {"task_id": "word-break", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        \n        # DP solution\n        # Time: O(n^2)\n        # Space: O(n)\n        \n        dp = [False] * (len(s) + 1)\n        dp[len(s)] = True\n        \n        for i in range(len(s) - 1, -1, -1):\n            for w in wordDict:\n                if (i + len(w)) <= len(s) and s[i:i + len(w)] == w:\n                    dp[i] = dp[i + len(w)]\n                if dp[i]:\n                    break\n        return dp[0]"}, {"task_id": "word-break", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        \n        # DP solution\n        # Time complexity: O(n^2)\n        # Space complexity: O(n)\n        \n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words\n        # dp[i] = False if s[:i] cannot be segmented into a space-separated sequence of one or more dictionary words\n        # dp[0] = True\n        # dp[i] = True if dp[j] is True and s[j:i] is in wordDict for some j < i\n        # dp[i] = False if dp[j] is True and s[j:i] is not in wordDict for any j < i\n        # dp[i] = True if dp[j] is True and s[j:i] is in wordDict for some j < i\n        # dp[i] = False if dp[j] is True and s[j:i] is not in wordDict for any j < i\n        # dp[i] = True if dp[j] is True and s[j:i] is in wordDict for some j < i\n        # dp[i] = False if dp[j] is True and s[j:i] is not in wordDict for any j < i\n        # dp[i] = True if dp[j] is True and s[j:i] is in wordDict for some j < i\n        # dp[i] = False if dp[j] is True and s[j:i] is not in wordDict for any j < i\n        # dp[i] = True if dp[j] is True and s[j:i] is in wordDict for some j < i\n        # dp[i] = False if dp[j] is True and s[j:i] is not in wordDict for any j < i\n        # dp[i] = True if dp[j] is True and s[j:i] is in wordDict for some j < i\n        # dp[i] = False if dp[j] is True and s[j:i] is not in wordDict for any j < i\n        # dp[i] = True if dp[j] is True and s[j:i] is in wordDict for some j < i\n        # dp[i] = False if dp[j] is True and s[j:i] is not in wordDict for any j < i\n        # dp[i] = True if dp[j] is True and s[j:i] is in wordDict for some j < i\n        # dp[i] = False if dp[j] is True and s[j:i] is not in wordDict for any j < i\n        # dp[i] = True if dp[j] is True and s[j:i] is in wordDict for some j < i\n        # dp[i] = False if dp[j] is True and s[j:i] is not in wordDict for any j < i\n        # dp[i] = True if dp[j] is True and s[j:i] is in wordDict for some j < i\n        # dp[i] = False if dp[j] is True and s[j:i] is not in wordDict for any j < i\n        # dp[i] = True if dp[j] is True and s[j:i] is in wordDict for some j < i\n        # dp[i] = False if dp[j] is True and s[j:i] is not in wordDict for any j < i\n        # dp[i] = True if dp[j] is True and s[j:i] is in wordDict for some j < i\n        # dp[i] = False if dp[j] is True and s[j:i] is not in wordDict for any j < i\n        # dp[i] = True if dp[j] is True and s[j:i] is in wordDict for some j < i\n        # dp[i] = False if dp[j] is True and s[j:i] is not in wordDict for any j"}, {"task_id": "word-break", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: bool\n        \"\"\"\n        \n        # DP solution\n        # dp[i] = True if s[:i] can be segmented into a space-separated sequence of one or more dictionary words\n        # dp[i] = any(dp[j] and s[j:i] in wordDict) for j < i\n        # dp[0] = True\n        # dp[len(s)] = True\n        \n        dp = [False] * (len(s) + 1)\n        dp[0] = True\n        \n        for i in range(1, len(s) + 1):\n            for j in range(i):\n                if dp[j] and s[j:i] in wordDict:\n                    dp[i] = True\n                    break\n        \n        return dp[-1]"}], "validate-binary-search-tree": [{"task_id": "validate-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def helper(root, min_val, max_val):\n            if not root:\n                return True\n            if root.val <= min_val or root.val >= max_val:\n                return False\n            return helper(root.left, min_val, root.val) and helper(root.right, root.val, max_val)\n        \n        return helper(root, float('-inf'), float('inf'))"}, {"task_id": "validate-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def helper(root, min_val, max_val):\n            if not root:\n                return True\n            if root.val <= min_val or root.val >= max_val:\n                return False\n            return helper(root.left, min_val, root.val) and helper(root.right, root.val, max_val)\n        \n        return helper(root, float('-inf'), float('inf'))"}, {"task_id": "validate-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def helper(root, min_val, max_val):\n            if not root:\n                return True\n            if root.val <= min_val or root.val >= max_val:\n                return False\n            return helper(root.left, min_val, root.val) and helper(root.right, root.val, max_val)\n        \n        return helper(root, float('-inf'), float('inf'))"}, {"task_id": "validate-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def helper(root, min_val, max_val):\n            if not root:\n                return True\n            if root.val <= min_val or root.val >= max_val:\n                return False\n            return helper(root.left, min_val, root.val) and helper(root.right, root.val, max_val)\n        \n        return helper(root, float('-inf'), float('inf'))"}, {"task_id": "validate-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isValidBST(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def helper(root, min_val, max_val):\n            if not root:\n                return True\n            if root.val <= min_val or root.val >= max_val:\n                return False\n            return helper(root.left, min_val, root.val) and helper(root.right, root.val, max_val)\n        \n        return helper(root, float('-inf'), float('inf'))"}], "insert-interval": [{"task_id": "insert-interval", "completion": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # 1. \u5148\u628anewInterval\u63d2\u5165\u5230intervals\u4e2d\n        intervals.append(newInterval)\n        intervals.sort(key=lambda x: x[0])\n        \n        # 2. \u5408\u5e76\n        merged = []\n        for interval in intervals:\n            if not merged or merged[-1][1] < interval[0]:\n                merged.append(interval)\n            else:\n                merged[-1][1] = max(merged[-1][1], interval[1])\n        \n        return merged"}, {"task_id": "insert-interval", "completion": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # 1. \uc0c8\ub85c\uc6b4 \uad6c\uac04\uc774 \uc5c6\uc744 \ub54c\n        if not intervals:\n            return [newInterval]\n        \n        # 2. \uc0c8\ub85c\uc6b4 \uad6c\uac04\uc774 \uccab \ubc88\uc9f8 \uad6c\uac04\ubcf4\ub2e4 \uc791\uc744 \ub54c\n        if newInterval[0] < intervals[0][0]:\n            intervals.insert(0, newInterval)\n            return intervals\n        \n        # 3. \uc0c8\ub85c\uc6b4 \uad6c\uac04\uc774 \ub9c8\uc9c0\ub9c9 \uad6c\uac04\ubcf4\ub2e4 \ud074 \ub54c\n        if newInterval[0] > intervals[-1][0]:\n            intervals.append(newInterval)\n            return intervals\n        \n        # 4. \uc0c8\ub85c\uc6b4 \uad6c\uac04\uc774 \uae30\uc874 \uad6c\uac04\ub4e4 \uc0ac\uc774\uc5d0 \uc788\uc744 \ub54c\n        for i in range(len(intervals)):\n            if newInterval[0] <= intervals[i][0]:\n                intervals.insert(i, newInterval)\n                break\n        \n        # 5. \uacb0\uacfc \ubc30\uc5f4 \ucd08\uae30\ud654\n        result = []\n        \n        # 6. \uacb0\uacfc \ubc30\uc5f4\uc5d0 \uccab \ubc88\uc9f8 \uad6c\uac04 \ucd94\uac00\n        result.append(intervals[0])\n        \n        # 7. \uacb0\uacfc \ubc30\uc5f4\uc5d0 \ub098\uba38\uc9c0 \uad6c\uac04\ub4e4 \ucd94\uac00\n        for i in range(1, len(intervals)):\n            if result[-1][1] >= intervals[i][0]:\n                result[-1][1] = max(result[-1][1], intervals[i][1])\n            else:\n                result.append(intervals[i])\n        \n        return result"}, {"task_id": "insert-interval", "completion": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # 1. \uc0c8\ub85c\uc6b4 \uad6c\uac04\uc774 \uc5c6\uc744 \ub54c\n        if not intervals:\n            return [newInterval]\n        \n        # 2. \uc0c8\ub85c\uc6b4 \uad6c\uac04\uc774 \uccab \ubc88\uc9f8 \uad6c\uac04\ubcf4\ub2e4 \uc791\uc744 \ub54c\n        if newInterval[0] < intervals[0][0]:\n            intervals.insert(0, newInterval)\n            return intervals\n        \n        # 3. \uc0c8\ub85c\uc6b4 \uad6c\uac04\uc774 \ub9c8\uc9c0\ub9c9 \uad6c\uac04\ubcf4\ub2e4 \ud074 \ub54c\n        if newInterval[0] > intervals[-1][0]:\n            intervals.append(newInterval)\n            return intervals\n        \n        # 4. \uc0c8\ub85c\uc6b4 \uad6c\uac04\uc774 \uae30\uc874 \uad6c\uac04\ub4e4 \uc0ac\uc774\uc5d0 \uc788\uc744 \ub54c\n        for i in range(len(intervals)):\n            if intervals[i][0] <= newInterval[0] <= intervals[i][1]:\n                intervals[i][1] = max(intervals[i][1], newInterval[1])\n                break\n            elif intervals[i][0] <= newInterval[1] <= intervals[i][1]:\n                intervals[i][0] = min(intervals[i][0], newInterval[0])\n                break\n            elif newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                intervals[i] = newInterval\n                break\n            elif newInterval[0] >= intervals[i][0] and newInterval[1] <= intervals[i][1]:\n                intervals[i] = intervals[i]\n                break\n            elif newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                intervals[i] = intervals[i]\n                break\n            elif newInterval[0] >= intervals[i][0] and newInterval[1] <= intervals[i][1]:\n                intervals[i] = intervals[i]\n                break\n            elif newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                intervals[i] = intervals[i]\n                break\n            elif newInterval[0] >= intervals[i][0] and newInterval[1] <= intervals[i][1]:\n                intervals[i] = intervals[i]\n                break\n            elif newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                intervals[i] = intervals[i]\n                break\n            elif newInterval[0] >= intervals[i][0] and newInterval[1] <= intervals[i][1]:\n                intervals[i] = intervals[i]\n                break\n            elif newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                intervals[i] = intervals[i]\n                break\n            elif newInterval[0] >= intervals[i][0] and newInterval[1] <= intervals[i][1]:\n                intervals[i] = intervals[i]\n                break\n            elif newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                intervals[i] = intervals[i]\n                break\n            elif newInterval[0] >= intervals[i][0] and newInterval[1] <= intervals[i][1]:\n                intervals[i] = intervals[i]\n                break\n            elif newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                intervals[i] = intervals[i]\n                break\n            elif newInterval[0] >= intervals[i][0] and newInterval[1] <= intervals[i][1]:\n                intervals[i] = intervals[i]\n                break\n            elif newInterval[0] <= intervals[i][0] and newInterval[1] >= intervals[i][1]:\n                intervals[i] = intervals[i]\n                break"}, {"task_id": "insert-interval", "completion": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # 1. \u5148\u628anewInterval\u63d2\u5165\u5230intervals\u4e2d\n        intervals.append(newInterval)\n        intervals.sort(key=lambda x: x[0])\n        \n        # 2. \u5408\u5e76intervals\n        merged = []\n        for interval in intervals:\n            if not merged or merged[-1][1] < interval[0]:\n                merged.append(interval)\n            else:\n                merged[-1][1] = max(merged[-1][1], interval[1])\n        \n        return merged"}, {"task_id": "insert-interval", "completion": "class Solution(object):\n    def insert(self, intervals, newInterval):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :type newInterval: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # 1. \u5148\u628anewInterval\u63d2\u5165\u5230intervals\u4e2d\n        intervals.append(newInterval)\n        intervals.sort(key=lambda x: x[0])\n        \n        # 2. \u5408\u5e76intervals\n        merged = []\n        for interval in intervals:\n            if not merged or merged[-1][1] < interval[0]:\n                merged.append(interval)\n            else:\n                merged[-1][1] = max(merged[-1][1], interval[1])\n        \n        return merged"}], "palindrome-partitioning": [{"task_id": "palindrome-partitioning", "completion": "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        def backtrack(s, path, res):\n            if not s:\n                res.append(path)\n                return\n            for i in range(1, len(s)+1):\n                if isPalindrome(s[:i]):\n                    backtrack(s[i:], path+[s[:i]], res)\n        \n        res = []\n        backtrack(s, [], res)\n        return res"}, {"task_id": "palindrome-partitioning", "completion": "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        def dfs(s, path, res):\n            if not s:\n                res.append(path)\n                return\n            for i in range(1, len(s)+1):\n                if isPalindrome(s[:i]):\n                    dfs(s[i:], path+[s[:i]], res)\n        \n        res = []\n        dfs(s, [], res)\n        return res"}, {"task_id": "palindrome-partitioning", "completion": "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        def backtrack(s, path, res):\n            if not s:\n                res.append(path)\n                return\n            for i in range(1, len(s)+1):\n                if isPalindrome(s[:i]):\n                    backtrack(s[i:], path+[s[:i]], res)\n        \n        res = []\n        backtrack(s, [], res)\n        return res"}, {"task_id": "palindrome-partitioning", "completion": "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        def backtrack(s, path, res):\n            if not s:\n                res.append(path)\n                return\n            for i in range(1, len(s)+1):\n                if isPalindrome(s[:i]):\n                    backtrack(s[i:], path+[s[:i]], res)\n        \n        res = []\n        backtrack(s, [], res)\n        return res"}, {"task_id": "palindrome-partitioning", "completion": "class Solution(object):\n    def partition(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        def backtrack(s, path, res):\n            if not s:\n                res.append(path)\n                return\n            for i in range(1, len(s)+1):\n                if isPalindrome(s[:i]):\n                    backtrack(s[i:], path+[s[:i]], res)\n        \n        res = []\n        backtrack(s, [], res)\n        return res"}], "smallest-range-covering-elements-from-k-lists": [{"task_id": "smallest-range-covering-elements-from-k-lists", "completion": "class Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \u5c06\u6240\u6709\u6570\u7ec4\u4e2d\u7684\u5143\u7d20\u653e\u5165\u4e00\u4e2a\u5927\u6839\u5806\u4e2d\n        # 2. \u6bcf\u6b21\u53d6\u51fa\u5806\u9876\u5143\u7d20\uff0c\u5e76\u5c06\u8be5\u5143\u7d20\u6240\u5728\u7684\u6570\u7ec4\u7684\u4e0b\u4e00\u4e2a\u5143\u7d20\u653e\u5165\u5806\u4e2d\n        # 3. \u91cd\u590d2\uff0c\u76f4\u5230\u67d0\u4e2a\u6570\u7ec4\u4e2d\u7684\u5143\u7d20\u5168\u90e8\u53d6\u5b8c\n        # 4. \u6bcf\u6b21\u53d6\u51fa\u5806\u9876\u5143\u7d20\u65f6\uff0c\u66f4\u65b0\u6700\u5c0f\u8303\u56f4\n        # 5. \u91cd\u590d3\uff0c4\uff0c\u76f4\u5230\u6240\u6709\u6570\u7ec4\u4e2d\u7684\u5143\u7d20\u5168\u90e8\u53d6\u5b8c\n        # 6. \u8fd4\u56de\u6700\u5c0f\u8303\u56f4\n        \n        import heapq\n        heap = []\n        for i in range(len(nums)):\n            heapq.heappush(heap, (nums[i][0], i, 0))\n        min_range = float('inf')\n        max_range = float('-inf')\n        while len(heap) == len(nums):\n            min_val, i, j = heapq.heappop(heap)\n            max_range = max(max_range, min_val)\n            if j + 1 < len(nums[i]):\n                heapqheappush(heap, (nums[i][j + 1], i, j + 1))\n            if min_range > max_range - min_val:\n                min_range = max_range - min_val\n        return [min_range, max_range]"}, {"task_id": "smallest-range-covering-elements-from-k-lists", "completion": "class Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. create a list of tuples (value, index, list_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, index, list_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, index, list_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, index, list_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, index, list_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, index, list_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, index, list_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, index, list_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, index, list_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, index, list_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, index, list_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, index, list_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, index, list_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, index, list_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, index, list_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, index, list_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, index, list_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, index, list_index)\n        # 2. sort the list\n        # 3. use a"}, {"task_id": "smallest-range-covering-elements-from-k-lists", "completion": "class Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. create a list of tuples (value, index, list_index)\n        # 2. sort the list of tuples\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, index, list_index)\n        # 2. sort the list of tuples\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, index, list_index)\n        # 2. sort the list of tuples\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, index, list_index)\n        # 2. sort the list of tuples\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, index, list_index)\n        # 2. sort the list of tuples\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, index, list_index)\n        # 2. sort the list of tuples\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, index, list_index)\n        # 2. sort the list of tuples\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, index, list_index)\n        # 2. sort the list of tuples\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, index, list_index)\n        # 2. sort the list of tuples\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, index, list_index)\n        # 2. sort the list of tuples\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, index, list_index)\n        # 2. sort the list of tuples\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, index, list_index)\n        # 2. sort the list of tuples\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, index, list_index)\n        # 2. sort the list of tuples\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, index, list_index)\n        # 2. sort the list of tuples\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, index, list_index)\n        # 2. sort the list of tuples\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, index, list_index)\n        # 2. sort the list of tuples\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, index, list_index)\n        # 2. sort the list of t"}, {"task_id": "smallest-range-covering-elements-from-k-lists", "completion": "class Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. create a list of tuples (value, list_index, value_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, list_index, value_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, list_index, value_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, list_index, value_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, list_index, value_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, list_index, value_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, list_index, value_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, list_index, value_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, list_index, value_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, list_index, value_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, list_index, value_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, list_index, value_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, list_index, value_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, list_index, value_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, list_index, value_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, list_index, value_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1. create a list of tuples (value, list_index, value_index)\n        # 2. sort the list\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # 1"}, {"task_id": "smallest-range-covering-elements-from-k-lists", "completion": "class Solution(object):\n    def smallestRange(self, nums):\n        \"\"\"\n        :type nums: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. create a list of tuples (value, list_index, value_index)\n        # 2. sort the list of tuples by value\n        # 3. use a sliding window to find the smallest range\n        # 4. return the smallest range\n        \n        # create a list of tuples (value, list_index, value_index)\n        # sort the list of tuples by value\n        # use a sliding window to find the smallest range\n        # return the smallest range\n        \n        # create a list of tuples (value, list_index, value_index)\n        # sort the list of tuples by value\n        # use a sliding window to find the smallest range\n        # return the smallest range\n        \n        # create a list of tuples (value, list_index, value_index)\n        # sort the list of tuples by value\n        # use a sliding window to find the smallest range\n        # return the smallest range\n        \n        # create a list of tuples (value, list_index, value_index)\n        # sort the list of tuples by value\n        # use a sliding window to find the smallest range\n        # return the smallest range\n        \n        # create a list of tuples (value, list_index, value_index)\n        # sort the list of tuples by value\n        # use a sliding window to find the smallest range\n        # return the smallest range\n        \n        # create a list of tuples (value, list_index, value_index)\n        # sort the list of tuples by value\n        # use a sliding window to find the smallest range\n        # return the smallest range\n        \n        # create a list of tuples (value, list_index, value_index)\n        # sort the list of tuples by value\n        # use a sliding window to find the smallest range\n        # return the smallest range\n        \n        # create a list of tuples (value, list_index, value_index)\n        # sort the list of tuples by value\n        # use a sliding window to find the smallest range\n        # return the smallest range\n        \n        # create a list of tuples (value, list_index, value_index)\n        # sort the list of tuples by value\n        # use a sliding window to find the smallest range\n        # return the smallest range\n        \n        # create a list of tuples (value, list_index, value_index)\n        # sort the list of tuples by value\n        # use a sliding window to find the smallest range\n        # return the smallest range\n        \n        # create a list of tuples (value, list_index, value_index)\n        # sort the list of tuples by value\n        # use a sliding window to find the smallest range\n        # return the smallest range\n        \n        # create a list of tuples (value, list_index, value_index)\n        # sort the list of tuples by value\n        # use a sliding window to find the smallest range\n        # return the smallest range\n        \n        # create a list of tuples (value, list_index, value_index)\n        # sort the list of tuples by value\n        # use a sliding window to find the smallest range\n        # return the smallest range\n        \n        # create a list of tuples (value, list_index, value_index)\n        # sort the list of tuples by value\n        # use a sliding window to find the smallest range\n        # return the smallest range\n        \n        # create a list of tuples (value, list_index, value_index)\n        # sort the list of tuples by value\n        # use a sliding window to find the smallest range\n        # return the smallest range\n        \n        # create a list of tuples (value, list_index, value_index)\n        # sort the list of tuples by value\n        # use a sliding window to find the smallest range\n        # return the smallest range\n        \n        # create a list of tuples (value, list_index, value_index)\n        # sort the list of tuples by value\n        # use a sliding window to find the smallest range\n        # return the smallest range\n        \n        # create a list of tuples (value, list_index, value_index)\n        # sort the list of tuples by value\n        # use a sliding window to"}], "poor-pigs": [{"task_id": "poor-pigs", "completion": "class Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 1 pig can test 2 buckets in 15 minutes\n        # 2. 1 pig can test 4 buckets in 30 minutes\n        # 3. 1 pig can test 8 buckets in 60 minutes\n        # 4. 1 pig can test 16 buckets in 120 minutes\n        # 5. 1 pig can test 32 buckets in 240 minutes\n        # 6. 1 pig can test 64 buckets in 480 minutes\n        # 7. 1 pig can test 128 buckets in 960 minutes\n        # 8. 1 pig can test 256 buckets in 1920 minutes\n        # 9. 1 pig can test 512 buckets in 3840 minutes\n        # 10. 1 pig can test 1024 buckets in 7680 minutes\n        # 11. 1 pig can test 2048 buckets in 15360 minutes\n        # 12. 1 pig can test 4096 buckets in 30720 minutes\n        # 13. 1 pig can test 8192 buckets in 61440 minutes\n        # 14. 1 pig can test 16384 buckets in 122880 minutes\n        # 15. 1 pig can test 32768 buckets in 245760 minutes\n        # 16. 1 pig can test 65536 buckets in 491520 minutes\n        # 17. 1 pig can test 131072 buckets in 983040 minutes\n        # 18. 1 pig can test 262144 buckets in 1966080 minutes\n        # 19. 1 pig can test 524288 buckets in 3932160 minutes\n        # 20. 1 pig can test 1048576 buckets in 7864320 minutes\n        # 21. 1 pig can test 2097152 buckets in 15728640 minutes\n        # 22. 1 pig can test 4194304 buckets in 31457280 minutes\n        # 23. 1 pig can test 8388608 buckets in 62914560 minutes\n        # 24. 1 pig can test 16777216 buckets in 125829120 minutes\n        # 25. 1 pig can test 33554432 buckets in 251658240 minutes\n        # 26. 1 pig can test 67108864 buckets in 503316480 minutes\n        # 27. 1 pig can test 134217728 buckets in 1006632960 minutes\n        # 28. 1 pig can test 268435456 buckets in 2013265920 minutes\n        # 29. 1 pig can test 536870912 buckets in 4026531840 minutes\n        # 30. 1 pig can test 1073741824 buckets in 8053063680 minutes\n        # 31. 1 pig can test 2147483648 buckets in 16106127360 minutes\n        # 32. 1 pig can test 4294967296 buckets in 32212254720 minutes\n        # 33. 1 pig can test 8589934592 buckets in 64424509440 minutes\n        # 34. 1 pig can test 17179869184 buckets in 128849018880"}, {"task_id": "poor-pigs", "completion": "class Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 1 pig can test 2 buckets in 15 minutes\n        # 2. 1 pig can test 4 buckets in 30 minutes\n        # 3. 1 pig can test 8 buckets in 60 minutes\n        # 4. 1 pig can test 16 buckets in 120 minutes\n        # 5. 1 pig can test 32 buckets in 240 minutes\n        # 6. 1 pig can test 64 buckets in 480 minutes\n        # 7. 1 pig can test 128 buckets in 960 minutes\n        # 8. 1 pig can test 256 buckets in 1920 minutes\n        # 9. 1 pig can test 512 buckets in 3840 minutes\n        # 10. 1 pig can test 1024 buckets in 7680 minutes\n        # 11. 1 pig can test 2048 buckets in 15360 minutes\n        # 12. 1 pig can test 4096 buckets in 30720 minutes\n        # 13. 1 pig can test 8192 buckets in 61440 minutes\n        # 14. 1 pig can test 16384 buckets in 122880 minutes\n        # 15. 1 pig can test 32768 buckets in 245760 minutes\n        # 16. 1 pig can test 65536 buckets in 491520 minutes\n        # 17. 1 pig can test 131072 buckets in 983040 minutes\n        # 18. 1 pig can test 262144 buckets in 1966080 minutes\n        # 19. 1 pig can test 524288 buckets in 3932160 minutes\n        # 20. 1 pig can test 1048576 buckets in 7864320 minutes\n        # 21. 1 pig can test 2097152 buckets in 15728640 minutes\n        # 22. 1 pig can test 4194304 buckets in 31457280 minutes\n        # 23. 1 pig can test 8388608 buckets in 62914560 minutes\n        # 24. 1 pig can test 16777216 buckets in 125829120 minutes\n        # 25. 1 pig can test 33554432 buckets in 251658240 minutes\n        # 26. 1 pig can test 67108864 buckets in 503316480 minutes\n        # 27. 1 pig can test 134217728 buckets in 1006632960 minutes\n        # 28. 1 pig can test 268435456 buckets in 2013265920 minutes\n        # 29. 1 pig can test 536870912 buckets in 4026531840 minutes\n        # 30. 1 pig can test 1073741824 buckets in 8053063680 minutes\n        # 31. 1 pig can test 2147483648 buckets in 16106127360 minutes\n        # 32. 1 pig can test 4294967296 buckets in 32212254720 minutes\n        # 33. 1 pig can test 8589934592 buckets in 64424509440 minutes\n        # 34. 1 pig can test 17179869184 buckets in 128849018880"}, {"task_id": "poor-pigs", "completion": "class Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 1 pig can test 2 buckets in 15 minutes\n        # 2. 1 pig can test 4 buckets in 30 minutes\n        # 3. 1 pig can test 8 buckets in 60 minutes\n        # 4. 1 pig can test 16 buckets in 120 minutes\n        # 5. 1 pig can test 32 buckets in 240 minutes\n        # 6. 1 pig can test 64 buckets in 480 minutes\n        # 7. 1 pig can test 128 buckets in 960 minutes\n        # 8. 1 pig can test 256 buckets in 1920 minutes\n        # 9. 1 pig can test 512 buckets in 3840 minutes\n        # 10. 1 pig can test 1024 buckets in 7680 minutes\n        # 11. 1 pig can test 2048 buckets in 15360 minutes\n        # 12. 1 pig can test 4096 buckets in 30720 minutes\n        # 13. 1 pig can test 8192 buckets in 61440 minutes\n        # 14. 1 pig can test 16384 buckets in 122880 minutes\n        # 15. 1 pig can test 32768 buckets in 245760 minutes\n        # 16. 1 pig can test 65536 buckets in 491520 minutes\n        # 17. 1 pig can test 131072 buckets in 983040 minutes\n        # 18. 1 pig can test 262144 buckets in 1966080 minutes\n        # 19. 1 pig can test 524288 buckets in 3932160 minutes\n        # 20. 1 pig can test 1048576 buckets in 7864320 minutes\n        # 21. 1 pig can test 2097152 buckets in 15728640 minutes\n        # 22. 1 pig can test 4194304 buckets in 31457280 minutes\n        # 23. 1 pig can test 8388608 buckets in 62914560 minutes\n        # 24. 1 pig can test 16777216 buckets in 125829120 minutes\n        # 25. 1 pig can test 33554432 buckets in 251658240 minutes\n        # 26. 1 pig can test 67108864 buckets in 503316480 minutes\n        # 27. 1 pig can test 134217728 buckets in 1006632960 minutes\n        # 28. 1 pig can test 268435456 buckets in 2013265920 minutes\n        # 29. 1 pig can test 536870912 buckets in 4026531840 minutes\n        # 30. 1 pig can test 1073741824 buckets in 8053063680 minutes\n        # 31. 1 pig can test 2147483648 buckets in 16106127360 minutes\n        # 32. 1 pig can test 4294967296 buckets in 32212254720 minutes\n        # 33. 1 pig can test 8589934592 buckets in 64424509440 minutes\n        # 34. 1 pig can test 17179869184 buckets in 128849018880"}, {"task_id": "poor-pigs", "completion": "class Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 1 pig can test 2 buckets in 15 minutes\n        # 2. 1 pig can test 4 buckets in 30 minutes\n        # 3. 1 pig can test 8 buckets in 60 minutes\n        # 4. 1 pig can test 16 buckets in 120 minutes\n        # 5. 1 pig can test 32 buckets in 240 minutes\n        # 6. 1 pig can test 64 buckets in 480 minutes\n        # 7. 1 pig can test 128 buckets in 960 minutes\n        # 8. 1 pig can test 256 buckets in 1920 minutes\n        # 9. 1 pig can test 512 buckets in 3840 minutes\n        # 10. 1 pig can test 1024 buckets in 7680 minutes\n        # 11. 1 pig can test 2048 buckets in 15360 minutes\n        # 12. 1 pig can test 4096 buckets in 30720 minutes\n        # 13. 1 pig can test 8192 buckets in 61440 minutes\n        # 14. 1 pig can test 16384 buckets in 122880 minutes\n        # 15. 1 pig can test 32768 buckets in 245760 minutes\n        # 16. 1 pig can test 65536 buckets in 491520 minutes\n        # 17. 1 pig can test 131072 buckets in 983040 minutes\n        # 18. 1 pig can test 262144 buckets in 1966080 minutes\n        # 19. 1 pig can test 524288 buckets in 3932160 minutes\n        # 20. 1 pig can test 1048576 buckets in 7864320 minutes\n        # 21. 1 pig can test 2097152 buckets in 15728640 minutes\n        # 22. 1 pig can test 4194304 buckets in 31457280 minutes\n        # 23. 1 pig can test 8388608 buckets in 62914560 minutes\n        # 24. 1 pig can test 16777216 buckets in 125829120 minutes\n        # 25. 1 pig can test 33554432 buckets in 251658240 minutes\n        # 26. 1 pig can test 67108864 buckets in 503316480 minutes\n        # 27. 1 pig can test 134217728 buckets in 1006632960 minutes\n        # 28. 1 pig can test 268435456 buckets in 2013265920 minutes\n        # 29. 1 pig can test 536870912 buckets in 4026531840 minutes\n        # 30. 1 pig can test 1073741824 buckets in 8053063680 minutes\n        # 31. 1 pig can test 2147483648 buckets in 16106127360 minutes\n        # 32. 1 pig can test 4294967296 buckets in 32212254720 minutes\n        # 33. 1 pig can test 8589934592 buckets in 64424509440 minutes\n        # 34. 1 pig can test 17179869184 buckets in 128849018880"}, {"task_id": "poor-pigs", "completion": "class Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 1 pig can test 2 buckets in 15 minutes\n        # 2. 1 pig can test 4 buckets in 30 minutes\n        # 3. 1 pig can test 8 buckets in 60 minutes\n        # 4. 1 pig can test 16 buckets in 120 minutes\n        # 5. 1 pig can test 32 buckets in 240 minutes\n        # 6. 1 pig can test 64 buckets in 480 minutes\n        # 7. 1 pig can test 128 buckets in 960 minutes\n        # 8. 1 pig can test 256 buckets in 1920 minutes\n        # 9. 1 pig can test 512 buckets in 3840 minutes\n        # 10. 1 pig can test 1024 buckets in 7680 minutes\n        # 11. 1 pig can test 2048 buckets in 15360 minutes\n        # 12. 1 pig can test 4096 buckets in 30720 minutes\n        # 13. 1 pig can test 8192 buckets in 61440 minutes\n        # 14. 1 pig can test 16384 buckets in 122880 minutes\n        # 15. 1 pig can test 32768 buckets in 245760 minutes\n        # 16. 1 pig can test 65536 buckets in 491520 minutes\n        # 17. 1 pig can test 131072 buckets in 983040 minutes\n        # 18. 1 pig can test 262144 buckets in 1966080 minutes\n        # 19. 1 pig can test 524288 buckets in 3932160 minutes\n        # 20. 1 pig can test 1048576 buckets in 7864320 minutes\n        # 21. 1 pig can test 2097152 buckets in 15728640 minutes\n        # 22. 1 pig can test 4194304 buckets in 31457280 minutes\n        # 23. 1 pig can test 8388608 buckets in 62914560 minutes\n        # 24. 1 pig can test 16777216 buckets in 125829120 minutes\n        # 25. 1 pig can test 33554432 buckets in 251658240 minutes\n        # 26. 1 pig can test 67108864 buckets in 503316480 minutes\n        # 27. 1 pig can test 134217728 buckets in 1006632960 minutes\n        # 28. 1 pig can test 268435456 buckets in 2013265920 minutes\n        # 29. 1 pig can test 536870912 buckets in 4026531840 minutes\n        # 30. 1 pig can test 1073741824 buckets in 8053063680 minutes\n        # 31. 1 pig can test 2147483648 buckets in 16106127360 minutes\n        # 32. 1 pig can test 4294967296 buckets in 32212254720 minutes\n        # 33. 1 pig can test 8589934592 buckets in 64424509440 minutes\n        # 34. 1 pig can test 17179869184 buckets in 128849018880"}], "swim-in-rising-water": [{"task_id": "swim-in-rising-water", "completion": "class Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        pq = [(grid[0][0], 0, 0)]\n        visited = set()\n        visited.add((0, 0))\n        while pq:\n            t, i, j = heapq.heappop(pq)\n            if i == n - 1 and j == n - 1:\n                return t\n            for x, y in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= x < n and 0 <= y < n and (x, y) not in visited:\n                    visited.add((x, y))\n                    heapq.heappush(pq, (max(t, grid[x][y]), x, y))\n        return -1"}, {"task_id": "swim-in-rising-water", "completion": "class Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # BFS\n        # Time: O(n^2 * log(n^2))\n        # Space: O(n^2)\n        \n        n = len(grid)\n        pq = [(grid[0][0], 0, 0)]\n        visited = set()\n        visited.add((0, 0))\n        res = 0\n        \n        while pq:\n            t, i, j = heapq.heappop(pq)\n            res = max(res, t)\n            if i == n - 1 and j == n - 1:\n                return res\n            for x, y in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= x < n and 0 <= y < n and (x, y) not in visited:\n                    visited.add((x, y))\n                    heapq.heappush(pq, (grid[x][y], x, y))\n        \n        return res"}, {"task_id": "swim-in-rising-water", "completion": "class Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        pq = [(grid[0][0], 0, 0)]\n        visited = set()\n        visited.add((0, 0))\n        while pq:\n            t, i, j = heapq.heappop(pq)\n            if i == n - 1 and j == n - 1:\n                return t\n            for x, y in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= x < n and 0 <= y < n and (x, y) not in visited:\n                    visited.add((x, y))\n                    heapq.heappush(pq, (max(t, grid[x][y]), x, y))\n        return -1"}, {"task_id": "swim-in-rising-water", "completion": "class Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # BFS\n        # Time: O(n^2 * log(n^2))\n        # Space: O(n^2)\n        \n        n = len(grid)\n        pq = [(grid[0][0], 0, 0)]\n        visited = set()\n        visited.add((0, 0))\n        res = 0\n        \n        while pq:\n            t, i, j = heapq.heappop(pq)\n            res = max(res, t)\n            if i == n - 1 and j == n - 1:\n                return res\n            for x, y in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= x < n and 0 <= y < n and (x, y) not in visited:\n                    visited.add((x, y))\n                    heapq.heappush(pq, (grid[x][y], x, y))\n        \n        return res"}, {"task_id": "swim-in-rising-water", "completion": "class Solution(object):\n    def swimInWater(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # BFS\n        # Time: O(n^2 * log(n^2))\n        # Space: O(n^2)\n        \n        n = len(grid)\n        pq = [(grid[0][0], 0, 0)]\n        visited = set()\n        visited.add((0, 0))\n        res = 0\n        \n        while pq:\n            t, i, j = heapq.heappop(pq)\n            res = max(res, t)\n            if i == n - 1 and j == n - 1:\n                return res\n            for x, y in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= x < n and 0 <= y < n and (x, y) not in visited:\n                    visited.add((x, y))\n                    heapq.heappush(pq, (grid[x][y], x, y))\n        \n        return res"}], "unique-paths": [{"task_id": "unique-paths", "completion": "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. DP\n        # Time: O(m*n)\n        # Space: O(m*n)\n        # dp = [[0] * n for _ in range(m)]\n        # dp[0][0] = 1\n        # for i in range(m):\n        #     for j in range(n):\n        #         if i > 0:\n        #             dp[i][j] += dp[i-1][j]\n        #         if j > 0:\n        #             dp[i][j] += dp[i][j-1]\n        # return dp[m-1][n-1]\n        \n        # 2. DP\n        # Time: O(m*n)\n        # Space: O(n)\n        dp = [1] * n\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[j] += dp[j-1]\n        return dp[n-1]\n        \n        # 3. Math\n        # Time: O(m)\n        # Space: O(1)\n        # return math.factorial(m+n-2) // math.factorial(m-1) // math.factorial(n-1)"}, {"task_id": "unique-paths", "completion": "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # DP solution\n        # Time: O(m*n)\n        # Space: O(m*n)\n        \n        dp = [[0 for _ in range(n)] for _ in range(m)]\n        \n        for i in range(m):\n            for j in range(n):\n                if i == 0 or j == 0:\n                    dp[i][j] = 1\n                else:\n                    dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        \n        return dp[m-1][n-1]"}, {"task_id": "unique-paths", "completion": "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # DP solution\n        # Time: O(m*n)\n        # Space: O(m*n)\n        \n        # dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        # dp[0][j] = 1\n        # dp[i][0] = 1\n        \n        dp = [[0 for _ in range(n)] for _ in range(m)]\n        \n        for i in range(m):\n            dp[i][0] = 1\n        \n        for j in range(n):\n            dp[0][j] = 1\n        \n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = dp[i-1][j] + dp"}, {"task_id": "unique-paths", "completion": "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # DP solution\n        # Time: O(m*n)\n        # Space: O(m*n)\n        \n        # dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        \n        dp = [[0 for _ in range(n)] for _ in range(m)]\n        \n        for i in range(m):\n            for j in range(n):\n                if i == 0 or j == 0:\n                    dp[i][j] = 1\n                else:\n                    dp[i][j] = dp[i-1][j] + dp[i][j-1]\n                    \n        return dp[m-1][n-1]"}, {"task_id": "unique-paths", "completion": "class Solution(object):\n    def uniquePaths(self, m, n):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. DP\n        # Time: O(m*n)\n        # Space: O(m*n)\n        # dp = [[0]*n for _ in range(m)]\n        # for i in range(m):\n        #     dp[i][0] = 1\n        # for j in range(n):\n        #     dp[0][j] = 1\n        # for i in range(1, m):\n        #     for j in range(1, n):\n        #         dp[i][j] = dp[i-1][j] + dp[i][j-1]\n        # return dp[m-1][n-1]\n        \n        # 2. DP\n        # Time: O(m*n)\n        # Space: O(n)\n        dp = [1]*n\n        for i in range(1, m):\n            for j in range(1, n):\n                dp[j] += dp[j-1]\n        return dp[n-1]\n        \n        # 3. DP\n        # Time: O(m*n)\n        # Space: O(1)\n        # dp = [1]*n\n        # for i in range(1, m):\n        #     for j in range(1, n):\n        #         dp[j] += dp[j-1]\n        #     dp[0] = 1\n        # return dp[n-1]\n        \n        # 4. DP\n        # Time: O(m*n)\n        # Space: O(1)\n        # dp = [1]*n\n        # for i in range(1, m):\n        #     for j in range(1, n):\n        #         dp[j] += dp[j-1]\n        # return dp[n-1]\n        \n        # 5. DP\n        # Time: O(m*n)\n        # Space: O(1)\n        # dp = [1]*n\n        # for i in range(1, m):\n        #     for j in range(1, n):\n        #         dp[j] += dp[j-1]\n        # return dp[n-1]\n        \n        # 6. DP\n        # Time: O(m*n)\n        # Space: O(1)\n        # dp = [1]*n\n        # for i in range(1, m):\n        #     for j in range(1, n):\n        #         dp[j] += dp[j-1]\n        # return dp[n-1]\n        \n        # 7. DP\n        # Time: O(m*n)\n        # Space: O(1)\n        # dp = [1]*n\n        # for i in range(1, m):\n        #     for j in range(1, n):\n        #         dp[j] += dp[j-1]\n        # return dp[n-1]\n        \n        # 8. DP\n        # Time: O(m*n)\n        # Space: O(1)\n        # dp = [1]*n\n        # for i in range(1, m):\n        #     for j in range(1, n):\n        #         dp[j] += dp[j-1]\n        # return dp[n-1]\n        \n        # 9. DP\n        # Time: O(m*n)\n        # Space: O(1)\n        # dp = [1]*n\n        # for i in range(1, m):\n        #     for j in range(1, n):\n        #         dp[j] += dp[j-1]\n        # return dp[n-1]\n        \n        # 10. DP\n        # Time: O(m*n)\n        # Space: O(1)\n        # dp = [1]*n\n        # for i in range(1, m):\n        #     for j in range(1, n):\n        #         dp[j] += dp[j-1]\n        # return dp[n-1]\n        \n        # 11."}], "multiply-strings": [{"task_id": "multiply-strings", "completion": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. convert num1 and num2 to int\n        num1 = int(num1)\n        num2 = int(num2)\n        \n        # 2. multiply num1 and num2\n        product = num1 * num2\n        \n        # 3. convert product to string\n        product = str(product)\n        \n        # 4. return product\n        return product"}, {"task_id": "multiply-strings", "completion": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. convert num1 and num2 to int\n        num1 = int(num1)\n        num2 = int(num2)\n        \n        # 2. multiply num1 and num2\n        product = num1 * num2\n        \n        # 3. convert product to string\n        product = str(product)\n        \n        # 4. return product\n        return product"}, {"task_id": "multiply-strings", "completion": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. convert num1 and num2 to int\n        num1 = int(num1)\n        num2 = int(num2)\n        \n        # 2. multiply num1 and num2\n        product = num1 * num2\n        \n        # 3. convert product to string\n        product = str(product)\n        \n        # 4. return product\n        return product"}, {"task_id": "multiply-strings", "completion": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. convert to int\n        num1 = int(num1)\n        num2 = int(num2)\n        \n        # 2. multiply\n        product = num1 * num2\n        \n        # 3. convert to string\n        product = str(product)\n        \n        return product"}, {"task_id": "multiply-strings", "completion": "class Solution(object):\n    def multiply(self, num1, num2):\n        \"\"\"\n        :type num1: str\n        :type num2: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. convert to int\n        num1 = int(num1)\n        num2 = int(num2)\n        \n        # 2. multiply\n        product = num1 * num2\n        \n        # 3. convert to string\n        product = str(product)\n        \n        return product"}], "best-time-to-buy-and-sell-stock-iii": [{"task_id": "best-time-to-buy-and-sell-stock-iii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2D DP\n        # Time: O(n)\n        # Space: O(n)\n        # dp[i][j] = max profit from 0 to i with j transactions\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + prices[i])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + prices[i], dp[i-1][j] - prices[i])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + prices[i], dp[i-1][j] - prices[i])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + prices[i], dp[i-1][j] - prices[i], dp[i-1][j] + prices[i])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + prices[i], dp[i-1][j] - prices[i], dp[i-1][j] + prices[i], dp[i-1][j] - prices[i] + prices[i])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + prices[i], dp[i-1][j] - prices[i], dp[i-1][j] + prices[i], dp[i-1][j] - prices[i] + prices[i], dp[i-1][j] + prices[i] - prices[i])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + prices[i], dp[i-1][j] - prices[i], dp[i-1][j] + prices[i], dp[i-1][j] - prices[i] + prices[i], dp[i-1][j] + prices[i] - prices[i], dp[i-1][j] + prices[i] - prices[i])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + prices[i], dp[i-1][j] - prices[i], dp[i-1][j] + prices[i], dp[i-1][j] - prices[i] + prices[i], dp[i-1][j] + prices[i] - prices[i], dp[i-1][j] + prices[i] - prices[i], dp[i-1][j] + prices[i] - prices[i])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + prices[i], dp[i-1][j] - prices[i], dp[i-1][j] + prices[i], dp[i-1][j] - prices[i] + prices[i], dp[i-1][j] + prices[i] - prices[i], dp[i-1][j] + prices[i] - prices[i], dp[i-1][j] + prices[i] - prices[i], dp[i-1][j] + prices[i] - prices[i])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + prices[i], dp[i-1][j] - prices[i], dp[i-1][j] + prices[i], dp[i-1][j] - prices[i] + prices[i], dp[i-1][j] + prices[i] - prices[i], dp[i-1][j] + prices[i] - prices[i], dp[i-1][j] + prices[i] - prices[i], dp[i-1][j] + prices[i] - prices[i],"}, {"task_id": "best-time-to-buy-and-sell-stock-iii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2D DP\n        # Time: O(n)\n        # Space: O(n)\n        # dp[i][j] = max profit for up to i days, j transactions\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + prices[i] - prices[i-1])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + prices[i] - prices[i-1])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + prices[i] - prices[s])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + prices[i] - prices[s])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + prices[i] - prices[s])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + prices[i] - prices[s])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + prices[i] - prices[s])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + prices[i] - prices[s])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + prices[i] - prices[s])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + prices[i] - prices[s])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + prices[i] - prices[s])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + prices[i] - prices[s])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + prices[i] - prices[s])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + prices[i] - prices[s])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + prices[i] - prices[s])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + prices[i] - prices[s])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + prices[i] - prices[s])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + prices[i] - prices[s])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + prices[i] - prices[s])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + prices[i] - prices[s])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + prices[i] - prices[s])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + prices[i] - prices[s])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + prices[i] - prices[s])\n        # d"}, {"task_id": "best-time-to-buy-and-sell-stock-iii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2D DP\n        # Time: O(n)\n        # Space: O(n)\n        # dp[i][j] = max profit from 0 to i with j transactions\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + prices[i])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + prices[i], dp[i-1][j] - prices[i])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + prices[i], dp[i-1][j] - prices[i])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + prices[i], dp[i-1][j] - prices[i], dp[i-1][j] + prices[i])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + prices[i], dp[i-1][j] - prices[i], dp[i-1][j] + prices[i], dp[i-1][j] - prices[i] + prices[i])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + prices[i], dp[i-1][j] - prices[i], dp[i-1][j] + prices[i], dp[i-1][j] - prices[i] + prices[i], dp[i-1][j] + prices[i] - prices[i])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + prices[i], dp[i-1][j] - prices[i], dp[i-1][j] + prices[i], dp[i-1][j] - prices[i] + prices[i], dp[i-1][j] + prices[i] - prices[i], dp[i-1][j] + prices[i] - prices[i])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + prices[i], dp[i-1][j] - prices[i], dp[i-1][j] + prices[i], dp[i-1][j] - prices[i] + prices[i], dp[i-1][j] + prices[i] - prices[i], dp[i-1][j] + prices[i] - prices[i], dp[i-1][j] + prices[i] - prices[i])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + prices[i], dp[i-1][j] - prices[i], dp[i-1][j] + prices[i], dp[i-1][j] - prices[i] + prices[i], dp[i-1][j] + prices[i] - prices[i], dp[i-1][j] + prices[i] - prices[i], dp[i-1][j] + prices[i] - prices[i], dp[i-1][j] + prices[i] - prices[i])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + prices[i], dp[i-1][j] - prices[i], dp[i-1][j] + prices[i], dp[i-1][j] - prices[i] + prices[i], dp[i-1][j] + prices[i] - prices[i], dp[i-1][j] + prices[i] - prices[i], dp[i-1][j] + prices[i] - prices[i], dp[i-1][j] + prices[i] - prices[i],"}, {"task_id": "best-time-to-buy-and-sell-stock-iii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2D DP\n        # Time: O(n)\n        # Space: O(n)\n        # dp[i][j] = max profit for up to i days, j transactions\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + prices[i])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + prices[i], dp[i-1][j] - prices[i])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + prices[i], dp[i-1][j] - prices[i])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + prices[i], dp[i-1][j] - prices[i], dp[i-1][j] + prices[i])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + prices[i], dp[i-1][j] - prices[i], dp[i-1][j] + prices[i], dp[i-1][j] - prices[i] + prices[i])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + prices[i], dp[i-1][j] - prices[i], dp[i-1][j] + prices[i], dp[i-1][j] - prices[i] + prices[i], dp[i-1][j] + prices[i] - prices[i])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + prices[i], dp[i-1][j] - prices[i], dp[i-1][j] + prices[i], dp[i-1][j] - prices[i] + prices[i], dp[i-1][j] + prices[i] - prices[i], dp[i-1][j] + prices[i] - prices[i])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + prices[i], dp[i-1][j] - prices[i], dp[i-1][j] + prices[i], dp[i-1][j] - prices[i] + prices[i], dp[i-1][j] + prices[i] - prices[i], dp[i-1][j] + prices[i] - prices[i], dp[i-1][j] + prices[i] - prices[i])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + prices[i], dp[i-1][j] - prices[i], dp[i-1][j] + prices[i], dp[i-1][j] - prices[i] + prices[i], dp[i-1][j] + prices[i] - prices[i], dp[i-1][j] + prices[i] - prices[i], dp[i-1][j] + prices[i] - prices[i], dp[i-1][j] + prices[i] - prices[i])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + prices[i], dp[i-1][j] - prices[i], dp[i-1][j] + prices[i], dp[i-1][j] - prices[i] + prices[i], dp[i-1][j] + prices[i] - prices[i], dp[i-1][j] + prices[i] - prices[i], dp[i-1][j] + prices[i] - prices[i], dp[i-1][j] + prices[i] - prices[i],"}, {"task_id": "best-time-to-buy-and-sell-stock-iii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2D DP\n        # Time: O(n)\n        # Space: O(n)\n        # dp[i][j] = max profit from 0 to i with j transactions\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + prices[i])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + prices[i], dp[i-1][j] - prices[i])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + prices[i], dp[i-1][j] - prices[i])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + prices[i], dp[i-1][j] - prices[i], dp[i-1][j] + prices[i])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + prices[i], dp[i-1][j] - prices[i], dp[i-1][j] + prices[i], dp[i-1][j] - prices[i] + prices[i])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + prices[i], dp[i-1][j] - prices[i], dp[i-1][j] + prices[i], dp[i-1][j] - prices[i] + prices[i], dp[i-1][j] + prices[i] - prices[i])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + prices[i], dp[i-1][j] - prices[i], dp[i-1][j] + prices[i], dp[i-1][j] - prices[i] + prices[i], dp[i-1][j] + prices[i] - prices[i], dp[i-1][j] + prices[i] - prices[i])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + prices[i], dp[i-1][j] - prices[i], dp[i-1][j] + prices[i], dp[i-1][j] - prices[i] + prices[i], dp[i-1][j] + prices[i] - prices[i], dp[i-1][j] + prices[i] - prices[i], dp[i-1][j] + prices[i] - prices[i])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + prices[i], dp[i-1][j] - prices[i], dp[i-1][j] + prices[i], dp[i-1][j] - prices[i] + prices[i], dp[i-1][j] + prices[i] - prices[i], dp[i-1][j] + prices[i] - prices[i], dp[i-1][j] + prices[i] - prices[i], dp[i-1][j] + prices[i] - prices[i])\n        # dp[i][j] = max(dp[i-1][j], dp[i-1][j-1] + prices[i], dp[i-1][j] - prices[i], dp[i-1][j] + prices[i], dp[i-1][j] - prices[i] + prices[i], dp[i-1][j] + prices[i] - prices[i], dp[i-1][j] + prices[i] - prices[i], dp[i-1][j] + prices[i] - prices[i], dp[i-1][j] + prices[i] - prices[i],"}], "combination-sum-ii": [{"task_id": "combination-sum-ii", "completion": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        self.dfs(candidates, target, [], res)\n        return res\n    \n    def dfs(self, nums, target, path, res):\n        if target < 0:\n            return  # backtracking\n        if target == 0:\n            res.append(path)\n            return \n        for i in range(len(nums)):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            if nums[i] > target:\n                break\n            self.dfs(nums[i+1:], target-nums[i], path+[nums[i]], res)"}, {"task_id": "combination-sum-ii", "completion": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        self.dfs(candidates, target, [], res)\n        return res\n    \n    def dfs(self, nums, target, path, res):\n        if target < 0:\n            return  # backtracking\n        if target == 0:\n            res.append(path)\n            return \n        for i in range(len(nums)):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            if nums[i] > target:\n                break\n            self.dfs(nums[i+1:], target-nums[i], path+[nums[i]], res)"}, {"task_id": "combination-sum-ii", "completion": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        self.dfs(candidates, target, [], res)\n        return res\n    \n    def dfs(self, nums, target, path, res):\n        if target < 0:\n            return  # backtracking\n        if target == 0:\n            res.append(path)\n            return \n        for i in range(len(nums)):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            if nums[i] > target:\n                break\n            self.dfs(nums[i+1:], target-nums[i], path+[nums[i]], res)"}, {"task_id": "combination-sum-ii", "completion": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        self.dfs(candidates, target, [], res)\n        return res\n    \n    def dfs(self, nums, target, path, res):\n        if target < 0:\n            return  # backtracking\n        if target == 0:\n            res.append(path)\n            return \n        for i in range(len(nums)):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            if nums[i] > target:\n                break\n            self.dfs(nums[i+1:], target-nums[i], path+[nums[i]], res)"}, {"task_id": "combination-sum-ii", "completion": "class Solution(object):\n    def combinationSum2(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        candidates.sort()\n        res = []\n        self.dfs(candidates, target, [], res)\n        return res\n    \n    def dfs(self, nums, target, path, res):\n        if target < 0:\n            return  # backtracking\n        if target == 0:\n            res.append(path)\n            return \n        for i in range(len(nums)):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            if nums[i] > target:\n                break\n            self.dfs(nums[i+1:], target-nums[i], path+[nums[i]], res)"}], "detect-capital": [{"task_id": "detect-capital", "completion": "class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if word.isupper():\n            return True\n        elif word.islower():\n            return True\n        elif word[0].isupper() and word[1:].islower():\n            return True\n        else:\n            return False"}, {"task_id": "detect-capital", "completion": "class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if word.isupper():\n            return True\n        elif word.islower():\n            return True\n        elif word[0].isupper() and word[1:].islower():\n            return True\n        else:\n            return False"}, {"task_id": "detect-capital", "completion": "class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if word.isupper():\n            return True\n        elif word.islower():\n            return True\n        elif word[0].isupper() and word[1:].islower():\n            return True\n        else:\n            return False"}, {"task_id": "detect-capital", "completion": "class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(word) == 1:\n            return True\n        \n        if word[0].isupper() and word[1].isupper():\n            for i in range(2, len(word)):\n                if word[i].islower():\n                    return False\n            return True\n        elif word[0].isupper() and word[1].islower():\n            for i in range(2, len(word)):\n                if word[i].isupper():\n                    return False\n            return True\n        elif word[0].islower():\n            for i in range(1, len(word)):\n                if word[i].isupper():\n                    return False\n            return True\n        else:\n            return False"}, {"task_id": "detect-capital", "completion": "class Solution(object):\n    def detectCapitalUse(self, word):\n        \"\"\"\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(word) == 1:\n            return True\n        \n        if word[0].isupper() and word[1].isupper():\n            for i in range(2, len(word)):\n                if word[i].islower():\n                    return False\n            return True\n        \n        if word[0].isupper() and word[1].islower():\n            for i in range(2, len(word)):\n                if word[i].isupper():\n                    return False\n            return True\n        \n        if word[0].islower():\n            for i in range(1, len(word)):\n                if word[i].isupper():\n                    return False\n            return True\n        \n        return False"}], "best-time-to-buy-and-sell-stock": [{"task_id": "best-time-to-buy-and-sell-stock", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # Time: O(n)\n        # Space: O(1)\n        # Runtime: 100 ms, faster than 99.99% of Python online submissions for Best Time to Buy and Sell Stock.\n        # Memory Usage: 21.5 MB, less than 99.99% of Python online submissions for Best Time to Buy and Sell Stock.\n        # 2. \n        # Time: O(n)\n        # Space: O(1)\n        # Runtime: 100 ms, faster than 99.99% of Python online submissions for Best Time to Buy and Sell Stock.\n        # Memory Usage: 21.5 MB, less than 99.99% of Python online submissions for Best Time to Buy and Sell Stock.\n        # 3. \n        # Time: O(n)\n        # Space: O(1)\n        # Runtime: 100 ms, faster than 99.99% of Python online submissions for Best Time to Buy and Sell Stock.\n        # Memory Usage: 21.5 MB, less than 99.99% of Python online submissions for Best Time to Buy and Sell Stock.\n        # 4. \n        # Time: O(n)\n        # Space: O(1)\n        # Runtime: 100 ms, faster than 99.99% of Python online submissions for Best Time to Buy and Sell Stock.\n        # Memory Usage: 21.5 MB, less than 99.99% of Python online submissions for Best Time to Buy and Sell Stock.\n        # 5. \n        # Time: O(n)\n        # Space: O(1)\n        # Runtime: 100 ms, faster than 99.99% of Python online submissions for Best Time to Buy and Sell Stock.\n        # Memory Usage: 21.5 MB, less than 99.99% of Python online submissions for Best Time to Buy and Sell Stock.\n        # 6. \n        # Time: O(n)\n        # Space: O(1)\n        # Runtime: 100 ms, faster than 99.99% of Python online submissions for Best Time to Buy and Sell Stock.\n        # Memory Usage: 21.5 MB, less than 99.99% of Python online submissions for Best Time to Buy and Sell Stock.\n        # 7. \n        # Time: O(n)\n        # Space: O(1)\n        # Runtime: 100 ms, faster than 99.99% of Python online submissions for Best Time to Buy and Sell Stock.\n        # Memory Usage: 21.5 MB, less than 99.99% of Python online submissions for Best Time to Buy and Sell Stock.\n        # 8. \n        # Time: O(n)\n        # Space: O(1)\n        # Runtime: 100 ms, faster than 99.99% of Python online submissions for Best Time to Buy and Sell Stock.\n        # Memory Usage: 21.5 MB, less than 99.99% of Python online submissions for Best Time to Buy and Sell Stock.\n        # 9. \n        # Time: O(n)\n        # Space: O(1)\n        # Runtime: 100 ms, faster than 99.99% of Python online submissions for Best Time to Buy and Sell Stock.\n        # Memory Usage: 21.5 MB, less than 99.99% of Python online submissions for Best Time to Buy and Sell Stock.\n        # 10. \n        # Time: O(n)\n        # Space: O(1)\n        # Runtime: 100 ms, faster than 99.99% of Python online submissions for Best Time to Buy and Sell Stock.\n        # Memory Usage: 21.5 MB, less than 99.99% of Python online submissions for Best Time to Buy and Sell Stock.\n        # 11. \n        # Time: O(n)\n        # Space: O(1)\n        # Runtime: 100 ms, faster than 99.9"}, {"task_id": "best-time-to-buy-and-sell-stock", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # Time: O(n)\n        # Space: O(1)\n        # Runtime: 100 ms, faster than 99.99% of Python online submissions for Best Time to Buy and Sell Stock.\n        # Memory Usage: 21.4 MB, less than 99.99% of Python online submissions for Best Time to Buy and Sell Stock.\n        # 2. \n        # Time: O(n)\n        # Space: O(1)\n        # Runtime: 100 ms, faster than 99.99% of Python online submissions for Best Time to Buy and Sell Stock.\n        # Memory Usage: 21.4 MB, less than 99.99% of Python online submissions for Best Time to Buy and Sell Stock.\n        # 3. \n        # Time: O(n)\n        # Space: O(1)\n        # Runtime: 100 ms, faster than 99.99% of Python online submissions for Best Time to Buy and Sell Stock.\n        # Memory Usage: 21.4 MB, less than 99.99% of Python online submissions for Best Time to Buy and Sell Stock.\n        # 4. \n        # Time: O(n)\n        # Space: O(1)\n        # Runtime: 100 ms, faster than 99.99% of Python online submissions for Best Time to Buy and Sell Stock.\n        # Memory Usage: 21.4 MB, less than 99.99% of Python online submissions for Best Time to Buy and Sell Stock.\n        # 5. \n        # Time: O(n)\n        # Space: O(1)\n        # Runtime: 100 ms, faster than 99.99% of Python online submissions for Best Time to Buy and Sell Stock.\n        # Memory Usage: 21.4 MB, less than 99.99% of Python online submissions for Best Time to Buy and Sell Stock.\n        # 6. \n        # Time: O(n)\n        # Space: O(1)\n        # Runtime: 100 ms, faster than 99.99% of Python online submissions for Best Time to Buy and Sell Stock.\n        # Memory Usage: 21.4 MB, less than 99.99% of Python online submissions for Best Time to Buy and Sell Stock.\n        # 7. \n        # Time: O(n)\n        # Space: O(1)\n        # Runtime: 100 ms, faster than 99.99% of Python online submissions for Best Time to Buy and Sell Stock.\n        # Memory Usage: 21.4 MB, less than 99.99% of Python online submissions for Best Time to Buy and Sell Stock.\n        # 8. \n        # Time: O(n)\n        # Space: O(1)\n        # Runtime: 100 ms, faster than 99.99% of Python online submissions for Best Time to Buy and Sell Stock.\n        # Memory Usage: 21.4 MB, less than 99.99% of Python online submissions for Best Time to Buy and Sell Stock.\n        # 9. \n        # Time: O(n)\n        # Space: O(1)\n        # Runtime: 100 ms, faster than 99.99% of Python online submissions for Best Time to Buy and Sell Stock.\n        # Memory Usage: 21.4 MB, less than 99.99% of Python online submissions for Best Time to Buy and Sell Stock.\n        # 10. \n        # Time: O(n)\n        # Space: O(1)\n        # Runtime: 100 ms, faster than 99.99% of Python online submissions for Best Time to Buy and Sell Stock.\n        # Memory Usage: 21.4 MB, less than 99.99% of Python online submissions for Best Time to Buy and Sell Stock.\n        # 11. \n        # Time: O(n)\n        # Space: O(1)\n        # Runtime: 100 ms, faster than 99.9"}, {"task_id": "best-time-to-buy-and-sell-stock", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## Runtime: 1824 ms, faster than 5.01% of Python online submissions for Best Time to Buy and Sell Stock.\n        ## Memory Usage: 22.4 MB, less than 10.00% of Python online submissions for Best Time to Buy and Sell Stock.\n        ## n = len(prices)\n        ## max_profit = 0\n        ## for i in range(n):\n        ##     for j in range(i+1, n):\n        ##         profit = prices[j] - prices[i]\n        ##         if profit > max_profit:\n        ##             max_profit = profit\n        ## return max_profit\n        \n        ## 2. One Pass\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 200 ms, faster than 99.22% of Python online submissions for Best Time to Buy and Sell Stock.\n        ## Memory Usage: 22.4 MB, less than 10.00% of Python online submissions for Best Time to Buy and Sell Stock.\n        ## n = len(prices)\n        ## min_price = float('inf')\n        ## max_profit = 0\n        ## for i in range(n):\n        ##     if prices[i] < min_price:\n        ##         min_price = prices[i]\n        ##     elif prices[i] - min_price > max_profit:\n        ##         max_profit = prices[i] - min_price\n        ## return max_profit\n        \n        ## 3. One Pass\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 200 ms, faster than 99.22% of Python online submissions for Best Time to Buy and Sell Stock.\n        ## Memory Usage: 22.4 MB, less than 10.00% of Python online submissions for Best Time to Buy and Sell Stock.\n        ## n = len(prices)\n        ## min_price = float('inf')\n        ## max_profit = 0\n        ## for i in range(n):\n        ##     min_price = min(min_price, prices[i])\n        ##     max_profit = max(max_profit, prices[i] - min_price)\n        ## return max_profit\n        \n        ## 4. One Pass\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 200 ms, faster than 99.22% of Python online submissions for Best Time to Buy and Sell Stock.\n        ## Memory Usage: 22.4 MB, less than 10.00% of Python online submissions for Best Time to Buy and Sell Stock.\n        ## n = len(prices)\n        ## min_price = float('inf')\n        ## max_profit = 0\n        ## for i in range(n):\n        ##     min_price = min(min_price, prices[i])\n        ##     max_profit = max(max"}, {"task_id": "best-time-to-buy-and-sell-stock", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## Runtime: 1260 ms, faster than 5.01% of Python online submissions for Best Time to Buy and Sell Stock.\n        ## Memory Usage: 22.4 MB, less than 10.00% of Python online submissions for Best Time to Buy and Sell Stock.\n        \n        ## 2. Two Pointers\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 124 ms, faster than 99.99% of Python online submissions for Best Time to Buy and Sell Stock.\n        ## Memory Usage: 22.4 MB, less than 10.00% of Python online submissions for Best Time to Buy and Sell Stock.\n        \n        ## 3. Kadane's Algorithm\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 124 ms, faster than 99.99% of Python online submissions for Best Time to Buy and Sell Stock.\n        ## Memory Usage: 22.4 MB, less than 10.00% of Python online submissions for Best Time to Buy and Sell Stock.\n        \n        ## 4. Kadane's Algorithm (Optimized)\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 124 ms, faster than 99.99% of Python online submissions for Best Time to Buy and Sell Stock.\n        ## Memory Usage: 22.4 MB, less than 10."}, {"task_id": "best-time-to-buy-and-sell-stock", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## Runtime: 168 ms, faster than 5.01% of Python online submissions for Best Time to Buy and Sell Stock.\n        ## Memory Usage: 13.5 MB, less than 99.99% of Python online submissions for Best Time to Buy and Sell Stock.\n        ## 2. Two Pointers\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 164 ms, faster than 5.01% of Python online submissions for Best Time to Buy and Sell Stock.\n        ## Memory Usage: 13.5 MB, less than 99.99% of Python online submissions for Best Time to Buy and Sell Stock.\n        ## 3. Dynamic Programming\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 164 ms, faster than 5.01% of Python online submissions for Best Time to Buy and Sell Stock.\n        ## Memory Usage: 13.5 MB, less than 99.99% of Python online submissions for Best Time to Buy and Sell Stock.\n        ## 4. Dynamic Programming\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 164 ms, faster than 5.01% of Python online submissions for Best Time to Buy and Sell Stock.\n        ## Memory Usage: 13.5 MB, less than 9999.99% of Python online submissions for Best Time to Buy and Sell Stock.\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## Runtime: 168 ms, faster than 5.01% of Python online submissions for Best Time to Buy and Sell Stock.\n        ## Memory Usage: 13.5 MB, less than 99.99% of Python online submissions for Best Time to Buy and Sell Stock.\n        ## 2. Two Pointers\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 164 ms, faster than 5.01% of Python online submissions for Best Time to Buy and Sell Stock.\n        ## Memory Usage: 13.5 MB, less than 99.99% of Python online submissions for Best Time to Buy and Sell Stock.\n        ## 3. Dynamic Programming\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 164 ms, faster than 5.01% of Python online submissions for Best Time to Buy and Sell Stock.\n        ## Memory Usage: 13.5 MB, less than 99.99% of Python online submissions for Best Time to Buy and Sell Stock.\n        ## 4. Dynamic Programming\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 164 ms, faster than 5.01% of Python online submissions for Best Time to Buy and Sell Stock.\n        ## Memory Usage: 13.5 MB, less than 99.99% of Python online submissions for Best Time to Buy and Sell Stock.\n        \n        ## 1. Brute Force\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(1)\n        ## Runtime: 168 ms, faster than 5.01% of Python online submissions for Best Time to Buy and Sell Stock.\n        ## Memory Usage: 13.5 MB, less than 99.99% of Python online submissions for Best Time to Buy and Sell Stock.\n        ## 2. Two Pointers\n        ## Time"}], "binary-tree-inorder-traversal": [{"task_id": "binary-tree-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        # Recursive solution\n        # if root is None:\n        #     return []\n        # return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right)\n        \n        # Iterative solution\n        stack = []\n        res = []\n        while root or stack:\n            while root:\n                stack.append(root)\n                root = root.left\n            root = stack.pop()\n            res.append(root.val)\n            root = root.right\n        return res"}, {"task_id": "binary-tree-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        # Recursive solution\n        # if root is None:\n        #     return []\n        # return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right)\n        \n        # Iterative solution\n        stack = []\n        res = []\n        curr = root\n        while curr or stack:\n            while curr:\n                stack.append(curr)\n                curr = curr.left\n            curr = stack.pop()\n            res.append(curr.val)\n            curr = curr.right\n        return res"}, {"task_id": "binary-tree-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        # Recursive solution\n        # if root is None:\n        #     return []\n        # return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right)\n        \n        # Iterative solution\n        stack = []\n        res = []\n        while root or stack:\n            while root:\n                stack.append(root)\n                root = root.left\n            root = stack.pop()\n            res.append(root.val)\n            root = root.right\n        return res"}, {"task_id": "binary-tree-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        # Recursive solution\n        # if root is None:\n        #     return []\n        # return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right)\n        \n        # Iterative solution\n        stack = []\n        res = []\n        curr = root\n        while curr or stack:\n            while curr:\n                stack.append(curr)\n                curr = curr.left\n            curr = stack.pop()\n            res.append(curr.val)\n            curr = curr.right\n        return res"}, {"task_id": "binary-tree-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def inorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        # Recursive solution\n        # if root is None:\n        #     return []\n        # return self.inorderTraversal(root.left) + [root.val] + self.inorderTraversal(root.right)\n        \n        # Iterative solution\n        stack = []\n        res = []\n        curr = root\n        while curr or stack:\n            while curr:\n                stack.append(curr)\n                curr = curr.left\n            curr = stack.pop()\n            res.append(curr.val)\n            curr = curr.right\n        return res"}], "construct-binary-tree-from-preorder-and-inorder-traversal": [{"task_id": "construct-binary-tree-from-preorder-and-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not preorder or not inorder:\n            return None\n        \n        root = TreeNode(preorder[0])\n        mid = inorder.index(preorder[0])\n        root.left = self.buildTree(preorder[1:mid+1], inorder[:mid])\n        root.right = self.buildTree(preorder[mid+1:], inorder[mid+1:])\n        return root"}, {"task_id": "construct-binary-tree-from-preorder-and-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not preorder or not inorder:\n            return None\n        \n        root = TreeNode(preorder[0])\n        mid = inorder.index(preorder[0])\n        root.left = self.buildTree(preorder[1:mid+1], inorder[:mid])\n        root.right = self.buildTree(preorder[mid+1:], inorder[mid+1:])\n        return root"}, {"task_id": "construct-binary-tree-from-preorder-and-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not preorder or not inorder:\n            return None\n        \n        root = TreeNode(preorder[0])\n        mid = inorder.index(preorder[0])\n        root.left = self.buildTree(preorder[1:mid+1], inorder[:mid])\n        root.right = self.buildTree(preorder[mid+1:], inorder[mid+1:])\n        return root"}, {"task_id": "construct-binary-tree-from-preorder-and-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not preorder or not inorder:\n            return None\n        \n        root = TreeNode(preorder[0])\n        mid = inorder.index(preorder[0])\n        root.left = self.buildTree(preorder[1:mid+1], inorder[:mid])\n        root.right = self.buildTree(preorder[mid+1:], inorder[mid+1:])\n        return root"}, {"task_id": "construct-binary-tree-from-preorder-and-inorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, preorder, inorder):\n        \"\"\"\n        :type preorder: List[int]\n        :type inorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        if not preorder or not inorder:\n            return None\n        \n        root = TreeNode(preorder[0])\n        mid = inorder.index(preorder[0])\n        root.left = self.buildTree(preorder[1:mid+1], inorder[:mid])\n        root.right = self.buildTree(preorder[mid+1:], inorder[mid+1:])\n        return root"}], "remove-invalid-parentheses": [{"task_id": "remove-invalid-parentheses", "completion": "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        \n        def isValid(s):\n            count = 0\n            for c in s:\n                if c == '(':\n                    count += 1\n                elif c == ')':\n                    count -= 1\n                    if count < 0:\n                        return False\n            return count == 0\n        \n        level = {s}\n        while True:\n            valid = filter(isValid, level)\n            if valid:\n                return valid\n            level = {s[:i] + s[i+1:] for s in level for i in range(len(s))}"}, {"task_id": "remove-invalid-parentheses", "completion": "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        \n        def isValid(s):\n            count = 0\n            for c in s:\n                if c == '(':\n                    count += 1\n                elif c == ')':\n                    count -= 1\n                    if count < 0:\n                        return False\n            return count == 0\n        \n        level = {s}\n        while True:\n            valid = filter(isValid, level)\n            if valid:\n                return valid\n            level = {s[:i] + s[i+1:] for s in level for i in range(len(s))}"}, {"task_id": "remove-invalid-parentheses", "completion": "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        \n        def isValid(s):\n            count = 0\n            for c in s:\n                if c == '(':\n                    count += 1\n                elif c == ')':\n                    count -= 1\n                    if count < 0:\n                        return False\n            return count == 0\n        \n        level = {s}\n        while True:\n            valid = filter(isValid, level)\n            if valid:\n                return valid\n            level = {s[:i] + s[i+1:] for s in level for i in range(len(s))}"}, {"task_id": "remove-invalid-parentheses", "completion": "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        \n        def isValid(s):\n            count = 0\n            for c in s:\n                if c == '(':\n                    count += 1\n                elif c == ')':\n                    count -= 1\n                    if count < 0:\n                        return False\n            return count == 0\n        \n        level = {s}\n        while True:\n            valid = filter(isValid, level)\n            if valid:\n                return valid\n            level = {s[:i] + s[i+1:] for s in level for i in range(len(s))}"}, {"task_id": "remove-invalid-parentheses", "completion": "class Solution(object):\n    def removeInvalidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: List[str]\n        \"\"\"\n        \n        def isValid(s):\n            count = 0\n            for c in s:\n                if c == '(':\n                    count += 1\n                elif c == ')':\n                    count -= 1\n                    if count < 0:\n                        return False\n            return count == 0\n        \n        level = {s}\n        while True:\n            valid = filter(isValid, level)\n            if valid:\n                return valid\n            level = {s[:i] + s[i+1:] for s in level for i in range(len(s))}"}], "merge-k-sorted-lists": [{"task_id": "merge-k-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        \n        # 1. \uc785\ub825\uac12\uc774 \ube44\uc5b4\uc788\ub2e4\uba74 \ube48 \ub9ac\uc2a4\ud2b8 \ubc18\ud658\n        if not lists:\n            return None\n        \n        # 2. \uc785\ub825\uac12\uc774 \ud558\ub098\ub77c\uba74 \uadf8\ub300\ub85c \ubc18\ud658\n        if len(lists) == 1:\n            return lists[0]\n        \n        # 3. \uc785\ub825\uac12\uc774 \ub450\uac1c \uc774\uc0c1\uc774\ub77c\uba74 \uc7ac\uadc0\ud568\uc218 \ud638\ucd9c\n        mid = len(lists) // 2\n        left = self.mergeKLists(lists[:mid])\n        right = self.mergeKLists(lists[mid:])\n        \n        # 4. \uc7ac\uadc0\ud568\uc218 \ud638\ucd9c \uacb0\uacfc\ub97c \ubcd1\ud569\n        return self.merge(left, right)\n    \n    def merge(self, l, r):\n        # 5. \ubcd1\ud569 \uacfc\uc815\uc5d0\uc11c \uc0ac\uc6a9\ud560 \ub178\ub4dc \ucd08\uae30\ud654\n        root = ListNode(0)\n        cur = root\n        \n        # 6. \ub450 \ub9ac\uc2a4\ud2b8\uc758 \ub178\ub4dc\ub97c \ube44\uad50\ud558\uc5ec \uc791\uc740 \uac12\uc744 \ucc28\ub840\ub300\ub85c \uc5f0\uacb0\n        while l and r:\n            if l.val < r.val:\n                cur.next = l\n                l = l.next\n            else:\n                cur.next = r\n                r = r.next\n            cur = cur.next\n        \n        # 7. \ub0a8\uc740 \ub9ac\uc2a4\ud2b8\ub97c \uc5f0\uacb0\n        cur.next = l or r\n        \n        # 8. \ubcd1\ud569\ub41c \ub9ac\uc2a4\ud2b8\uc758 \uccab \ubc88\uc9f8 \ub178\ub4dc\ub97c \ubc18\ud658\n        return root.next"}, {"task_id": "merge-k-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        \n        # 1. create a new linked list\n        # 2. add the smallest element from each linked list to the new linked list\n        # 3. repeat until all linked lists are empty\n        \n        # 1. create a new linked list\n        new_list = ListNode()\n        current = new_list\n        \n        # 2. add the smallest element from each linked list to the new linked list\n        while True:\n            # 2.1 find the smallest element from each linked list\n            smallest = None\n            for i in range(len(lists)):\n                if lists[i] and (smallest is None or lists[i].val < smallest.val):\n                    smallest = lists[i]\n            \n            # 2.2 add the smallest element to the new linked list\n            if smallest is None:\n                break\n            current.next = smallest\n            current = current.next\n            lists[i] = lists[i].next\n        \n        # 3. return the new linked list\n        return new_list.next"}, {"task_id": "merge-k-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        \n        if not lists:\n            return None\n        \n        if len(lists) == 1:\n            return lists[0]\n        \n        mid = len(lists) // 2\n        left = self.mergeKLists(lists[:mid])\n        right = self.mergeKLists(lists[mid:])\n        \n        return self.merge(left, right)\n    \n    def merge(self, l1, l2):\n        dummy = ListNode()\n        curr = dummy\n        \n        while l1 and l2:\n            if l1.val < l2.val:\n                curr.next = l1\n                l1 = l1.next\n            else:\n                curr.next = l2\n                l2 = l2.next\n            curr = curr.next\n        \n        if l1:\n            curr.next = l1\n        if l2:\n            curr.next = l2\n        \n        return dummy.next"}, {"task_id": "merge-k-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        \n        # 1. create a new linked list\n        # 2. add the smallest element from each linked list to the new linked list\n        # 3. repeat until all linked lists are empty\n        \n        # 1. create a new linked list\n        new_list = ListNode()\n        current = new_list\n        \n        # 2. add the smallest element from each linked list to the new linked list\n        while True:\n            # 2.1 find the smallest element from each linked list\n            smallest = None\n            for i in range(len(lists)):\n                if lists[i] and (smallest is None or lists[i].val < smallest.val):\n                    smallest = lists[i]\n            \n            # 2.2 add the smallest element to the new linked list\n            if smallest is None:\n                break\n            current.next = smallest\n            current = current.next\n            lists[i] = lists[i].next\n        \n        # 3. return the new linked list\n        return new_list.next"}, {"task_id": "merge-k-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeKLists(self, lists):\n        \"\"\"\n        :type lists: List[ListNode]\n        :rtype: ListNode\n        \"\"\"\n        \n        # 1. \uc785\ub825\uac12\uc774 \ube44\uc5b4\uc788\uc744 \ub54c \uc608\uc678\ucc98\ub9ac\n        if not lists:\n            return None\n        \n        # 2. \uc785\ub825\uac12\uc774 \ud558\ub098\uc77c \ub54c \uc608\uc678\ucc98\ub9ac\n        if len(lists) == 1:\n            return lists[0]\n        \n        # 3. \uc785\ub825\uac12\uc774 \ub450 \uac1c \uc774\uc0c1\uc77c \ub54c \uc608\uc678\ucc98\ub9ac\n        mid = len(lists) // 2\n        left = self.mergeKLists(lists[:mid])\n        right = self.mergeKLists(lists[mid:])\n        \n        # 4. \ub450 \uac1c\uc758 \uc815\ub82c\ub41c \ub9ac\uc2a4\ud2b8\ub97c \ud569\uce58\ub294 \uacfc\uc815\n        return self.merge(left, right)\n    \n    def merge(self, l, r):\n        # \uc7ac\uadc0\ud568\uc218\ub97c \uc774\uc6a9\ud574\uc11c \ub450 \uac1c\uc758 \uc815\ub82c\ub41c \ub9ac\uc2a4\ud2b8\ub97c \ud569\uce58\ub294 \uacfc\uc815\n        temp = ListNode()\n        tail = temp\n        \n        while l and r:\n            if l.val < r.val:\n                tail.next = l\n                l = l.next\n            else:\n                tail.next = r\n                r = r.next\n            tail = tail.next\n            \n        if l:\n            tail.next = l\n        elif r:\n            tail.next = r\n            \n        return temp.next"}], "palindrome-partitioning-ii": [{"task_id": "palindrome-partitioning-ii", "completion": "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i] = min cuts to make s[:i] palindrome\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[0] = 0\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[0] = 0\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[0] = 0\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[0] = 0\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[0] = 0\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[0] = 0\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[0] = 0\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[0] = 0\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[0] = 0\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[0] = 0\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[0] = 0\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[0] = 0\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[0] = 0\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[0] = 0\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[0] = 0\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[0] = 0\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[0] = 0\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[0] = 0\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[0] = 0\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[0] = 0\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[0] = 0\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        # dp[0] = 0\n        # dp[i] = min(dp[j] + 1) for all j < i and s[j:i] is palindrome\n        #"}, {"task_id": "palindrome-partitioning-ii", "completion": "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. DP\n        # Time: O(n^2)\n        # Space: O(n^2)\n        # Runtime: 108 ms, faster than 99.99% of Python online submissions for Palindrome Partitioning II.\n        # Memory Usage: 13.7 MB, less than 99.99% of Python online submissions for Palindrome Partitioning II.\n        n = len(s)\n        dp = [[False] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = True\n        for i in range(n - 1):\n            dp[i][i + 1] = s[i] == s[i + 1]\n        for i in range(n - 2, -1, -1):\n            for j in range(i + 2, n):\n                dp[i][j] = dp[i + 1][j - 1] and s[i] == s[j]\n        dp2 = [float('inf')] * n\n        for i in range(n):\n            if dp[0][i]:\n                dp2[i] = 0\n            else:\n                for j in range(i):\n                    if dp[j + 1][i]:\n                        dp2[i] = min(dp2[i], dp2[j] + 1)\n        return dp2[-1]"}, {"task_id": "palindrome-partitioning-ii", "completion": "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i] = min cuts to make s[:i] palindrome\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[j:i] is palindrome)\n        # dp[0] = 0\n        # dp[1] = 0\n        # dp[2] = 1 if s[0] == s[1] else 0\n        # dp[3] = 1 if s[0] == s[2] else 0\n        # dp[4] = 1 if s[0] == s[3] else 0\n        # dp[5] = 1 if s[0] == s[4] else 0\n        # dp[6] = 1 if s[0] == s[5] else 0\n        # dp[7] = 1 if s[0] == s[6] else 0\n        # dp[8] = 1 if s[0] == s[7] else 0\n        # dp[9] = 1 if s[0] == s[8] else 0\n        # dp[10] = 1 if s[0] == s[9] else 0\n        # dp[11] = 1 if s[0] == s[10] else 0\n        # dp[12] = 1 if s[0] == s[11] else 0\n        # dp[13] = 1 if s[0] == s[12] else 0\n        # dp[14] = 1 if s[0] == s[13] else 0\n        # dp[15] = 1 if s[0] == s[14] else 0\n        # dp[16] = 1 if s[0] == s[15] else 0\n        # dp[17] = 1 if s[0] == s[16] else 0\n        # dp[18] = 1 if s[0] == s[17] else 0\n        # dp[19] = 1 if s[0] == s[18] else 0\n        # dp[20] = 1 if s[0] == s[19] else 0\n        # dp[21] = 1 if s[0] == s[20] else 0\n        # dp[22] = 1 if s[0] == s[21] else 0\n        # dp[23] = 1 if s[0] == s[22] else 0\n        # dp[24] = 1 if s[0] == s[23] else 0\n        # dp[25] = 1 if s[0] == s[24] else 0\n        # dp[26] = 1 if s[0] == s[25] else 0\n        # dp[27] = 1 if s[0] == s[26] else 0\n        # dp[28] = 1 if s[0] == s[27] else 0\n        # dp[29] = 1 if s[0] == s[28] else 0\n        # dp[30] = 1 if s[0] == s[29] else 0\n        # dp[31] = 1 if s[0] == s[30] else 0\n        # dp[32] = 1 if s[0] == s[31] else 0\n        # dp[33] = 1 if s[0] == s[32] else 0\n        # dp[34] = 1 if s[0] == s[33] else 0\n        # dp[35] = 1 if s[0] == s[34] else 0\n        # dp[36] = 1 if s[0] == s[35] else 0\n        # dp[37] = 1 if s[0] == s[36] else 0\n        # dp[38] = 1 if s[0] == s[37] else 0\n        # dp[39] = 1 if s[0] == s[38] else 0\n        # dp[40] = 1 if s[0]"}, {"task_id": "palindrome-partitioning-ii", "completion": "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. DP\n        # Time: O(n^2)\n        # Space: O(n^2)\n        # Runtime: 128 ms, faster than 99.27% of Python online submissions for Palindrome Partitioning II.\n        # Memory Usage: 13.9 MB, less than 99.99% of Python online submissions for Palindrome Partitioning II.\n        n = len(s)\n        dp = [[False] * n for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = True\n        for i in range(n - 1, -1, -1):\n            for j in range(i + 1, n):\n                if s[i] == s[j]:\n                    if j - i == 1:\n                        dp[i][j] = True\n                    else:\n                        dp[i][j] = dp[i + 1][j - 1]\n        cuts = [float('inf')] * n\n        for i in range(n):\n            if dp[0][i]:\n                cuts[i] = 0\n            else:\n                for j in range(i):\n                    if dp[j + 1][i]:\n                        cuts[i] = min(cuts[i], cuts[j] + 1)\n        return cuts[-1]"}, {"task_id": "palindrome-partitioning-ii", "completion": "class Solution(object):\n    def minCut(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i] = min cuts to make s[:i] palindrome\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[j:i] is palindrome)\n        # dp[0] = 0\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[j:i] is palindrome)\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[j] == s[i])\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[j] == s[i] and s[j+1:i] is palindrome)\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[j] == s[i] and dp[j+1] == 0)\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[j] == s[i] and dp[j+1] == 0)\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[j] == s[i] and dp[j+1] == 0)\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[j] == s[i] and dp[j+1] == 0)\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[j] == s[i] and dp[j+1] == 0)\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[j] == s[i] and dp[j+1] == 0)\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[j] == s[i] and dp[j+1] == 0)\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[j] == s[i] and dp[j+1] == 0)\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[j] == s[i] and dp[j+1] == 0)\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[j] == s[i] and dp[j+1] == 0)\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[j] == s[i] and dp[j+1] == 0)\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[j] == s[i] and dp[j+1] == 0)\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[j] == s[i] and dp[j+1] == 0)\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[j] == s[i] and dp[j+1] == 0)\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[j] == s[i] and dp[j+1] == 0)\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[j] == s[i] and dp[j+1] == 0)\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[j] == s[i] and dp[j+1] == 0)\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[j] == s[i] and dp[j+1] == 0)\n        # dp[i] = min(dp[j] + 1 for j in range(i) if s[j] == s"}], "preimage-size-of-factorial-zeroes-function": [{"task_id": "preimage-size-of-factorial-zeroes-function", "completion": "class Solution(object):\n    def preimageSizeFZF(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def trailingZeroes(n):\n            res = 0\n            while n > 0:\n                n //= 5\n                res += n\n            return res\n        \n        l, r = 0, 5 * (k + 1)\n        while l < r:\n            mid = (l + r) // 2\n            if trailingZeroes(mid) < k:\n                l = mid + 1\n            else:\n                r = mid\n        return 0 if l == r and trailingZeroes(l) != k else l - r"}, {"task_id": "preimage-size-of-factorial-zeroes-function", "completion": "class Solution(object):\n    def preimageSizeFZF(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def f(x):\n            res = 0\n            while x > 0:\n                x //= 5\n                res += x\n            return res\n        \n        l, r = 0, 5 * k\n        while l < r:\n            mid = (l + r) // 2\n            if f(mid) < k:\n                l = mid + 1\n            else:\n                r = mid\n        return 5 if f(l) == k else 0"}, {"task_id": "preimage-size-of-factorial-zeroes-function", "completion": "class Solution(object):\n    def preimageSizeFZF(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def trailingZeroes(n):\n            count = 0\n            while n > 0:\n                n //= 5\n                count += n\n            return count\n        \n        left, right = 0, 5 * (k + 1)\n        while left < right:\n            mid = left + (right - left) // 2\n            if trailingZeroes(mid) < k:\n                left = mid + 1\n            else:\n                right = mid\n        return 0 if left == right and trailingZeroes(left) != k else left - right"}, {"task_id": "preimage-size-of-factorial-zeroes-function", "completion": "class Solution(object):\n    def preimageSizeFZF(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def trailingZeroes(n):\n            res = 0\n            while n > 0:\n                n //= 5\n                res += n\n            return res\n        \n        l, r = 0, 5 * (k + 1)\n        while l < r:\n            mid = (l + r) // 2\n            if trailingZeroes(mid) < k:\n                l = mid + 1\n            else:\n                r = mid\n        return 0 if l == r and trailingZeroes(l) != k else l - r"}, {"task_id": "preimage-size-of-factorial-zeroes-function", "completion": "class Solution(object):\n    def preimageSizeFZF(self, k):\n        \"\"\"\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def f(x):\n            res = 0\n            while x > 0:\n                x //= 5\n                res += x\n            return res\n        \n        def binary_search(k):\n            left, right = 0, 5 * (k + 1)\n            while left < right:\n                mid = (left + right) // 2\n                if f(mid) == k:\n                    return mid\n                elif f(mid) < k:\n                    left = mid + 1\n                else:\n                    right = mid\n            return left\n        \n        return binary_search(k + 1) - binary"}], "palindrome-pairs": [{"task_id": "palindrome-pairs", "completion": "class Solution(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def isPalindrome(word):\n            return word == word[::-1]\n        \n        word_dict = {word: i for i, word in enumerate(words)}\n        res = []\n        \n        for i, word in enumerate(words):\n            for j in range(len(word) + 1):\n                prefix = word[:j]\n                suffix = word[j:]\n                \n                if isPalindrome(prefix):\n                    back = suffix[::-1]\n                    if back != word and back in word_dict:\n                        res.append([word_dict[back], i])\n                \n                if j != len(word) and isPalindrome(suffix):\n                    back = prefix[::-1]\n                    if back != word and back in word_dict:\n                        res.append([i, word_dict[back]])\n        \n        return res"}, {"task_id": "palindrome-pairs", "completion": "class Solution(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def isPalindrome(word):\n            return word == word[::-1]\n        \n        word_dict = {word: i for i, word in enumerate(words)}\n        res = []\n        \n        for i, word in enumerate(words):\n            for j in range(len(word) + 1):\n                prefix = word[:j]\n                suffix = word[j:]\n                \n                if isPalindrome(prefix):\n                    back = suffix[::-1]\n                    if back != word and back in word_dict:\n                        res.append([word_dict[back], i])\n                \n                if j != len(word) and isPalindrome(suffix):\n                    back = prefix[::-1]\n                    if back != word and back in word_dict:\n                        res.append([i, word_dict[back]])\n        \n        return res"}, {"task_id": "palindrome-pairs", "completion": "class Solution(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        word_dict = {word: i for i, word in enumerate(words)}\n        res = []\n        \n        for i, word in enumerate(words):\n            for j in range(len(word) + 1):\n                prefix = word[:j]\n                suffix = word[j:]\n                \n                if isPalindrome(prefix):\n                    back = suffix[::-1]\n                    if back != word and back in word_dict:\n                        res.append([word_dict[back], i])\n                \n                if j != len(word) and isPalindrome(suffix):\n                    back = prefix[::-1]\n                    if back != word and back in word_dict:\n                        res.append([i, word_dict[back]])\n        \n        return res"}, {"task_id": "palindrome-pairs", "completion": "class Solution(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def isPalindrome(s):\n            return s == s[::-1]\n        \n        wordDict = {}\n        for i, word in enumerate(words):\n            wordDict[word] = i\n        \n        res = []\n        for i, word in enumerate(words):\n            for j in range(len(word)+1):\n                prefix = word[:j]\n                suffix = word[j:]\n                if isPalindrome(prefix):\n                    back = suffix[::-1]\n                    if back != word and back in wordDict:\n                        res.append([wordDict[back], i])\n                if j != len(word) and isPalindrome(suffix):\n                    back = prefix[::-1]\n                    if back != word and back in wordDict:\n                        res.append([i, wordDict[back]])\n        return res"}, {"task_id": "palindrome-pairs", "completion": "class Solution(object):\n    def palindromePairs(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def isPalindrome(word):\n            return word == word[::-1]\n        \n        word_dict = {word: i for i, word in enumerate(words)}\n        res = []\n        \n        for i, word in enumerate(words):\n            for j in range(len(word) + 1):\n                prefix = word[:j]\n                suffix = word[j:]\n                \n                if isPalindrome(prefix):\n                    back = suffix[::-1]\n                    if back != word and back in word_dict:\n                        res.append([word_dict[back], i])\n                \n                if j != len(word) and isPalindrome(suffix):\n                    back = prefix[::-1]\n                    if back != word and back in word_dict:\n                        res.append([i, word_dict[back]])\n        \n        return res"}], "convert-sorted-array-to-binary-search-tree": [{"task_id": "convert-sorted-array-to-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        def helper(left, right):\n            if left > right:\n                return None\n            mid = (left + right) // 2\n            root = TreeNode(nums[mid])\n            root.left = helper(left, mid - 1)\n            root.right = helper(mid + 1, right)\n            return root\n        \n        return helper(0, len(nums) - 1)"}, {"task_id": "convert-sorted-array-to-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        def helper(left, right):\n            if left > right:\n                return None\n            mid = (left + right) // 2\n            root = TreeNode(nums[mid])\n            root.left = helper(left, mid - 1)\n            root.right = helper(mid + 1, right)\n            return root\n        \n        return helper(0, len(nums) - 1)"}, {"task_id": "convert-sorted-array-to-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        def helper(left, right):\n            if left > right:\n                return None\n            mid = (left + right) // 2\n            root = TreeNode(nums[mid])\n            root.left = helper(left, mid - 1)\n            root.right = helper(mid + 1, right)\n            return root\n        \n        return helper(0, len(nums) - 1)"}, {"task_id": "convert-sorted-array-to-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        def helper(left, right):\n            if left > right:\n                return None\n            mid = (left + right) // 2\n            root = TreeNode(nums[mid])\n            root.left = helper(left, mid - 1)\n            root.right = helper(mid + 1, right)\n            return root\n        \n        return helper(0, len(nums) - 1)"}, {"task_id": "convert-sorted-array-to-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedArrayToBST(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        \n        def helper(left, right):\n            if left > right:\n                return None\n            mid = (left + right) // 2\n            root = TreeNode(nums[mid])\n            root.left = helper(left, mid - 1)\n            root.right = helper(mid + 1, right)\n            return root\n        \n        return helper(0, len(nums) - 1)"}], "contain-virus": [{"task_id": "contain-virus", "completion": "class Solution(object):\n    def containVirus(self, isInfected):\n        \"\"\"\n        :type isInfected: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def dfs(i, j, region):\n            if i < 0 or i >= len(isInfected) or j < 0 or j >= len(isInfected[0]) or isInfected[i][j] != 1:\n                return 0\n            isInfected[i][j] = -region\n            return 1 + dfs(i + 1, j, region) + dfs(i - , j, region) + dfs(i, j + 1, region) + dfs(i, j - 1, region)\n        \n        def buildWalls(region):\n            walls = 0\n            for i in range(len(isInfected)):\n                for j in range(len(isInfected[0])):\n                    if isInfected[i][j] == -region:\n                        for x, y in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                            if 0 <= x < len(isInfected) and 0 <= y < len(isInfected[0]) and isInfected[x][y] == 0:\n                                isInfected[x][y] = -region\n                                walls += 1\n            return walls\n        \n        def spread(region):\n            for i in range(len(isInfected)):\n                for j in range(len(isInfected[0])):\n                    if isInfected[i][j] == -region:\n                        isInfected[i][j] = 1\n        \n        regions = []\n        region = 2\n        while True:\n            walls = 0\n            for i in range(len(isInfected)):\n                for j in range(len(isInfected[0])):\n                    if isInfected[i][j] == 1:\n                        regions.append(dfs(i, j, region))\n                        walls += buildWalls(region)\n                        region += 1\n            if not regions:\n                break\n            spread(region)\n            regions.sort(reverse=True)\n            walls += regions[0]\n            regions = regions[1:]\n        return walls"}, {"task_id": "contain-virus", "completion": "class Solution(object):\n    def containVirus(self, isInfected):\n        \"\"\"\n        :type isInfected: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def dfs(i, j, region):\n            if i < 0 or i >= len(isInfected) or j < 0 or j >= len(isInfected[0]) or isInfected[i][j] != 1:\n                return 0\n            isInfected[i][j] = -region\n            return 1 + dfs(i + 1, j, region) + dfs(i - , j, region) + dfs(i, j + 1, region) + dfs(i, j - 1, region)\n        \n        def buildWalls(region):\n            walls = 0\n            for i in range(len(isInfected)):\n                for j in range(len(isInfected[0])):\n                    if isInfected[i][j] == -region:\n                        for x, y in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                            if 0 <= x < len(isInfected) and 0 <= y < len(isInfected[0]) and isInfected[x][y] == 0:\n                                isInfected[x][y] = -region\n                                walls += 1\n            return walls\n        \n        def spread(region):\n            for i in range(len(isInfected)):\n                for j in range(len(isInfected[0])):\n                    if isInfected[i][j] == -region:\n                        isInfected[i][j] = 1\n        \n        regions = []\n        region = 2\n        while True:\n            walls = 0\n            for i in range(len(isInfected)):\n                for j in range(len(isInfected[0])):\n                    if isInfected[i][j] == 1:\n                        regions.append(dfs(i, j, region))\n                        walls += buildWalls(region)\n                        region += 1\n            if not regions:\n                break\n            spread(region)\n            regions.sort(reverse=True)\n            walls += regions[0]\n            regions = regions[1:]\n        return walls"}, {"task_id": "contain-virus", "completion": "class Solution(object):\n    def containVirus(self, isInfected):\n        \"\"\"\n        :type isInfected: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def dfs(i, j, region):\n            if i < 0 or i >= len(isInfected) or j < 0 or j >= len(isInfected[0]) or isInfected[i][j] != 1:\n                return 0\n            isInfected[i][j] = -region\n            return 1 + dfs(i + 1, j, region) + dfs(i - , j, region) + dfs(i, j + 1, region) + dfs(i, j - 1, region)\n        \n        def buildWalls(region):\n            walls = 0\n            for i in range(len(isInfected)):\n                for j in range(len(isInfected[0])):\n                    if isInfected[i][j] == -region:\n                        for x, y in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                            if 0 <= x < len(isInfected) and 0 <= y < len(isInfected[0]) and isInfected[x][y] == 0:\n                                isInfected[x][y] = -region\n                                walls += 1\n            return walls\n        \n        def spread(region):\n            for i in range(len(isInfected)):\n                for j in range(len(isInfected[0])):\n                    if isInfected[i][j] == -region:\n                        isInfected[i][j] = 1\n        \n        regions = []\n        region = 2\n        while True:\n            walls = 0\n            for i in range(len(isInfected)):\n                for j in range(len(isInfected[0])):\n                    if isInfected[i][j] == 1:\n                        regions.append(dfs(i, j, region))\n                        walls += buildWalls(region)\n                        region += 1\n            if not regions:\n                break\n            spread(region)\n            regions.sort(reverse=True)\n            walls += regions[0]\n            regions = regions[1:]\n        return walls"}, {"task_id": "contain-virus", "completion": "class Solution(object):\n    def containVirus(self, isInfected):\n        \"\"\"\n        :type isInfected: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def dfs(i, j, region):\n            if i < 0 or i >= m or j < 0 or j >= n or isInfected[i][j] == 0 or (i, j) in region:\n                return 0\n            region.add((i, j))\n            return 1 + dfs(i - 1, j, region) + dfs(i + 1, j, region) + dfs(i, j - 1, region) + dfs(i, j + 1, region)\n        \n        def buildWalls(region):\n            for i, j in region:\n                for x, y in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                    if 0 <= x < m and 0 <= y < n and isInfected[x][y] == 0:\n                        isInfected[x][y] = -1\n        \n        def removeWalls():\n            for i in range(m):\n                for j in range(n):\n                    if isInfected[i][j] == -1:\n                        isInfected[i][j] = 0\n        \n        m, n = len(isInfected), len(isInfected[0])\n        res = 0\n        while True:\n            regions = []\n            for i in range(m):\n                for j in range(n):\n                    if isInfected[i][j] == 1:\n                        regions.append(dfs(i, j, set()))\n            if not regions:\n                break\n            regions.sort(reverse=True)\n            res += regions[0][0]\n            buildWalls(regions[0][1])\n            removeWalls()\n        return res"}, {"task_id": "contain-virus", "completion": "class Solution(object):\n    def containVirus(self, isInfected):\n        \"\"\"\n        :type isInfected: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def dfs(i, j, region):\n            if i < 0 or i >= m or j < 0 or j >= n or isInfected[i][j] == 0 or (i, j) in region:\n                return 0\n            region.add((i, j))\n            return 1 + dfs(i + 1, j, region) + dfs(i - , j, region) + dfs(i, j + 1, region) + dfs(i, j - 1, region)\n        \n        m, n = len(isInfected), len(isInfected[0])\n        res = 0\n        while True:\n            walls = []\n            regions = []\n            for i in range(m):\n                for j in range(n):\n                    if isInfected[i][j] == 1:\n                        region = set()\n                        walls.append(dfs(i, j, region))\n                        regions.append(region)\n            if not walls:\n                break\n            idx = walls.index(max(walls))\n            res += walls[idx]\n            for i, j in regions[idx]:\n                isInfected[i][j] = -1\n            for i in range(m):\n                for j in range(n):\n                    if isInfected[i][j] == 1:\n                        isInfected[i][j] = 2\n            for i, j in regions[idx]:\n                for x, y in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                    if 0 <= x < m and 0 <= y < n and isInfected[x][y] == 2:\n                        isInfected[x][y] = 1\n        return res"}], "longest-increasing-path-in-a-matrix": [{"task_id": "longest-increasing-path-in-a-matrix", "completion": "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # DFS + Memoization\n        # Time: O(mn)\n        # Space: O(mn)\n        \n        m, n = len(matrix), len(matrix[0])\n        dp = [[0] * n for _ in range(m)]\n        \n        def dfs(i, j):\n            if dp[i][j] != 0:\n                return dp[i][j]\n            \n            dp[i][j] = 1\n            for x, y in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= x < m and 0 <= y < n and matrix[x][y] > matrix[i][j]:\n                    dp[i][j] = max(dp[i][j], dfs(x, y) + 1)\n            return dp[i][j]\n        \n        res = 0\n        for i in range(m):\n            for j in range(n):\n                res = max(res, dfs(i, j))\n        return res"}, {"task_id": "longest-increasing-path-in-a-matrix", "completion": "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # DFS + Memoization\n        # Time: O(mn)\n        # Space: O(mn)\n        \n        m, n = len(matrix), len(matrix[0])\n        dp = [[0] * n for _ in range(m)]\n        \n        def dfs(i, j):\n            if dp[i][j] != 0:\n                return dp[i][j]\n            \n            dp[i][j] = 1\n            for x, y in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= x < m and 0 <= y < n and matrix[x][y] > matrix[i][j]:\n                    dp[i][j] = max(dp[i][j], dfs(x, y) + 1)\n            return dp[i][j]\n        \n        res = 0\n        for i in range(m):\n            for j in range(n):\n                res = max(res, dfs(i, j))\n        return res"}, {"task_id": "longest-increasing-path-in-a-matrix", "completion": "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # DFS + Memoization\n        # Time: O(mn)\n        # Space: O(mn)\n        \n        m, n = len(matrix), len(matrix[0])\n        dp = [[0] * n for _ in range(m)]\n        \n        def dfs(i, j):\n            if dp[i][j] != 0:\n                return dp[i][j]\n            \n            dp[i][j] = 1\n            for x, y in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= x < m and 0 <= y < n and matrix[x][y] > matrix[i][j]:\n                    dp[i][j] = max(dp[i][j], dfs(x, y) + 1)\n            return dp[i][j]\n        \n        res = 0\n        for i in range(m):\n            for j in range(n):\n                res = max(res, dfs(i, j))\n        return res"}, {"task_id": "longest-increasing-path-in-a-matrix", "completion": "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # DFS + Memoization\n        # Time: O(mn)\n        # Space: O(mn)\n        \n        m, n = len(matrix), len(matrix[0])\n        dp = [[0] * n for _ in range(m)]\n        \n        def dfs(i, j):\n            if dp[i][j] != 0:\n                return dp[i][j]\n            \n            dp[i][j] = 1\n            for x, y in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                if 0 <= x < m and 0 <= y < n and matrix[x][y] > matrix[i][j]:\n                    dp[i][j] = max(dp[i][j], dfs(x, y) + 1)\n            return dp[i][j]\n        \n        res = 0\n        for i in range(m):\n            for j in range(n):\n                res = max(res, dfs(i, j))\n        return res"}, {"task_id": "longest-increasing-path-in-a-matrix", "completion": "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # DFS + Memoization\n        # Time: O(mn)\n        # Space: O(mn)\n        \n        m, n = len(matrix), len(matrix[0])\n        dp = [[0] * n for _ in range(m)]\n        \n        def dfs(i, j):\n            if dp[i][j]:\n                return dp[i][j]\n            \n            dp[i][j] = 1\n            for x, y in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= x < m and 0 <= y < n and matrix[x][y] > matrix[i][j]:\n                    dp[i][j] = max(dp[i][j], dfs(x, y) + 1)\n            return dp[i][j]\n        \n        res = 0\n        for i in range(m):\n            for j in range(n):\n                res = max(res, dfs(i, j))\n        return res"}], "number-of-digit-one": [{"task_id": "number-of-digit-one", "completion": "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 123456789\n        # 123456789\n        # 123456789\n        # 123456789\n        # 123456789\n        # 123456789\n        # 123456789\n        # 123456789\n        # 123456789\n        # 123456789\n        # 123456789\n        # 123456789\n        # 123456789\n        # 123456789\n        # 123456789\n        # 123456789\n        # 123456789\n        # 123456789\n        # 123456789\n        # 123456789\n        # 123456789\n        # 123456789\n        # 123456789\n        # 123456789\n        # 123456789\n        # 123456789\n        # 123456789\n        # 123456789\n        # 123456789\n        # 123456789\n        # 123456789\n        # 123456789\n        # 123456789\n        # 123456789\n        # 123456789\n        # 123456789\n        # 123456789\n        # 123456789\n        # 123456789\n        # 123456789\n        # 123456789\n        # 123456789\n        # 123456789\n        # 123456789\n        # 123456789\n        # 123456789\n        # 123456789\n        # 123456789\n        # 123456789\n        # 123456789\n        # 123456789\n        # 123456789\n        # 123456789\n        # 123456789\n        # 123456789\n        # 123456789\n        # 123456789\n        # 123456789\n        # 123456789\n        # 123456789\n        # 123456789\n        # 123456789\n        # 123456789\n        # 123456789\n        # 123456789\n        # 123456789\n        # 123456789\n        # 123456789\n        # 123456789\n        # 123456789\n        # 123456789\n        # 123456789\n        # 123456789\n        # 123456789\n        # 123456789\n        # 123456789\n        # 123456789\n        # 123456789\n        # 1234567"}, {"task_id": "number-of-digit-one", "completion": "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 13\n        # 100 - 199\n        # 1000 - 1999\n        # 10000 - 19999\n        # 100000 - 199999\n        # 1000000 - 1999999\n        # 10000000 - 19999999\n        # 100000000 - 199999999\n        # 1000000000 - 1999999999\n        \n        # 1000000000 - 1999999999\n        # 10000000000 - 19999999999\n        # 100000000000 - 199999999999\n        # 1000000000000 - 1999999999999\n        # 10000000000000 - 19999999999999\n        # 100000000000000 - 199999999999999\n        # 1000000000000000 - 1999999999999999\n        # 10000000000000000 - 19999999999999999\n        # 100000000000000000 - 199999999999999999\n        # 1000000000000000000 - 1999999999999999999\n        \n        # 10000000000000000000 - 19999999999999999999\n        # 100000000000000000000 - 199999999999999999999\n        # 1000000000000000000000 - 1999999999999999999999\n        # 10000000000000000000000 - 19999999999999999999999\n        # 100000000000000000000000 - 199999999999999999999999\n        # 1000000000000000000000000 - 1999999999999999999999999\n        # 10000000000000000000000000 - 19999999999999999999999999\n        # 100000000000000000000000000 - 199999999999999999999999999\n        # 1000000000000000000000000000 - 1999999999999999999999999999\n        # 10000000000000000000000"}, {"task_id": "number-of-digit-one", "completion": "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 123456789\n        # 12345678\n        # 1234567\n        # 123456\n        # 12345\n        # 1234\n        # 123\n        # 12\n        # 1\n        \n        # 123456789\n        # 12345678\n        # 1234567\n        # 123456\n        # 12345\n        # 1234\n        # 123\n        # 12\n        # 1\n        \n        # 123456789\n        # 12345678\n        # 1234567\n        # 123456\n        # 12345\n        # 1234\n        # 123\n        # 12\n        # 1\n        \n        # 123456789\n        # 12345678\n        # 1234567\n        # 123456\n        # 12345\n        # 1234\n        # 123\n        # 12\n        # 1\n        \n        # 123456789\n        # 12345678\n        # 1234567\n        # 123456\n        # 12345\n        # 1234\n        # 123\n        # 12\n        # 1\n        \n        # 123456789\n        # 12345678\n        # 1234567\n        # 123456\n        # 12345\n        # 1234\n        # 123\n        # 12\n        # 1\n        \n        # 123456789\n        # 12345678\n        # 1234567\n        # 123456\n        # 12345\n        # 1234\n        # 123\n        # 12\n        # 1\n        \n        # 123456789\n        # 12345678\n        # 1234567\n        # 123456\n        # 12345\n        # 1234\n        # 123\n        # 12\n        # 1\n        \n        # 123456789\n        # 12345678\n        # 1234567\n        # 123456\n        # 12345\n        # 1234\n        # 123\n        # 12\n        # 1\n        \n        # 123456789\n        # 12345678\n        # 1234567\n        # 123456\n        # 12345\n        # 1234\n        # 123\n        # 12\n        # 1\n        \n        # 123456789\n        # 12345678\n        # 1234567\n        # 123456\n        # 12345\n        # 1234\n        # 123\n        # 12\n        # 1\n        \n        # 123456789\n        # 12345678\n        # 1234567\n        # 123456\n        # 12345\n        # 1234\n        # 123\n        # 12\n        # 1\n        \n        # 123456789\n        # 12345678\n        #"}, {"task_id": "number-of-digit-one", "completion": "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 123456789\n        # 1234567810\n        # 12345671011\n        # 123456101112\n        # 1234510111213\n        # 12341011121314\n        # 123101112131415\n        # 1210111213141516\n        # 11011121314151617\n        # 101112131415161718\n        # 111213141516171819\n        # 111213141516171890\n        # 1112131415161718990\n        # 11121314151617189990\n        # 111213141516171899990\n        # 1112131415161718999990\n        # 11121314151617189999990\n        # 111213141516171899999990\n        # 1112131415161718999999990\n        # 11121314151617189999999990\n        # 111213141516171899999999990\n        # 1112131415161718999999999990\n        # 11121314151617189999999999990\n        # 111213141516171899999999999990\n        # 1112131415161718999999999999990\n        # 11121314151617189999999999999990\n        # 111213141516171899999999999999990\n        # 1112131415161718999999999999999990\n        # 11121314151617189999999999999999990\n        # 111213141516171899999999999999999990\n        # 1112131415161718999999999999999999990\n        # 11121314151617189999999999999999999990\n        # 111213141516171899999999999999999999990\n        # 1112131415161718999999999999999999999990\n        # 11121314151617189999999999999999999999990\n        # 11121314151617189999"}, {"task_id": "number-of-digit-one", "completion": "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 13\n        # 100 - 199\n        # 1000 - 1999\n        # 10000 - 19999\n        # 100000 - 199999\n        # 1000000 - 1999999\n        # 10000000 - 19999999\n        # 100000000 - 199999999\n        # 1000000000 - 1999999999\n        \n        # 1000000000 - 1999999999\n        # 10000000000 - 19999999999\n        # 100000000000 - 199999999999\n        # 1000000000000 - 1999999999999\n        # 10000000000000 - 19999999999999\n        # 100000000000000 - 199999999999999\n        # 1000000000000000 - 1999999999999999\n        # 10000000000000000 - 19999999999999999\n        # 100000000000000000 - 199999999999999999\n        # 1000000000000000000 - 1999999999999999999\n        \n        # 10000000000000000000 - 19999999999999999999\n        # 100000000000000000000 - 199999999999999999999\n        # 1000000000000000000000 - 1999999999999999999999\n        # 10000000000000000000000 - 19999999999999999999999\n        # 100000000000000000000000 - 199999999999999999999999\n        # 1000000000000000000000000 - 1999999999999999999999999\n        # 10000000000000000000000000 - 19999999999999999999999999\n        # 100000000000000000000000000 - 199999999999999999999999999\n        # 1000000000000000000000000000 - 1999999999999999999999999999\n        # 10000000000000000000000"}], "word-break-ii": [{"task_id": "word-break-ii", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(s, wordDict, memo):\n            if s in memo:\n                return memo[s]\n            if not s:\n                return [[]]\n            res = []\n            for word in wordDict:\n                if not s.startswith(word):\n                    continue\n                if len(word) == len(s):\n                    res.append([word])\n                else:\n                    for rest in dfs(s[len(word):], wordDict, memo):\n                        res.append([word] + rest)\n            memo[s] = res\n            return res\n        \n        return [\" \".join(words) for words in dfs(s, wordDict, {})]"}, {"task_id": "word-break-ii", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # DP solution\n        # Time: O(n^2)\n        # Space: O(n)\n        \n        # dp[i] = list of strings that can be formed from s[:i]\n        # dp[i] = [s[:j] + \" \" + s[j:i] for j in range(i) if s[j:i] in wordDict and dp[j]]\n        # dp[0] = [\"\"]\n        \n        dp = [[] for _ in range(len(s) + 1)]\n        dp[0] = [\"\"]\n        \n        for i in range(1, len(s) + 1):\n            for j in range(i):\n                if s[j:i] in wordDict and dp[j]:\n                    dp[i] += [s[j:i] + \" \" + dp[j][0] for dp[j] in dp[j]]\n        \n        return [dp[-1][i][:-1] for i in range(len(dp[-1]))]"}, {"task_id": "word-break-ii", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        ## DP solution\n        ## Time Complexity: O(n^2)\n        ## Space Complexity: O(n)\n        \n        ## DP[i] = True if s[:i] can be segmented into words in wordDict\n        ## DP[i] = False if s[:i] cannot be segmented into words in wordDict\n        ## DP[0] = True\n        \n        ## DP[i] = DP[j] and s[j:i] in wordDict for all j < i\n        \n        ## DP[i] = True if DP[j] and s[j:i] in wordDict for any j < i\n        \n        ## DP[i] = True if DP[j] and s[j:i] in wordDict for any j < i\n        \n        ## DP[i] = True if DP[j] and s[j:i] in wordDict for any j < i\n        \n        ## DP[i] = True if DP[j] and s[j:i] in wordDict for any j < i\n        \n        ## DP[i] = True if DP[j] and s[j:i] in wordDict for any j < i\n        \n        ## DP[i] = True if DP[j] and s[j:i] in wordDict for any j < i\n        \n        ## DP[i] = True if DP[j] and s[j:i] in wordDict for any j < i\n        \n        ## DP[i] = True if DP[j] and s[j:i] in wordDict for any j < i\n        \n        ## DP[i] = True if DP[j] and s[j:i] in wordDict for any j < i\n        \n        ## DP[i] = True if DP[j] and s[j:i] in wordDict for any j < i\n        \n        ## DP[i] = True if DP[j] and s[j:i] in wordDict for any j < i\n        \n        ## DP[i] = True if DP[j] and s[j:i] in wordDict for any j < i\n        \n        ## DP[i] = True if DP[j] and s[j:i] in wordDict for any j < i\n        \n        ## DP[i] = True if DP[j] and s[j:i] in wordDict for any j < i\n        \n        ## DP[i] = True if DP[j] and s[j:i] in wordDict for any j < i\n        \n        ## DP[i] = True if DP[j] and s[j:i] in wordDict for any j < i\n        \n        ## DP[i] = True if DP[j] and s[j:i] in wordDict for any j < i\n        \n        ## DP[i] = True if DP[j] and s[j:i] in wordDict for any j < i\n        \n        ## DP[i] = True if DP[j] and s[j:i] in wordDict for any j < i\n        \n        ## DP[i] = True if DP[j] and s[j:i] in wordDict for any j < i\n        \n        ## DP[i] = True if DP[j] and s[j:i] in wordDict for any j < i\n        \n        ## DP[i] = True if DP[j] and s[j:i] in wordDict for any j < i\n        \n        ## DP[i] = True if DP[j] and s[j:i] in wordDict for any j < i\n        \n        ## DP[i] = True if DP[j] and s[j:i] in wordDict for any j < i\n        \n        ## DP[i] = True if DP[j] and s[j:i] in wordDict for any j < i\n        \n        ## DP[i] = True if DP["}, {"task_id": "word-break-ii", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(s, wordDict, memo):\n            if s in memo:\n                return memo[s]\n            if not s:\n                return [[]]\n            res = []\n            for word in wordDict:\n                if not s.startswith(word):\n                    continue\n                if len(word) == len(s):\n                    res.append([word])\n                else:\n                    for rest in dfs(s[len(word):], wordDict, memo):\n                        res.append([word] + rest)\n            memo[s] = res\n            return res\n        \n        return [\" \".join(words) for words in dfs(s, wordDict, {})]"}, {"task_id": "word-break-ii", "completion": "class Solution(object):\n    def wordBreak(self, s, wordDict):\n        \"\"\"\n        :type s: str\n        :type wordDict: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(s, wordDict, memo):\n            if s in memo:\n                return memo[s]\n            if not s:\n                return [[]]\n            res = []\n            for word in wordDict:\n                if not s.startswith(word):\n                    continue\n                if len(word) == len(s):\n                    res.append([word])\n                else:\n                    for rest in dfs(s[len(word):], wordDict, memo):\n                        res.append([word] + rest)\n            memo[s] = res\n            return res\n        \n        return [\" \".join(words) for words in dfs(s, wordDict, {})]"}], "binary-tree-zigzag-level-order-traversal": [{"task_id": "binary-tree-zigzag-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def zigzagLevelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        res = []\n        level = 0\n        \n        while queue:\n            level_size = len(queue)\n            level_res = []\n            \n            for i in range(level_size):\n                node = queue.pop(0)\n                level_res.append(node.val)\n                \n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n                    \n            if level % 2 == 0:\n                res.append(level_res)\n            else:\n                res.append(level_res[::-1])\n            \n            level += 1\n            \n        return res"}, {"task_id": "binary-tree-zigzag-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def zigzagLevelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        res = []\n        level = 0\n        \n        while queue:\n            level_size = len(queue)\n            level_res = []\n            \n            for i in range(level_size):\n                node = queue.pop(0)\n                level_res.append(node.val)\n                \n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n                    \n            if level % 2 == 0:\n                res.append(level_res)\n            else:\n                res.append(level_res[::-1])\n            \n            level += 1\n            \n        return res"}, {"task_id": "binary-tree-zigzag-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def zigzagLevelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        res = []\n        level = 0\n        \n        while queue:\n            level_size = len(queue)\n            level_res = []\n            \n            for i in range(level_size):\n                node = queue.pop(0)\n                level_res.append(node.val)\n                \n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n            \n            if level % 2 == 0:\n                res.append(level_res)\n            else:\n                res.append(level_res[::-1])\n            \n            level += 1\n        \n        return res"}, {"task_id": "binary-tree-zigzag-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def zigzagLevelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        res = []\n        level = 0\n        \n        while queue:\n            level_size = len(queue)\n            level_res = []\n            \n            for i in range(level_size):\n                node = queue.pop(0)\n                level_res.append(node.val)\n                \n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n                    \n            if level % 2 == 0:\n                res.append(level_res)\n            else:\n                res.append(level_res[::-1])\n                \n            level += 1\n            \n        return res"}, {"task_id": "binary-tree-zigzag-level-order-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def zigzagLevelOrder(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if not root:\n            return []\n        \n        queue = [root]\n        res = []\n        level = 0\n        \n        while queue:\n            level_size = len(queue)\n            level_res = []\n            \n            for i in range(level_size):\n                node = queue.pop(0)\n                level_res.append(node.val)\n                \n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n                    \n            if level % 2 == 0:\n                res.append(level_res)\n            else:\n                res.append(level_res[::-1])\n                \n            level += 1\n            \n        return res"}], "binary-watch": [{"task_id": "binary-watch", "completion": "class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        \"\"\"\n        :type turnedOn: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def count_bits(n):\n            count = 0\n            while n:\n                count += 1\n                n &= (n - 1)\n            return count\n        \n        res = []\n        for h in range(12):\n            for m in range(60):\n                if count_bits(h) + count_bits(m) == turnedOn:\n                    res.append(f'{h}:{m:02d}')\n        return res"}, {"task_id": "binary-watch", "completion": "class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        \"\"\"\n        :type turnedOn: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def count_bits(n):\n            count = 0\n            while n:\n                n &= n - 1\n                count += 1\n            return count\n        \n        res = []\n        for h in range(12):\n            for m in range(60):\n                if count_bits(h) + count_bits(m) == turnedOn:\n                    res.append(f'{h}:{m:02d}')\n        return res"}, {"task_id": "binary-watch", "completion": "class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        \"\"\"\n        :type turnedOn: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def get_hour(num):\n            hour = []\n            for i in range(4):\n                if num & (1 << i):\n                    hour.append(i)\n            return hour\n        \n        def get_minute(num):\n            minute = []\n            for i in range(6):\n                if num & (1 << i):\n                    minute.append(i)\n            return minute\n        \n        res = []\n        for i in range(12):\n            for j in range(60):\n                if bin(i).count('1') + bin(j).count('1') == turnedOn:\n                    res.append(str(i) + ':' + str(j).zfill(2))\n        return res"}, {"task_id": "binary-watch", "completion": "class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        \"\"\"\n        :type turnedOn: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def get_hour(num):\n            hour = []\n            for i in range(4):\n                if num & (1 << i):\n                    hour.append(i)\n            return hour\n        \n        def get_minute(num):\n            minute = []\n            for i in range(6):\n                if num & (1 << i):\n                    minute.append(i)\n            return minute\n        \n        res = []\n        for i in range(12):\n            for j in range(60):\n                if bin(i).count('1') + bin(j).count('1') == turnedOn:\n                    res.append(str(i) + ':' + str(j).zfill(2))\n        return res"}, {"task_id": "binary-watch", "completion": "class Solution(object):\n    def readBinaryWatch(self, turnedOn):\n        \"\"\"\n        :type turnedOn: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def count_bits(n):\n            count = 0\n            while n:\n                n &= n - 1\n                count += 1\n            return count\n        \n        res = []\n        for h in range(12):\n            for m in range(60):\n                if count_bits(h) + count_bits(m) == turnedOn:\n                    res.append(f'{h}:{m:02d}')\n        return res"}], "pascals-triangle": [{"task_id": "pascals-triangle", "completion": "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if numRows == 1:\n            return [[1]]\n        if numRows == 2:\n            return [[1],[1,1]]\n        \n        res = [[1],[1,1]]\n        \n        for i in range(2,numRows):\n            temp = [1]\n            for j in range(len(res[i-1])-1):\n                temp.append(res[i-1][j] + res[i-1][j+1])\n            temp.append(1)\n            res.append(temp)\n        return res"}, {"task_id": "pascals-triangle", "completion": "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if numRows == 1:\n            return [[1]]\n        elif numRows == 2:\n            return [[1],[1,1]]\n        else:\n            res = [[1],[1,1]]\n            for i in range(2,numRows):\n                res.append([1])\n                for j in range(1,i):\n                    res[i].append(res[i-1][j-1]+res[i-1][j])\n                res[i].append(1)\n            return res"}, {"task_id": "pascals-triangle", "completion": "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if numRows == 1:\n            return [[1]]\n        elif numRows == 2:\n            return [[1],[1,1]]\n        else:\n            res = [[1],[1,1]]\n            for i in range(2,numRows):\n                temp = [1]\n                for j in range(len(res[i-1])-1):\n                    temp.append(res[i-1][j] + res[i-1][j+1])\n                temp.append(1)\n                res.append(temp)\n            return res"}, {"task_id": "pascals-triangle", "completion": "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if numRows == 1:\n            return [[1]]\n        elif numRows == 2:\n            return [[1],[1,1]]\n        else:\n            result = [[1],[1,1]]\n            for i in range(2,numRows):\n                temp = [1]\n                for j in range(len(result[i-1])-1):\n                    temp.append(result[i-1][j]+result[i-1][j+1])\n                temp.append(1)\n                result.append(temp)\n            return result"}, {"task_id": "pascals-triangle", "completion": "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        if numRows == 1:\n            return [[1]]\n        elif numRows == 2:\n            return [[1],[1,1]]\n        else:\n            res = [[1],[1,1]]\n            for i in range(2,numRows):\n                temp = [1]\n                for j in range(len(res[i-1])-1):\n                    temp.append(res[i-1][j] + res[i-1][j+1])\n                temp.append(1)\n                res.append(temp)\n            return res"}], "power-of-three": [{"task_id": "power-of-three", "completion": "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 1:\n            return True\n        if n < 1:\n            return False\n        \n        while n > 1:\n            if n % 3 != 0:\n                return False\n            n = n / 3\n        return True"}, {"task_id": "power-of-three", "completion": "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 1:\n            return True\n        if n < 1:\n            return False\n        while n > 1:\n            if n % 3 != 0:\n                return False\n            n = n / 3\n        return True"}, {"task_id": "power-of-three", "completion": "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 1:\n            return True\n        if n < 1:\n            return False\n        \n        while n > 1:\n            if n % 3 != 0:\n                return False\n            n = n / 3\n        return True"}, {"task_id": "power-of-three", "completion": "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 1:\n            return True\n        if n < 1:\n            return False\n        \n        while n > 1:\n            if n % 3 != 0:\n                return False\n            n = n / 3\n        return True"}, {"task_id": "power-of-three", "completion": "class Solution(object):\n    def isPowerOfThree(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 1:\n            return True\n        if n < 1:\n            return False\n        while n > 1:\n            if n % 3 != 0:\n                return False\n            n = n / 3\n        return True"}], "binary-tree-maximum-path-sum": [{"task_id": "binary-tree-maximum-path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def max_gain(node):\n            nonlocal max_sum\n            if not node:\n                return 0\n            \n            # max sum on the left and right sub-trees of node\n            left_gain = max(max_gain(node.left), 0)\n            right_gain = max(max_gain(node.right), 0)\n            \n            # the price to start a new path where `node` is a highest node\n            price_newpath = node.val + left_gain + right_gain\n            \n            # update max_sum if it's better to start a new path\n            max_sum = max(max_sum, price_newpath)\n            \n            # for recursion :\n            # return the max gain if continue the same path\n            return node.val + max(left_gain, right_gain)\n        \n        max_sum = float('-inf')\n        max_gain(root)\n        return max_sum"}, {"task_id": "binary-tree-maximum-path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def dfs(node):\n            if not node:\n                return 0\n            left = dfs(node.left)\n            right = dfs(node.right)\n            self.res = max(self.res, left + right + node.val)\n            return max(left, right) + node.val\n        \n        self.res = float('-inf')\n        dfs(root)\n        return self.res"}, {"task_id": "binary-tree-maximum-path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def dfs(root):\n            if not root:\n                return 0\n            left = dfs(root.left)\n            right = dfs(root.right)\n            self.res = max(self.res, left + right + root.val)\n            return max(left, right) + root.val\n        \n        self.res = float('-inf')\n        dfs(root)\n        return self.res"}, {"task_id": "binary-tree-maximum-path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def dfs(root):\n            if not root:\n                return 0\n            left = dfs(root.left)\n            right = dfs(root.right)\n            self.res = max(self.res, left + right + root.val)\n            return max(left, right) + root.val\n        \n        self.res = float('-inf')\n        dfs(root)\n        return self.res"}, {"task_id": "binary-tree-maximum-path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxPathSum(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def dfs(node):\n            if not node:\n                return 0\n            \n            left = dfs(node.left)\n            right = dfs(node.right)\n            \n            self.max_sum = max(self.max_sum, left + right + node.val)\n            \n            return max(left, right) + node.val\n        \n        self.max_sum = float('-inf')\n        dfs(root)\n        return self.max_sum"}], "trapping-rain-water-ii": [{"task_id": "trapping-rain-water-ii", "completion": "class Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m, n = len(heightMap), len(heightMap[0])\n        heap = []\n        for i in range(m):\n            for j in range(n):\n                if i == 0 or i == m - 1 or j == 0 or j == n - 1:\n                    heapq.heappush(heap, (heightMap[i][j], i, j))\n                    heightMap[i][j] = -1\n        res = 0\n        while heap:\n            h, i, j = heapq.heappop(heap)\n            for x, y in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= x < m and 0 <= y < n and heightMap[x][y] != -1:\n                    res += max(0, h - heightMap[x][y])\n                    heapq.heappush(heap, (max(h, heightMap[x][y]), x, y))\n                    heightMap[x][y] = -1\n        return res"}, {"task_id": "trapping-rain-water-ii", "completion": "class Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m, n = len(heightMap), len(heightMap[0])\n        heap = []\n        for i in range(m):\n            for j in range(n):\n                if i == 0 or i == m - 1 or j == 0 or j == n - 1:\n                    heapq.heappush(heap, (heightMap[i][j], i, j))\n                    heightMap[i][j] = -1\n        res = 0\n        while heap:\n            h, i, j = heapq.heappop(heap)\n            for x, y in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= x < m and 0 <= y < n and heightMap[x][y] != -1:\n                    res += max(0, h - heightMap[x][y])\n                    heapq.heappush(heap, (max(h, heightMap[x][y]), x, y))\n                    heightMap[x][y] = -1\n        return res"}, {"task_id": "trapping-rain-water-ii", "completion": "class Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m, n = len(heightMap), len(heightMap[0])\n        heap = []\n        for i in range(m):\n            for j in range(n):\n                if i == 0 or i == m - 1 or j == 0 or j == n - 1:\n                    heapq.heappush(heap, (heightMap[i][j], i, j))\n                    heightMap[i][j] = -1\n        res = 0\n        while heap:\n            h, i, j = heapq.heappop(heap)\n            for x, y in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\n                if 0 <= x < m and 0 <= y < n and heightMap[x][y] != -1:\n                    res += max(0, h - heightMap[x][y])\n                    heapq.heappush(heap, (max(h, heightMap[x][y]), x, y))\n                    heightMap[x][y] = -1\n        return res"}, {"task_id": "trapping-rain-water-ii", "completion": "class Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(heightMap)\n        n = len(heightMap[0])\n        \n        if m <= 2 or n <= 2:\n            return 0\n        \n        heap = []\n        visited = set()\n        \n        for i in range(m):\n            for j in range(n):\n                if i == 0 or i == m-1 or j == 0 or j == n-1:\n                    heapq.heappush(heap, (heightMap[i][j], i, j))\n                    visited.add((i, j))\n        \n        res = 0\n        while heap:\n            height, i, j = heapq.heappop(heap)\n            for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:\n                if 0 <= x < m and 0 <= y < n and (x, y) not in visited:\n                    res += max(0, height - heightMap[x][y])\n                    heapq.heappush(heap, (max(height, heightMap[x][y]), x, y))\n                    visited.add((x, y))\n        \n        return res"}, {"task_id": "trapping-rain-water-ii", "completion": "class Solution(object):\n    def trapRainWater(self, heightMap):\n        \"\"\"\n        :type heightMap: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(heightMap)\n        n = len(heightMap[0])\n        \n        if m <= 2 or n <= 2:\n            return 0\n        \n        heap = []\n        visited = set()\n        \n        for i in range(m):\n            for j in range(n):\n                if i == 0 or i == m-1 or j == 0 or j == n-1:\n                    heapq.heappush(heap, (heightMap[i][j], i, j))\n                    visited.add((i,j))\n        \n        res = 0\n        while heap:\n            height, i, j = heapq.heappop(heap)\n            for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:\n                if 0 <= x < m and 0 <= y < n and (x, y) not in visited:\n                    res += max(0, height - heightMap[x][y])\n                    heapq.heappush(heap, (max(height, heightMap[x][y]), x, y))\n                    visited.add((x, y))\n        \n        return res"}], "valid-palindrome": [{"task_id": "valid-palindrome", "completion": "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # 1. remove all non-alphanumeric characters\n        # 2. convert all uppercase letters into lowercase letters\n        # 3. check if the string is a palindrome\n        \n        # 1. remove all non-alphanumeric characters\n        s = ''.join(c for c in s if c.isalnum())\n        \n        # 2. convert all uppercase letters into lowercase letters\n        s = s.lower()\n        \n        # 3. check if the string is a palindrome\n        return s == s[::-1]"}, {"task_id": "valid-palindrome", "completion": "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # 1. remove all non-alphanumeric characters\n        # 2. convert all uppercase letters into lowercase letters\n        # 3. check if the string is a palindrome\n        \n        # 1. remove all non-alphanumeric characters\n        s = ''.join(c for c in s if c.isalnum())\n        \n        # 2. convert all uppercase letters into lowercase letters\n        s = s.lower()\n        \n        # 3. check if the string is a palindrome\n        return s == s[::-1]"}, {"task_id": "valid-palindrome", "completion": "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # 1. remove all non-alphanumeric characters\n        # 2. convert all uppercase letters into lowercase letters\n        # 3. check if the string is a palindrome\n        \n        # 1. remove all non-alphanumeric characters\n        s = ''.join(c for c in s if c.isalnum())\n        \n        # 2. convert all uppercase letters into lowercase letters\n        s = s.lower()\n        \n        # 3. check if the string is a palindrome\n        return s == s[::-1]"}, {"task_id": "valid-palindrome", "completion": "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # 1. remove non-alphanumeric characters\n        # 2. convert to lowercase\n        # 3. check if palindrome\n        \n        # 1. remove non-alphanumeric characters\n        s = ''.join(c for c in s if c.isalnum())\n        \n        # 2. convert to lowercase\n        s = s.lower()\n        \n        # 3. check if palindrome\n        return s == s[::-1]"}, {"task_id": "valid-palindrome", "completion": "class Solution(object):\n    def isPalindrome(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # 1. remove all non-alphanumeric characters\n        # 2. convert all uppercase letters into lowercase letters\n        # 3. check if the string is a palindrome\n        \n        # 1. remove all non-alphanumeric characters\n        s = ''.join(c for c in s if c.isalnum())\n        \n        # 2. convert all uppercase letters into lowercase letters\n        s = s.lower()\n        \n        # 3. check if the string is a palindrome\n        return s == s[::-1]"}], "sliding-window-median": [{"task_id": "sliding-window-median", "completion": "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        \n        # 1. create a max heap and a min heap\n        # 2. add the first k elements to the max heap\n        # 3. add the first k elements to the min heap\n        # 4. remove the first element from the max heap\n        # 5. remove the last element from the min heap\n        # 6. add the last element to the max heap\n        # 7. add the first element to the min heap\n        # 8. add the median to the result\n        # 9. return the result\n        \n        # 1. create a max heap and a min heap\n        max_heap = []\n        min_heap = []\n        \n        # 2. add the first k elements to the max heap\n        for i in range(k):\n            heapq.heappush(max_heap, (-nums[i], i))\n        \n        # 3. add the first k elements to the min heap\n        for i in range(k):\n            heapq.heappush(min_heap, (nums[i], i))\n        \n        # 4. remove the first element from the max heap\n        heapq.heappop(max_heap)\n        \n        # 5. remove the last element from the min heap\n        heapq.heappop(min_heap)\n        \n        # 6. add the last element to the max heap\n        heapq.heappush(max_heap, (-nums[k-1], k-1))\n        \n        # 7. add the first element to the min heap\n        heapq.heappush(min_heap, (nums[k-1], k-1))\n        \n        # 8. add the median to the result\n        result = []\n        result.append(float(min_heap[0][0] - max_heap[0][0]) / 2.0)\n        \n        # 9. return the result\n        return result"}, {"task_id": "sliding-window-median", "completion": "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        \n        # 1. Initialize the window\n        window = nums[:k]\n        window.sort()\n        \n        # 2. Initialize the result\n        result = []\n        \n        # 3. Iterate through the rest of the array\n        for i in range(k, len(nums)):\n            # 3.1. Add the median to the result\n            result.append((window[k//2] + window[(k-1)//2]) / 2.0)\n            \n            # 3.2. Remove the first element from the window\n            window.remove(nums[i-k])\n            \n            # 3.3. Add the new element to the window\n            window.append(nums[i])\n            \n            # 3.4. Sort the window\n            window.sort()\n        \n        # 4. Add the median of the last window to the result\n        result.append((window[k//2] + window[(k-1)//2]) / 2.0)\n        \n        return result"}, {"task_id": "sliding-window-median", "completion": "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        \n        # 1. create a max heap and a min heap\n        # 2. add the first k elements to the max heap\n        # 3. add the first k elements to the min heap\n        # 4. remove the first element from the max heap\n        # 5. remove the last element from the min heap\n        # 6. add the last element to the max heap\n        # 7. add the first element to the min heap\n        # 8. add the median to the result\n        # 9. return the result\n        \n        # 1. create a max heap and a min heap\n        max_heap = []\n        min_heap = []\n        \n        # 2. add the first k elements to the max heap\n        for i in range(k):\n            heapq.heappush(max_heap, (-nums[i], i))\n        \n        # 3. add the first k elements to the min heap\n        for i in range(k):\n            heapq.heappush(min_heap, (nums[i], i))\n        \n        # 4. remove the first element from the max heap\n        heapq.heappop(max_heap)\n        \n        # 5. remove the last element from the min heap\n        heapq.heappop(min_heap)\n        \n        # 6. add the last element to the max heap\n        heapq.heappush(max_heap, (-nums[k-1], k-1))\n        \n        # 7. add the first element to the min heap\n        heapq.heappush(min_heap, (nums[k-1], k-1))\n        \n        # 8. add the median to the result\n        result = []\n        result.append(float(min_heap[0][0] - max_heap[0][0]) / 2.0)\n        \n        # 9. return the result\n        return result"}, {"task_id": "sliding-window-median", "completion": "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        \n        # 1. create a max heap and a min heap\n        # 2. add the first k elements to the max heap\n        # 3. add the first k elements to the min heap\n        # 4. remove the first element from the max heap\n        # 5. remove the last element from the min heap\n        # 6. add the last element to the max heap\n        # 7. add the first element to the min heap\n        # 8. add the median to the result\n        # 9. return the result\n        \n        # 1. create a max heap and a min heap\n        max_heap = []\n        min_heap = []\n        \n        # 2. add the first k elements to the max heap\n        for i in range(k):\n            heapq.heappush(max_heap, (-nums[i], i))\n        \n        # 3. add the first k elements to the min heap\n        for i in range(k):\n            heapq.heappush(min_heap, (nums[i], i))\n        \n        # 4. remove the first element from the max heap\n        heapq.heappop(max_heap)\n        \n        # 5. remove the last element from the min heap\n        heapq.heappop(min_heap)\n        \n        # 6. add the last element to the max heap\n        heapq.heappush(max_heap, (-nums[k-1], k-1))\n        \n        # 7. add the first element to the min heap\n        heapq.heappush(min_heap, (nums[k-1], k-1))\n        \n        # 8. add the median to the result\n        result = []\n        result.append(float(min_heap[0][0] - max_heap[0][0]) / 2.0)\n        \n        # 9. return the result\n        return result"}, {"task_id": "sliding-window-median", "completion": "class Solution(object):\n    def medianSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[float]\n        \"\"\"\n        \n        # 1. Initialize the window with the first k elements\n        window = nums[:k]\n        window.sort()\n        \n        # 2. Initialize the result list\n        result = []\n        \n        # 3. Iterate through the rest of the elements\n        for i in range(k, len(nums)):\n            # 4. Add the new element to the window\n            window.append(nums[i])\n            \n            # 5. Sort the window\n            window.sort()\n            \n            # 6. Calculate the median\n            if k % 2 == 0:\n                median = (window[k//2] + window[k//2 - 1]) / 2.0\n            else:\n                median = window[k//2]\n            \n            # 7. Add the median to the result list\n            result.append(median)\n            \n            # 8. Remove the first element from the window\n            window.remove(nums[i - k])\n        \n        # 9. Return the result list\n        return result"}], "rotate-list": [{"task_id": "rotate-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return head\n        \n        # find the length of the linked list\n        length = 0\n        curr = head\n        while curr:\n            length += 1\n            curr = curr.next\n        \n        # if k is greater than the length of the linked list, we need to rotate the linked list k % length times\n        k = k % length\n        \n        # if k is 0, we don't need to rotate the linked list\n        if k == 0:\n            return head\n        \n        # find the node before the new head\n        curr = head\n        for i in range(length - k - 1):\n            curr = curr.next\n        \n        # set the new head\n        new_head = curr.next\n        \n        # set the new tail\n        curr.next = None\n        \n        # find the new tail\n        curr = new_head\n        while curr.next:\n            curr = curr.next\n        \n        # set the new tail's next to the old head\n        curr.next = head\n        \n        return new_head"}, {"task_id": "rotate-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return head\n        \n        length = 1\n        tail = head\n        \n        while tail.next:\n            tail = tail.next\n            length += 1\n        \n        k = k % length\n        \n        if k == 0:\n            return head\n        \n        tail.next = head\n        \n        for _ in range(length - k):\n            tail = tail.next\n        \n        head = tail.next\n        tail.next = None\n        \n        return head"}, {"task_id": "rotate-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return head\n        \n        length = 1\n        tail = head\n        \n        while tail.next:\n            tail = tail.next\n            length += 1\n        \n        k = k % length\n        \n        if k == 0:\n            return head\n        \n        tail.next = head\n        \n        for _ in range(length - k):\n            tail = tail.next\n        \n        head = tail.next\n        tail.next = None\n        \n        return head"}, {"task_id": "rotate-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return head\n        \n        length = 1\n        tail = head\n        \n        while tail.next:\n            tail = tail.next\n            length += 1\n        \n        k = k % length\n        \n        if k == 0:\n            return head\n        \n        tail.next = head\n        \n        for _ in range(length - k):\n            tail = tail.next\n        \n        head = tail.next\n        tail.next = None\n        \n        return head"}, {"task_id": "rotate-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def rotateRight(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return head\n        \n        # find the length of the linked list\n        length = 0\n        curr = head\n        while curr:\n            length += 1\n            curr = curr.next\n        \n        # if k is greater than the length of the linked list, we need to rotate the linked list k % length times\n        k = k % length\n        \n        # if k is 0, we don't need to rotate the linked list\n        if k == 0:\n            return head\n        \n        # find the node before the new head\n        curr = head\n        for i in range(length - k - 1):\n            curr = curr.next\n        \n        # set the new head\n        new_head = curr.next\n        \n        # set the new tail\n        curr.next = None\n        \n        # find the new tail\n        curr = new_head\n        while curr.next:\n            curr = curr.next\n        \n        # set the new tail's next to the old head\n        curr.next = head\n        \n        return new_head"}], "ugly-number": [{"task_id": "ugly-number", "completion": "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 2 == 0:\n            n = n / 2\n        \n        while n % 3 == 0:\n            n = n / 3\n        \n        while n % 5 == 0:\n            n = n / 5\n        \n        return n == 1"}, {"task_id": "ugly-number", "completion": "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 2 == 0:\n            n = n / 2\n        \n        while n % 3 == 0:\n            n = n / 3\n        \n        while n % 5 == 0:\n            n = n / 5\n        \n        return n == 1"}, {"task_id": "ugly-number", "completion": "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 2 == 0:\n            n = n / 2\n        while n % 3 == 0:\n            n = n / 3\n        while n % 5 == 0:\n            n = n / 5\n        \n        return n == 1"}, {"task_id": "ugly-number", "completion": "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n > 1:\n            if n % 2 == 0:\n                n = n / 2\n            elif n % 3 == 0:\n                n = n / 3\n            elif n % 5 == 0:\n                n = n / 5\n            else:\n                return False\n        \n        return True"}, {"task_id": "ugly-number", "completion": "class Solution(object):\n    def isUgly(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 0:\n            return False\n        \n        while n % 2 == 0:\n            n = n / 2\n        \n        while n % 3 == 0:\n            n = n / 3\n        \n        while n % 5 == 0:\n            n = n / 5\n        \n        if n == 1:\n            return True\n        else:\n            return False"}], "falling-squares": [{"task_id": "falling-squares", "completion": "class Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \u5148\u628a\u6240\u6709\u843d\u4e0b\u7684\u65b9\u5757\u7684\u5de6\u8fb9\u754c\u548c\u53f3\u8fb9\u754c\u90fd\u5b58\u8d77\u6765\n        # 2. \u7136\u540e\u5bf9\u6240\u6709\u843d\u4e0b\u7684\u65b9\u5757\u8fdb\u884c\u6392\u5e8f\uff0c\u6309\u7167\u5de6\u8fb9\u754c\u4ece\u5c0f\u5230\u5927\u6392\u5e8f\n        # 3. \u7136\u540e\u5bf9\u6bcf\u4e2a\u65b9\u5757\u8fdb\u884c\u904d\u5386\uff0c\u5982\u679c\u5f53\u524d\u65b9\u5757\u7684\u5de6\u8fb9\u754c\u5927\u4e8e\u524d\u4e00\u4e2a\u65b9\u5757\u7684\u53f3\u8fb9\u754c\uff0c\u90a3\u4e48\u5f53\u524d\u65b9\u5757\u7684\u6700\u5927\u9ad8\u5ea6\u5c31\u662f\u524d\u4e00\u4e2a\u65b9\u5757\u7684\u6700\u5927\u9ad8\u5ea6\n        # 4. \u5982\u679c\u5f53\u524d\u65b9\u5757\u7684\u5de6\u8fb9\u754c\u5c0f\u4e8e\u7b49\u4e8e\u524d\u4e00\u4e2a\u65b9\u5757\u7684\u53f3\u8fb9\u754c\uff0c\u90a3\u4e48\u5f53\u524d\u65b9\u5757\u7684\u6700\u5927\u9ad8\u5ea6\u5c31\u662f\u524d\u4e00\u4e2a\u65b9\u5757\u7684\u6700\u5927\u9ad8\u5ea6\u548c\u5f53\u524d\u65b9\u5757\u7684\u6700\u5927\u9ad8\u5ea6\u4e2d\u7684\u6700\u5927\u503c\n        # 5. \u7136\u540e\u5bf9\u6bcf\u4e2a\u65b9\u5757\u8fdb\u884c\u904d\u5386\uff0c\u5982\u679c\u5f53\u524d\u65b9\u5757\u7684\u53f3\u8fb9\u754c\u5927\u4e8e\u524d\u4e00\u4e2a\u65b9\u5757\u7684\u53f3\u8fb9\u754c\uff0c\u90a3\u4e48\u5f53\u524d\u65b9\u5757\u7684\u6700\u5927\u9ad8\u5ea6\u5c31\u662f\u524d\u4e00\u4e2a\u65b9\u5757\u7684\u6700\u5927\u9ad8\u5ea6\u548c\u5f53\u524d\u65b9\u5757\u7684\u6700\u5927\u9ad8\u5ea6\u4e2d\u7684\u6700\u5927\u503c\n        # 6. \u5982\u679c\u5f53\u524d\u65b9\u5757\u7684\u53f3\u8fb9\u754c\u5c0f\u4e8e\u7b49\u4e8e\u524d\u4e00\u4e2a\u65b9\u5757\u7684\u53f3\u8fb9\u754c\uff0c\u90a3\u4e48\u5f53\u524d\u65b9\u5757\u7684\u6700\u5927\u9ad8\u5ea6\u5c31\u662f\u524d\u4e00\u4e2a\u65b9\u5757\u7684\u6700\u5927\u9ad8\u5ea6\n        # 7. \u7136\u540e\u5bf9\u6bcf\u4e2a\u65b9\u5757\u8fdb\u884c\u904d\u5386\uff0c\u5982\u679c\u5f53\u524d\u65b9\u5757\u7684\u5de6\u8fb9\u754c\u5927\u4e8e\u524d\u4e00\u4e2a\u65b9\u5757\u7684\u53f3\u8fb9\u754c\uff0c\u90a3\u4e48\u5f53\u524d\u65b9\u5757\u7684\u6700\u5927\u9ad8\u5ea6\u5c31\u662f\u524d\u4e00\u4e2a\u65b9\u5757\u7684\u6700\u5927\u9ad8\u5ea6\n        # 8. \u5982\u679c\u5f53\u524d\u65b9\u5757\u7684\u5de6\u8fb9\u754c\u5c0f\u4e8e\u7b49\u4e8e\u524d\u4e00\u4e2a\u65b9\u5757\u7684\u53f3\u8fb9\u754c\uff0c\u90a3\u4e48\u5f53\u524d\u65b9\u5757\u7684\u6700\u5927\u9ad8\u5ea6\u5c31\u662f\u524d\u4e00\u4e2a\u65b9\u5757\u7684\u6700\u5927\u9ad8\u5ea6\u548c\u5f53\u524d\u65b9\u5757\u7684\u6700\u5927\u9ad8\u5ea6\u4e2d\u7684\u6700\u5927\u503c\n        # 9. \u7136\u540e\u5bf9\u6bcf\u4e2a\u65b9\u5757\u8fdb\u884c\u904d\u5386\uff0c\u5982\u679c\u5f53\u524d\u65b9\u5757\u7684\u53f3\u8fb9\u754c\u5927\u4e8e\u524d\u4e00\u4e2a\u65b9\u5757\u7684\u53f3\u8fb9\u754c\uff0c\u90a3\u4e48\u5f53\u524d\u65b9\u5757\u7684\u6700\u5927\u9ad8\u5ea6\u5c31\u662f\u524d\u4e00\u4e2a\u65b9\u5757\u7684\u6700\u5927\u9ad8\u5ea6\u548c\u5f53\u524d\u65b9\u5757\u7684\u6700\u5927\u9ad8\u5ea6\u4e2d\u7684\u6700\u5927\u503c\n        # 10. \u5982\u679c\u5f53\u524d\u65b9\u5757\u7684\u53f3\u8fb9\u754c\u5c0f\u4e8e\u7b49\u4e8e\u524d\u4e00\u4e2a\u65b9\u5757\u7684\u53f3\u8fb9\u754c\uff0c\u90a3\u4e48\u5f53\u524d\u65b9\u5757\u7684\u6700\u5927\u9ad8\u5ea6\u5c31\u662f\u524d\u4e00\u4e2a\u65b9\u5757\u7684\u6700\u5927\u9ad8\u5ea6\n        # 11. \u7136\u540e\u5bf9\u6bcf\u4e2a\u65b9\u5757\u8fdb\u884c\u904d\u5386\uff0c\u5982\u679c\u5f53\u524d\u65b9\u5757\u7684\u5de6\u8fb9\u754c\u5927\u4e8e\u524d\u4e00\u4e2a\u65b9\u5757\u7684\u53f3\u8fb9\u754c\uff0c\u90a3\u4e48\u5f53\u524d\u65b9\u5757\u7684\u6700\u5927\u9ad8\u5ea6\u5c31\u662f\u524d\u4e00\u4e2a\u65b9\u5757\u7684\u6700\u5927\u9ad8\u5ea6\n        # 12. \u5982\u679c\u5f53\u524d\u65b9\u5757\u7684\u5de6\u8fb9\u754c\u5c0f\u4e8e\u7b49\u4e8e\u524d\u4e00\u4e2a\u65b9\u5757\u7684\u53f3\u8fb9\u754c\uff0c\u90a3\u4e48\u5f53\u524d\u65b9\u5757\u7684\u6700\u5927\u9ad8\u5ea6\u5c31\u662f\u524d\u4e00\u4e2a\u65b9\u5757\u7684\u6700\u5927\u9ad8\u5ea6\u548c\u5f53\u524d\u65b9\u5757\u7684\u6700\u5927\u9ad8\u5ea6\u4e2d\u7684\u6700\u5927\u503c\n        # 13. \u7136\u540e\u5bf9\u6bcf\u4e2a\u65b9\u5757\u8fdb\u884c\u904d\u5386\uff0c\u5982\u679c\u5f53\u524d\u65b9\u5757\u7684\u53f3\u8fb9\u754c\u5927\u4e8e\u524d\u4e00\u4e2a\u65b9\u5757\u7684\u53f3\u8fb9\u754c\uff0c\u90a3\u4e48\u5f53\u524d\u65b9\u5757\u7684\u6700\u5927\u9ad8\u5ea6\u5c31\u662f\u524d\u4e00\u4e2a\u65b9\u5757\u7684\u6700\u5927\u9ad8\u5ea6\u548c\u5f53\u524d\u65b9\u5757\u7684\u6700\u5927\u9ad8\u5ea6\u4e2d\u7684\u6700\u5927\u503c\n        # 14. \u5982\u679c\u5f53\u524d\u65b9\u5757\u7684\u53f3\u8fb9\u754c\u5c0f\u4e8e\u7b49\u4e8e\u524d\u4e00\u4e2a\u65b9\u5757\u7684\u53f3\u8fb9\u754c\uff0c\u90a3\u4e48\u5f53\u524d\u65b9\u5757\u7684\u6700\u5927\u9ad8\u5ea6\u5c31\u662f\u524d\u4e00\u4e2a\u65b9\u5757\u7684\u6700\u5927\u9ad8\u5ea6\n        # 15. \u7136\u540e\u5bf9\u6bcf\u4e2a\u65b9\u5757\u8fdb\u884c\u904d\u5386\uff0c\u5982\u679c\u5f53\u524d\u65b9\u5757\u7684\u5de6\u8fb9\u754c\u5927\u4e8e\u524d\u4e00\u4e2a\u65b9\u5757\u7684\u53f3\u8fb9\u754c\uff0c\u90a3\u4e48\u5f53\u524d\u65b9\u5757\u7684\u6700\u5927\u9ad8\u5ea6\u5c31\u662f\u524d\u4e00\u4e2a\u65b9\u5757\u7684\u6700\u5927\u9ad8\u5ea6\n        # 16. \u5982\u679c\u5f53\u524d\u65b9\u5757\u7684\u5de6\u8fb9\u754c\u5c0f\u4e8e\u7b49\u4e8e\u524d\u4e00\u4e2a\u65b9\u5757\u7684\u53f3\u8fb9\u754c\uff0c\u90a3\u4e48\u5f53\u524d\u65b9\u5757\u7684\u6700\u5927\u9ad8\u5ea6\u5c31\u662f\u524d\u4e00\u4e2a\u65b9\u5757\u7684\u6700\u5927\u9ad8\u5ea6\u548c\u5f53\u524d\u65b9\u5757\u7684\u6700\u5927\u9ad8\u5ea6\u4e2d\u7684\u6700\u5927\u503c\n        # 17. \u7136\u540e\u5bf9\u6bcf\u4e2a\u65b9\u5757\u8fdb\u884c\u904d\u5386\uff0c\u5982\u679c\u5f53\u524d\u65b9\u5757\u7684\u53f3\u8fb9\u754c\u5927\u4e8e\u524d\u4e00\u4e2a\u65b9\u5757\u7684\u53f3\u8fb9\u754c\uff0c\u90a3\u4e48\u5f53\u524d\u65b9\u5757\u7684\u6700\u5927\u9ad8\u5ea6\u5c31\u662f\u524d\u4e00\u4e2a\u65b9\u5757\u7684\u6700\u5927\u9ad8\u5ea6\u548c\u5f53\u524d\u65b9\u5757\u7684\u6700\u5927\u9ad8\u5ea6\u4e2d\u7684\u6700\u5927\u503c\n        # 18. \u5982\u679c\u5f53\u524d\u65b9\u5757\u7684\u53f3\u8fb9\u754c\u5c0f\u4e8e\u7b49\u4e8e\u524d\u4e00\u4e2a\u65b9\u5757\u7684\u53f3\u8fb9\u754c\uff0c\u90a3\u4e48\u5f53\u524d\u65b9\u5757\u7684\u6700\u5927\u9ad8\u5ea6\u5c31\u662f\u524d\u4e00\u4e2a\u65b9\u5757\u7684\u6700\u5927\u9ad8\u5ea6\n        # 19. \u7136\u540e\u5bf9\u6bcf\u4e2a\u65b9\u5757\u8fdb\u884c\u904d\u5386\uff0c\u5982\u679c\u5f53\u524d\u65b9\u5757\u7684\u5de6\u8fb9\u754c\u5927\u4e8e\u524d\u4e00\u4e2a\u65b9\u5757\u7684\u53f3\u8fb9\u754c\uff0c\u90a3\u4e48\u5f53\u524d\u65b9\u5757\u7684\u6700\u5927\u9ad8\u5ea6\u5c31\u662f\u524d\u4e00\u4e2a\u65b9\u5757\u7684\u6700\u5927\u9ad8\u5ea6\n        # 20. \u5982\u679c\u5f53\u524d\u65b9\u5757\u7684\u5de6\u8fb9\u754c\u5c0f\u4e8e\u7b49\u4e8e\u524d\u4e00\u4e2a\u65b9\u5757\u7684\u53f3\u8fb9\u754c\uff0c\u90a3\u4e48\u5f53\u524d\u65b9\u5757\u7684\u6700\u5927\u9ad8\u5ea6\u5c31\u662f\u524d\u4e00\u4e2a\u65b9\u5757\u7684\u6700\u5927\u9ad8\u5ea6\u548c\u5f53\u524d\u65b9\u5757\u7684\u6700\u5927\u9ad8\u5ea6\u4e2d\u7684\u6700\u5927\u503c\n        # 21. \u7136\u540e\u5bf9\u6bcf\u4e2a\u65b9\u5757\u8fdb\u884c\u904d\u5386\uff0c\u5982\u679c\u5f53\u524d\u65b9\u5757\u7684\u53f3\u8fb9\u754c\u5927\u4e8e\u524d\u4e00\u4e2a\u65b9\u5757\u7684\u53f3\u8fb9\u754c"}, {"task_id": "falling-squares", "completion": "class Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. sort the positions by left\n        positions.sort()\n        \n        # 2. create a list to store the max height of each position\n        max_height = [0] * len(positions)\n        \n        # 3. iterate through the positions\n        for i in range(len(positions)):\n            # 3.1 get the left and side length of the current position\n            left, side_length = positions[i]\n            \n            # 3.2 get the right of the current position\n            right = left + side_length\n            \n            # 3.3 get the max height of the current position\n            max_height[i] = side_length\n            \n            # 3.4 iterate through the positions before the current position\n            for j in range(i):\n                # 3.4.1 get the left and side length of the previous position\n                prev_left, prev_side_length = positions[j]\n                \n                # 3.4.2 get the right of the previous position\n                prev_right = prev_left + prev_side_length\n                \n                # 3.4.3 if the current position is not overlapping with the previous position\n                if left >= prev_right or right <= prev_left:\n                    continue\n                \n                # 3.4.4 update the max height of the current position\n                max_height[i] = max(max_height[i], max_height[j] + side_length)\n        \n        # 4. create a list to store the result\n        result = []\n        \n        # 5. iterate through the max height\n        for i in range(len(max_height)):\n            # 5.1 if the result is empty, append the max height\n            if not result:\n                result.append(max_height[i])\n            # 5.2 otherwise, append the max of the current max height and the previous max height\n            else:\n                result.append(max(max_height[i], result[-1]))\n        \n        # 6. return the result\n        return result"}, {"task_id": "falling-squares", "completion": "class Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. sort the positions by left\n        positions.sort()\n        \n        # 2. create a list to store the max height of each position\n        max_height = [0] * len(positions)\n        \n        # 3. iterate through the positions\n        for i in range(len(positions)):\n            # 3.1 get the left and side length of the current position\n            left, side_length = positions[i]\n            \n            # 3.2 get the right of the current position\n            right = left + side_length\n            \n            # 3.3 get the max height of the current position\n            max_height[i] = side_length\n            \n            # 3.4 iterate through the positions before the current position\n            for j in range(i):\n                # 3.4.1 get the left and side length of the previous position\n                prev_left, prev_side_length = positions[j]\n                \n                # 3.4.2 get the right of the previous position\n                prev_right = prev_left + prev_side_length\n                \n                # 3.4.3 if the current position is not overlapping with the previous position\n                if left >= prev_right or right <= prev_left:\n                    continue\n                \n                # 3.4.4 update the max height of the current position\n                max_height[i] = max(max_height[i], max_height[j] + side_length)\n        \n        # 4. create a list to store the result\n        result = []\n        \n        # 5. iterate through the max height\n        for i in range(len(max_height)):\n            # 5.1 if the result is empty, append the max height\n            if not result:\n                result.append(max_height[i])\n            # 5.2 otherwise, append the max of the current max height and the previous max height\n            else:\n                result.append(max(max_height[i], result[-1]))\n        \n        # 6. return the result\n        return result"}, {"task_id": "falling-squares", "completion": "class Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. sort the positions by left\n        positions.sort()\n        \n        # 2. create a list to store the max height of each position\n        max_height = [0] * len(positions)\n        \n        # 3. iterate through the positions\n        for i in range(len(positions)):\n            # 3.1 get the left and side length of the current position\n            left, side_length = positions[i]\n            \n            # 3.2 get the right of the current position\n            right = left + side_length\n            \n            # 3.3 get the max height of the current position\n            max_height[i] = side_length\n            \n            # 3.4 iterate through the positions before the current position\n            for j in range(i - 1, -1, -1):\n                # 3.4.1 get the left and side length of the previous position\n                prev_left, prev_side_length = positions[j]\n                \n                # 3.4.2 get the right of the previous position\n                prev_right = prev_left + prev_side_length\n                \n                # 3.4.3 if the current position is not overlapping with the previous position\n                if right <= prev_left or left >= prev_right:\n                    # 3.4.4 break the loop\n                    break\n                \n                # 3.4.5 update the max height of the current position\n                max_height[i] = max(max_height[i], max_height[j] + side_length)\n        \n        # 4. create a list to store the result\n        result = []\n        \n        # 5. iterate through the max height\n        for i in range(len(max_height)):\n            # 5.1 if the result is empty\n            if not result:\n                # 5.1.1 append the max height to the result\n                result.append(max_height[i])\n            # 5.2 if the result is not empty\n            else:\n                # 5.2.1 append the max of the current max height and the previous max height to the result\n                result.append(max(max_height[i], result[-1]))\n        \n        # 6. return the result\n        return result"}, {"task_id": "falling-squares", "completion": "class Solution(object):\n    def fallingSquares(self, positions):\n        \"\"\"\n        :type positions: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \u5148\u628a\u6240\u6709\u843d\u4e0b\u7684\u65b9\u5757\u7684\u5de6\u8fb9\u754c\u548c\u53f3\u8fb9\u754c\u90fd\u5b58\u8d77\u6765\uff0c\u7136\u540e\u6392\u5e8f\n        # 2. \u7136\u540e\u4ece\u5de6\u5230\u53f3\u904d\u5386\uff0c\u5982\u679c\u5f53\u524d\u7684\u5de6\u8fb9\u754c\u5927\u4e8e\u524d\u4e00\u4e2a\u7684\u53f3\u8fb9\u754c\uff0c\u90a3\u4e48\u5c31\u8bf4\u660e\u6ca1\u6709\u91cd\u53e0\uff0c\u90a3\u4e48\u5c31\u628a\u5f53\u524d\u7684\u53f3\u8fb9\u754c\u548c\u9ad8\u5ea6\u90fd\u5b58\u8d77\u6765\n        # 3. \u5982\u679c\u5f53\u524d\u7684\u5de6\u8fb9\u754c\u5c0f\u4e8e\u524d\u4e00\u4e2a\u7684\u53f3\u8fb9\u754c\uff0c\u90a3\u4e48\u5c31\u8bf4\u660e\u6709\u91cd\u53e0\uff0c\u90a3\u4e48\u5c31\u628a\u5f53\u524d\u7684\u53f3\u8fb9\u754c\u548c\u9ad8\u5ea6\u90fd\u5b58\u8d77\u6765\uff0c\u7136\u540e\u53d6\u6700\u5927\u7684\u9ad8\u5ea6\n        # 4. \u7136\u540e\u518d\u4ece\u5de6\u5230\u53f3\u904d\u5386\uff0c\u5982\u679c\u5f53\u524d\u7684\u5de6\u8fb9\u754c\u5927\u4e8e\u524d\u4e00\u4e2a\u7684\u53f3\u8fb9\u754c\uff0c\u90a3\u4e48\u5c31\u8bf4\u660e\u6ca1\u6709\u91cd\u53e0\uff0c\u90a3\u4e48\u5c31\u628a\u5f53\u524d\u7684\u53f3\u8fb9\u754c\u548c\u9ad8\u5ea6\u90fd\u5b58\u8d77\u6765\n        # 5. \u5982\u679c\u5f53\u524d\u7684\u5de6\u8fb9\u754c\u5c0f\u4e8e\u524d\u4e00\u4e2a\u7684\u53f3\u8fb9\u754c\uff0c\u90a3\u4e48\u5c31\u8bf4\u660e\u6709\u91cd\u53e0\uff0c\u90a3\u4e48\u5c31\u628a\u5f53\u524d\u7684\u53f3\u8fb9\u754c\u548c\u9ad8\u5ea6\u90fd\u5b58\u8d77\u6765\uff0c\u7136\u540e\u53d6\u6700\u5927\u7684\u9ad8\u5ea6\n        # 6. \u7136\u540e\u518d\u4ece\u5de6\u5230\u53f3\u904d\u5386\uff0c\u5982\u679c\u5f53\u524d\u7684\u5de6\u8fb9\u754c\u5927\u4e8e\u524d\u4e00\u4e2a\u7684\u53f3\u8fb9\u754c\uff0c\u90a3\u4e48\u5c31\u8bf4\u660e\u6ca1\u6709\u91cd\u53e0\uff0c\u90a3\u4e48\u5c31\u628a\u5f53\u524d\u7684\u53f3\u8fb9\u754c\u548c\u9ad8\u5ea6\u90fd\u5b58\u8d77\u6765\n        # 7. \u5982\u679c\u5f53\u524d\u7684\u5de6\u8fb9\u754c\u5c0f\u4e8e\u524d\u4e00\u4e2a\u7684\u53f3\u8fb9\u754c\uff0c\u90a3\u4e48\u5c31\u8bf4\u660e\u6709\u91cd\u53e0\uff0c\u90a3\u4e48\u5c31\u628a\u5f53\u524d\u7684\u53f3\u8fb9\u754c\u548c\u9ad8\u5ea6\u90fd\u5b58\u8d77\u6765\uff0c\u7136\u540e\u53d6\u6700\u5927\u7684\u9ad8\u5ea6\n        # 8. \u7136\u540e\u518d\u4ece\u5de6\u5230\u53f3\u904d\u5386\uff0c\u5982\u679c\u5f53\u524d\u7684\u5de6\u8fb9\u754c\u5927\u4e8e\u524d\u4e00\u4e2a\u7684\u53f3\u8fb9\u754c\uff0c\u90a3\u4e48\u5c31\u8bf4\u660e\u6ca1\u6709\u91cd\u53e0\uff0c\u90a3\u4e48\u5c31\u628a\u5f53\u524d\u7684\u53f3\u8fb9\u754c\u548c\u9ad8\u5ea6\u90fd\u5b58\u8d77\u6765\n        # 9. \u5982\u679c\u5f53\u524d\u7684\u5de6\u8fb9\u754c\u5c0f\u4e8e\u524d\u4e00\u4e2a\u7684\u53f3\u8fb9\u754c\uff0c\u90a3\u4e48\u5c31\u8bf4\u660e\u6709\u91cd\u53e0\uff0c\u90a3\u4e48\u5c31\u628a\u5f53\u524d\u7684\u53f3\u8fb9\u754c\u548c\u9ad8\u5ea6\u90fd\u5b58\u8d77\u6765\uff0c\u7136\u540e\u53d6\u6700\u5927\u7684\u9ad8\u5ea6\n        # 10. \u7136\u540e\u518d\u4ece\u5de6\u5230\u53f3\u904d\u5386\uff0c\u5982\u679c\u5f53\u524d\u7684\u5de6\u8fb9\u754c\u5927\u4e8e\u524d\u4e00\u4e2a\u7684\u53f3\u8fb9\u754c\uff0c\u90a3\u4e48\u5c31\u8bf4\u660e\u6ca1\u6709\u91cd\u53e0\uff0c\u90a3\u4e48\u5c31\u628a\u5f53\u524d\u7684\u53f3\u8fb9\u754c\u548c\u9ad8\u5ea6\u90fd\u5b58\u8d77\u6765\n        # 11. \u5982\u679c\u5f53\u524d\u7684\u5de6\u8fb9\u754c\u5c0f\u4e8e\u524d\u4e00\u4e2a\u7684\u53f3\u8fb9\u754c\uff0c\u90a3\u4e48\u5c31\u8bf4\u660e\u6709\u91cd\u53e0\uff0c\u90a3\u4e48\u5c31\u628a\u5f53\u524d\u7684\u53f3\u8fb9\u754c\u548c\u9ad8\u5ea6\u90fd\u5b58\u8d77\u6765\uff0c\u7136\u540e\u53d6\u6700\u5927\u7684\u9ad8\u5ea6\n        # 12. \u7136\u540e\u518d\u4ece\u5de6\u5230\u53f3\u904d\u5386\uff0c\u5982\u679c\u5f53\u524d\u7684\u5de6\u8fb9\u754c\u5927\u4e8e\u524d\u4e00\u4e2a\u7684\u53f3\u8fb9\u754c\uff0c\u90a3\u4e48\u5c31\u8bf4\u660e\u6ca1\u6709\u91cd\u53e0\uff0c\u90a3\u4e48\u5c31\u628a\u5f53\u524d\u7684\u53f3\u8fb9\u754c\u548c\u9ad8\u5ea6\u90fd\u5b58\u8d77\u6765\n        # 13. \u5982\u679c\u5f53\u524d\u7684\u5de6\u8fb9\u754c\u5c0f\u4e8e\u524d\u4e00\u4e2a\u7684\u53f3\u8fb9\u754c\uff0c\u90a3\u4e48\u5c31\u8bf4\u660e\u6709\u91cd\u53e0\uff0c\u90a3\u4e48\u5c31\u628a\u5f53\u524d\u7684\u53f3\u8fb9\u754c\u548c\u9ad8\u5ea6\u90fd\u5b58\u8d77\u6765\uff0c\u7136\u540e\u53d6\u6700\u5927\u7684\u9ad8\u5ea6\n        # 14. \u7136\u540e\u518d\u4ece\u5de6\u5230\u53f3\u904d\u5386\uff0c\u5982\u679c\u5f53\u524d\u7684\u5de6\u8fb9\u754c\u5927\u4e8e\u524d\u4e00\u4e2a\u7684\u53f3\u8fb9\u754c\uff0c\u90a3\u4e48\u5c31\u8bf4\u660e\u6ca1\u6709\u91cd\u53e0\uff0c\u90a3\u4e48\u5c31\u628a\u5f53\u524d\u7684\u53f3\u8fb9\u754c\u548c\u9ad8\u5ea6\u90fd\u5b58\u8d77\u6765\n        # 15. \u5982\u679c\u5f53\u524d\u7684\u5de6\u8fb9\u754c\u5c0f\u4e8e\u524d\u4e00\u4e2a\u7684\u53f3\u8fb9\u754c\uff0c\u90a3\u4e48\u5c31\u8bf4\u660e\u6709\u91cd\u53e0\uff0c\u90a3\u4e48\u5c31\u628a\u5f53\u524d\u7684\u53f3\u8fb9\u754c\u548c\u9ad8\u5ea6\u90fd\u5b58\u8d77\u6765\uff0c\u7136\u540e\u53d6\u6700\u5927\u7684\u9ad8\u5ea6\n        # 16. \u7136\u540e\u518d\u4ece\u5de6\u5230\u53f3\u904d\u5386\uff0c\u5982\u679c\u5f53\u524d\u7684\u5de6\u8fb9\u754c\u5927\u4e8e\u524d\u4e00\u4e2a\u7684\u53f3\u8fb9\u754c\uff0c\u90a3\u4e48\u5c31\u8bf4\u660e\u6ca1\u6709\u91cd\u53e0\uff0c\u90a3\u4e48\u5c31\u628a\u5f53\u524d\u7684\u53f3\u8fb9\u754c\u548c\u9ad8\u5ea6\u90fd\u5b58\u8d77\u6765\n        # 17. \u5982\u679c\u5f53\u524d\u7684\u5de6\u8fb9\u754c\u5c0f\u4e8e\u524d\u4e00\u4e2a\u7684\u53f3\u8fb9\u754c\uff0c\u90a3\u4e48\u5c31\u8bf4\u660e\u6709\u91cd\u53e0\uff0c\u90a3\u4e48\u5c31\u628a\u5f53\u524d\u7684\u53f3\u8fb9\u754c\u548c\u9ad8\u5ea6\u90fd\u5b58\u8d77\u6765\uff0c\u7136\u540e\u53d6\u6700\u5927\u7684\u9ad8\u5ea6\n        # 18. \u7136\u540e\u518d\u4ece\u5de6\u5230\u53f3\u904d\u5386\uff0c\u5982\u679c\u5f53\u524d\u7684\u5de6\u8fb9\u754c\u5927\u4e8e\u524d\u4e00\u4e2a\u7684\u53f3\u8fb9\u754c\uff0c\u90a3\u4e48\u5c31\u8bf4\u660e\u6ca1\u6709\u91cd\u53e0\uff0c\u90a3\u4e48\u5c31\u628a\u5f53\u524d\u7684\u53f3\u8fb9\u754c\u548c\u9ad8\u5ea6\u90fd\u5b58\u8d77\u6765\n        # 19. \u5982\u679c\u5f53\u524d\u7684\u5de6\u8fb9\u754c\u5c0f\u4e8e\u524d\u4e00\u4e2a\u7684\u53f3\u8fb9\u754c\uff0c\u90a3\u4e48\u5c31\u8bf4\u660e\u6709\u91cd\u53e0\uff0c\u90a3\u4e48\u5c31\u628a\u5f53\u524d\u7684\u53f3\u8fb9\u754c\u548c\u9ad8\u5ea6\u90fd\u5b58\u8d77\u6765\uff0c\u7136\u540e\u53d6\u6700\u5927\u7684\u9ad8\u5ea6\n        # 20. \u7136\u540e\u518d\u4ece\u5de6\u5230\u53f3\u904d\u5386\uff0c\u5982\u679c\u5f53\u524d\u7684\u5de6\u8fb9\u754c\u5927\u4e8e\u524d\u4e00\u4e2a\u7684\u53f3\u8fb9\u754c\uff0c\u90a3\u4e48\u5c31\u8bf4\u660e\u6ca1\u6709\u91cd\u53e0\uff0c\u90a3\u4e48\u5c31\u628a\u5f53\u524d\u7684\u53f3\u8fb9\u754c\u548c\u9ad8\u5ea6\u90fd\u5b58\u8d77\u6765\n        # 21. \u5982\u679c\u5f53\u524d\u7684\u5de6\u8fb9\u754c\u5c0f\u4e8e\u524d\u4e00\u4e2a\u7684\u53f3\u8fb9\u754c\uff0c\u90a3\u4e48\u5c31\u8bf4\u660e\u6709\u91cd\u53e0\uff0c\u90a3\u4e48\u5c31\u628a\u5f53\u524d\u7684\u53f3\u8fb9\u754c\u548c\u9ad8\u5ea6\u90fd\u5b58\u8d77\u6765\uff0c\u7136\u540e\u53d6\u6700\u5927\u7684\u9ad8\u5ea6\n        # 2"}], "sum-of-left-leaves": [{"task_id": "sum-of-left-leaves", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def dfs(node, is_left):\n            if not node:\n                return 0\n            if not node.left and not node.right:\n                if is_left:\n                    return node.val\n                else:\n                    return 0\n            return dfs(node.left, True) + dfs(node.right, False)\n        \n        return dfs(root, False)"}, {"task_id": "sum-of-left-leaves", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def dfs(node, is_left):\n            if not node:\n                return 0\n            if not node.left and not node.right:\n                if is_left:\n                    return node.val\n                else:\n                    return 0\n            return dfs(node.left, True) + dfs(node.right, False)\n        \n        return dfs(root, False)"}, {"task_id": "sum-of-left-leaves", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def dfs(node, is_left):\n            if not node:\n                return 0\n            if not node.left and not node.right:\n                if is_left:\n                    return node.val\n                else:\n                    return 0\n            return dfs(node.left, True) + dfs(node.right, False)\n        \n        return dfs(root, False)"}, {"task_id": "sum-of-left-leaves", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def dfs(node, is_left):\n            if not node:\n                return 0\n            if not node.left and not node.right:\n                if is_left:\n                    return node.val\n                else:\n                    return 0\n            return dfs(node.left, True) + dfs(node.right, False)\n        \n        return dfs(root, False)"}, {"task_id": "sum-of-left-leaves", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sumOfLeftLeaves(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def dfs(node, is_left):\n            if not node:\n                return 0\n            if not node.left and not node.right:\n                if is_left:\n                    return node.val\n                else:\n                    return 0\n            return dfs(node.left, True) + dfs(node.right, False)\n        \n        return dfs(root, False)"}], "max-sum-of-rectangle-no-larger-than-k": [{"task_id": "max-sum-of-rectangle-no-larger-than-k", "completion": "class Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2D prefix sum\n        # 2. 1D prefix sum\n        # 3. binary search\n        \n        m, n = len(matrix), len(matrix[0])\n        prefix = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                prefix[i][j] = prefix[i - 1][j] + prefix[i][j - 1] - prefix[i - 1][j - 1] + matrix[i - 1][j - 1]\n        \n        res = float('-inf')\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                for p in range(i, m + 1):\n                    for q in range(j, n + 1):\n                        curr = prefix[p][q] - prefix[i - 1][q] - prefix[p][j - 1] + prefix[i - 1][j - 1]\n                        if curr <= k:\n                            res = max(res, curr)\n        return res"}, {"task_id": "max-sum-of-rectangle-no-larger-than-k", "completion": "class Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        m, n = len(matrix), len(matrix[0])\n        res = float('-inf')\n        for l in range(n):\n            row_sum = [0] * m\n            for r in range(l, n):\n                for i in range(m):\n                    row_sum[i] += matrix[i][r]\n                res = max(res, self.maxSumSubarray(row_sum, k))\n        return res\n    \n    def maxSumSubarray(self, nums, k):\n        res = float('-inf')\n        prefix_sum = 0\n        prefix_sum_set = set([0])\n        for num in nums:\n            prefix_sum += num\n            target = prefix_sum - k\n            if target >= 0:\n                res = max(res, prefix_sum - min(prefix_sum_set, key=lambda x: abs(x - target)))\n            prefix_sum_set.add(prefix_sum)\n        return res"}, {"task_id": "max-sum-of-rectangle-no-larger-than-k", "completion": "class Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2D prefix sum\n        # 2. 1D prefix sum\n        # 3. binary search\n        \n        m, n = len(matrix), len(matrix[0])\n        prefix = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                prefix[i][j] = prefix[i - 1][j] + prefix[i][j - 1] - prefix[i - 1][j - 1] + matrix[i - 1][j - 1]\n        \n        res = float('-inf')\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                for p in range(i, m + 1):\n                    for q in range(j, n + 1):\n                        curr = prefix[p][q] - prefix[p][j - 1] - prefix[i - 1][q] + prefix[i - 1][j - 1]\n                        if curr <= k:\n                            res = max(res, curr)\n        return res"}, {"task_id": "max-sum-of-rectangle-no-larger-than-k", "completion": "class Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        m, n = len(matrix), len(matrix[0])\n        res = float('-inf')\n        for l in range(n):\n            row_sum = [0] * m\n            for r in range(l, n):\n                for i in range(m):\n                    row_sum[i] += matrix[i][r]\n                res = max(res, self.maxSumSubarray(row_sum, k))\n        return res\n    \n    def maxSumSubarray(self, nums, k):\n        res = float('-inf')\n        prefix_sum = 0\n        prefix_sum_set = set([0])\n        for num in nums:\n            prefix_sum += num\n            target = prefix_sum - k\n            if target >= 0:\n                res = max(res, prefix_sum - min(prefix_sum_set, key=lambda x: abs(x - target)))\n            prefix_sum_set.add(prefix_sum)\n        return res"}, {"task_id": "max-sum-of-rectangle-no-larger-than-k", "completion": "class Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2D prefix sum\n        # 2. 1D prefix sum\n        # 3. binary search\n        \n        m, n = len(matrix), len(matrix[0])\n        prefix = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                prefix[i][j] = prefix[i - 1][j] + prefix[i][j - 1] - prefix[i - 1][j - 1] + matrix[i - 1][j - 1]\n        \n        res = float('-inf')\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                for p in range(i, m + 1):\n                    for q in range(j, n + 1):\n                        curr = prefix[p][q] - prefix[p][j - 1] - prefix[i - 1][q] + prefix[i - 1][j - 1]\n                        if curr <= k:\n                            res = max(res, curr)\n        return res"}], "divide-two-integers": [{"task_id": "divide-two-integers", "completion": "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10."}, {"task_id": "divide-two-integers", "completion": "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10."}, {"task_id": "divide-two-integers", "completion": "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10."}, {"task_id": "divide-two-integers", "completion": "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10."}, {"task_id": "divide-two-integers", "completion": "class Solution(object):\n    def divide(self, dividend, divisor):\n        \"\"\"\n        :type dividend: int\n        :type divisor: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10."}], "surrounded-regions": [{"task_id": "surrounded-regions", "completion": "class Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        # 1. \u904d\u5386\u8fb9\u754c\uff0c\u5c06\u8fb9\u754c\u7684O\u548c\u5176\u76f8\u8fde\u7684O\u90fd\u6807\u8bb0\u4e3a#\n        # 2. \u904d\u5386\u6574\u4e2aboard\uff0c\u5c06O\u53d8\u4e3aX\uff0c\u5c06#\u53d8\u4e3aO\n        \n        if not board:\n            return\n        \n        m, n = len(board), len(board[0])\n        \n        def dfs(i, j):\n            if i < 0 or i >= m or j < 0 or j >= n or board[i][j] != 'O':\n                return\n            board[i][j] = '#'\n            dfs(i + 1, j)\n            dfs(i - 1, j)\n            dfs(i, j + 1)\n            dfs(i, j - 1)\n        \n        for i in range(m):\n            dfs(i, 0)\n            dfs(i, n - 1)\n        \n        for j in range(n):\n            dfs(0, j)\n            dfs(m - 1, j)\n        \n        for i in range(m):\n            for j in range(n):\n                if board[i][j] == 'O':\n                    board[i][j] = 'X'\n                elif board[i][j] == '#':\n                    board[i][j] = 'O'\n        \n        return board"}, {"task_id": "surrounded-regions", "completion": "class Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        # 1. \u904d\u5386\u6240\u6709\u8fb9\u754c\u4e0a\u7684O\uff0c\u5e76\u5c06\u6240\u6709\u4e0e\u5176\u76f8\u8fde\u7684O\u90fd\u6807\u8bb0\u4e3a#\n        # 2. \u904d\u5386\u6574\u4e2aboard\uff0c\u5c06\u6240\u6709O\u53d8\u4e3aX\uff0c\u5c06\u6240\u6709#\u53d8\u4e3aO\n        \n        if not board or not board[0]:\n            return\n        \n        m, n = len(board), len(board[0])\n        \n        def dfs(i, j):\n            if i < 0 or i >= m or j < 0 or j >= n or board[i][j] != 'O':\n                return\n            board[i][j] = '#'\n            dfs(i + 1, j)\n            dfs(i - 1, j)\n            dfs(i, j + 1)\n            dfs(i, j - 1)\n        \n        for i in range(m):\n            dfs(i, 0)\n            dfs(i, n - 1"}, {"task_id": "surrounded-regions", "completion": "class Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        # 1. \u904d\u5386\u6240\u6709\u8fb9\u754c\u4e0a\u7684O\uff0c\u5e76\u5c06\u5176\u4e0e\u5176\u76f8\u8fde\u7684O\u5168\u90e8\u6807\u8bb0\u4e3a#\n        # 2. \u904d\u5386\u6574\u4e2aboard\uff0c\u5c06O\u5168\u90e8\u66ff\u6362\u4e3aX\uff0c\u5c06#\u66ff\u6362\u4e3aO\n        \n        if not board or not board[0]:\n            return\n        \n        m, n = len(board), len(board[0])\n        \n        def dfs(i, j):\n            if i < 0 or i >= m or j < 0 or j >= n or board[i][j] != 'O':\n                return\n            board[i][j] = '#'\n            dfs(i + 1, j)\n            dfs(i - 1, j)\n            dfs(i, j + 1)\n            dfs(i, j - 1)\n        \n        for i in range(m):\n            dfs(i, 0)\n            dfs(i, n - 1"}, {"task_id": "surrounded-regions", "completion": "class Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        # 1. \u628a\u6240\u6709\u8fb9\u754c\u4e0a\u7684O\u90fd\u6807\u8bb0\u4e3a#\n        # 2. \u628a\u6240\u6709\u4e0d\u4e0e\u8fb9\u754c\u4e0a\u7684O\u76f8\u8fde\u7684O\u90fd\u6807\u8bb0\u4e3aX\n        # 3. \u628a\u6240\u6709#\u90fd\u8fd8\u539f\u4e3aO\n        \n        if not board or not board[0]:\n            return\n        \n        m, n = len(board), len(board[0])\n        \n        def dfs(i, j):\n            if i < 0 or i >= m or j < 0 or j >= n or board[i][j] != 'O':\n                return\n            board[i][j] = '#'\n            dfs(i + 1, j)\n            dfs(i - 1, j)\n            dfs(i, j + 1)\n            dfs(i, j - 1)\n        \n        for i in range(m):\n            dfs(i, 0)\n            dfs(i, n - 1)\n        \n        for j in range(n):\n            dfs(0, j)\n            dfs(m - 1, j)\n        \n        for i in range(m):\n            for j in range(n):\n                if board[i][j] == 'O':\n                    board[i][j] = 'X'\n                elif board[i][j] == '#':\n                    board[i][j] = 'O'\n        \n        return board"}, {"task_id": "surrounded-regions", "completion": "class Solution(object):\n    def solve(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        # 1. \u904d\u5386\u6240\u6709\u8fb9\u754c\u4e0a\u7684O\uff0c\u5e76\u5c06\u5176\u4e0e\u5176\u76f8\u90bb\u7684O\u8fdb\u884c\u6807\u8bb0\n        # 2. \u904d\u5386\u6574\u4e2aboard\uff0c\u5c06\u6ca1\u6709\u88ab\u6807\u8bb0\u7684O\u53d8\u4e3aX\uff0c\u5c06\u88ab\u6807\u8bb0\u7684O\u53d8\u4e3aO\n        \n        if not board or not board[0]:\n            return\n        \n        m, n = len(board), len(board[0])\n        \n        def dfs(i, j):\n            if i < 0 or i >= m or j < 0 or j >= n or board[i][j] != 'O':\n                return\n            board[i][j] = 'A'\n            dfs(i + 1, j)\n            dfs(i - 1, j)\n            dfs(i, j + 1)\n            dfs(i, j - 1)\n        \n        for i in range(m):\n            dfs(i, 0)\n            dfs(i, n - 1"}], "two-sum": [{"task_id": "two-sum", "completion": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # Brute Force\n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if nums[i] + nums[j] == target:\n        #             return [i, j]\n        \n        # Two-pass Hash Table\n        # hashmap = {}\n        # for i in range(len(nums)):\n        #     hashmap[nums[i]] = i\n        # for i in range(len(nums)):\n        #     complement = target - nums[i]\n        #     if complement in hashmap and hashmap[complement] != i:\n        #         return [i, hashmap[complement]]\n        \n        # One-pass Hash Table\n        hashmap = {}\n        for i in range(len(nums)):\n            complement = target - nums[i]\n            if complement in hashmap:\n                return [i, hashmap[complement]]\n            hashmap[nums[i]] = i\n        \n        # One-pass Hash Table\n        # hashmap = {}\n        # for i, num in enumerate(nums):\n        #     complement = target - num\n        #     if complement in hashmap:\n        #         return [i, hashmap[complement]]\n        #     hashmap[num] = i\n        \n        # One-pass Hash Table\n        # hashmap = {}\n        # for i, num in enumerate(nums):\n        #     complement = target - num\n        #     if complement in hashmap:\n        #         return [hashmap[complement], i]\n        #     hashmap[num] = i\n        \n        # One-pass Hash Table\n        # hashmap = {}\n        # for i, num in enumerate(nums):\n        #     complement = target - num\n        #     if complement in hashmap:\n        #         return [i, hashmap[complement]]\n        #     hashmap[complement] = i\n        \n        # One-pass Hash Table\n        # hashmap = {}\n        # for i, num in enumerate(nums):\n        #     complement = target - num\n        #     if complement in hashmap:\n        #         return [hashmap[complement], i]\n        #     hashmap[complement] = i\n        \n        # One-pass Hash Table\n        # hashmap = {}\n        # for i, num in enumerate(nums):\n        #     complement = target - num\n        #     if complement in hashmap:\n        #         return [i, hashmap[complement]]\n        #     hashmap[complement] = i\n        \n        # One-pass Hash Table\n        # hashmap = {}\n        # for i, num in enumerate(nums):\n        #     complement = target - num\n        #     if complement in hashmap:\n        #         return [i, hashmap[complement]]\n        #     hashmap[complement] = i\n        \n        # One-pass Hash Table\n        # hashmap = {}\n        # for i, num in enumerate(nums):\n        #     complement = target - num\n        #     if complement in hashmap:\n        #         return [i, hashmap[complement]]\n        #     hashmap[complement] = i\n        \n        # One-pass Hash Table\n        # hashmap = {}\n        # for i, num in enumerate(nums):\n        #     complement = target - num\n        #     if complement in hashmap:\n        #         return [i, hashmap[complement]]\n        #     hashmap[complement] = i\n        \n        # One-pass Hash Table\n        # hashmap = {}\n        # for i, num in enumerate(nums):\n        #     complement = target - num\n        #     if complement in hashmap:\n        #         return [i, hashmap[complement]]\n        #     hashmap[complement] = i\n        \n        # One-pass Hash Table\n        # hashmap = {}\n        # for i, num in enumerate(nums):\n        #     complement = target - num\n        #     if complement in hashmap:\n        #         return [i, hashmap[complement]]\n        #     hashmap[complement] = i\n        \n        # One-pass Hash Table\n        # hashmap = {}\n        # for"}, {"task_id": "two-sum", "completion": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # create a dictionary to store the values and their indices\n        d = {}\n        \n        # iterate through the nums list\n        for i in range(len(nums)):\n            # if the target minus the current number is in the dictionary, return the indices\n            if target - nums[i] in d:\n                return [d[target - nums[i]], i]\n            # otherwise, add the current number and its index to the dictionary\n            d[nums[i]] = i\n        \n        # if no solution is found, return an empty list\n        return []"}, {"task_id": "two-sum", "completion": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. Brute Force\n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if nums[i] + nums[j] == target:\n        #             return [i, j]\n        \n        # 2. Hashmap\n        # hashmap = {}\n        # for i in range(len(nums)):\n        #     complement = target - nums[i]\n        #     if complement in hashmap:\n        #         return [hashmap[complement], i]\n        #     hashmap[nums[i]] = i\n        \n        # 3. Two Pointers\n        nums.sort()\n        left, right = 0, len(nums) - 1\n        while left < right:\n            if nums[left] + nums[right] == target:\n                return [left, right]\n            elif nums[left] + numsright"}, {"task_id": "two-sum", "completion": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # Brute Force\n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if nums[i] + nums[j] == target:\n        #             return [i, j]\n        \n        # Two-pass Hash Table\n        # hashmap = {}\n        # for i in range(len(nums)):\n        #     hashmap[nums[i]] = i\n        # for i in range(len(nums)):\n        #     complement = target - nums[i]\n        #     if complement in hashmap and hashmap[complement] != i:\n        #         return [i, hashmap[complement]]\n        \n        # One-pass Hash Table\n        hashmap = {}\n        for i in range(len(nums)):\n            complement = target - nums[i]\n            if complement in hashmap:\n                return [i, hashmap[complement]]\n            hashmap[nums[i]] = i"}, {"task_id": "two-sum", "completion": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # Brute Force\n        # for i in range(len(nums)):\n        #     for j in range(i+1, len(nums)):\n        #         if nums[i] + nums[j] == target:\n        #             return [i, j]\n        \n        # Two-pass Hash Table\n        # hashmap = {}\n        # for i in range(len(nums)):\n        #     hashmap[nums[i]] = i\n        # for i in range(len(nums)):\n        #     complement = target - nums[i]\n        #     if complement in hashmap and hashmap[complement] != i:\n        #         return [i, hashmap[complement]]\n        \n        # One-pass Hash Table\n        hashmap = {}\n        for i in range(len(nums)):\n            complement = target - nums[i]\n            if complement in hashmap:\n                return [i, hashmap[complement]]\n            hashmap[nums[i]] = i\n        \n        # Two Pointers\n        # nums.sort()\n        # left, right = 0, len(nums) - 1\n        # while left < right:\n        #     curr_sum = nums[left] + nums[right]\n        #     if curr_sum == target:\n        #         return [left, right]\n        #     elif currum < target:\n        #         left += 1\n        #     elif curr_sum > target:\n        #         right -= 1\n        \n        # One-pass Hash Table\n        # hashmap = {}\n        # for i, num in enumerate(nums):\n        #     complement = target - num\n        #     if complement in hashmap:\n        #         return [i, hashmap[complement]]\n        #     hashmap[num] = i\n        \n        # Two Pointers\n        # nums.sort()\n        # left, right = 0, len(nums) - 1\n        # while left < right:\n        #     curr_sum = nums[left] + nums[right]\n        #     if curr_sum == target:\n        #         return [left, right]\n        #     elif curr_sum < target:\n        #         left += 1\n        #     elif curr_sum > target:\n        #         right -= 1\n        \n        # One-pass Hash Table\n        # hashmap = {}\n        # for i, num in enumerate(nums):\n        #     complement = target - num\n        #     if complement in hashmap:\n        #         return [i, hashmap[complement]]\n        #     hashmap[num] = i\n        \n        # Two Pointers\n        # nums.sort()\n        # left, right = 0, len(nums) - 1\n        # while left < right:\n        #     curr_sum = nums[left] + nums[right]\n        #     if curr_sum == target:\n        #         return [left, right]\n        #     elif curr_sum < target:\n        #         left += 1\n        #     elif curr_sum > target:\n        #         right -= 1\n        \n        # One-pass Hash Table\n        # hashmap = {}\n        # for i, num in enumerate(nums):\n        #     complement = target - num\n        #     if complement in hashmap:\n        #         return [i, hashmap[complement]]\n        #     hashmap[num] = i\n        \n        # Two Pointers\n        # nums.sort()\n        # left, right = 0, len(nums) - 1\n        # while left < right:\n        #     curr_sum = nums[left] + nums[right]\n        #     if curr_sum == target:\n        #         return [left, right]\n        #     elif curr_sum < target:\n        #         left += 1\n        #     elif curr_sum > target:\n        #         right -= 1\n        \n        # One-pass Hash Table\n        # hashmap = {}\n        # for i, num in enumerate(nums):\n        #     complement = target - num\n        #     if complement in hashmap:\n        #         return [i, hashmap[com"}], "24-game": [{"task_id": "24-game", "completion": "class Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        def helper(nums):\n            if len(nums) == 1:\n                return abs(nums[0] - 24) < 1e-6\n            \n            for i in range(len(nums)):\n                for j in range(len(nums)):\n                    if i != j:\n                        new_nums = [nums[k] for k in range(len(nums)) if i != k != j]\n                        for op in [lambda x, y: x + y, lambda x, y: x - y, lambda x, y: x * y, lambda x, y: x / y if y != 0 else 0]:\n                            new_nums.append(op(nums[i], nums[j]))\n                            if helper(new_nums):\n                                return True\n                            new_nums.pop()\n            return False\n        \n        return helper(cards)"}, {"task_id": "24-game", "completion": "class Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        def helper(nums):\n            if len(nums) == 1:\n                return abs(nums[0] - 24) < 1e-6\n            \n            for i in range(len(nums)):\n                for j in range(len(nums)):\n                    if i != j:\n                        new_nums = [nums[k] for k in range(len(nums)) if i != k != j]\n                        for op in [lambda x, y: x + y, lambda x, y: x - y, lambda x, y: x * y, lambda x, y: x / y if y != 0 else 0]:\n                            new_nums.append(op(nums[i], nums[j]))\n                            if helper(new_nums):\n                                return True\n                            new_nums.pop()\n            return False\n        \n        return helper(cards)"}, {"task_id": "24-game", "completion": "class Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        def helper(nums):\n            if len(nums) == 1:\n                return abs(nums[0] - 24) < 1e-6\n            \n            for i in range(len(nums)):\n                for j in range(len(nums)):\n                    if i != j:\n                        new_nums = [nums[k] for k in range(len(nums)) if i != k != j]\n                        for op in [lambda x, y: x + y, lambda x, y: x - y, lambda x, y: x * y, lambda x, y: x / y if y != 0 else 0]:\n                            new_nums.append(op(nums[i], nums[j]))\n                            if helper(new_nums):\n                                return True\n                            new_nums.pop()\n            return False\n        \n        return helper(cards)"}, {"task_id": "24-game", "completion": "class Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        def helper(nums):\n            if len(nums) == 1:\n                return abs(nums[0] - 24) < 1e-6\n            \n            for i in range(len(nums)):\n                for j in range(len(nums)):\n                    if i != j:\n                        new_nums = [nums[k] for k in range(len(nums)) if i != k != j]\n                        for op in [lambda x, y: x + y, lambda x, y: x - y, lambda x, y: x * y, lambda x, y: x / y if y != 0 else 0]:\n                            new_nums.append(op(nums[i], nums[j]))\n                            if helper(new_nums):\n                                return True\n                            new_nums.pop()\n            return False\n        \n        return helper(cards)"}, {"task_id": "24-game", "completion": "class Solution(object):\n    def judgePoint24(self, cards):\n        \"\"\"\n        :type cards: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        def helper(nums):\n            if len(nums) == 1:\n                return abs(nums[0] - 24) < 1e-6\n            \n            for i in range(len(nums)):\n                for j in range(len(nums)):\n                    if i != j:\n                        new_nums = [nums[k] for k in range(len(nums)) if i != k != j]\n                        for op in [lambda x, y: x + y, lambda x, y: x - y, lambda x, y: x * y, lambda x, y: x / y if y != 0 else 0]:\n                            new_nums.append(op(nums[i], nums[j]))\n                            if helper(new_nums):\n                                return True\n                            new_nums.pop()\n            return False\n        \n        return helper(cards)"}], "wildcard-matching": [{"task_id": "wildcard-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        ## DP solution\n        ## Time complexity: O(m*n)\n        ## Space complexity: O(m*n)\n        \n        m = len(s)\n        n = len(p)\n        \n        dp = [[False]*(n+1) for _ in range(m+1)]\n        \n        dp[0][0] = True\n        \n        for j in range(1, n+1):\n            if p[j-1] == '*':\n                dp[0][j] = dp[0][j-1]\n        \n        for i in range(1, m+1):\n            for j in range(1, n+1):\n                if p[j-1] == '*':\n                    dp[i][j] = dp[i][j-1] or dp[i-1][j]\n                elif p[j-1] == '?' or s[i-1] == p[j-1]:\n                    dp[i][j] = dp[i-1][j-1]\n        \n        return dp[m][n]"}, {"task_id": "wildcard-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        ## DP solution\n        ## Time complexity: O(m*n)\n        ## Space complexity: O(m*n)\n        \n        m = len(s)\n        n = len(p)\n        \n        dp = [[False]*(n+1) for _ in range(m+1)]\n        \n        dp[0][0] = True\n        \n        for j in range(1, n+1):\n            if p[j-1] == '*':\n                dp[0][j] = dp[0][j-1]\n        \n        for i in range(1, m+1):\n            for j in range(1, n+1):\n                if p[j-1] == '*':\n                    dp[i][j] = dp[i][j-1] or dp[i-1][j]\n                elif p[j-1] == '?' or s[i-1] == p[j-1]:\n                    dp[i][j] = dp[i-1][j-1]\n        \n        return dp[m][n]"}, {"task_id": "wildcard-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        ## DP solution\n        ## Time complexity: O(m*n)\n        ## Space complexity: O(m*n)\n        \n        m = len(s)\n        n = len(p)\n        \n        dp = [[False]*(n+1) for _ in range(m+1)]\n        \n        dp[0][0] = True\n        \n        for j in range(1, n+1):\n            if p[j-1] == '*':\n                dp[0][j] = dp[0][j-1]\n        \n        for i in range(1, m+1):\n            for j in range(1, n+1):\n                if p[j-1] == '*':\n                    dp[i][j] = dp[i][j-1] or dp[i-1][j]\n                elif p[j-1] == '?' or s[i-1] == p[j-1]:\n                    dp[i][j] = dp[i-1][j-1]\n        \n        return dp[m][n]"}, {"task_id": "wildcard-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        ## DP solution\n        ## Time complexity: O(m*n)\n        ## Space complexity: O(m*n)\n        \n        m = len(s)\n        n = len(p)\n        \n        dp = [[False]*(n+1) for _ in range(m+1)]\n        \n        dp[0][0] = True\n        \n        for j in range(1, n+1):\n            if p[j-1] == '*':\n                dp[0][j] = dp[0][j-1]\n        \n        for i in range(1, m+1):\n            for j in range(1, n+1):\n                if p[j-1] == '*':\n                    dp[i][j] = dp[i][j-1] or dp[i-1][j]\n                elif p[j-1] == '?' or s[i-1] == p[j-1]:\n                    dp[i][j] = dp[i-1][j-1]\n        \n        return dp[m][n]"}, {"task_id": "wildcard-matching", "completion": "class Solution(object):\n    def isMatch(self, s, p):\n        \"\"\"\n        :type s: str\n        :type p: str\n        :rtype: bool\n        \"\"\"\n        \n        # DP solution\n        # Time: O(m*n)\n        # Space: O(m*n)\n        \n        # m = len(s)\n        # n = len(p)\n        \n        # dp = [[False]*(n+1) for _ in range(m+1)]\n        \n        # dp[0][0] = True\n        \n        # for j in range(1, n+1):\n        #     if p[j-1] == '*':\n        #         dp[0][j] = dp[0][j-1]\n        \n        # for i in range(1, m+1):\n        #     for j in range(1, n+1):\n        #         if p[j-1] == '*':\n        #             dp[i][j] = dp[i][j-1] or dp[i-1][j]\n        #         elif p[j-1] == '?' or s[i-1] == p[j-1]:\n        #             dp[i][j] = dp[i-1][j-1]\n        \n        # return dp[m][n]\n        \n        \n        # Recursive solution\n        # Time: O(2^(m+n))\n        # Space: O(m+n)\n        \n        m = len(s)\n        n = len(p)\n        \n        @lru_cache(None)\n        def dfs(i, j):\n            if i >= m and j >= n:\n                return True\n            if j >= n:\n                return False\n            \n            match = i < m and (s[i] == p[j] or p[j] == '?')\n            \n            if p[j] == '*':\n                return dfs(i, j+1) or (match and dfs(i+1, j))\n            else:\n                return match and dfs(i+1, j+1)\n        \n        return dfs(0, 0)"}], "majority-element": [{"task_id": "majority-element", "completion": "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## O(n) time and O(1) space\n        ## Boyer-Moore Voting Algorithm\n        ## https://en.wikipedia."}, {"task_id": "majority-element", "completion": "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## O(n) time and O(1) space\n        ## Boyer-Moore Voting Algorithm\n        ## https://en.wikipedia."}, {"task_id": "majority-element", "completion": "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 1. sort the array and return the middle element\n        ## 2. use a hashmap to store the count of each element\n        ## 3. use a hashmap to store the count of each element\n        ## 4. use a hashmap to store the count of each element\n        ## 5. use a hashmap to store the count of each element\n        ## 6. use a hashmap to store the count of each element\n        ## 7. use a hashmap to store the count of each element\n        ## 8. use a hashmap to store the count of each element\n        ## 9. use a hashmap to store the count of each element\n        ## 10. use a hashmap to store the count of each element\n        ## 11. use a hashmap to store the count of each element\n        ## 12. use a hashmap to store the count of each element\n        ## 13. use a hashmap to store the count of each element\n        ## 14. use a hashmap to store the count of each element\n        ## 15. use a hashmap to store the count of each element\n        ## 16. use a hashmap to store the count of each element\n        ## 17. use a hashmap to store the count of each element\n        ## 18. use a hashmap to store the count of each element\n        ## 19. use a hashmap to store the count of each element\n        ## 20. use a hashmap to store the count of each element\n        ## 21. use a hashmap to store the count of each element\n        ## 22. use a hashmap to store the count of each element\n        ## 23. use a hashmap to store the count of each element\n        ## 24. use a hashmap to store the count of each element\n        ## 25. use a hashmap to store the count of each element\n        ## 26. use a hashmap to store the count of each element\n        ## 27. use a hashmap to store the count of each element\n        ## 28. use a hashmap to store the count of each element\n        ## 29. use a hashmap to store the count of each element\n        ## 30. use a hashmap to store the count of each element\n        ## 31. use a hashmap to store the count of each element\n        ## 32. use a hashmap to store the count of each element\n        ## 33. use a hashmap to store the count of each element\n        ## 34. use a hashmap to store the count of each element\n        ## 35. use a hashmap to store the count of each element\n        ## 36. use a hashmap to store the count of each element\n        ## 37. use a hashmap to store the count of each element\n        ## 38. use a hashmap to store the count of each element\n        ## 39. use a hashmap to store the count of each element\n        ## 40. use a hashmap to store the count of each element\n        ## 41. use a hashmap to store the count of each element\n        ## 42. use a hashmap to store the count of each element\n        ## 43. use a hashmap to store the count of each element\n        ## 44. use a hashmap to store the count of each element\n        ## 45. use a hashmap to store the count of each element\n        ## 46. use a hashmap to store the count of each element\n        ## 47. use a hashmap to store the count of each element\n        ## 48. use a hashmap to store the count of each element\n        ## 49. use a hashmap to store the count of each element\n        ## 50. use a hashmap to store the count of each element\n        ## 51. use a hashmap to store the count of each element\n        ## 52. use a hashmap to store the count of each element\n        ## 53. use a hashmap to store the count of each element\n        ## 54. use a hashmap to store the count of each element\n        ## 55. use a hash"}, {"task_id": "majority-element", "completion": "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. sort the array\n        # 2. return the middle element\n        \n        nums.sort()\n        return nums[len(nums)//2]"}, {"task_id": "majority-element", "completion": "class Solution(object):\n    def majorityElement(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. sort the array\n        # 2. return the middle element\n        \n        nums.sort()\n        return nums[len(nums)//2]"}], "reconstruct-itinerary": [{"task_id": "reconstruct-itinerary", "completion": "class Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        \n        # 1. build the graph\n        graph = collections.defaultdict(list)\n        for src, dst in tickets:\n            graph[src].append(dst)\n        \n        # 2. sort the graph\n        for src in graph:\n            graph[src].sort(reverse=True)\n        \n        # 3. DFS\n        res = []\n        def dfs(src):\n            while graph[src]:\n                dst = graph[src].pop()\n                dfs(dst)\n            res.append(src)\n        \n        dfs(\"JFK\")\n        return res[::-1]"}, {"task_id": "reconstruct-itinerary", "completion": "class Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        \n        graph = collections.defaultdict(list)\n        for u, v in sorted(tickets)[::-1]:\n            graph[u].append(v)\n        \n        route = []\n        def dfs(u):\n            while graph[u]:\n                dfs(graph[u].pop())\n            route.append(u)\n        \n        dfs('JFK')\n        return route[::-1]"}, {"task_id": "reconstruct-itinerary", "completion": "class Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        \n        # 1. build the graph\n        graph = collections.defaultdict(list)\n        for src, dst in tickets:\n            graph[src].append(dst)\n        \n        # 2. sort the graph\n        for src in graph:\n            graph[src].sort(reverse=True)\n        \n        # 3. DFS\n        res = []\n        def dfs(src):\n            while graph[src]:\n                dst = graph[src].pop()\n                dfs(dst)\n            res.append(src)\n        \n        dfs(\"JFK\")\n        return res[::-1]"}, {"task_id": "reconstruct-itinerary", "completion": "class Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        \n        # 1. build the graph\n        graph = collections.defaultdict(list)\n        for src, dst in tickets:\n            graph[src].append(dst)\n        \n        # 2. sort the graph\n        for src in graph:\n            graph[src].sort(reverse=True)\n        \n        # 3. dfs\n        res = []\n        def dfs(src):\n            while graph[src]:\n                dfs(graph[src].pop())\n            res.append(src)\n        \n        dfs(\"JFK\")\n        return res[::-1]"}, {"task_id": "reconstruct-itinerary", "completion": "class Solution(object):\n    def findItinerary(self, tickets):\n        \"\"\"\n        :type tickets: List[List[str]]\n        :rtype: List[str]\n        \"\"\"\n        \n        # 1. build graph\n        graph = collections.defaultdict(list)\n        for u, v in tickets:\n            graph[u].append(v)\n        for u in graph:\n            graph[u].sort(reverse=True)\n        \n        # 2. dfs\n        res = []\n        def dfs(u):\n            while graph[u]:\n                v = graph[u].pop()\n                dfs(v)\n            res.append(u)\n        dfs('JFK')\n        return res[::-1]"}], "4sum": [{"task_id": "4sum", "completion": "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-3):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            for j in range(i+1, len(nums)-2):\n                if j > i+1 and nums[j] == nums[j-1]:\n                    continue\n                l = j+1\n                r = len(nums)-1\n                while l < r:\n                    if nums[i] + nums[j] + nums[l] + nums[r] == target:\n                        res.append([nums[i], nums[j], nums[l], nums[r]])\n                        l += 1\n                        r -= 1\n                        while l < r and nums[l] == nums[l-1]:\n                            l += 1\n                        while l < r and nums[r] == nums[r+1]:\n                            r -= 1\n                    elif nums[i] + nums[j] + nums[l] + nums[r] < target:\n                        l += 1\n                    else:\n                        r -= 1\n        return res"}, {"task_id": "4sum", "completion": "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-3):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            for j in range(i+1, len(nums)-2):\n                if j > i+1 and nums[j] == nums[j-1]:\n                    continue\n                l = j+1\n                r = len(nums)-1\n                while l < r:\n                    s = nums[i] + nums[j] + nums[l] + nums[r]\n                    if s == target:\n                        res.append([nums[i], nums[j], nums[l], nums[r]])\n                        l += 1\n                        r -= 1\n                        while l < r and nums[l] == nums[l-1]:\n                            l += 1\n                        while l < r and nums[r] == nums[r+1]:\n                            r -= 1\n                    elif s < target:\n                        l += 1\n                    else:\n                        r -= 1\n        return res"}, {"task_id": "4sum", "completion": "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-3):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            for j in range(i+1, len(nums)-2):\n                if j > i+1 and nums[j] == nums[j-1]:\n                    continue\n                l = j+1\n                r = len(nums)-1\n                while l < r:\n                    s = nums[i] + nums[j] + nums[l] + nums[r]\n                    if s == target:\n                        res.append([nums[i], nums[j], nums[l], nums[r]])\n                        l += 1\n                        r -= 1\n                        while l < r and nums[l] == nums[l-1]:\n                            l += 1\n                        while l < r and nums[r] == nums[r+1]:\n                            r -= 1\n                    elif s < target:\n                        l += 1\n                    else:\n                        r -= 1\n        return res"}, {"task_id": "4sum", "completion": "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-3):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            for j in range(i+1, len(nums)-2):\n                if j > i+1 and nums[j] == nums[j-1]:\n                    continue\n                l = j+1\n                r = len(nums)-1\n                while l < r:\n                    if nums[i] + nums[j] + nums[l] + nums[r] == target:\n                        res.append([nums[i], nums[j], nums[l], nums[r]])\n                        l += 1\n                        r -= 1\n                        while l < r and nums[l] == nums[l-1]:\n                            l += 1\n                        while l < r and nums[r] == nums[r+1]:\n                            r -= 1\n                    elif nums[i] + nums[j] + nums[l] + nums[r] < target:\n                        l += 1\n                    else:\n                        r -= 1\n        return res"}, {"task_id": "4sum", "completion": "class Solution(object):\n    def fourSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-3):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            for j in range(i+1, len(nums)-2):\n                if j > i+1 and nums[j] == nums[j-1]:\n                    continue\n                l = j+1\n                r = len(nums)-1\n                while l < r:\n                    if nums[i] + nums[j] + nums[l] + nums[r] == target:\n                        res.append([nums[i], nums[j], nums[l], nums[r]])\n                        l += 1\n                        r -= 1\n                        while l < r and nums[l] == nums[l-1]:\n                            l += 1\n                        while l < r and nums[r] == nums[r+1]:\n                            r -= 1\n                    elif nums[i] + nums[j] + nums[l] + nums[r] < target:\n                        l += 1\n                    else:\n                        r -= 1\n        return res"}], "the-skyline-problem": [{"task_id": "the-skyline-problem", "completion": "class Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # 1. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u6210\u4e00\u4e2a\u4e2a\u7684\u70b9\uff0c\u6bcf\u4e2a\u70b9\u6709\u4e24\u4e2a\u5c5e\u6027\uff0c\u4e00\u4e2a\u662fx\u5750\u6807\uff0c\u4e00\u4e2a\u662fy\u5750\u6807\uff0cy\u5750\u6807\u6709\u6b63\u8d1f\u4e4b\u5206\uff0c\u6b63\u7684\u8868\u793a\u5de6\u8fb9\u7684\u9ad8\u5ea6\uff0c\u8d1f\u7684\u8868\u793a\u53f3\u8fb9\u7684\u9ad8\u5ea6\n        # 2. \u5c06\u6240\u6709\u70b9\u6309\u7167x\u5750\u6807\u6392\u5e8f\n        # 3. \u904d\u5386\u6240\u6709\u70b9\uff0c\u5bf9\u4e8e\u6bcf\u4e2a\u70b9\uff0c\u5982\u679cy\u5750\u6807\u662f\u6b63\u6570\uff0c\u90a3\u4e48\u5c31\u5c06\u8be5\u70b9\u52a0\u5165\u5230\u5806\u4e2d\uff0c\u5982\u679cy\u5750\u6807\u662f\u8d1f\u6570\uff0c\u90a3\u4e48\u5c31\u5c06\u8be5\u70b9\u4ece\u5806\u4e2d\u79fb\u9664\n        # 4. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u53d1\u751f\u4e86\u53d8\u5316\uff0c\u90a3\u4e48\u5c31\u5c06\u8be5\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 5. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u6ca1\u6709\u53d1\u751f\u53d8\u5316\uff0c\u90a3\u4e48\u5c31\u5c06\u8be5\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 6. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u6ca1\u6709\u53d1\u751f\u53d8\u5316\uff0c\u90a3\u4e48\u5c31\u5c06\u8be5\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 7. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u6ca1\u6709\u53d1\u751f\u53d8\u5316\uff0c\u90a3\u4e48\u5c31\u5c06\u8be5\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 8. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u6ca1\u6709\u53d1\u751f\u53d8\u5316\uff0c\u90a3\u4e48\u5c31\u5c06\u8be5\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 9. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u6ca1\u6709\u53d1\u751f\u53d8\u5316\uff0c\u90a3\u4e48\u5c31\u5c06\u8be5\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 10. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u6ca1\u6709\u53d1\u751f\u53d8\u5316\uff0c\u90a3\u4e48\u5c31\u5c06\u8be5\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 11. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u6ca1\u6709\u53d1\u751f\u53d8\u5316\uff0c\u90a3\u4e48\u5c31\u5c06\u8be5\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 12. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u6ca1\u6709\u53d1\u751f\u53d8\u5316\uff0c\u90a3\u4e48\u5c31\u5c06\u8be5\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 13. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u6ca1\u6709\u53d1\u751f\u53d8\u5316\uff0c\u90a3\u4e48\u5c31\u5c06\u8be5\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 14. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u6ca1\u6709\u53d1\u751f\u53d8\u5316\uff0c\u90a3\u4e48\u5c31\u5c06\u8be5\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 15. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u6ca1\u6709\u53d1\u751f\u53d8\u5316\uff0c\u90a3\u4e48\u5c31\u5c06\u8be5\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 16. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u6ca1\u6709\u53d1\u751f\u53d8\u5316\uff0c\u90a3\u4e48\u5c31\u5c06\u8be5\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 17. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u6ca1\u6709\u53d1\u751f\u53d8\u5316\uff0c\u90a3\u4e48\u5c31\u5c06\u8be5\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 18. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u6ca1\u6709\u53d1\u751f\u53d8\u5316\uff0c\u90a3\u4e48\u5c31\u5c06\u8be5\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 19. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u6ca1\u6709\u53d1\u751f\u53d8\u5316\uff0c\u90a3\u4e48\u5c31\u5c06\u8be5\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 20. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u6ca1\u6709\u53d1\u751f\u53d8\u5316\uff0c\u90a3\u4e48\u5c31\u5c06\u8be5\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 21. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u6ca1\u6709\u53d1\u751f\u53d8\u5316\uff0c\u90a3\u4e48\u5c31\u5c06\u8be5\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 22. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u6ca1\u6709\u53d1\u751f\u53d8\u5316\uff0c\u90a3\u4e48\u5c31\u5c06\u8be5\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 23. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u6ca1\u6709\u53d1\u751f\u53d8\u5316\uff0c\u90a3\u4e48\u5c31\u5c06\u8be5\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 24. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u6ca1\u6709\u53d1\u751f\u53d8\u5316\uff0c\u90a3\u4e48\u5c31\u5c06\u8be5\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 25. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u6ca1\u6709\u53d1\u751f\u53d8\u5316\uff0c\u90a3\u4e48\u5c31\u5c06\u8be5\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 26. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u6ca1\u6709\u53d1\u751f\u53d8\u5316\uff0c\u90a3\u4e48\u5c31\u5c06\u8be5\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 27. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u6ca1\u6709\u53d1\u751f\u53d8\u5316\uff0c\u90a3\u4e48\u5c31\u5c06\u8be5\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 28. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u6ca1\u6709\u53d1\u751f\u53d8\u5316\uff0c\u90a3\u4e48\u5c31\u5c06\u8be5\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 29. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u6ca1\u6709\u53d1\u751f\u53d8\u5316\uff0c\u90a3\u4e48\u5c31\u5c06\u8be5\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 30. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u6ca1\u6709\u53d1\u751f\u53d8\u5316\uff0c\u90a3\u4e48\u5c31\u5c06\u8be5\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 31. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u6ca1\u6709\u53d1\u751f\u53d8\u5316\uff0c\u90a3\u4e48\u5c31\u5c06\u8be5\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 32. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u6ca1\u6709\u53d1\u751f\u53d8\u5316\uff0c\u90a3\u4e48\u5c31\u5c06\u8be5\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 33. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u6ca1\u6709\u53d1\u751f\u53d8\u5316\uff0c\u90a3\u4e48\u5c31\u5c06\u8be5\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 34. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u6ca1\u6709\u53d1\u751f\u53d8\u5316\uff0c\u90a3\u4e48\u5c31\u5c06\u8be5\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 35. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u6ca1\u6709\u53d1\u751f\u53d8\u5316\uff0c\u90a3\u4e48\u5c31\u5c06\u8be5\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 36. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u6ca1\u6709\u53d1\u751f\u53d8\u5316\uff0c\u90a3\u4e48\u5c31\u5c06\u8be5\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 37. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u6ca1\u6709\u53d1\u751f\u53d8\u5316\uff0c\u90a3\u4e48\u5c31\u5c06\u8be5\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 38. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u6ca1\u6709\u53d1\u751f\u53d8\u5316\uff0c\u90a3\u4e48"}, {"task_id": "the-skyline-problem", "completion": "class Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # 1. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u4e3a\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u5de6\u8fb9\u754c\uff0c\u53f3\u8fb9\u4e3a\u53f3\u8fb9\u754c\n        # 2. \u5c06\u6240\u6709\u5de6\u8fb9\u754c\u548c\u53f3\u8fb9\u754c\u653e\u5165\u4e00\u4e2a\u5217\u8868\u4e2d\uff0c\u5e76\u6309\u7167x\u5750\u6807\u6392\u5e8f\n        # 3. \u904d\u5386\u5217\u8868\uff0c\u5982\u679c\u5f53\u524d\u5143\u7d20\u662f\u5de6\u8fb9\u754c\uff0c\u5219\u5c06\u9ad8\u5ea6\u52a0\u5165\u5806\u4e2d\uff0c\u5982\u679c\u5f53\u524d\u5143\u7d20\u662f\u53f3\u8fb9\u754c\uff0c\u5219\u5c06\u9ad8\u5ea6\u4ece\u5806\u4e2d\u79fb\u9664\n        # 4. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u9ad8\u5ea6\u53d1\u751f\u53d8\u5316\uff0c\u5219\u5c06\u5f53\u524dx\u5750\u6807\u548c\u6700\u5927\u9ad8\u5ea6\u52a0\u5165\u7ed3\u679c\u5217\u8868\u4e2d\n        # 5. \u8fd4\u56de\u7ed3\u679c\u5217\u8868\n        \n        # \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u4e3a\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u5de6\u8fb9\u754c\uff0c\u53f3\u8fb9\u4e3a\u53f3\u8fb9\u754c\n        lefts, rights = [], []\n        for left, right, height in buildings:\n            lefts.append((left, height, right))\n            rights.append((right, height, left))\n        \n        # \u5c06\u6240\u6709\u5de6\u8fb9\u754c\u548c\u53f3\u8fb9\u754c\u653e\u5165\u4e00\u4e2a\u5217\u8868\u4e2d\uff0c\u5e76\u6309\u7167x\u5750\u6807\u6392\u5e8f\n        boundaries = sorted(list(set(lefts + rights)))\n        \n        # \u904d\u5386\u5217\u8868\uff0c\u5982\u679c\u5f53\u524d\u5143\u7d20\u662f\u5de6\u8fb9\u754c\uff0c\u5219\u5c06\u9ad8\u5ea6\u52a0\u5165\u5806\u4e2d\uff0c\u5982\u679c\u5f53\u524d\u5143\u7d20\u662f\u53f3\u8fb9\u754c\uff0c\u5219\u5c06\u9ad8\u5ea6\u4ece\u5806\u4e2d\u79fb\u9664\n        # \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u9ad8\u5ea6\u53d1\u751f\u53d8\u5316\uff0c\u5219\u5c06\u5f53\u524dx\u5750\u6807\u548c\u6700\u5927\u9ad8\u5ea6\u52a0\u5165\u7ed3\u679c\u5217\u8868\u4e2d\n        # \u8fd4\u56de\u7ed3\u679c\u5217\u8868\n        ans = []\n        heap = [0]\n        for x, height, isLeft in boundaries:\n            if isLeft:\n                heapq.heappush(heap, -height)\n            else:\n                heap.remove(-height)\n                heapq\n            if heap[-1] != heap[0]:\n                ans.append([x, -heap[0]])\n        return ans"}, {"task_id": "the-skyline-problem", "completion": "class Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # 1. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u6210\u4e00\u4e2a\u4e2a\u7684\u70b9\uff0c\u6bcf\u4e2a\u70b9\u6709\u4e24\u4e2a\u5c5e\u6027\uff0c\u4e00\u4e2a\u662fx\u5750\u6807\uff0c\u4e00\u4e2a\u662fy\u5750\u6807\uff0cy\u5750\u6807\u6709\u6b63\u8d1f\u4e4b\u5206\uff0c\u6b63\u7684\u8868\u793a\u5de6\u8fb9\uff0c\u8d1f\u7684\u8868\u793a\u53f3\u8fb9\n        # 2. \u5c06\u6240\u6709\u70b9\u6309\u7167x\u5750\u6807\u6392\u5e8f\n        # 3. \u904d\u5386\u6240\u6709\u70b9\uff0c\u5982\u679c\u5f53\u524d\u70b9\u662f\u5de6\u8fb9\uff0c\u90a3\u4e48\u5c31\u5c06\u5f53\u524d\u70b9\u52a0\u5165\u5230\u5806\u4e2d\uff0c\u5982\u679c\u5f53\u524d\u70b9\u662f\u53f3\u8fb9\uff0c\u90a3\u4e48\u5c31\u5c06\u5f53\u524d\u70b9\u4ece\u5806\u4e2d\u79fb\u9664\n        # 4. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u53d1\u751f\u4e86\u53d8\u5316\uff0c\u90a3\u4e48\u5c31\u5c06\u5f53\u524d\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 5. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u6ca1\u6709\u53d1\u751f\u53d8\u5316\uff0c\u90a3\u4e48\u5c31\u5c06\u5f53\u524d\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 6. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u6ca1\u6709\u53d1\u751f\u53d8\u5316\uff0c\u90a3\u4e48\u5c31\u5c06\u5f53\u524d\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 7. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u6ca1\u6709\u53d1\u751f\u53d8\u5316\uff0c\u90a3\u4e48\u5c31\u5c06\u5f53\u524d\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 8. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u6ca1\u6709\u53d1\u751f\u53d8\u5316\uff0c\u90a3\u4e48\u5c31\u5c06\u5f53\u524d\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 9. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u6ca1\u6709\u53d1\u751f\u53d8\u5316\uff0c\u90a3\u4e48\u5c31\u5c06\u5f53\u524d\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 10. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u6ca1\u6709\u53d1\u751f\u53d8\u5316\uff0c\u90a3\u4e48\u5c31\u5c06\u5f53\u524d\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 11. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u6ca1\u6709\u53d1\u751f\u53d8\u5316\uff0c\u90a3\u4e48\u5c31\u5c06\u5f53\u524d\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 12. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u6ca1\u6709\u53d1\u751f\u53d8\u5316\uff0c\u90a3\u4e48\u5c31\u5c06\u5f53\u524d\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 13. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u6ca1\u6709\u53d1\u751f\u53d8\u5316\uff0c\u90a3\u4e48\u5c31\u5c06\u5f53\u524d\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 14. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u6ca1\u6709\u53d1\u751f\u53d8\u5316\uff0c\u90a3\u4e48\u5c31\u5c06\u5f53\u524d\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 15. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u6ca1\u6709\u53d1\u751f\u53d8\u5316\uff0c\u90a3\u4e48\u5c31\u5c06\u5f53\u524d\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 16. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u6ca1\u6709\u53d1\u751f\u53d8\u5316\uff0c\u90a3\u4e48\u5c31\u5c06\u5f53\u524d\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 17. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u6ca1\u6709\u53d1\u751f\u53d8\u5316\uff0c\u90a3\u4e48\u5c31\u5c06\u5f53\u524d\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 18. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u6ca1\u6709\u53d1\u751f\u53d8\u5316\uff0c\u90a3\u4e48\u5c31\u5c06\u5f53\u524d\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 19. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u6ca1\u6709\u53d1\u751f\u53d8\u5316\uff0c\u90a3\u4e48\u5c31\u5c06\u5f53\u524d\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 20. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u6ca1\u6709\u53d1\u751f\u53d8\u5316\uff0c\u90a3\u4e48\u5c31\u5c06\u5f53\u524d\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 21. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u6ca1\u6709\u53d1\u751f\u53d8\u5316\uff0c\u90a3\u4e48\u5c31\u5c06\u5f53\u524d\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 22. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u6ca1\u6709\u53d1\u751f\u53d8\u5316\uff0c\u90a3\u4e48\u5c31\u5c06\u5f53\u524d\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 23. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u6ca1\u6709\u53d1\u751f\u53d8\u5316\uff0c\u90a3\u4e48\u5c31\u5c06\u5f53\u524d\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 24. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u6ca1\u6709\u53d1\u751f\u53d8\u5316\uff0c\u90a3\u4e48\u5c31\u5c06\u5f53\u524d\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 25. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u6ca1\u6709\u53d1\u751f\u53d8\u5316\uff0c\u90a3\u4e48\u5c31\u5c06\u5f53\u524d\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 26. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u6ca1\u6709\u53d1\u751f\u53d8\u5316\uff0c\u90a3\u4e48\u5c31\u5c06\u5f53\u524d\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 27. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u6ca1\u6709\u53d1\u751f\u53d8\u5316\uff0c\u90a3\u4e48\u5c31\u5c06\u5f53\u524d\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 28. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u6ca1\u6709\u53d1\u751f\u53d8\u5316\uff0c\u90a3\u4e48\u5c31\u5c06\u5f53\u524d\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 29. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u6ca1\u6709\u53d1\u751f\u53d8\u5316\uff0c\u90a3\u4e48\u5c31\u5c06\u5f53\u524d\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 30. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u6ca1\u6709\u53d1\u751f\u53d8\u5316\uff0c\u90a3\u4e48\u5c31\u5c06\u5f53\u524d\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 31. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u6ca1\u6709\u53d1\u751f\u53d8\u5316\uff0c\u90a3\u4e48\u5c31\u5c06\u5f53\u524d\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 32. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u6ca1\u6709\u53d1\u751f\u53d8\u5316\uff0c\u90a3\u4e48\u5c31\u5c06\u5f53\u524d\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 33. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u6ca1\u6709\u53d1\u751f\u53d8\u5316\uff0c\u90a3\u4e48\u5c31\u5c06\u5f53\u524d\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 34. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u6ca1\u6709\u53d1\u751f\u53d8\u5316\uff0c\u90a3\u4e48\u5c31\u5c06\u5f53\u524d\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 35. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u6ca1\u6709\u53d1\u751f\u53d8\u5316\uff0c\u90a3\u4e48\u5c31\u5c06\u5f53\u524d\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 36. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u6ca1\u6709\u53d1\u751f\u53d8\u5316\uff0c\u90a3\u4e48\u5c31\u5c06\u5f53\u524d\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 37. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u6ca1\u6709\u53d1\u751f\u53d8\u5316\uff0c\u90a3\u4e48\u5c31\u5c06\u5f53\u524d\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 38. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u6ca1\u6709\u53d1\u751f\u53d8\u5316\uff0c\u90a3\u4e48\u5c31\u5c06\u5f53\u524d\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d"}, {"task_id": "the-skyline-problem", "completion": "class Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # 1. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u4e3a\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u5de6\u8fb9\u754c\uff0c\u53f3\u8fb9\u4e3a\u53f3\u8fb9\u754c\n        # 2. \u5c06\u6240\u6709\u5de6\u8fb9\u754c\u548c\u53f3\u8fb9\u754c\u653e\u5165\u4e00\u4e2a\u5217\u8868\u4e2d\uff0c\u5e76\u6309\u7167x\u5750\u6807\u6392\u5e8f\n        # 3. \u904d\u5386\u5217\u8868\uff0c\u5982\u679c\u5f53\u524d\u5143\u7d20\u662f\u5de6\u8fb9\u754c\uff0c\u5219\u5c06\u9ad8\u5ea6\u52a0\u5165\u5806\u4e2d\uff0c\u5982\u679c\u5f53\u524d\u5143\u7d20\u662f\u53f3\u8fb9\u754c\uff0c\u5219\u5c06\u9ad8\u5ea6\u4ece\u5806\u4e2d\u79fb\u9664\n        # 4. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u9ad8\u5ea6\u53d1\u751f\u53d8\u5316\uff0c\u5219\u5c06\u5f53\u524dx\u5750\u6807\u548c\u6700\u5927\u9ad8\u5ea6\u52a0\u5165\u7ed3\u679c\u5217\u8868\n        # 5. \u5982\u679c\u5806\u4e3a\u7a7a\uff0c\u5219\u5c06\u5f53\u524dx\u5750\u6807\u548c\u9ad8\u5ea60\u52a0\u5165\u7ed3\u679c\u5217\u8868\n        \n        # 1. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u4e3a\u5de6\u53f3\u4e24\u90e8\u5206\uff0c\u5de6\u8fb9\u4e3a\u5de6\u8fb9\u754c\uff0c\u53f3\u8fb9\u4e3a\u53f3\u8fb9\u754c\n        lefts, rights = [], []\n        for left, right, height in buildings:\n            lefts.append((left, height, right))\n            rights.append((right, height, left))\n        \n        # 2. \u5c06\u6240\u6709\u5de6\u8fb9\u754c\u548c\u53f3\u8fb9\u754c\u653e\u5165\u4e00\u4e2a\u5217\u8868\u4e2d\uff0c\u5e76\u6309\u7167x\u5750\u6807\u6392\u5e8f\n        boundaries = sorted(list(set(lefts + rights)))\n        \n        # 3. \u904d\u5386\u5217\u8868\uff0c\u5982\u679c\u5f53\u524d\u5143\u7d20\u662f\u5de6\u8fb9\u754c\uff0c\u5219\u5c06\u9ad8\u5ea6\u52a0\u5165\u5806\u4e2d\uff0c\u5982\u679c\u5f53\u524d\u5143\u7d20\u662f\u53f3\u8fb9\u754c\uff0c\u5219\u5c06\u9ad8\u5ea6\u4ece\u5806\u4e2d\u79fb\u9664\n        # 4. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u9ad8\u5ea6\u53d1\u751f\u53d8\u5316\uff0c\u5219\u5c06\u5f53\u524dx\u5750\u6807\u548c\u6700\u5927\u9ad8\u5ea6\u52a0\u5165\u7ed3\u679c\u5217\u8868\n        # 5. \u5982\u679c\u5806\u4e3a\u7a7a\uff0c\u5219\u5c06\u5f53\u524dx\u5750\u6807\u548c\u9ad8\u5ea60\u52a0\u5165\u7ed3\u679c\u5217\u8868\n        ans = []\n        heap = [0]\n        for x, height, isLeft in boundaries:\n            if isLeft:\n                heapq.heappush(heap, -height)\n            else:\n                heap.remove(-height)\n                heapq\n            if heap[-1] != heap[0]:\n                ans.append([x, -heap[0]])\n            else:\n                ans.append([x, 0])\n        return ans"}, {"task_id": "the-skyline-problem", "completion": "class Solution(object):\n    def getSkyline(self, buildings):\n        \"\"\"\n        :type buildings: List[List[int]]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # 1. \u5c06\u6240\u6709\u5efa\u7b51\u7269\u62c6\u5206\u6210\u4e00\u4e2a\u4e2a\u7684\u70b9\uff0c\u6bcf\u4e2a\u70b9\u6709\u4e24\u4e2a\u5c5e\u6027\uff0c\u4e00\u4e2a\u662fx\u5750\u6807\uff0c\u4e00\u4e2a\u662fy\u5750\u6807\uff0cy\u5750\u6807\u6709\u6b63\u8d1f\u4e4b\u5206\uff0c\u6b63\u7684\u8868\u793a\u5de6\u8fb9\u7684\u9ad8\u5ea6\uff0c\u8d1f\u7684\u8868\u793a\u53f3\u8fb9\u7684\u9ad8\u5ea6\n        # 2. \u5c06\u6240\u6709\u70b9\u6309\u7167x\u5750\u6807\u6392\u5e8f\n        # 3. \u904d\u5386\u6240\u6709\u70b9\uff0c\u5bf9\u4e8e\u6bcf\u4e2a\u70b9\uff0c\u5982\u679cy\u5750\u6807\u4e3a\u6b63\uff0c\u5219\u5c06\u8be5\u70b9\u52a0\u5165\u5230\u5806\u4e2d\uff0c\u5982\u679cy\u5750\u6807\u4e3a\u8d1f\uff0c\u5219\u5c06\u8be5\u70b9\u4ece\u5806\u4e2d\u79fb\u9664\n        # 4. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u53d1\u751f\u53d8\u5316\uff0c\u5219\u5c06\u8be5\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 5. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u4e0d\u53d1\u751f\u53d8\u5316\uff0c\u5219\u5c06\u8be5\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 6. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u53d1\u751f\u53d8\u5316\uff0c\u5219\u5c06\u8be5\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 7. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u4e0d\u53d1\u751f\u53d8\u5316\uff0c\u5219\u5c06\u8be5\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 8. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u53d1\u751f\u53d8\u5316\uff0c\u5219\u5c06\u8be5\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 9. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u4e0d\u53d1\u751f\u53d8\u5316\uff0c\u5219\u5c06\u8be5\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 10. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u53d1\u751f\u53d8\u5316\uff0c\u5219\u5c06\u8be5\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 11. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u4e0d\u53d1\u751f\u53d8\u5316\uff0c\u5219\u5c06\u8be5\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 12. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u53d1\u751f\u53d8\u5316\uff0c\u5219\u5c06\u8be5\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 13. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u4e0d\u53d1\u751f\u53d8\u5316\uff0c\u5219\u5c06\u8be5\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 14. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u53d1\u751f\u53d8\u5316\uff0c\u5219\u5c06\u8be5\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 15. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u4e0d\u53d1\u751f\u53d8\u5316\uff0c\u5219\u5c06\u8be5\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 16. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u53d1\u751f\u53d8\u5316\uff0c\u5219\u5c06\u8be5\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 17. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u4e0d\u53d1\u751f\u53d8\u5316\uff0c\u5219\u5c06\u8be5\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 18. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u53d1\u751f\u53d8\u5316\uff0c\u5219\u5c06\u8be5\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 19. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u4e0d\u53d1\u751f\u53d8\u5316\uff0c\u5219\u5c06\u8be5\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 20. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u53d1\u751f\u53d8\u5316\uff0c\u5219\u5c06\u8be5\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 21. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u4e0d\u53d1\u751f\u53d8\u5316\uff0c\u5219\u5c06\u8be5\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 22. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u53d1\u751f\u53d8\u5316\uff0c\u5219\u5c06\u8be5\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 23. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u4e0d\u53d1\u751f\u53d8\u5316\uff0c\u5219\u5c06\u8be5\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 24. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u53d1\u751f\u53d8\u5316\uff0c\u5219\u5c06\u8be5\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 25. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u4e0d\u53d1\u751f\u53d8\u5316\uff0c\u5219\u5c06\u8be5\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 26. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u53d1\u751f\u53d8\u5316\uff0c\u5219\u5c06\u8be5\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 27. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u4e0d\u53d1\u751f\u53d8\u5316\uff0c\u5219\u5c06\u8be5\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 28. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u53d1\u751f\u53d8\u5316\uff0c\u5219\u5c06\u8be5\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 29. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u4e0d\u53d1\u751f\u53d8\u5316\uff0c\u5219\u5c06\u8be5\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 30. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u53d1\u751f\u53d8\u5316\uff0c\u5219\u5c06\u8be5\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 31. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u4e0d\u53d1\u751f\u53d8\u5316\uff0c\u5219\u5c06\u8be5\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 32. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u53d1\u751f\u53d8\u5316\uff0c\u5219\u5c06\u8be5\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 33. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u4e0d\u53d1\u751f\u53d8\u5316\uff0c\u5219\u5c06\u8be5\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 34. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u53d1\u751f\u53d8\u5316\uff0c\u5219\u5c06\u8be5\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 35. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u4e0d\u53d1\u751f\u53d8\u5316\uff0c\u5219\u5c06\u8be5\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 36. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u53d1\u751f\u53d8\u5316\uff0c\u5219\u5c06\u8be5\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 37. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u4e0d\u53d1\u751f\u53d8\u5316\uff0c\u5219\u5c06\u8be5\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 38. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u53d1\u751f\u53d8\u5316\uff0c\u5219\u5c06\u8be5\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 39. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u4e0d\u53d1\u751f\u53d8\u5316\uff0c\u5219\u5c06\u8be5\u70b9\u52a0\u5165\u5230\u7ed3\u679c\u96c6\u4e2d\n        # 40. \u5982\u679c\u5806\u4e2d\u7684\u6700\u5927\u503c\u53d1\u751f\u53d8\u5316\uff0c\u5219\u5c06\u8be5\u70b9\u52a0\u5165\u5230\u7ed3\u679c"}], "reverse-string": [{"task_id": "reverse-string", "completion": "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        \n        # 1. 2 pointer approach\n        # Time: O(n)\n        # Space: O(1)\n        left, right = 0, len(s) - 1\n        while left < right:\n            s[left], s[right] = s[right], s[left]\n            left += 1\n            right -= 1\n        \n        # 2. Recursive approach\n        # Time: O(n)\n        # Space: O(n)\n        def helper(left, right):\n            if left < right:\n                s[left], s[right] = s[right], s[left]\n                helper(left + 1, right - 1)\n        \n        helper(0, len(s) - 1)\n        \n        # 3. Pythonic approach\n        # Time: O(n)\n        # Space: O(n)\n        s.reverse()"}, {"task_id": "reverse-string", "completion": "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        \n        # 1. Two pointers\n        # Time: O(n)\n        # Space: O(1)\n        left, right = 0, len(s) - 1\n        while left < right:\n            s[left], s[right] = s[right], s[left]\n            left += 1\n            right -= 1\n        \n        # 2. Recursion\n        # Time: O(n)\n        # Space: O(n)\n        def helper(left, right):\n            if left < right:\n                s[left], s[right] = s[right], s[left]\n                helper(left + 1, right - 1)\n        \n        helper(0, len(s) - 1)"}, {"task_id": "reverse-string", "completion": "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        \n        # 1. Two pointer approach\n        # Time: O(n)\n        # Space: O(1)\n        left, right = 0, len(s) - 1\n        while left < right:\n            s[left], s[right] = s[right], s[left]\n            left += 1\n            right -= 1\n        \n        # 2. Recursive approach\n        # Time: O(n)\n        # Space: O(n)\n        def helper(left, right):\n            if left < right:\n                s[left], s[right] = s[right], s[left]\n                helper(left + 1, right - 1)\n        \n        helper(0, len(s) - 1)\n        \n        # 3. Pythonic approach\n        # Time: O(n)\n        # Space: O(n)\n        s.reverse()"}, {"task_id": "reverse-string", "completion": "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        \n        # 1. 2 pointer\n        # Time: O(n)\n        # Space: O(1)\n        left, right = 0, len(s) - 1\n        while left < right:\n            s[left], s[right] = s[right], s[left]\n            left += 1\n            right -= 1\n        \n        # 2. Recursion\n        # Time: O(n)\n        # Space: O(n)\n        def helper(left, right):\n            if left < right:\n                s[left], s[right] = s[right], s[left]\n                helper(left + 1, right - 1)\n        \n        helper(0, len(s) - 1)\n        \n        # 3. Pythonic\n        # Time: O(n)\n        # Space: O(1)\n        s.reverse()"}, {"task_id": "reverse-string", "completion": "class Solution(object):\n    def reverseString(self, s):\n        \"\"\"\n        :type s: List[str]\n        :rtype: None Do not return anything, modify s in-place instead.\n        \"\"\"\n        \n        # 1. 2 pointer approach\n        # Time: O(n)\n        # Space: O(1)\n        left, right = 0, len(s) - 1\n        while left < right:\n            s[left], s[right] = s[right], s[left]\n            left += 1\n            right -= 1\n        \n        # 2. Pythonic way\n        # Time: O(n)\n        # Space: O(1)\n        s.reverse()"}], "reverse-linked-list": [{"task_id": "reverse-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # iterative solution\n        # prev = None\n        # curr = head\n        # while curr:\n        #     next_node = curr.next\n        #     curr.next = prev\n        #     prev = curr\n        #     curr = next_node\n        # return prev\n        \n        # recursive solution\n        if not head or not head.next:\n            return head\n        p = self.reverseList(head.next)\n        head.next.next = head\n        head.next = None\n        return p"}, {"task_id": "reverse-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # 1. Iterative\n        # prev = None\n        # curr = head\n        # while curr:\n        #     temp = curr.next\n        #     curr.next = prev\n        #     prev = curr\n        #     curr = temp\n        # return prev\n        \n        # 2. Recursive\n        if not head or not head.next:\n            return head\n        p = self.reverseList(head.next)\n        head.next.next = head\n        head.next = None\n        return p"}, {"task_id": "reverse-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # 1. Iterative\n        # prev = None\n        # curr = head\n        # while curr:\n        #     next_node = curr.next\n        #     curr.next = prev\n        #     prev = curr\n        #     curr = next_node\n        # return prev\n        \n        # 2. Recursive\n        if not head or not head.next:\n            return head\n        p = self.reverseList(head.next)\n        head.next.next = head\n        head.next = None\n        return p"}, {"task_id": "reverse-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # iterative\n        # prev = None\n        # curr = head\n        # while curr:\n        #     next_node = curr.next\n        #     curr.next = prev\n        #     prev = curr\n        #     curr = next_node\n        # return prev\n        \n        # recursive\n        if not head or not head.next:\n            return head\n        p = self.reverseList(head.next)\n        head.next.next = head\n        head.next = None\n        return p"}, {"task_id": "reverse-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # iterative solution\n        # if head is None:\n        #     return None\n        # prev = None\n        # curr = head\n        # while curr:\n        #     next_node = curr.next\n        #     curr.next = prev\n        #     prev = curr\n        #     curr = next_node\n        # return prev\n        \n        # recursive solution\n        if head is None or head.next is None:\n            return head\n        p = self.reverseList(head.next)\n        head.next.next = head\n        head.next = None\n        return p"}], "triangle": [{"task_id": "triangle", "completion": "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # DP\n        # Time: O(n^2)\n        # Space: O(n)\n        \n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        \n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        # DP[i] = min"}, {"task_id": "triangle", "completion": "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # 1. DP\n        # Time: O(n^2)\n        # Space: O(n)\n        # 2. DP\n        # Time: O(n^2)\n        # Space: O(1)\n        # 3. DP\n        # Time: O(n^2)\n        # Space: O(n)\n        # 4. DP\n        # Time: O(n^2)\n        # Space: O(n)\n        # 5. DP\n        # Time: O(n^2)\n        # Space: O(n)\n        # 6. DP\n        # Time: O(n^2)\n        # Space: O(n)\n        # 7. DP\n        # Time: O(n^2)\n        # Space: O(n)\n        # 8. DP\n        # Time: O(n^2)\n        # Space: O(n)\n        # 9. DP\n        # Time: O(n^2)\n        # Space: O(n)\n        # 10. DP\n        # Time: O(n^2)\n        # Space: O(n)\n        # 11. DP\n        # Time: O(n^2)\n        # Space: O(n)\n        # 12. DP\n        # Time: O(n^2)\n        # Space: O(n)\n        # 13. DP\n        # Time: O(n^2)\n        # Space: O(n)\n        # 14. DP\n        # Time: O(n^2)\n        # Space: O(n)\n        # 15. DP\n        # Time: O(n^2)\n        # Space: O(n)\n        # 16. DP\n        # Time: O(n^2)\n        # Space: O(n)\n        # 17. DP\n        # Time: O(n^2)\n        # Space: O(n)\n        # 18. DP\n        # Time: O(n^2)\n        # Space: O(n)\n        # 19. DP\n        # Time: O(n^2)\n        # Space: O(n)\n        # 20. DP\n        # Time: O(n^2)\n        # Space: O(n)\n        # 21. DP\n        # Time: O(n^2)\n        # Space: O(n)\n        # 22. DP\n        # Time: O(n^2)\n        # Space: O(n)\n        # 23. DP\n        # Time: O(n^2)\n        # Space: O(n)\n        # 24. DP\n        # Time: O(n^2)\n        # Space: O(n)\n        # 25. DP\n        # Time: O(n^2)\n        # Space: O(n)\n        # 26. DP\n        # Time: O(n^2)\n        # Space: O(n)\n        # 27. DP\n        # Time: O(n^2)\n        # Space: O(n)\n        # 28. DP\n        # Time: O(n^2)\n        # Space: O(n)\n        # 29. DP\n        # Time: O(n^2)\n        # Space: O(n)\n        # 30. DP\n        # Time: O(n^2)\n        # Space: O(n)\n        # 31. DP\n        # Time: O(n^2)\n        # Space: O(n)\n        # 32. DP\n        # Time: O(n^2)\n        # Space: O(n)\n        # 33. DP\n        # Time: O(n^2)\n        # Space: O(n)\n        # 34. DP\n        # Time: O(n^2)\n        # Space: O(n)\n        # 35. DP\n        # Time: O(n^2)\n        # Space: O(n)\n        # 36. DP\n        # Time: O(n^2"}, {"task_id": "triangle", "completion": "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # DP solution\n        # Time: O(n^2)\n        # Space: O(n)\n        \n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        \n        # DP[0] = triangle[0][0]\n        \n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        \n        # DP[0] = triangle[0][0]\n        \n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        \n        # DP[0] = triangle[0][0]\n        \n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        \n        # DP[0] = triangle[0][0]\n        \n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        \n        # DP[0] = triangle[0][0]\n        \n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        \n        # DP[0] = triangle[0][0]\n        \n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        \n        # DP[0] = triangle[0][0]\n        \n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        \n        # DP[0] = triangle[0][0]\n        \n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        \n        # DP[0] = triangle[0][0]\n        \n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        \n        # DP[0] = triangle[0][0]\n        \n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        \n        # DP[0] = triangle[0][0]\n        \n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        \n        # DP[0] = triangle[0][0]\n        \n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        \n        # DP[0] = triangle[0][0]\n        \n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        \n        # DP[0] = triangle[0][0]\n        \n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        \n        # DP[0] = triangle[0][0]\n        \n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        \n        # DP[0] = triangle[0][0]\n        \n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        \n        # DP[0] = triangle[0][0]\n        \n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        \n        # DP[0] = triangle[0][0]\n        \n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        \n        # DP[0] = triangle[0][0]\n        \n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        \n        # DP[0] = triangle[0][0]\n        \n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        \n        # DP["}, {"task_id": "triangle", "completion": "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # DP solution\n        # Time: O(n^2)\n        # Space: O(n)\n        \n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        \n        # DP[0] = triangle[0][0]\n        \n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        \n        # DP[0] = triangle[0][0]\n        \n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        \n        # DP[0] = triangle[0][0]\n        \n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        \n        # DP[0] = triangle[0][0]\n        \n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        \n        # DP[0] = triangle[0][0]\n        \n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        \n        # DP[0] = triangle[0][0]\n        \n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        \n        # DP[0] = triangle[0][0]\n        \n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        \n        # DP[0] = triangle[0][0]\n        \n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        \n        # DP[0] = triangle[0][0]\n        \n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        \n        # DP[0] = triangle[0][0]\n        \n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        \n        # DP[0] = triangle[0][0]\n        \n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        \n        # DP[0] = triangle[0][0]\n        \n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        \n        # DP[0] = triangle[0][0]\n        \n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        \n        # DP[0] = triangle[0][0]\n        \n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        \n        # DP[0] = triangle[0][0]\n        \n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        \n        # DP[0] = triangle[0][0]\n        \n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        \n        # DP[0] = triangle[0][0]\n        \n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        \n        # DP[0] = triangle[0][0]\n        \n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        \n        # DP[0] = triangle[0][0]\n        \n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        \n        # DP[0] = triangle[0][0]\n        \n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        \n        # DP["}, {"task_id": "triangle", "completion": "class Solution(object):\n    def minimumTotal(self, triangle):\n        \"\"\"\n        :type triangle: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # DP\n        # Time: O(n^2)\n        # Space: O(n)\n        \n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        \n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        # DP[i] = min(DP[i-1], DP[i]) + triangle[i][j]\n        # DP[i] = min"}], "integer-to-english-words": [{"task_id": "integer-to-english-words", "completion": "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        def helper(num):\n            if num == 0:\n                return \"\"\n            elif num < 20:\n                return to19[num-1] + \" \"\n            elif num < 100:\n                return tens[num/10-2] + \" \" + helper(num%10)\n            else:\n                return to999[num/100-1] + \" Hundred \" + helper(num%100)\n        \n        to19 = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\n        tens = [\"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n        to999 = [\"One Hundred\", \"Two Hundred\", \"Three Hundred\", \"Four Hundred\", \"Five Hundred\", \"Six Hundred\", \"Seven Hundred\", \"Eight Hundred\", \"Nine Hundred\"]\n        \n        if num == 0:\n            return \"Zero\"\n        res = \"\"\n        i = 0\n        while num > 0:\n            if num % 1000 != 0:\n                res = helper(num%1000) + thousands[i] + \" \" + res\n            num /= 1000\n            i += 1\n        return res.strip()"}, {"task_id": "integer-to-english-words", "completion": "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"Zero\"\n        \n        def helper(num):\n            if num == 0:\n                return \"\"\n            elif num < 20:\n                return one[num] + \" \"\n            elif num < 100:\n                return ten[num // 10] + \" \" + helper(num % 10)\n            else:\n                return helper(num // 1000000000) + \"Billion \" + helper(num // 1000000) + \"Million \" + helper(num // 1000) + \"Thousand \" + helper(num % 1000)\n        \n        one = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\n        ten = [\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n        \n        return helper(num).strip()"}, {"task_id": "integer-to-english-words", "completion": "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        def helper(num):\n            if num == 0:\n                return \"\"\n            elif num < 20:\n                return to19[num-1] + \" \"\n            elif num < 100:\n                return tens[num/10-2] + \" \" + helper(num%10)\n            else:\n                return to999[num/100-1] + \" Hundred \" + helper(num%100)\n        \n        to19 = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\n        tens = [\"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n        to999 = [\"One Hundred\", \"Two Hundred\", \"Three Hundred\", \"Four Hundred\", \"Five Hundred\", \"Six Hundred\", \"Seven Hundred\", \"Eight Hundred\", \"Nine Hundred\"]\n        \n        if num == 0:\n            return \"Zero\"\n        \n        res = \"\"\n        i = 0\n        \n        while num > 0:\n            if num % 1000 != 0:\n                res = helper(num%1000) + thousands[i] + \" \" + res\n            num /= 1000\n            i += 1\n        \n        return res.strip()"}, {"task_id": "integer-to-english-words", "completion": "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        def helper(num):\n            if num == 0:\n                return \"\"\n            elif num < 20:\n                return to19[num-1] + \" \"\n            elif num < 100:\n                return tens[num/10-2] + \" \" + helper(num%10)\n            else:\n                return to999[num/100-1] + \" Hundred \" + helper(num%100)\n        \n        to19 = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\n        tens = [\"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n        to999 = [\"One Hundred\", \"Two Hundred\", \"Three Hundred\", \"Four Hundred\", \"Five Hundred\", \"Six Hundred\", \"Seven Hundred\", \"Eight Hundred\", \"Nine Hundred\"]\n        \n        if num == 0:\n            return \"Zero\"\n        \n        res = \"\"\n        i = 0\n        \n        while num > 0:\n            if num % 1000 != 0:\n                res = helper(num%1000) + thousands[i] + \" \" + res\n            num /= 1000\n            i += 1\n        \n        return res.strip()"}, {"task_id": "integer-to-english-words", "completion": "class Solution(object):\n    def numberToWords(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"Zero\"\n        \n        def helper(num):\n            if num == 0:\n                return \"\"\n            elif num < 20:\n                return one[num] + \" \"\n            elif num < 100:\n                return ten[num // 10] + \" \" + helper(num % 10)\n            else:\n                return helper(num // 1000000000) + \"Billion \" + helper(num // 1000000) + \"Million \" + helper(num // 1000) + \"Thousand \" + helper(num % 1000)\n        \n        one = [\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"]\n        ten = [\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"]\n        \n        return helper(num).strip()"}], "k-inverse-pairs-array": [{"task_id": "k-inverse-pairs-array", "completion": "class Solution(object):\n    def kInversePairs(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i+1]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]"}, {"task_id": "k-inverse-pairs-array", "completion": "class Solution(object):\n    def kInversePairs(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i+1]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]"}, {"task_id": "k-inverse-pairs-array", "completion": "class Solution(object):\n    def kInversePairs(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i+1]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i][j-i]"}, {"task_id": "k-inverse-pairs-array", "completion": "class Solution(object):\n    def kInversePairs(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i+1]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i"}, {"task_id": "k-inverse-pairs-array", "completion": "class Solution(object):\n    def kInversePairs(self, n, k):\n        \"\"\"\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j-2] + ... + dp[i-1][j-i+1]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]\n        # dp[i][j] = dp[i-1][j] + dp[i][j-1] - dp[i-1][j-i]"}], "swap-nodes-in-pairs": [{"task_id": "swap-nodes-in-pairs", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if head == None or head.next == None:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        \n        while curr and curr.next:\n            next_node = curr.next\n            curr.next = next_node.next\n            next_node.next = curr\n            prev.next = next_node\n            prev = curr\n            curr = curr.next\n            \n        return dummy.next"}, {"task_id": "swap-nodes-in-pairs", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if head == None or head.next == None:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        \n        while curr and curr.next:\n            nextNode = curr.next\n            curr.next = nextNode.next\n            nextNode.next = curr\n            prev.next = nextNode\n            prev = curr\n            curr = curr.next\n            \n        return dummy.next"}, {"task_id": "swap-nodes-in-pairs", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if head == None or head.next == None:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        \n        while curr and curr.next:\n            next_node = curr.next\n            curr.next = next_node.next\n            next_node.next = curr\n            prev.next = next_node\n            prev = curr\n            curr = curr.next\n            \n        return dummy.next"}, {"task_id": "swap-nodes-in-pairs", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if head is None or head.next is None:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev, curr = dummy, head\n        \n        while curr and curr.next:\n            first = curr\n            second = curr.next\n            \n            prev.next = second\n            first.next = second.next\n            second.next = first\n            \n            prev = first\n            curr = first.next\n            \n        return dummy.next"}, {"task_id": "swap-nodes-in-pairs", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def swapPairs(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if head == None or head.next == None:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        \n        while curr and curr.next:\n            next_node = curr.next\n            curr.next = next_node.next\n            next_node.next = curr\n            prev.next = next_node\n            prev = curr\n            curr = curr.next\n            \n        return dummy.next"}], "path-sum": [{"task_id": "path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def hasPathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: bool\n        \"\"\"\n        \n        if not root:\n            return False\n        \n        if not root.left and not root.right:\n            return targetSum == root.val\n        \n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - rootval"}, {"task_id": "path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def hasPathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: bool\n        \"\"\"\n        \n        if not root:\n            return False\n        \n        if not root.left and not root.right:\n            return targetSum == root.val\n        \n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val"}, {"task_id": "path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def hasPathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: bool\n        \"\"\"\n        \n        if not root:\n            return False\n        \n        if not root.left and not root.right:\n            return targetSum == root.val\n        \n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - root.val"}, {"task_id": "path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def hasPathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: bool\n        \"\"\"\n        \n        if root == None:\n            return False\n        \n        if root.left == None and root.right == None:\n            return targetSum == root.val\n        \n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - rootval"}, {"task_id": "path-sum", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def hasPathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: bool\n        \"\"\"\n        \n        if root is None:\n            return False\n        \n        if root.left is None and root.right is None:\n            return targetSum == root.val\n        \n        return self.hasPathSum(root.left, targetSum - root.val) or self.hasPathSum(root.right, targetSum - rootval"}], "partition-list": [{"task_id": "partition-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def partition(self, head, x):\n        \"\"\"\n        :type head: ListNode\n        :type x: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # create two dummy nodes\n        dummy1 = ListNode(0)\n        dummy2 = ListNode(0)\n        \n        # create two pointers\n        p1 = dummy1\n        p2 = dummy2\n        \n        # iterate through the linked list\n        while head:\n            # if the value is less than x, append to dummy1\n            if head.val < x:\n                p1.next = head\n                p1 = p1.next\n            # if the value is greater than or equal to x, append to dummy2\n            else:\n                p2.next = head\n                p2 = p2.next\n            # move to the next node\n            head = head.next\n        \n        # set the next of p2 to None\n        p2.next = None\n        \n        # set the next of p1 to the head of dummy2\n        p1.next = dummy2.next\n        \n        # return the head of dummy1\n        return dummy1.next"}, {"task_id": "partition-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def partition(self, head, x):\n        \"\"\"\n        :type head: ListNode\n        :type x: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # create two dummy nodes\n        dummy1 = ListNode(0)\n        dummy2 = ListNode(0)\n        \n        # create two pointers\n        p1 = dummy1\n        p2 = dummy2\n        \n        # iterate through the linked list\n        while head:\n            if head.val < x:\n                p1.next = head\n                p1 = p1.next\n            else:\n                p2.next = head\n                p2 = p2.next\n            head = head.next\n        \n        # connect the two lists\n        p2.next = None\n        p1.next = dummy2.next\n        \n        return dummy1.next"}, {"task_id": "partition-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def partition(self, head, x):\n        \"\"\"\n        :type head: ListNode\n        :type x: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # create two dummy nodes\n        dummy1 = ListNode(0)\n        dummy2 = ListNode(0)\n        \n        # create two pointers\n        p1 = dummy1\n        p2 = dummy2\n        \n        # traverse the linked list\n        while head:\n            if head.val < x:\n                p1.next = head\n                p1 = p1.next\n            else:\n                p2.next = head\n                p2 = p2.next\n            head = head.next\n        \n        # connect the two lists\n        p2.next = None\n        p1.next = dummy2.next\n        \n        return dummy1.next"}, {"task_id": "partition-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def partition(self, head, x):\n        \"\"\"\n        :type head: ListNode\n        :type x: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # create two dummy nodes\n        dummy1 = ListNode(0)\n        dummy2 = ListNode(0)\n        \n        # create two pointers\n        p1 = dummy1\n        p2 = dummy2\n        \n        # traverse the linked list\n        while head:\n            if head.val < x:\n                p1.next = head\n                p1 = p1.next\n            else:\n                p2.next = head\n                p2 = p2.next\n            head = head.next\n        \n        # connect the two lists\n        p2.next = None\n        p1.next = dummy2.next\n        \n        return dummy1.next"}, {"task_id": "partition-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def partition(self, head, x):\n        \"\"\"\n        :type head: ListNode\n        :type x: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # create two dummy nodes\n        dummy1 = ListNode(0)\n        dummy2 = ListNode(0)\n        \n        # create two pointers\n        p1 = dummy1\n        p2 = dummy2\n        \n        # iterate through the linked list\n        while head:\n            # if the value is less than x, add it to the first list\n            if head.val < x:\n                p1.next = head\n                p1 = p1.next\n            # if the value is greater than or equal to x, add it to the second list\n            else:\n                p2.next = head\n                p2 = p2.next\n            # move to the next node\n            head = head.next\n        \n        # set the next of the last node of the first list to the head of the second list\n        p1.next = dummy2.next\n        # set the next of the last node of the second list to None\n        p2.next = None\n        \n        # return the head of the first list\n        return dummy1.next"}], "redundant-connection-ii": [{"task_id": "redundant-connection-ii", "completion": "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. find the node with two parents\n        # 2. find the edge that creates the cycle\n        # 3. return the edge that creates the cycle\n        \n        # 1. find the node with two parents\n        # 2. find the edge that creates the cycle\n        # 3. return the edge that creates the cycle\n        \n        # 1. find the node with two parents\n        # 2. find the edge that creates the cycle\n        # 3. return the edge that creates the cycle\n        \n        # 1. find the node with two parents\n        # 2. find the edge that creates the cycle\n        # 3. return the edge that creates the cycle\n        \n        # 1. find the node with two parents\n        # 2. find the edge that creates the cycle\n        # 3. return the edge that creates the cycle\n        \n        # 1. find the node with two parents\n        # 2. find the edge that creates the cycle\n        # 3. return the edge that creates the cycle\n        \n        # 1. find the node with two parents\n        # 2. find the edge that creates the cycle\n        # 3. return the edge that creates the cycle\n        \n        # 1. find the node with two parents\n        # 2. find the edge that creates the cycle\n        # 3. return the edge that creates the cycle\n        \n        # 1. find the node with two parents\n        # 2. find the edge that creates the cycle\n        # 3. return the edge that creates the cycle\n        \n        # 1. find the node with two parents\n        # 2. find the edge that creates the cycle\n        # 3. return the edge that creates the cycle\n        \n        # 1. find the node with two parents\n        # 2. find the edge that creates the cycle\n        # 3. return the edge that creates the cycle\n        \n        # 1. find the node with two parents\n        # 2. find the edge that creates the cycle\n        # 3. return the edge that creates the cycle\n        \n        # 1. find the node with two parents\n        # 2. find the edge that creates the cycle\n        # 3. return the edge that creates the cycle\n        \n        # 1. find the node with two parents\n        # 2. find the edge that creates the cycle\n        # 3. return the edge that creates the cycle\n        \n        # 1. find the node with two parents\n        # 2. find the edge that creates the cycle\n        # 3. return the edge that creates the cycle\n        \n        # 1. find the node with two parents\n        # 2. find the edge that creates the cycle\n        # 3. return the edge that creates the cycle\n        \n        # 1. find the node with two parents\n        # 2. find the edge that creates the cycle\n        # 3. return the edge that creates the cycle\n        \n        # 1. find the node with two parents\n        # 2. find the edge that creates the cycle\n        # 3. return the edge that creates the cycle\n        \n        # 1. find the node with two parents\n        # 2. find the edge that creates the cycle\n        # 3. return the edge that creates the cycle\n        \n        # 1. find the node with two parents\n        # 2. find the edge that creates the cycle\n        # 3. return the edge that creates the cycle\n        \n        # 1. find the node with two parents\n        # 2. find the edge that creates the cycle\n        # 3. return the edge that creates the cycle\n        \n        # 1. find the node with two parents\n        # 2. find the edge that creates the cycle\n        # 3. return the edge that creates the cycle\n        \n        # 1. find the node with two parents\n        # 2. find the edge that creates the cycle\n        # 3. return the edge that creates the cycle\n        \n        # 1. find the node with two parents\n        # 2. find the edge that creates the cycle\n        # 3. return the edge that creates the cycle\n        \n        # 1. find the node with two parents\n        # 2. find the edge that creates the cycle\n        # 3. return the edge that creates the cycle\n        \n        # 1. find the node with two parents\n        # 2. find the edge that creates the cycle"}, {"task_id": "redundant-connection-ii", "completion": "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        n = len(edges)\n        parent = [i for i in range(n+1)]\n        candA, candB = None, None\n        \n        for u, v in edges:\n            if parent[v] != v:\n                candA = [parent[v], v]\n                candB = [u, v]\n            else:\n                parent[v] = u\n        \n        def find(x):\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n        \n        def union(x, y):\n            parent[find(x)] = find(y)\n        \n        for u, v in edges:\n            if [u, v] == candB:\n                continue\n            if find(u) == find(v):\n                if candA:\n                    return candA\n                else:\n                    return [u, v]\n            union(u, v)\n        \n        return candB"}, {"task_id": "redundant-connection-ii", "completion": "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        n = len(edges)\n        parent = [i for i in range(n+1)]\n        candA, candB = None, None\n        \n        for u, v in edges:\n            if parent[v] != v:\n                candA = [parent[v], v]\n                candB = [u, v]\n            else:\n                parent[v] = u\n        \n        def find(x):\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n        \n        def union(x, y):\n            parent[find(x)] = find(y)\n        \n        for u, v in edges:\n            if [u, v] == candB:\n                continue\n            if find(u) == find(v):\n                if candA:\n                    return candA\n                else:\n                    return [u, v]\n            union(u, v)\n        \n        return candB"}, {"task_id": "redundant-connection-ii", "completion": "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. find the node with two parents\n        # 2. find the edge that creates a cycle\n        # 3. return the edge that creates the cycle\n        \n        # 1. find the node with two parents\n        # 2. find the edge that creates a cycle\n        # 3. return the edge that creates the cycle\n        \n        # 1. find the node with two parents\n        # 2. find the edge that creates a cycle\n        # 3. return the edge that creates the cycle\n        \n        # 1. find the node with two parents\n        # 2. find the edge that creates a cycle\n        # 3. return the edge that creates the cycle\n        \n        # 1. find the node with two parents\n        # 2. find the edge that creates a cycle\n        # 3. return the edge that creates the cycle\n        \n        # 1. find the node with two parents\n        # 2. find the edge that creates a cycle\n        # 3. return the edge that creates the cycle\n        \n        # 1. find the node with two parents\n        # 2. find the edge that creates a cycle\n        # 3. return the edge that creates the cycle\n        \n        # 1. find the node with two parents\n        # 2. find the edge that creates a cycle\n        # 3. return the edge that creates the cycle\n        \n        # 1. find the node with two parents\n        # 2. find the edge that creates a cycle\n        # 3. return the edge that creates the cycle\n        \n        # 1. find the node with two parents\n        # 2. find the edge that creates a cycle\n        # 3. return the edge that creates the cycle\n        \n        # 1. find the node with two parents\n        # 2. find the edge that creates a cycle\n        # 3. return the edge that creates the cycle\n        \n        # 1. find the node with two parents\n        # 2. find the edge that creates a cycle\n        # 3. return the edge that creates the cycle\n        \n        # 1. find the node with two parents\n        # 2. find the edge that creates a cycle\n        # 3. return the edge that creates the cycle\n        \n        # 1. find the node with two parents\n        # 2. find the edge that creates a cycle\n        # 3. return the edge that creates the cycle\n        \n        # 1. find the node with two parents\n        # 2. find the edge that creates a cycle\n        # 3. return the edge that creates the cycle\n        \n        # 1. find the node with two parents\n        # 2. find the edge that creates a cycle\n        # 3. return the edge that creates the cycle\n        \n        # 1. find the node with two parents\n        # 2. find the edge that creates a cycle\n        # 3. return the edge that creates the cycle\n        \n        # 1. find the node with two parents\n        # 2. find the edge that creates a cycle\n        # 3. return the edge that creates the cycle\n        \n        # 1. find the node with two parents\n        # 2. find the edge that creates a cycle\n        # 3. return the edge that creates the cycle\n        \n        # 1. find the node with two parents\n        # 2. find the edge that creates a cycle\n        # 3. return the edge that creates the cycle\n        \n        # 1. find the node with two parents\n        # 2. find the edge that creates a cycle\n        # 3. return the edge that creates the cycle\n        \n        # 1. find the node with two parents\n        # 2. find the edge that creates a cycle\n        # 3. return the edge that creates the cycle\n        \n        # 1. find the node with two parents\n        # 2. find the edge that creates a cycle\n        # 3. return the edge that creates the cycle\n        \n        # 1. find the node with two parents\n        # 2. find the edge that creates a cycle\n        # 3. return the edge that creates the cycle\n        \n        # 1. find the node with two parents\n        # 2. find the edge that creates a cycle\n        # 3. return the edge that creates the cycle\n        \n        # 1. find the node with two parents\n        # 2. find the edge that creates a cycle"}, {"task_id": "redundant-connection-ii", "completion": "class Solution(object):\n    def findRedundantDirectedConnection(self, edges):\n        \"\"\"\n        :type edges: List[List[int]]\n        :rtype: List[int]\n        \"\"\"\n        \n        n = len(edges)\n        parent = [i for i in range(n+1)]\n        candA, candB = None, None\n        \n        for u, v in edges:\n            if parent[v] != v:\n                candA = [parent[v], v]\n                candB = [u, v]\n            else:\n                parent[v] = u\n        \n        def find(x):\n            if parent[x] != x:\n                parent[x] = find(parent[x])\n            return parent[x]\n        \n        def union(x, y):\n            parent[find(x)] = find(y)\n        \n        for u, v in edges:\n            if [u, v] == candB:\n                continue\n            if find(u) == find(v):\n                if candA:\n                    return candA\n                else:\n                    return [u, v]\n            union(u, v)\n        \n        return candB"}], "permutations-ii": [{"task_id": "permutations-ii", "completion": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(nums, path, res):\n            if not nums:\n                res.append(path)\n            for i in range(len(nums)):\n                if i > 0 and nums[i] == nums[i-1]:\n                    continue\n                backtrack(nums[:i] + nums[i+1:], path + [nums[i]], res)\n        \n        res = []\n        backtrack(sorted(nums), [], res)\n        return res"}, {"task_id": "permutations-ii", "completion": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(nums, path, res):\n            if not nums:\n                res.append(path)\n                return\n            for i in range(len(nums)):\n                if i > 0 and nums[i] == nums[i-1]:\n                    continue\n                backtrack(nums[:i]+nums[i+1:], path+[nums[i]], res)\n        \n        res = []\n        backtrack(sorted(nums), [], res)\n        return res"}, {"task_id": "permutations-ii", "completion": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(nums, path, res):\n            if not nums:\n                res.append(path)\n                return\n            for i in range(len(nums)):\n                if i > 0 and nums[i] == nums[i-1]:\n                    continue\n                backtrack(nums[:i]+nums[i+1:], path+[nums[i]], res)\n        \n        res = []\n        backtrack(sorted(nums), [], res)\n        return res"}, {"task_id": "permutations-ii", "completion": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(nums, path, res):\n            if not nums:\n                res.append(path)\n                return\n            for i in range(len(nums)):\n                if i > 0 and nums[i] == nums[i-1]:\n                    continue\n                backtrack(nums[:i]+nums[i+1:], path+[nums[i]], res)\n        \n        res = []\n        backtrack(sorted(nums), [], res)\n        return res"}, {"task_id": "permutations-ii", "completion": "class Solution(object):\n    def permuteUnique(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(nums, path, res):\n            if not nums:\n                res.append(path)\n                return\n            for i in range(len(nums)):\n                if i > 0 and nums[i] == nums[i-1]:\n                    continue\n                backtrack(nums[:i]+nums[i+1:], path+[nums[i]], res)\n        \n        res = []\n        backtrack(sorted(nums), [], res)\n        return res"}], "add-digits": [{"task_id": "add-digits", "completion": "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        if num == 0:\n            return 0\n        else:\n            return (num - 1) % 9 + 1"}, {"task_id": "add-digits", "completion": "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        if num == 0:\n            return 0\n        else:\n            return (num - 1) % 9 + 1"}, {"task_id": "add-digits", "completion": "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        if num == 0:\n            return 0\n        else:\n            return (num - 1) % 9 + 1"}, {"task_id": "add-digits", "completion": "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        if num == 0:\n            return 0\n        else:\n            return (num - 1) % 9 + 1"}, {"task_id": "add-digits", "completion": "class Solution(object):\n    def addDigits(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        while num > 9:\n            num = sum([int(i) for i in str(num)])\n        return num"}], "single-number": [{"task_id": "single-number", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. use set\n        # return (2 * sum(set(nums)) - sum(nums))\n        \n        # 2. use hashmap\n        # hashmap = {}\n        # for num in nums:\n        #     if num in hashmap:\n        #         hashmap[num] += 1\n        #     else:\n       \n        #         hashmap[num] = 1\n        # for key, value in hashmap.items():\n        #     if value == 1:\n        #         return key"}, {"task_id": "single-number", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. use set\n        # return (2 * sum(set(nums)) - sum(nums))\n        \n        # 2. use hashmap\n        # hashmap = {}\n        # for num in nums:\n        #     if num in hashmap:\n        #         hashmap[num] += 1\n        #     else:\n       \n        #         hashmap[num] = 1\n        # for key, value in hashmap.items():\n        #     if value == 1:\n        #         return key"}, {"task_id": "single-number", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. use set\n        # return (2 * sum(set(nums)) - sum(nums))\n        \n        # 2. use hashmap\n        # hashmap = {}\n        # for num in nums:\n        #     if num in hashmap:\n        #         hashmap[num] += 1\n        #     else:\n       \n        #         hashmap[num] = 1\n        # for key, value in hashmap.items():\n        #     if value == 1:\n        #         return key"}, {"task_id": "single-number", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. use set\n        # return (2 * sum(set(nums)) - sum(nums))\n        \n        # 2. use hashmap\n        # hashmap = {}\n        # for num in nums:\n        #     if num in hashmap:\n        #         hashmap[num] += 1\n        #     else:\n       \n        #         hashmap[num] = 1\n        # for key, value in hashmap.items():\n        #     if value == 1:\n        #         return key"}, {"task_id": "single-number", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. use set\n        # return (2 * sum(set(nums)) - sum(nums))\n        \n        # 2. use hashmap\n        # hashmap = {}\n        # for num in nums:\n        #     if num in hashmap:\n        #         hashmap[num] += 1\n        #     else:\n       \n        #         hashmap[num] = 1\n        # for key, value in hashmap.items():\n        #     if value == 1:\n        #         return key\n        # return -1\n        \n        # 3. use bit manipulation\n        # a ^ 0 = a\n        # a ^ a = 0\n        # a ^ b ^ a = b\n        # a ^ b ^ c ^ a = b ^ c\n        # a ^ b ^ c ^ a ^ b ^ c = c\n        # a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c = c ^ a ^ b ^ c ^ a ^ b ^ c = 0\n        # a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ d ^ a ^ b ^ c ^ a ^ b ^ c ^ d = d\n        # a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ d ^ a ^ b ^ c ^ a ^ b ^ c ^ d ^ a ^ b ^ c ^ a ^ b ^ c ^ d = d ^ a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ d ^ a ^ b ^ c ^ a ^ b ^ c ^ d = 0\n        # a ^ b ^ c ^ a ^ b ^ c ^ a ^ b ^ c ^ d ^ a ^ b ^ c ^ a ^ b ^ c ^ d ^ a ^ b ^ c ^ a ^ b ^ c ^ d ^ a ^ b ^ c ^ a ^ b ^ c ^ d ^ a ^ b ^ c ^ a ^ b ^ c ^ d ^ a ^ b ^ c ^ a ^ b ^ c ^ d ^ a ^ b ^ c ^ a ^ b ^ c ^ d ^ a ^ b ^ c ^ a ^ b ^ c ^ d ^ a ^ b ^ c ^ a ^ b ^ c ^ d ^ a ^ b ^ c ^ a ^ b ^ c ^ d ^ a ^ b ^ c ^ a ^ b ^ c ^ d ^ a ^ b ^ c ^ a ^ b ^ c ^ d ^ a ^ b ^ c ^ a ^ b ^ c ^ d ^ a ^ b ^ c ^ a ^ b ^ c ^ d ^ a ^ b ^ c ^ a ^ b ^ c ^ d ^ a ^ b ^ c ^ a ^ b ^ c ^ d ^ a ^ b ^ c ^ a ^ b ^ c ^ d ^ a ^ b ^ c ^ a ^ b ^ c ^ d ^ a ^ b ^ c ^ a ^ b ^ c ^ d ^ a ^ b ^ c ^ a ^ b ^ c ^ d ^ a ^ b ^ c ^ a ^ b ^ c ^ d ^ a ^ b ^ c ^ a ^ b ^ c ^ d ^ a ^ b ^ c ^ a ^ b ^ c ^ d ^ a ^ b ^ c ^ a ^ b ^ c ^ d ^ a ^ b ^ c ^ a ^ b ^ c ^ d ^ a ^ b ^ c ^ a ^ b ^ c ^ d ^ a ^ b ^ c ^ a ^ b ^ c ^ d ^ a ^ b ^ c ^ a ^ b ^ c ^ d ^ a ^ b ^ c ^ a ^ b ^ c ^ d ^ a ^ b ^ c ^ a ^ b ^ c ^ d ^ a ^ b ^ c ^ a ^ b ^ c ^ d ^ a ^ b ^ c ^ a ^ b ^ c ^ d ^ a ^ b ^ c ^ a ^ b ^ c ^ d ^ a ^ b ^ c ^ a ^ b ^ c ^ d ^ a ^ b ^ c ^ a ^ b ^ c ^ d ^ a ^ b ^ c ^ a ^ b ^ c ^ d ^ a ^ b ^ c ^ a ^ b ^ c ^ d ^ a ^ b ^ c ^ a ^ b ^ c ^ d ^ a ^ b ^ c ^ a ^ b ^ c ^ d ^ a ^ b ^ c ^ a ^ b ^ c ^ d ^ a ^ b ^ c ^ a ^ b ^ c ^ d ^ a ^ b ^ c ^ a ^ b ^ c ^ d ^ a ^ b ^ c ^ a ^ b ^ c ^ d ^ a ^ b ^ c ^ a ^ b ^ c ^ d ^ a ^ b ^ c ^ a ^ b ^ c ^ d ^ a ^ b ^ c ^ a ^ b ^ c ^ d ^ a ^ b ^ c ^ a ^ b ^ c"}], "length-of-last-word": [{"task_id": "length-of-last-word", "completion": "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. split the string into a list of words\n        # 2. return the length of the last word\n        # 3. if the last word is empty, return 0\n        # 4. if the last word is a space, return the length of the second to last word\n        # 5. if the last word is a space and the second to last word is empty, return 0\n        # 6. if the last word is a space and the second to last word is a space, return the length of the third to last word\n        # 7. if the last word is a space and the second to last word is a space and the third to last word is empty, return 0\n        # 8. if the last word is a space and the second to last word is a space and the third to last word is a space, return the length of the fourth to last word\n        # 9. if the last word is a space and the second to last word is a space and the third to last word is a space and the fourth to last word is empty, return"}, {"task_id": "length-of-last-word", "completion": "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. split the string into a list of words\n        # 2. return the length of the last word\n        # 3. if the last word is empty, return 0\n        # 4. if the last word is a space, return the length of the second to last word\n        # 5. if the last word is a space and the second to last word is a space, return 0\n        # 6. if the last word is a space and the second to last word is not a space, return the length of the second to last word\n        # 7. if the last word is not a space and the second to last word is a space, return the length of the last word\n        # 8. if the last word is not a space and the second to last word is not a space, return the length of the last word\n        \n        # 1. split the string into a list of words\n        words = s.split()\n        \n        # 2. return the length of the last word\n        return len(words[-1])"}, {"task_id": "length-of-last-word", "completion": "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. split the string into a list of words\n        # 2. return the length of the last word\n        # 3. if the last word is empty, return 0\n        # 4. if the last word is a space, return the length of the second to last word\n        # 5. if the last word is a space and the second to last word is empty, return 0\n        # 6. if the last word is a space and the second to last word is a space, return the length of the third to last word\n        # 7. if the last word is a space and the second to last word is a space and the third to last word is empty, return 0\n        # 8. if the last word is a space and the second to last word is a space and the third to last word is a space, return the length of the fourth to last word\n        # 9. if the last word is a space and the second to last word is a space and the third to last word is a space and the fourth to last word is empty, return"}, {"task_id": "length-of-last-word", "completion": "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. split the string into a list of words\n        # 2. return the length of the last word\n        # 3. if the last word is empty, return 0\n        # 4. if the last word is a space, return the length of the second to last word\n        # 5. if the last word is a space and the second to last word is empty, return 0\n        # 6. if the last word is a space and the second to last word is a space, return the length of the third to last word\n        # 7. if the last word is a space and the second to last word is a space and the third to last word is empty, return 0\n        # 8. if the last word is a space and the second to last word is a space and the third to last word is a space, return the length of the fourth to last word\n        # 9. if the last word is a space and the second to last word is a space and the third to last word is a space and the fourth to last word is empty, return"}, {"task_id": "length-of-last-word", "completion": "class Solution(object):\n    def lengthOfLastWord(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. split the string into a list of words\n        # 2. return the length of the last word\n        # 3. if the last word is empty, return 0\n        # 4. if the last word is a space, return the length of the second to last word\n        # 5. if the last word is a space and the second to last word is a space, return 0\n        # 6. if the last word is a space and the second to last word is not a space, return the length of the second to last word\n        # 7. if the last word is not a space and the second to last word is a space, return the length of the last word\n        # 8. if the last word is not a space and the second to last word is not a space, return the length of the last word\n        \n        # 1. split the string into a list of words\n        words = s.split()\n        \n        # 2. return the length of the last word\n        return len(words[-1])"}], "cherry-pickup": [{"task_id": "cherry-pickup", "completion": "class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        dp = [[[-1] * n for _ in range(n)] for _ in range(n)]\n        dp[0][0][0] = grid[0][0]\n        \n        for k in range(1, 2 * n - 1):\n            for i in range(max(0, k - n + 1), min(n, k + 1)):\n                for j in range(max(0, k - n + 1), min(n, k + 1)):\n                    if grid[i][k - i] == -1 or grid[j][k - j] == -1:\n                        continue\n                    res = dp[i][j][k - 1]\n                    if i > 0:\n                        res = max(res, dp[i - 1][j][k - 1])\n                    if j > 0:\n                        res = max(res, dp[i][j - 1"}, {"task_id": "cherry-pickup", "completion": "class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        dp = [[[0] * n for _ in range(n)] for _ in range(n)]\n        dp[0][0][0] = grid[0][0]\n        for k in range(1, 2 * n - 1):\n            for i in range(max(0, k - n + 1), min(n, k + 1)):\n                j = k - i\n                if grid[i][j] == -1:\n                    continue\n                for i1 in range(max(0, i - 1), min(n, i + 1)):\n                    j1 = j - (i - i1)\n                    if j1 < 0 or j1 >= n or grid[i1][j1] == -1:\n                        continue\n                    dp[i][j][0] = max(dp[i][j][0], dp[i1][j1][0] + grid[i][j])\n                for i1 in range(max(0, i - 1), min(n, i + 1)):\n                    j1 = j - (i - i1)\n                    if j1 < 0 or j1 >= n or grid[i1][j1] == -1:\n                        continue\n                    dp[i][j][1] = max(dp[i][j][1], dp[i1][j1][1] + grid[i][j])\n                for i1 in range(max(0, i - 1), min(n, i + 1)):\n                    j1 = j - (i - i1)\n                    if j1 < 0 or j1 >= n or grid[i1][j1] == -1:\n                        continue\n                    dp[i][j][1] = max(dpdp[i][j][1], dp[i1][j1][0] + grid[i][j])\n        return max(dp[n - 1][n - 1][0], dp[n - 1][n - 1][1])"}, {"task_id": "cherry-pickup", "completion": "class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        dp = [[[0] * n for _ in range(n)] for _ in range(n)]\n        dp[0][0][0] = grid[0][0]\n        \n        for k in range(1, 2 * n - 1):\n            for i in range(max(0, k - n + 1), min(n, k + 1)):\n                j = k - i\n                if grid[i][j] == -1:\n                    continue\n                for i1 in range(max(0, i - 1), min(n, i + 1)):\n                    j1 = j - (i - i1)\n                    if j1 < 0 or j1 >= n or grid[i1][j1] == -1:\n                        continue\n                    dp[i][j][0] = max(dp[i][j][0], dp[i1][j1][0] + grid[i][j])\n                for i1 in range(max(0, i - 1), min(n, i + 1)):\n                    j1 = j - (i - i1)\n                    if j1 < 0 or j1 >= n or grid[i1][j1] == -1:\n                        continue\n                    dp[i][j][1] = max(dp[i][j][1], dp[i1][j1][1] + grid[i][j])\n                for i1 in range(max(0, i - 1), min(n, i + 1)):\n                    j1 = j - (i - i1)\n                    if j1 < 0 or j1 >= n or grid[i1][j1] == -1:\n                        continue\n                    dp[i][j][1] = max(dpdp[i][j][1], dp[i1][j1][0] + grid[i][j])\n        \n        return max(dp[n - 1][n - 1][0], dp[n - 1][n - 1][1])"}, {"task_id": "cherry-pickup", "completion": "class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        dp = [[[0] * n for _ in range(n)] for _ in range(n)]\n        dp[0][0][0] = grid[0][0]\n        \n        for k in range(1, 2 * n - 1):\n            for i in range(max(0, k - n + 1), min(n, k + 1)):\n                j = k - i\n                if grid[i][j] == -1:\n                    continue\n                for i1 in range(i, min(n, i + 2)):\n                    j1 = k - i1\n                    if grid[i1][j1] == -1:\n                        continue\n                    for i2 in range(i, min(n, i + 2)):\n                        j2 = k - i2\n                        if grid[i2][j2] == -1:\n                            continue\n                        res = dp[i1][j1][i2]\n                        if i1 != i2:\n                            res += grid[i1][j1] + grid[i2][j2]\n                        else:\n                            res += grid[i1][j1]\n                        dp[i][j][i1] = max(dp[i][j][i1], res)\n        \n        return dp[n - 1"}, {"task_id": "cherry-pickup", "completion": "class Solution(object):\n    def cherryPickup(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        n = len(grid)\n        dp = [[[0] * n for _ in range(n)] for _ in range(n)]\n        dp[0][0][0] = grid[0][0]\n        \n        for k in range(1, 2 * n - 1):\n            for i in range(max(0, k - n + 1), min(n, k + 1)):\n                j = k - i\n                if grid[i][j] == -1:\n                    continue\n                for i1 in range(max(0, i - 1), min(n, i + 1)):\n                    j1 = j - (i - i1)\n                    if j1 < 0 or j1 >= n or grid[i1][j1] == -1:\n                        continue\n                    dp[i][j][0] = max(dp[i][j][0], dp[i1][j1][0] + grid[i][j])\n                for i1 in range(max(0, i - 1), min(n, i + 1)):\n                    j1 = j - (i - i1)\n                    if j1 < 0 or j1 >= n or grid[i1][j1] == -1:\n                        continue\n                    dp[i][j][1] = max(dp[i][j][1], dp[i1][j1][1] + grid[i][j])\n                for i1 in range(max(0, i - 1), min(n, i + 1)):\n                    j1 = j - (i - i1)\n                    if j1 < 0 or j1 >= n or grid[i1][j1] == -1:\n                        continue\n                    dp[i][j][1] = max(dpdp[i][j][1], dp[i1][j1][0] + grid[i][j])\n        \n        return max(dp[n - 1][n - 1][0], dp[n - 1][n - 1][1])"}], "student-attendance-record-ii": [{"task_id": "student-attendance-record-ii", "completion": "class Solution(object):\n    def checkRecord(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # dp[i][j][k] = dp[i-1][j][k] + dp[i-1][j-1][k] + dp[i-1][j][k-1]\n        # dp[i][j][k] = dp[i-1][j][k] + dp[i-1][j-1][k] + dp[i-1][j][k-1]\n        # dp[i][j][k] = dp[i-1][j][k] + dp[i-1][j-1][k] + dp[i-1][j][k-1] - dp[i-1][j][k-2]\n        # dp[i][j][k] = dp[i-1][j][k] + dp[i-1][j-1][k] + dp[i-1][j][k-1] - dp[i-1][j][k-2] + dp[i-1][j][k-3]\n        # dp[i][j][k] = dp[i-1][j][k] + dp[i-1][j-1][k] + dp[i-1][j][k-1] - dp[i-1][j][k-2] + dp[i-1][j][k-3] - dp[i-1][j][k-4]\n        # dp[i][j][k] = dp[i-1][j][k] + dp[i-1][j-1][k] + dp[i-1][j][k-1] - dp[i-1][j][k-2] + dp[i-1][j][k-3] - dp[i-1][j][k-4] + dp[i-1][j][k-5]\n        # dp[i][j][k] = dp[i-1][j][k] + dp[i-1][j-1][k] + dp[i-1][j][k-1] - dp[i-1][j][k-2] + dp[i-1][j][k-3] - dp[i-1][j][k-4] + dp[i-1][j][k-5] - dp[i-1][j][k-6]\n        # dp[i][j][k] = dp[i-1][j][k] + dp[i-1][j-1][k] + dp[i-1][j][k-1] - dp[i-1][j][k-2] + dp[i-1][j][k-3] - dp[i-1][j][k-4] + dp[i-1][j][k-5] - dp[i-1][j][k-6] + dp[i-1][j][k-7]\n        # dp[i][j][k] = dp[i-1][j][k] + dp[i-1][j-1][k] + dp[i-1][j][k-1] - dp[i-1][j][k-2] + dp[i-1][j][k-3] - dp[i-1][j][k-4] + dp[i-1][j][k-5] - dp[i-1][j][k-6] + dp[i-1][j][k-7] - dp[i-1][j][k-8]\n        # dp[i][j][k] = dp[i-1][j][k] + dp[i-1][j-1][k] + dp[i-1][j][k-1] - dp[i-1][j][k-2] + dp[i-1][j][k-3] - dp[i-1][j][k-4] + dp[i-1][j][k-5] - dp[i-1][j][k-6] + dp[i-1][j][k-7] - dp[i-1][j][k-8] + dp[i-1"}, {"task_id": "student-attendance-record-ii", "completion": "class Solution(object):\n    def checkRecord(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # dp[i][j][k] = dp[i-1][j][k] + dp[i-1][j-1][k] + dp[i-1][j][k-1]\n        # dp[i][j][k] = dp[i-1][j][k] + dp[i-1][j-1][k] + dp[i-1][j][k-1]\n        # dp[i][j][k] = dp[i-1][j][k] + dp[i-1][j-1][k] + dp[i-1][j][k-1] - dp[i-1][j][k-2]\n        # dp[i][j][k] = dp[i-1][j][k] + dp[i-1][j-1][k] + dp[i-1][j][k-1] - dp[i-1][j][k-2] + dp[i-1][j][k-3]\n        # dp[i][j][k] = dp[i-1][j][k] + dp[i-1][j-1][k] + dp[i-1][j][k-1] - dp[i-1][j][k-2] + dp[i-1][j][k-3] - dp[i-1][j][k-4]\n        # dp[i][j][k] = dp[i-1][j][k] + dp[i-1][j-1][k] + dp[i-1][j][k-1] - dp[i-1][j][k-2] + dp[i-1][j][k-3] - dp[i-1][j][k-4] + dp[i-1][j][k-5]\n        # dp[i][j][k] = dp[i-1][j][k] + dp[i-1][j-1][k] + dp[i-1][j][k-1] - dp[i-1][j][k-2] + dp[i-1][j][k-3] - dp[i-1][j][k-4] + dp[i-1][j][k-5] - dp[i-1][j][k-6]\n        # dp[i][j][k] = dp[i-1][j][k] + dp[i-1][j-1][k] + dp[i-1][j][k-1] - dp[i-1][j][k-2] + dp[i-1][j][k-3] - dp[i-1][j][k-4] + dp[i-1][j][k-5] - dp[i-1][j][k-6] + dp[i-1][j][k-7]\n        # dp[i][j][k] = dp[i-1][j][k] + dp[i-1][j-1][k] + dp[i-1][j][k-1] - dp[i-1][j][k-2] + dp[i-1][j][k-3] - dp[i-1][j][k-4] + dp[i-1][j][k-5] - dp[i-1][j][k-6] + dp[i-1][j][k-7] - dp[i-1][j][k-8]\n        # dp[i][j][k] = dp[i-1][j][k] + dp[i-1][j-1][k] + dp[i-1][j][k-1] - dp[i-1][j][k-2] + dp[i-1][j][k-3] - dp[i-1][j][k-4] + dp[i-1][j][k-5] - dp[i-1][j][k-6] + dp[i-1][j][k-7] - dp[i-1][j][k-8] + dp[i-1"}, {"task_id": "student-attendance-record-ii", "completion": "class Solution(object):\n    def checkRecord(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17."}, {"task_id": "student-attendance-record-ii", "completion": "class Solution(object):\n    def checkRecord(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17."}, {"task_id": "student-attendance-record-ii", "completion": "class Solution(object):\n    def checkRecord(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17."}], "happy-number": [{"task_id": "happy-number", "completion": "class Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        def get_next(n):\n            total_sum = 0\n            while n > 0:\n                n, digit = divmod(n, 10)\n                total_sum += digit ** 2\n            return total_sum\n        \n        seen = set()\n        while n != 1 and n not in seen:\n            seen.add(n)\n            n = get_next(n)\n        \n        return n == 1"}, {"task_id": "happy-number", "completion": "class Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        def get_next(n):\n            total_sum = 0\n            while n > 0:\n                n, digit = divmod(n, 10)\n                total_sum += digit ** 2\n            return total_sum\n        \n        seen = set()\n        while n != 1 and n not in seen:\n            seen.add(n)\n            n = get_next(n)\n        \n        return n == 1"}, {"task_id": "happy-number", "completion": "class Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        def get_next(n):\n            total_sum = 0\n            while n > 0:\n                n, digit = divmod(n, 10)\n                total_sum += digit ** 2\n            return total_sum\n        \n        slow_runner = n\n        fast_runner = get_next(n)\n        while fast_runner != 1 and slow_runner != fast_runner:\n            slow_runner = get_next(slow_runner)\n            fast_runner = get_next(get_next(fast_runner))\n        return fast_runner == 1"}, {"task_id": "happy-number", "completion": "class Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        def get_next(n):\n            total_sum = 0\n            while n > 0:\n                n, digit = divmod(n, 10)\n                total_sum += digit ** 2\n            return total_sum\n        \n        seen = set()\n        while n != 1 and n not in seen:\n            seen.add(n)\n            n = get_next(n)\n        \n        return n == 1"}, {"task_id": "happy-number", "completion": "class Solution(object):\n    def isHappy(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        def get_next(n):\n            total_sum = 0\n            while n > 0:\n                n, digit = divmod(n, 10)\n                total_sum += digit ** 2\n            return total_sum\n        \n        slow_runner = n\n        fast_runner = get_next(n)\n        while fast_runner != 1 and slow_runner != fast_runner:\n            slow_runner = get_next(slow_runner)\n            fast_runner = get_next(get_next(fast_runner))\n        return fast_runner == 1"}], "search-insert-position": [{"task_id": "search-insert-position", "completion": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # Binary Search\n        # Time: O(log n)\n        # Space: O(1)\n        \n        left = 0\n        right = len(nums) - 1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return left"}, {"task_id": "search-insert-position", "completion": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # binary search\n        left = 0\n        right = len(nums) - 1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return left"}, {"task_id": "search-insert-position", "completion": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # Binary Search\n        # Time Complexity: O(log n)\n        # Space Complexity: O(1)\n        \n        # Initialize left and right pointers\n        left = 0\n        right = len(nums) - 1\n        \n        # Iterate until left pointer is less than or equal to right pointer\n        while left <= right:\n            # Calculate the middle index\n            mid = (left + right) // 2\n            \n            # If target is found, return the index\n            if nums[mid] == target:\n                return mid\n            \n            # If target is less than the middle element, search the left half\n            elif nums[mid] > target:\n                right = mid - 1\n            \n            # If target is greater than the middle element, search the right half\n            else:\n                left = mid + 1\n        \n        # If target is not found, return the left pointer as the index where it would be inserted\n        return left"}, {"task_id": "search-insert-position", "completion": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # Binary Search\n        # Time Complexity: O(log n)\n        # Space Complexity: O(1)\n        \n        # Initialize left and right pointers\n        left = 0\n        right = len(nums) - 1\n        \n        # Loop until left pointer is less than or equal to right pointer\n        while left <= right:\n            # Calculate the middle index\n            mid = (left + right) // 2\n            \n            # If target is found at middle index, return middle index\n            if nums[mid] == target:\n                return mid\n            \n            # If target is less than middle element, search left half\n            elif nums[mid] > target:\n                right = mid - 1\n            \n            # If target is greater than middle element, search right half\n            else:\n                left = mid + 1\n        \n        # If target is not found, return left pointer as the index where it would be inserted\n        return left"}, {"task_id": "search-insert-position", "completion": "class Solution(object):\n    def searchInsert(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # binary search\n        left = 0\n        right = len(nums) - 1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if nums[mid] == target:\n                return mid\n            elif nums[mid] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return left"}], "jump-game": [{"task_id": "jump-game", "completion": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        ## 1. DP\n        ## Time: O(n^2)\n        ## Space: O(n)\n        ## dp[i] = True if we can reach the end from i\n        ## dp[i] = any(dp[i+1:i+nums[i]+1])\n        ## dp[n-1] = True\n        ## dp[n-2] = dp[n-1] or nums[n-2] >= 1\n        ## dp[n-3] = dp[n-2] or dp[n-1] and nums[n-3] >= 2\n        ## ...\n        ## dp[0] = dp[1] and nums[0] >= 1\n        ## return dp[0]\n        \n        ## 2. Greedy\n        ## Time: O(n)\n        ## Space: O(1)\n        ## max_reachable = max(max_reachable, i + nums[i])\n        ## if max_reachable >= len(nums) - 1:\n        ##     return True\n        ## return False\n        \n        ## 3. Greedy\n        ## Time: O(n)\n        ## Space: O(1)\n        ## max_reachable = nums[0]\n        ## for i in range(1, len(nums)):\n        ##     if max_reachable >= i:\n        ##         max_reachable = max(max_reachable, i + nums[i])\n        ##     if max_reachable >= len(nums) - 1:\n        ##         return True\n        ## return False\n        \n        ## 4. Greedy\n        ## Time: O(n)\n        ## Space: O(1)\n        ## max_reachable = nums[0]\n        ## for i in range(1, len(nums)):\n        ##     if max_reachable >= i:\n        ##         max_reachable = max(max_reachable, i + nums[i])\n        ##     if max_reachable >= len(nums) - 1:\n        ##         return True\n        ## return False\n        \n        ## 5. Greedy\n        ## Time: O(n)\n        ## Space: O(1)\n        ## max_reachable = nums[0]\n        ## for i in range(1, len(nums)):\n        ##     if max_reachable >= i:\n        ##         max_reachable = max(max_reachable, i + nums[i])\n        ##     if max_reachable >= len(nums) - 1:\n        ##         return True\n        ## return False\n        \n        ## 6. Greedy\n        ## Time: O(n)\n        ## Space: O(1)\n        ## max_reachable = nums[0]\n        ## for i in range(1, len(nums)):\n        ##     if max_reachable >= i:\n        ##         max_reachable = max(max_reachable, i + nums[i])\n        ##     if max_reachable >= len(nums) - 1:\n        ##         return True\n        ## return False\n        \n        ## 7. Greedy\n        ## Time: O(n)\n        ## Space: O(1)\n        ## max_reachable = nums[0]\n        ## for i in range(1, len(nums)):\n        ##     if max_reachable >= i:\n        ##         max_reachable = max(max_reachable, i + nums[i])\n        ##     if max_reachable >= len(nums) - 1:\n        ##         return True\n        ## return False\n        \n        ## 8. Greedy\n        ## Time: O(n)\n        ## Space: O(1)\n        ## max_reachable = nums[0]\n        ## for i in range(1, len(nums)):\n        ##     if max_reachable >= i:\n        ##         max_reachable"}, {"task_id": "jump-game", "completion": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        ## 1. DP\n        ## Time: O(n^2)\n        ## Space: O(n)\n        ## dp[i] = True if we can reach the end from i\n        ## dp[i] = any(dp[i+1:i+nums[i]+1])\n        ## dp[n-1] = True\n        ## return dp[0]\n        \n        ## 2. Greedy\n        ## Time: O(n)\n        ## Space: O(1)\n        ## max_reach = max(max_reach, i + nums[i])\n        ## if max_reach >= len(nums) - 1:\n        ##     return True\n        ## return False\n        \n        ## 3. Greedy\n        ## Time: O(n)\n        ## Space: O(1)\n        ## max_reach = nums[0]\n        ## for i in range(1, len(nums)):\n        ##     if max_reach >= i:\n        ##         max_reach = max(max_reach, i + nums[i])\n        ##     if max_reach >= len(nums) - 1:\n        ##         return True\n        ## return False\n        \n        ## 4. Greedy\n        ## Time: O(n)\n        ## Space: O(1)\n        ## max_reach = nums[0]\n        ## for i in range(1, len(nums)):\n        ##     if max_reach >= i:\n        ##         max_reach = max(max_reach, i + nums[i])\n        ##     if max_reach >= len(nums) - 1:\n        ##         return True\n        ## return False\n        \n        ## 5. Greedy\n        ## Time: O(n)\n        ## Space: O(1)\n        ## max_reach = nums[0]\n        ## for i in range(1, len(nums)):\n        ##     if max_reach >= i:\n        ##         max_reach = max(max_reach, i + nums[i])\n        ##     if max_reach >= len(nums) - 1:\n        ##         return True\n        ## return False\n        \n        ## 6. Greedy\n        ## Time: O(n)\n        ## Space: O(1)\n        ## max_reach = nums[0]\n        ## for i in range(1, len(nums)):\n        ##     if max_reach >= i:\n        ##         max_reach = max(max_reach, i + nums[i])\n        ##     if max_reach >= len(nums) - 1:\n        ##         return True\n        ## return False\n        \n        ## 7. Greedy\n        ## Time: O(n)\n        ## Space: O(1)\n        ## max_reach = nums[0]\n        ## for i in range(1, len(nums)):\n        ##     if max_reach >= i:\n        ##         max_reach = max(max_reach, i + nums[i])\n        ##     if max_reach >= len(nums) - 1:\n        ##         return True\n        ## return False\n        \n        ## 8. Greedy\n        ## Time: O(n)\n        ## Space: O(1)\n        ## max_reach = nums[0]\n        ## for i in range(1, len(nums)):\n        ##     if max_reach >= i:\n        ##         max_reach = max(max_reach, i + nums[i])\n        ##     if max_reach >= len(nums) - 1:\n        ##         return True\n        ## return False\n        \n        ## 9. Greedy\n        ## Time: O(n)\n        ## Space: O(1)\n        ## max_reach = nums[0]\n        ## for i in range(1, len(nums)):\n        ##     if max_reach >= i:\n        ##         max"}, {"task_id": "jump-game", "completion": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        ## 1. DP\n        ## Time: O(n^2)\n        ## Space: O(n)\n        ## dp[i] = True if we can reach the end from i\n        ## dp[i] = any(dp[j] for j in range(i+1, i+nums[i]+1))\n        ## dp[0] = True\n        ## dp[-1] = dp[0]\n        ## return dp[0]\n        \n        ## 2. Greedy\n        ## Time: O(n)\n        ## Space: O(1)\n        ## max_reach = max(max_reach, i + nums[i])\n        ## if max_reach >= len(nums) - 1:\n        ##     return True\n        ## return False\n        \n        ## 3. Greedy\n        ## Time: O(n)\n        ## Space: O(1)\n        ## max_reach = nums[0]\n        ## for i in range(1, len(nums)):\n        ##     if max_reach >= i:\n        ##         max_reach = max(max_reach, i + nums[i])\n        ##     if max_reach >= len(nums) - 1:\n        ##         return True\n        ## return False\n        \n        ## 4. Greedy\n        ## Time: O(n)\n        ## Space: O(1)\n        ## max_reach = nums[0]\n        ## for i in range(1, len(nums)):\n        ##     if max_reach >= i:\n        ##         max_reach = max(max_reach, i + nums[i])\n        ##     if max_reach >= len(nums) - 1:\n        ##         return True\n        ## return False\n        \n        ## 5. Greedy\n        ## Time: O(n)\n        ## Space: O(1)\n        ## max_reach = nums[0]\n        ## for i in range(1, len(nums)):\n        ##     if max_reach >= i:\n        ##         max_reach = max(max_reach, i + nums[i])\n        ##     if max_reach >= len(nums) - 1:\n        ##         return True\n        ## return False\n        \n        ## 6. Greedy\n        ## Time: O(n)\n        ## Space: O(1)\n        ## max_reach = nums[0]\n        ## for i in range(1, len(nums)):\n        ##     if max_reach >= i:\n        ##         max_reach = max(max_reach, i + nums[i])\n        ##     if max_reach >= len(nums) - 1:\n        ##         return True\n        ## return False\n        \n        ## 7. Greedy\n        ## Time: O(n)\n        ## Space: O(1)\n        ## max_reach = nums[0]\n        ## for i in range(1, len(nums)):\n        ##     if max_reach >= i:\n        ##         max_reach = max(max_reach, i + nums[i])\n        ##     if max_reach >= len(nums) - 1:\n        ##         return True\n        ## return False\n        \n        ## 8. Greedy\n        ## Time: O(n)\n        ## Space: O(1)\n        ## max_reach = nums[0]\n        ## for i in range(1, len(nums)):\n        ##     if max_reach >= i:\n        ##         max_reach = max(max_reach, i + nums[i])\n        ##     if max_reach >= len(nums) - 1:\n        ##         return True\n        ## return False\n        \n        ## 9. Greedy\n        ## Time: O(n)\n        ## Space: O(1)\n        ## max_reach = nums[0]\n        ## for i in range(1, len(nums"}, {"task_id": "jump-game", "completion": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        ## 1. DP\n        ## Time: O(n^2)\n        ## Space: O(n)\n        ## dp[i] = True if we can reach the end from i\n        ## dp[i] = any(dp[i+1:i+nums[i]+1])\n        ## dp[n-1] = True\n        ## return dp[0]\n        \n        ## 2. Greedy\n        ## Time: O(n)\n        ## Space: O(1)\n        ## max_reach = max(max_reach, i + nums[i])\n        ## if max_reach >= len(nums) - 1:\n        ##     return True\n        ## return False\n        \n        ## 3. Greedy\n        ## Time: O(n)\n        ## Space: O(1)\n        ## max_reach = nums[0]\n        ## for i in range(1, len(nums)):\n        ##     if max_reach >= i:\n        ##         max_reach = max(max_reach, i + nums[i])\n        ##     if max_reach >= len(nums) - 1:\n        ##         return True\n        ## return False\n        \n        ## 4. Greedy\n        ## Time: O(n)\n        ## Space: O(1)\n        ## max_reach = nums[0]\n        ## for i in range(1, len(nums)):\n        ##     if max_reach >= i:\n        ##         max_reach = max(max_reach, i + nums[i])\n        ##     if max_reach >= len(nums) - 1:\n        ##         return True\n        ## return False\n        \n        ## 5. Greedy\n        ## Time: O(n)\n        ## Space: O(1)\n        ## max_reach = nums[0]\n        ## for i in range(1, len(nums)):\n        ##     if max_reach >= i:\n        ##         max_reach = max(max_reach, i + nums[i])\n        ##     if max_reach >= len(nums) - 1:\n        ##         return True\n        ## return False\n        \n        ## 6. Greedy\n        ## Time: O(n)\n        ## Space: O(1)\n        ## max_reach = nums[0]\n        ## for i in range(1, len(nums)):\n        ##     if max_reach >= i:\n        ##         max_reach = max(max_reach, i + nums[i])\n        ##     if max_reach >= len(nums) - 1:\n        ##         return True\n        ## return False\n        \n        ## 7. Greedy\n        ## Time: O(n)\n        ## Space: O(1)\n        ## max_reach = nums[0]\n        ## for i in range(1, len(nums)):\n        ##     if max_reach >= i:\n        ##         max_reach = max(max_reach, i + nums[i])\n        ##     if max_reach >= len(nums) - 1:\n        ##         return True\n        ## return False\n        \n        ## 8. Greedy\n        ## Time: O(n)\n        ## Space: O(1)\n        ## max_reach = nums[0]\n        ## for i in range(1, len(nums)):\n        ##     if max_reach >= i:\n        ##         max_reach = max(max_reach, i + nums[i])\n        ##     if max_reach >= len(nums) - 1:\n        ##         return True\n        ## return False\n        \n        ## 9. Greedy\n        ## Time: O(n)\n        ## Space: O(1)\n        ## max_reach = nums[0]\n        ## for i in range(1, len(nums)):\n        ##     if max_reach >= i:\n        ##         max"}, {"task_id": "jump-game", "completion": "class Solution(object):\n    def canJump(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        ## 1. DP\n        ## Time: O(n^2)\n        ## Space: O(n)\n        ## dp[i] = True if we can reach the end from i\n        ## dp[i] = any(dp[i+1:i+nums[i]+1])\n        ## dp[n-1] = True\n        ## return dp[0]\n        \n        ## 2. Greedy\n        ## Time: O(n)\n        ## Space: O(1)\n        ## max_reach = max(max_reach, i + nums[i])\n        ## if max_reach >= len(nums) - 1:\n        ##     return True\n        ## return False\n        \n        ## 3. Greedy\n        ## Time: O(n)\n        ## Space: O(1)\n        ## max_reach = nums[0]\n        ## for i in range(1, len(nums)):\n        ##     if max_reach >= i:\n        ##         max_reach = max(max_reach, i + nums[i])\n        ##     if max_reach >= len(nums) - 1:\n        ##         return True\n        ## return False\n        \n        ## 4. Greedy\n        ## Time: O(n)\n        ## Space: O(1)\n        ## max_reach = nums[0]\n        ## for i in range(1, len(nums)):\n        ##     if max_reach >= i:\n        ##         max_reach = max(max_reach, i + nums[i])\n        ##     if max_reach >= len(nums) - 1:\n        ##         return True\n        ## return False\n        \n        ## 5. Greedy\n        ## Time: O(n)\n        ## Space: O(1)\n        ## max_reach = nums[0]\n        ## for i in range(1, len(nums)):\n        ##     if max_reach >= i:\n        ##         max_reach = max(max_reach, i + nums[i])\n        ##     if max_reach >= len(nums) - 1:\n        ##         return True\n        ## return False\n        \n        ## 6. Greedy\n        ## Time: O(n)\n        ## Space: O(1)\n        ## max_reach = nums[0]\n        ## for i in range(1, len(nums)):\n        ##     if max_reach >= i:\n        ##         max_reach = max(max_reach, i + nums[i])\n        ##     if max_reach >= len(nums) - 1:\n        ##         return True\n        ## return False\n        \n        ## 7. Greedy\n        ## Time: O(n)\n        ## Space: O(1)\n        ## max_reach = nums[0]\n        ## for i in range(1, len(nums)):\n        ##     if max_reach >= i:\n        ##         max_reach = max(max_reach, i + nums[i])\n        ##     if max_reach >= len(nums) - 1:\n        ##         return True\n        ## return False\n        \n        ## 8. Greedy\n        ## Time: O(n)\n        ## Space: O(1)\n        ## max_reach = nums[0]\n        ## for i in range(1, len(nums)):\n        ##     if max_reach >= i:\n        ##         max_reach = max(max_reach, i + nums[i])\n        ##     if max_reach >= len(nums) - 1:\n        ##         return True\n        ## return False\n        \n        ## 9. Greedy\n        ## Time: O(n)\n        ## Space: O(1)\n        ## max_reach = nums[0]\n        ## for i in range(1, len(nums)):\n        ##     if max_reach >= i:\n        ##         max"}], "minimum-path-sum": [{"task_id": "minimum-path-sum", "completion": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(grid)\n        n = len(grid[0])\n        \n        dp = [[0 for _ in range(n)] for _ in range(m)]\n        \n        dp[0][0] = grid[0][0]\n        \n        for i in range(1, m):\n            dp[i][0] = dp[i-1][0] + grid[i][0]\n        \n        for j in range(1, n):\n            dp[0][j] = dp[0][j-1] + grid[0][j]\n        \n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n        \n        return dp[m-1][n-1]"}, {"task_id": "minimum-path-sum", "completion": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(grid)\n        n = len(grid[0])\n        \n        dp = [[0 for _ in range(n)] for _ in range(m)]\n        \n        dp[0][0] = grid[0][0]\n        \n        for i in range(1, m):\n            dp[i][0] = dp[i-1][0] + grid[i][0]\n        \n        for j in range(1, n):\n            dp[0][j] = dp[0][j-1] + grid[0][j]\n        \n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n        \n        return dp[m-1][n-1]"}, {"task_id": "minimum-path-sum", "completion": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(grid)\n        n = len(grid[0])\n        \n        dp = [[0 for _ in range(n)] for _ in range(m)]\n        \n        dp[0][0] = grid[0][0]\n        \n        for i in range(1, m):\n            dp[i][0] = dp[i-1][0] + grid[i][0]\n        \n        for j in range(1, n):\n            dp[0][j] = dp[0][j-1] + grid[0][j]\n        \n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n        \n        return dp[m-1][n-1]"}, {"task_id": "minimum-path-sum", "completion": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(grid)\n        n = len(grid[0])\n        \n        dp = [[0 for _ in range(n)] for _ in range(m)]\n        \n        dp[0][0] = grid[0][0]\n        \n        for i in range(1, m):\n            dp[i][0] = dp[i-1][0] + grid[i][0]\n        \n        for j in range(1, n):\n            dp[0][j] = dp[0][j-1] + grid[0][j]\n        \n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n        \n        return dp[m-1][n-1]"}, {"task_id": "minimum-path-sum", "completion": "class Solution(object):\n    def minPathSum(self, grid):\n        \"\"\"\n        :type grid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(grid)\n        n = len(grid[0])\n        \n        dp = [[0 for _ in range(n)] for _ in range(m)]\n        \n        dp[0][0] = grid[0][0]\n        \n        for i in range(1, m):\n            dp[i][0] = dp[i-1][0] + grid[i][0]\n        \n        for j in range(1, n):\n            dp[0][j] = dp[0][j-1] + grid[0][j]\n        \n        for i in range(1, m):\n            for j in range(1, n):\n                dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j]\n        \n        return dp[m-1][n-1]"}], "count-and-say": [{"task_id": "count-and-say", "completion": "class Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        \n        if n == 1:\n            return \"1\"\n        \n        prev = self.countAndSay(n-1)\n        res = \"\"\n        count = 1\n        for i in range(len(prev)):\n            if i == len(prev)-1 or prev[i] != prev[i+1]:\n                res += str(count) + prev[i]\n                count = 1\n            else:\n                count += 1\n        return res"}, {"task_id": "count-and-say", "completion": "class Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        \n        if n == 1:\n            return \"1\"\n        \n        prev = self.countAndSay(n-1)\n        res = \"\"\n        count = 1\n        for i in range(len(prev)):\n            if i == len(prev)-1 or prev[i] != prev[i+1]:\n                res += str(count) + prev[i]\n                count = 1\n            else:\n                count += 1\n        return res"}, {"task_id": "count-and-say", "completion": "class Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        \n        if n == 1:\n            return \"1\"\n        \n        prev = self.countAndSay(n-1)\n        res = \"\"\n        count = 1\n        for i in range(len(prev)):\n            if i == len(prev)-1 or prev[i] != prev[i+1]:\n                res += str(count) + prev[i]\n                count = 1\n            else:\n                count += 1\n        return res"}, {"task_id": "count-and-say", "completion": "class Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        \n        if n == 1:\n            return \"1\"\n        \n        prev = self.countAndSay(n-1)\n        res = \"\"\n        count = 1\n        for i in range(len(prev)):\n            if i == len(prev)-1 or prev[i] != prev[i+1]:\n                res += str(count) + prev[i]\n                count = 1\n            else:\n                count += 1\n        return res"}, {"task_id": "count-and-say", "completion": "class Solution(object):\n    def countAndSay(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: str\n        \"\"\"\n        \n        if n == 1:\n            return \"1\"\n        \n        prev = self.countAndSay(n-1)\n        res = \"\"\n        count = 1\n        for i in range(len(prev)):\n            if i == len(prev)-1 or prev[i] != prev[i+1]:\n                res += str(count) + prev[i]\n                count = 1\n            else:\n                count += 1\n        return res"}], "split-array-largest-sum": [{"task_id": "split-array-largest-sum", "completion": "class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def canSplit(maxSum):\n            subarray = 0\n            currSum = 0\n            for num in nums:\n                currSum += num\n                if currSum > maxSum:\n                    subarray += 1\n                    currSum = num\n            return subarray + 1 <= k\n        \n        left = max(nums)\n        right = sum(nums)\n        \n        while left < right:\n            mid = left + (right - left) // 2\n            if canSplit(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left"}, {"task_id": "split-array-largest-sum", "completion": "class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def canSplit(mid):\n            count = 1\n            currSum = 0\n            for num in nums:\n                currSum += num\n                if currSum > mid:\n                    count += 1\n                    currSum = num\n            return count <= k\n        \n        left = max(nums)\n        right = sum(nums)\n        while left < right:\n            mid = left + (right - left) // 2\n            if canSplit(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left"}, {"task_id": "split-array-largest-sum", "completion": "class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def is_valid(mid):\n            count = 1\n            curr_sum = 0\n            for num in nums:\n                curr_sum += num\n                if curr_sum > mid:\n                    count += 1\n                    curr_sum = num\n            return count <= k\n        \n        left = max(nums)\n        right = sum(nums)\n        while left < right:\n            mid = (left + right) // 2\n            if is_valid(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left"}, {"task_id": "split-array-largest-sum", "completion": "class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def is_valid(mid):\n            count = 1\n            curr_sum = 0\n            for num in nums:\n                curr_sum += num\n                if curr_sum > mid:\n                    count += 1\n                    curr_sum = num\n            return count <= k\n        \n        left = max(nums)\n        right = sum(nums)\n        while left < right:\n            mid = left + (right - left) // 2\n            if is_valid(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left"}, {"task_id": "split-array-largest-sum", "completion": "class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def canSplit(mid):\n            count = 1\n            currSum = 0\n            for num in nums:\n                currSum += num\n                if currSum > mid:\n                    count += 1\n                    currSum = num\n            return count <= k\n        \n        left = max(nums)\n        right = sum(nums)\n        while left < right:\n            mid = left + (right - left) // 2\n            if canSplit(mid):\n                right = mid\n            else:\n                left = mid + 1\n        return left"}], "search-in-rotated-sorted-array": [{"task_id": "search-in-rotated-sorted-array", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1"}, {"task_id": "search-in-rotated-sorted-array", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1"}, {"task_id": "search-in-rotated-sorted-array", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1"}, {"task_id": "search-in-rotated-sorted-array", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1"}, {"task_id": "search-in-rotated-sorted-array", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1"}], "letter-combinations-of-a-phone-number": [{"task_id": "letter-combinations-of-a-phone-number", "completion": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(digits) == 0:\n            return []\n        \n        letters = {\n            '2': 'abc',\n            '3': 'def',\n            '4': 'ghi',\n            '5': 'jkl',\n            '6': 'mno',\n            '7': 'pqrs',\n            '8': 'tuv',\n            '9': 'wxyz'\n        }\n        \n        def backtrack(combination, next_digits):\n            if len(next_digits) == 0:\n                output.append(combination)\n            else:\n                for letter in letters[next_digits[0]]:\n                    backtrack(combination + letter, next_digits[1:])\n        \n        output = []\n        backtrack(\"\", digits)\n        return output"}, {"task_id": "letter-combinations-of-a-phone-number", "completion": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(digits) == 0:\n            return []\n        \n        letters = {\n            '2': 'abc',\n            '3': 'def',\n            '4': 'ghi',\n            '5': 'jkl',\n            '6': 'mno',\n            '7': 'pqrs',\n            '8': 'tuv',\n            '9': 'wxyz'\n        }\n        \n        def backtrack(combination, next_digits):\n            if len(next_digits) == 0:\n                output.append(combination)\n            else:\n                for letter in letters[next_digits[0]]:\n                    backtrack(combination + letter, next_digits[1:])\n        \n        output = []\n        backtrack(\"\", digits)\n        return output"}, {"task_id": "letter-combinations-of-a-phone-number", "completion": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(digits) == 0:\n            return []\n        \n        mapping = {\n            '2': 'abc',\n            '3': 'def',\n            '4': 'ghi',\n            '5': 'jkl',\n            '6': 'mno',\n            '7': 'pqrs',\n            '8': 'tuv',\n            '9': 'wxyz'\n        }\n        \n        def backtrack(combination, next_digits):\n            if len(next_digits) == 0:\n                output.append(combination)\n            else:\n                for letter in mapping[next_digits[0]]:\n                    backtrack(combination + letter, next_digits[1:])\n        \n        output = []\n        backtrack(\"\", digits)\n        return output"}, {"task_id": "letter-combinations-of-a-phone-number", "completion": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(digits) == 0:\n            return []\n        \n        mapping = {\n            '2': 'abc',\n            '3': 'def',\n            '4': 'ghi',\n            '5': 'jkl',\n            '6': 'mno',\n            '7': 'pqrs',\n            '8': 'tuv',\n            '9': 'wxyz'\n        }\n        \n        def backtrack(combination, next_digits):\n            if len(next_digits) == 0:\n                output.append(combination)\n            else:\n                for letter in mapping[next_digits[0]]:\n                    backtrack(combination + letter, next_digits[1:])\n        \n        output = []\n        backtrack(\"\", digits)\n        return output"}, {"task_id": "letter-combinations-of-a-phone-number", "completion": "class Solution(object):\n    def letterCombinations(self, digits):\n        \"\"\"\n        :type digits: str\n        :rtype: List[str]\n        \"\"\"\n        \n        if len(digits) == 0:\n            return []\n        \n        mapping = {\n            '2': 'abc',\n            '3': 'def',\n            '4': 'ghi',\n            '5': 'jkl',\n            '6': 'mno',\n            '7': 'pqrs',\n            '8': 'tuv',\n            '9': 'wxyz'\n        }\n        \n        def backtrack(combination, next_digits):\n            if len(next_digits) == 0:\n                output.append(combination)\n            else:\n                for letter in mapping[next_digits[0]]:\n                    backtrack(combination + letter, next_digits[1:])\n        \n        output = []\n        backtrack(\"\", digits)\n        return output"}], "combination-sum": [{"task_id": "combination-sum", "completion": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(candidates, target, path, res):\n            if target == 0:\n                res.append(path)\n                return\n            if target < 0:\n                return\n            for i in range(len(candidates)):\n                dfs(candidates[i:], target-candidates[i], path+[candidates[i]], res)\n        \n        res = []\n        dfs(candidates, target, [], res)\n        return res"}, {"task_id": "combination-sum", "completion": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(candidates, target, path, res):\n            if target == 0:\n                res.append(path)\n                return\n            if target < 0:\n                return\n            for i in range(len(candidates)):\n                dfs(candidates[i:], target - candidates[i], path + [candidates[i]], res)\n        \n        res = []\n        dfs(candidates, target, [], res)\n        return res"}, {"task_id": "combination-sum", "completion": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(candidates, target, path, res):\n            if target == 0:\n                res.append(path)\n                return\n            if target < 0:\n                return\n            for i in range(len(candidates)):\n                dfs(candidates[i:], target-candidates[i], path+[candidates[i]], res)\n        \n        res = []\n        dfs(candidates, target, [], res)\n        return res"}, {"task_id": "combination-sum", "completion": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(candidates, target, path, res):\n            if target == 0:\n                res.append(path)\n                return\n            if target < 0:\n                return\n            for i in range(len(candidates)):\n                dfs(candidates[i:], target-candidates[i], path+[candidates[i]], res)\n        \n        res = []\n        dfs(candidates, target, [], res)\n        return res"}, {"task_id": "combination-sum", "completion": "class Solution(object):\n    def combinationSum(self, candidates, target):\n        \"\"\"\n        :type candidates: List[int]\n        :type target: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(candidates, target, path, res):\n            if target == 0:\n                res.append(path)\n                return\n            if target < 0:\n                return\n            for i in range(len(candidates)):\n                dfs(candidates[i:], target - candidates[i], path + [candidates[i]], res)\n        \n        res = []\n        dfs(candidates, target, [], res)\n        return res"}], "find-the-closest-palindrome": [{"task_id": "find-the-closest-palindrome", "completion": "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10."}, {"task_id": "find-the-closest-palindrome", "completion": "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. find the closest palindrome\n        # 2. if the closest palindrome is the same as n, then find the closest palindrome with one digit different\n        # 3. if the closest palindrome is the same as n, then find the closest palindrome with two digits different\n        # 4. if the closest palindrome is the same as n, then find the closest palindrome with three digits different\n        # 5. if the closest palindrome is the same as n, then find the closest palindrome with four digits different\n        # 6. if the closest palindrome is the same as n, then find the closest palindrome with five digits different\n        # 7. if the closest palindrome is the same as n, then find the closest palindrome with six digits different\n        # 8. if the closest palindrome is the same as n, then find the closest palindrome with seven digits different\n        # 9. if the closest palindrome is the same as n, then find the closest palindrome with eight digits different\n        # 10. if the closest palindrome is the same as n, then find the closest palindrome with nine digits different\n        # 11. if the closest palindrome is the same as n, then find the closest palindrome with ten digits different\n        # 12. if the closest palindrome is the same as n, then find the closest palindrome with eleven digits different\n        # 13. if the closest palindrome is the same as n, then find the closest palindrome with twelve digits different\n        # 14. if the closest palindrome is the same as n, then find the closest palindrome with thirteen digits different\n        # 15. if the closest palindrome is the same as n, then find the closest palindrome with fourteen digits different\n        # 16. if the closest palindrome is the same as n, then find the closest palindrome with fifteen digits different\n        # 17. if the closest palindrome is the same as n, then find the closest palindrome with sixteen digits different\n        # 18. if the closest palindrome is the same as n, then find the closest palindrome with seventeen digits different\n        # 19. if the closest palindrome is the same as n, then find the closest palindrome with eighteen digits different\n        # 20. if the closest palindrome is the same as n, then find the closest palindrome with nineteen digits different\n        # 21. if the closest palindrome is the same as n, then find the closest palindrome with twenty digits different\n        # 22. if the closest palindrome is the same as n, then find the closest palindrome with twenty-one digits different\n        # 23. if the closest palindrome is the same as n, then find the closest palindrome with twenty-two digits different\n        # 24. if the closest palindrome is the same as n, then find the closest palindrome with twenty-three digits different\n        # 25. if the closest palindrome is the same as n, then find the closest palindrome with twenty-four digits different\n        # 26. if the closest palindrome is the same as n, then find the closest palindrome with twenty-five digits different\n        # 27. if the closest palindrome is the same as n, then find the closest palindrome with twenty-six digits different\n        # 28. if the closest palindrome is the same as n, then find the closest palindrome with twenty-seven digits different\n        # 29. if the closest palindrome is the same as n, then find the closest palindrome with twenty-eight digits different\n        # 30. if the closest palindrome is the same as n, then find the closest palindrome with twenty-nine digits different\n        # 31. if the closest palindrome is the same as n, then find the closest palindrome with thirty digits different\n        # 32. if the closest palindrome is the same as n, then find the closest palindrome with thirty-one digits different\n        # 33. if the closest palindrome is the same as n, then find the closest palindrome with thirty-two dig"}, {"task_id": "find-the-closest-palindrome", "completion": "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10."}, {"task_id": "find-the-closest-palindrome", "completion": "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. find the closest palindrome\n        # 2. if the closest palindrome is the same as n, then find the closest palindrome with one digit different\n        # 3. if the closest palindrome is the same as n, then find the closest palindrome with two digits different\n        # 4. if the closest palindrome is the same as n, then find the closest palindrome with three digits different\n        # 5. if the closest palindrome is the same as n, then find the closest palindrome with four digits different\n        # 6. if the closest palindrome is the same as n, then find the closest palindrome with five digits different\n        # 7. if the closest palindrome is the same as n, then find the closest palindrome with six digits different\n        # 8. if the closest palindrome is the same as n, then find the closest palindrome with seven digits different\n        # 9. if the closest palindrome is the same as n, then find the closest palindrome with eight digits different\n        # 10. if the closest palindrome is the same as n, then find the closest palindrome with nine digits different\n        # 11. if the closest palindrome is the same as n, then find the closest palindrome with ten digits different\n        # 12. if the closest palindrome is the same as n, then find the closest palindrome with eleven digits different\n        # 13. if the closest palindrome is the same as n, then find the closest palindrome with twelve digits different\n        # 14. if the closest palindrome is the same as n, then find the closest palindrome with thirteen digits different\n        # 15. if the closest palindrome is the same as n, then find the closest palindrome with fourteen digits different\n        # 16. if the closest palindrome is the same as n, then find the closest palindrome with fifteen digits different\n        # 17. if the closest palindrome is the same as n, then find the closest palindrome with sixteen digits different\n        # 18. if the closest palindrome is the same as n, then find the closest palindrome with seventeen digits different\n        # 19. if the closest palindrome is the same as n, then find the closest palindrome with eighteen digits different\n        # 20. if the closest palindrome is the same as n, then find the closest palindrome with nineteen digits different\n        # 21. if the closest palindrome is the same as n, then find the closest palindrome with twenty digits different\n        # 22. if the closest palindrome is the same as n, then find the closest palindrome with twenty-one digits different\n        # 23. if the closest palindrome is the same as n, then find the closest palindrome with twenty-two digits different\n        # 24. if the closest palindrome is the same as n, then find the closest palindrome with twenty-three digits different\n        # 25. if the closest palindrome is the same as n, then find the closest palindrome with twenty-four digits different\n        # 26. if the closest palindrome is the same as n, then find the closest palindrome with twenty-five digits different\n        # 27. if the closest palindrome is the same as n, then find the closest palindrome with twenty-six digits different\n        # 28. if the closest palindrome is the same as n, then find the closest palindrome with twenty-seven digits different\n        # 29. if the closest palindrome is the same as n, then find the closest palindrome with twenty-eight digits different\n        # 30. if the closest palindrome is the same as n, then find the closest palindrome with twenty-nine digits different\n        # 31. if the closest palindrome is the same as n, then find the closest palindrome with thirty digits different\n        # 32. if the closest palindrome is the same as n, then find the closest palindrome with thirty-one digits different\n        # 33. if the closest palindrome is the same as n, then find the closest palindrome with thirty-two dig"}, {"task_id": "find-the-closest-palindrome", "completion": "class Solution(object):\n    def nearestPalindromic(self, n):\n        \"\"\"\n        :type n: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. find the closest palindrome\n        # 2. if the closest palindrome is the same as n, then find the closest palindrome with one digit different\n        # 3. if the closest palindrome is the same as n, then find the closest palindrome with two digits different\n        # 4. if the closest palindrome is the same as n, then find the closest palindrome with three digits different\n        # 5. if the closest palindrome is the same as n, then find the closest palindrome with four digits different\n        # 6. if the closest palindrome is the same as n, then find the closest palindrome with five digits different\n        # 7. if the closest palindrome is the same as n, then find the closest palindrome with six digits different\n        # 8. if the closest palindrome is the same as n, then find the closest palindrome with seven digits different\n        # 9. if the closest palindrome is the same as n, then find the closest palindrome with eight digits different\n        # 10. if the closest palindrome is the same as n, then find the closest palindrome with nine digits different\n        # 11. if the closest palindrome is the same as n, then find the closest palindrome with ten digits different\n        # 12. if the closest palindrome is the same as n, then find the closest palindrome with eleven digits different\n        # 13. if the closest palindrome is the same as n, then find the closest palindrome with twelve digits different\n        # 14. if the closest palindrome is the same as n, then find the closest palindrome with thirteen digits different\n        # 15. if the closest palindrome is the same as n, then find the closest palindrome with fourteen digits different\n        # 16. if the closest palindrome is the same as n, then find the closest palindrome with fifteen digits different\n        # 17. if the closest palindrome is the same as n, then find the closest palindrome with sixteen digits different\n        # 18. if the closest palindrome is the same as n, then find the closest palindrome with seventeen digits different\n        # 19. if the closest palindrome is the same as n, then find the closest palindrome with eighteen digits different\n        # 20. if the closest palindrome is the same as n, then find the closest palindrome with nineteen digits different\n        # 21. if the closest palindrome is the same as n, then find the closest palindrome with twenty digits different\n        # 22. if the closest palindrome is the same as n, then find the closest palindrome with twenty-one digits different\n        # 23. if the closest palindrome is the same as n, then find the closest palindrome with twenty-two digits different\n        # 24. if the closest palindrome is the same as n, then find the closest palindrome with twenty-three digits different\n        # 25. if the closest palindrome is the same as n, then find the closest palindrome with twenty-four digits different\n        # 26. if the closest palindrome is the same as n, then find the closest palindrome with twenty-five digits different\n        # 27. if the closest palindrome is the same as n, then find the closest palindrome with twenty-six digits different\n        # 28. if the closest palindrome is the same as n, then find the closest palindrome with twenty-seven digits different\n        # 29. if the closest palindrome is the same as n, then find the closest palindrome with twenty-eight digits different\n        # 30. if the closest palindrome is the same as n, then find the closest palindrome with twenty-nine digits different\n        # 31. if the closest palindrome is the same as n, then find the closest palindrome with thirty digits different\n        # 32. if the closest palindrome is the same as n, then find the closest palindrome with thirty-one digits different\n        # 33. if the closest palindrome is the same as n, then find the closest palindrome with thirty-two dig"}], "spiral-matrix-ii": [{"task_id": "spiral-matrix-ii", "completion": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # 1. Initialize the matrix with 0's\n        matrix = [[0 for i in range(n)] for j in range(n)]\n        \n        # 2. Initialize the row, col, left, right, top and bottom\n        left, right, top, bottom = 0, n-1, 0, n-1\n        \n        # 3. Initialize the number to be filled\n        num = 1\n        \n        # 4. Iterate while the number is less than or equal to n*n\n        while num <= n*n:\n            \n            # 5. Fill the top row from left to right\n            for i in range(left, right+1):\n                matrix[top][i] = num\n                num += 1\n            top += 1\n            \n            # 6. Fill the right column from top to bottom\n            for i in range(top, bottom+1):\n                matrix[i][right] = num\n                num += 1\n            right -= 1\n            \n            # 7. Fill the bottom row from right to left\n            for i in range(right, left-1, -1):\n                matrix[bottom][i] = num\n                num += 1\n            bottom -= 1\n            \n            # 8. Fill the left column from bottom to top\n            for i in range(bottom, top-1, -1):\n                matrix[i][left] = num\n                num += 1\n            left += 1\n            \n        # 9. Return the matrix\n        return matrix"}, {"task_id": "spiral-matrix-ii", "completion": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # initialize the matrix\n        matrix = [[0 for i in range(n)] for j in range(n)]\n        \n        # initialize the row and column indices\n        row_start = 0\n        row_end = n - 1\n        col_start = 0\n        col_end = n - 1\n        \n        # initialize the counter\n        counter = 1\n        \n        # loop until the matrix is filled\n        while row_start <= row_end and col_start <= col_end:\n            # fill the top row\n            for i in range(col_start, col_end + 1):\n                matrix[row_start][i] = counter\n                counter += 1\n            row_start += 1\n            \n            # fill the right column\n            for i in range(row_start, row_end + 1):\n                matrix[i][col_end] = counter\n                counter += 1\n            col_end -= 1\n            \n            # fill the bottom row\n            if row_start <= row_end:\n                for i in range(col_end, col_start - 1, -1):\n                    matrix[row_end][i] = counter\n                    counter += 1\n                row_end -= 1\n            \n            # fill the left column\n            if col_start <= col_end:\n                for i in range(row_end, row_start - 1, -1):\n                    matrix[i][colcol_start] = counter\n                    counter += 1\n                col_start += 1\n        \n        return matrix"}, {"task_id": "spiral-matrix-ii", "completion": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # initialize the matrix\n        matrix = [[0 for i in range(n)] for j in range(n)]\n        \n        # initialize the row and column indices\n        row_start = 0\n        row_end = n - 1\n        col_start = 0\n        col_end = n - 1\n        \n        # initialize the counter\n        counter = 1\n        \n        # loop until the matrix is filled\n        while row_start <= row_end and col_start <= col_end:\n            # fill the top row\n            for i in range(col_start, col_end + 1):\n                matrix[row_start][i] = counter\n                counter += 1\n            row_start += 1\n            \n            # fill the right column\n            for i in range(row_start, row_end + 1):\n                matrix[i][col_end] = counter\n                counter += 1\n            col_end -= 1\n            \n            # fill the bottom row\n            if row_start <= row_end:\n                for i in range(col_end, col_start - 1, -1):\n                    matrix[row_end][i] = counter\n                    counter += 1\n                row_end -= 1\n            \n            # fill the left column\n            if col_start <= col_end:\n                for i in range(row_end, row_start - 1, -1):\n                    matrix[i][colcol_start] = counter\n                    counter += 1\n                col_start += 1\n        \n        return matrix"}, {"task_id": "spiral-matrix-ii", "completion": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # initialize the matrix with all 0's\n        matrix = [[0 for i in range(n)] for j in range(n)]\n        \n        # initialize the row and column indices\n        row_start = 0\n        row_end = n - 1\n        col_start = 0\n        col_end = n - 1\n        \n        # initialize the counter\n        counter = 1\n        \n        # loop until the matrix is filled\n        while row_start <= row_end and col_start <= col_end:\n            # fill the top row from left to right\n            for i in range(col_start, col_end + 1):\n                matrix[row_start][i] = counter\n                counter += 1\n            row_start += 1\n            \n            # fill the right column from top to bottom\n            for i in range(row_start, row_end + 1):\n                matrix[i][col_end] = counter\n                counter += 1\n            col_end -= 1\n            \n            # fill the bottom row from right to left\n            if row_start <= row_end:\n                for i in range(col_end, col_start - 1, -1):\n                    matrix[row_end][i] = counter\n                    counter += 1\n                row_end -= 1\n            \n            # fill the left column from bottom to top\n            if col_start <= col"}, {"task_id": "spiral-matrix-ii", "completion": "class Solution(object):\n    def generateMatrix(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        # initialize the matrix with all 0's\n        matrix = [[0 for i in range(n)] for j in range(n)]\n        \n        # initialize the row and column indices\n        row_start = 0\n        row_end = n - 1\n        col_start = 0\n        col_end = n - 1\n        \n        # initialize the counter\n        counter = 1\n        \n        # loop until the matrix is filled\n        while row_start <= row_end and col_start <= col_end:\n            # fill the top row from left to right\n            for i in range(col_start, col_end + 1):\n                matrix[row_start][i] = counter\n                counter += 1\n            row_start += 1\n            \n            # fill the right column from top to bottom\n            for i in range(row_start, row_end + 1):\n                matrix[i][col_end] = counter\n                counter += 1\n            col_end -= 1\n            \n            # fill the bottom row from right to left\n            if row_start <= row_end:\n                for i in range(col_end, col_start - 1, -1):\n                    matrix[row_end][i] = counter\n                    counter += 1\n                row_end -= 1\n            \n            # fill the left column from bottom to top\n            if col_start <= col"}], "reverse-integer": [{"task_id": "reverse-integer", "completion": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x < 0:\n            x = -x\n            neg = True\n        else:\n            neg = False\n        \n        x = str(x)\n        x = x[::-1]\n        x = int(x)\n        \n        if neg:\n            x = -x\n        \n        if x < -2**31 or x > 2**31 - 1:\n            return 0\n        else:\n            return x"}, {"task_id": "reverse-integer", "completion": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x < 0:\n            x = -x\n            neg = True\n        else:\n            neg = False\n        \n        x = str(x)\n        x = x[::-1]\n        x = int(x)\n        \n        if neg:\n            x = -x\n        \n        if x < -2**31 or x > 2**31 - 1:\n            return 0\n        else:\n            return x"}, {"task_id": "reverse-integer", "completion": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x < 0:\n            x = -x\n            neg = True\n        else:\n            neg = False\n        \n        x = str(x)\n        x = x[::-1]\n        x = int(x)\n        \n        if neg:\n            x = -x\n        \n        if x < -2**31 or x > 2**31 - 1:\n            return 0\n        else:\n            return x"}, {"task_id": "reverse-integer", "completion": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x < 0:\n            x = -x\n            neg = True\n        else:\n            neg = False\n        \n        x = str(x)\n        x = x[::-1]\n        x = int(x)\n        \n        if neg:\n            x = -x\n        \n        if x < -2**31 or x > 2**31 - 1:\n            return 0\n        \n        return x"}, {"task_id": "reverse-integer", "completion": "class Solution(object):\n    def reverse(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x < 0:\n            x = -x\n            neg = True\n        else:\n            neg = False\n        \n        x = str(x)\n        x = x[::-1]\n        x = int(x)\n        \n        if neg:\n            x = -x\n        \n        if x < -2**31 or x > 2**31 - 1:\n            return 0\n        else:\n            return x"}], "rotate-image": [{"task_id": "rotate-image", "completion": "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        # 1. transpose the matrix\n        # 2. reverse each row\n        \n        # transpose\n        for i in range(len(matrix)):\n            for j in range(i, len(matrix[0])):\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n        \n        # reverse each row\n        for i in range(len(matrix)):\n            matrix[i].reverse()\n        \n        return matrix"}, {"task_id": "rotate-image", "completion": "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        # 1. transpose the matrix\n        # 2. reverse each row\n        \n        # transpose\n        for i in range(len(matrix)):\n            for j in range(i, len(matrix[0])):\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n        \n        # reverse each row\n        for i in range(len(matrix)):\n            matrix[i].reverse()\n        \n        return matrix"}, {"task_id": "rotate-image", "completion": "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        # 1. transpose the matrix\n        # 2. reverse each row\n        \n        # transpose\n        for i in range(len(matrix)):\n            for j in range(i, len(matrix)):\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n        \n        # reverse each row\n        for i in range(len(matrix)):\n            matrix[i].reverse()\n        \n        return matrix"}, {"task_id": "rotate-image", "completion": "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        # 1. transpose the matrix\n        # 2. reverse each row\n        \n        # transpose\n        for i in range(len(matrix)):\n            for j in range(i, len(matrix)):\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n        \n        # reverse each row\n        for i in range(len(matrix)):\n            matrix[i].reverse()\n        \n        return matrix"}, {"task_id": "rotate-image", "completion": "class Solution(object):\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        # 1. transpose the matrix\n        # 2. reverse each row\n        \n        # transpose\n        for i in range(len(matrix)):\n            for j in range(i, len(matrix[0])):\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n        \n        # reverse each row\n        for i in range(len(matrix)):\n            matrix[i].reverse()\n        \n        return matrix"}], "maximum-product-subarray": [{"task_id": "maximum-product-subarray", "completion": "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 2 pointer approach\n        ## 1. find the first positive number\n        ## 2. find the first negative number\n        ## 3. find the first zero\n        ## 4. if zero is found, then we can skip the zero and find the next positive number\n        ## 5. if positive number is found, then we can skip the positive number and find the next negative number\n        ## 6. if negative number is found, then we can skip the negative number and find the next positive number\n        ## 7. if negative number is found, then we can skip the negative number and find the next positive number\n        ## 8. if positive number is found, then we can skip the positive number and find the next negative number\n        ## 9. if negative number is found, then we can skip the negative number and find the next positive number\n        ## 10. if positive number is found, then we can skip the positive number and find the next negative number\n        ## 11. if negative number is found, then we can skip the negative number and find the next positive number\n        ## 12. if positive number is found, then we can skip the positive number and find the next negative number\n        ## 13. if negative number is found, then we can skip the negative number and find the next positive number\n        ## 14. if positive number is found, then we can skip the positive number and find the next negative number\n        ## 15. if negative number is found, then we can skip the negative number and find the next positive number\n        ## 16. if positive number is found, then we can skip the positive number and find the next negative number\n        ## 17. if negative number is found, then we can skip the negative number and find the next positive number\n        ## 18. if positive number is found, then we can skip the positive number and find the next negative number\n        ## 19. if negative number is found, then we can skip the negative number and find the next positive number\n        ## 20. if positive number is found, then we can skip the positive number and find the next negative number\n        ## 21. if negative number is found, then we can skip the negative number and find the next positive number\n        ## 22. if positive number is found, then we can skip the positive number and find the next negative number\n        ## 23. if negative number is found, then we can skip the negative number and find the next positive number\n        ## 24. if positive number is found, then we can skip the positive number and find the next negative number\n        ## 25. if negative number is found, then we can skip the negative number and find the next positive number\n        ## 26. if positive number is found, then we can skip the positive number and find the next negative number\n        ## 27. if negative number is found, then we can skip the negative number and find the next positive number\n        ## 28. if positive number is found, then we can skip the positive number and find the next negative number\n        ## 29. if negative number is found, then we can skip the negative number and find the next positive number\n        ## 30. if positive number is found, then we can skip the positive number and find the next negative number\n        ## 31. if negative number is found, then we can skip the negative number and find the next positive number\n        ## 32. if positive number is found, then we can skip the positive number and find the next negative number\n        ## 33. if negative number is found, then we can skip the negative number and find the next positive number\n        ## 34. if positive number is found, then we can skip the positive number and find the next negative number\n        ## 35. if negative number is found, then we can skip the negative number and find the next positive number\n        ## 36. if positive number is found, then we can skip the positive number and find the next negative number\n        ## 37. if negative number is found, then we can skip the negative number and find the next positive number\n        ## 38. if positive number is found, then we can skip the positive number and find the next negative number\n        ## 39. if negative number is found, then we can skip the negative number and find the next positive number\n        ## 40. if positive number is found, then we can skip"}, {"task_id": "maximum-product-subarray", "completion": "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 2 pointer approach\n        ## 1. find the first positive number\n        ## 2. find the first negative number\n        ## 3. find the first zero\n        ## 4. if zero is found, then we can skip the subarray\n        ## 5. if negative number is found, then we can skip the subarray\n        ## 6. if positive number is found, then we can skip the subarray\n        ## 7. if positive number is found, then we can skip the subarray\n        ## 8. if positive number is found, then we can skip the subarray\n        ## 9. if positive number is found, then we can skip the subarray\n        ## 10. if positive number is found, then we can skip the subarray\n        ## 11. if positive number is found, then we can skip the subarray\n        ## 12. if positive number is found, then we can skip the subarray\n        ## 13. if positive number is found, then we can skip the subarray\n        ## 14. if positive number is found, then we can skip the subarray\n        ## 15. if positive number is found, then we can skip the subarray\n        ## 16. if positive number is found, then we can skip the subarray\n        ## 17. if positive number is found, then we can skip the subarray\n        ## 18. if positive number is found, then we can skip the subarray\n        ## 19. if positive number is found, then we can skip the subarray\n        ## 20. if positive number is found, then we can skip the subarray\n        ## 21. if positive number is found, then we can skip the subarray\n        ## 22. if positive number is found, then we can skip the subarray\n        ## 23. if positive number is found, then we can skip the subarray\n        ## 24. if positive number is found, then we can skip the subarray\n        ## 25. if positive number is found, then we can skip the subarray\n        ## 26. if positive number is found, then we can skip the subarray\n        ## 27. if positive number is found, then we can skip the subarray\n        ## 28. if positive number is found, then we can skip the subarray\n        ## 29. if positive number is found, then we can skip the subarray\n        ## 30. if positive number is found, then we can skip the subarray\n        ## 31. if positive number is found, then we can skip the subarray\n        ## 32. if positive number is found, then we can skip the subarray\n        ## 33. if positive number is found, then we can skip the subarray\n        ## 34. if positive number is found, then we can skip the subarray\n        ## 35. if positive number is found, then we can skip the subarray\n        ## 36. if positive number is found, then we can skip the subarray\n        ## 37. if positive number is found, then we can skip the subarray\n        ## 38. if positive number is found, then we can skip the subarray\n        ## 39. if positive number is found, then we can skip the subarray\n        ## 40. if positive number is found, then we can skip the subarray\n        ## 41. if positive number is found, then we can skip the subarray\n        ## 42. if positive number is found, then we can skip the subarray\n        ## 43. if positive number is found, then we can skip the subarray\n        ## 44. if positive number is found, then we can skip the subarray\n        ## 45. if positive number is found, then we can skip the subarray\n        ## 46. if positive number is found, then we can skip the subarray\n        ## 47. if positive number is found, then we can skip the subarray\n        ## 48. if positive number is found, then we can skip the subarray\n        ## 49. if positive number is found, then we can skip the subarray\n        ## 50. if positive number is found, then we can skip the subarray"}, {"task_id": "maximum-product-subarray", "completion": "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 2 pointer approach\n        ## 1. find the first positive number\n        ## 2. find the first negative number\n        ## 3. find the first zero\n        ## 4. if zero is present, then the product will be 0\n        ## 5. if zero is not present, then the product will be the product of the subarray from the first positive number to the first negative number\n        ## 6. if the first positive number is the first negative number, then the product will be the product of the subarray from the first positive number to the last number\n        ## 7. if the first positive number is the first negative number, then the product will be the product of the subarray from the first positive number to the last number\n        ## 8. if the first positive number is the first negative number, then the product will be the product of the subarray from the first positive number to the last number\n        ## 9. if the first positive number is the first negative number, then the product will be the product of the subarray from the first positive number to the last number\n        ## 10. if the first positive number is the first negative number, then the product will be the product of the subarray from the first positive number to the last number\n        ## 11. if the first positive number is the first negative number, then the product will be the product of the subarray from the first positive number to the last number\n        ## 12. if the first positive number is the first negative number, then the product will be the product of the subarray from the first positive number to the last number\n        ## 13. if the first positive number is the first negative number, then the product will be the product of the subarray from the first positive number to the last number\n        ## 14. if the first positive number is the first negative number, then the product will be the product of the subarray from the first positive number to the last number\n        ## 15. if the first positive number is the first negative number, then the product will be the product of the subarray from the first positive number to the last number\n        ## 16. if the first positive number is the first negative number, then the product will be the product of the subarray from the first positive number to the last number\n        ## 17. if the first positive number is the first negative number, then the product will be the product of the subarray from the first positive number to the last number\n        ## 18. if the first positive number is the first negative number, then the product will be the product of the subarray from the first positive number to the last number\n        ## 19. if the first positive number is the first negative number, then the product will be the product of the subarray from the first positive number to the last number\n        ## 20. if the first positive number is the first negative number, then the product will be the product of the subarray from the first positive number to the last number\n        ## 21. if the first positive number is the first negative number, then the product will be the product of the subarray from the first positive number to the last number\n        ## 22. if the first positive number is the first negative number, then the product will be the product of the subarray from the first positive number to the last number\n        ## 23. if the first positive number is the first negative number, then the product will be the product of the subarray from the first positive number to the last number\n        ## 24. if the first positive number is the first negative number, then the product will be the product of the subarray from the first positive number to the last number\n        ## 25. if the first positive number is the first negative number, then the product will be the product of the subarray from the first positive number to the last number\n        ## 26. if the first positive number is the first negative number, then the product will be the product of the subarray from the first positive number to the last number\n        ## 27. if the first positive number is the first negative number, then the product will be the product of the subarray from the first positive number to the last number\n        ## 28. if the first positive number is the first negative number, then the product will be the product of the subarray from the first positive number to the last number\n        ## 29. if the first positive number is the first negative number, then the product will be the product of the subarray from the first positive number to"}, {"task_id": "maximum-product-subarray", "completion": "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 2 pointer approach\n        ## 1. find the first positive number\n        ## 2. find the first negative number\n        ## 3. find the first zero\n        ## 4. if zero is found, then we can skip the subarray\n        ## 5. if positive number is found, then we can skip the subarray\n        ## 6. if negative number is found, then we can skip the subarray\n        ## 7. if negative number is found, then we can skip the subarray\n        ## 8. if negative number is found, then we can skip the subarray\n        ## 9. if negative number is found, then we can skip the subarray\n        ## 10. if negative number is found, then we can skip the subarray\n        ## 11. if negative number is found, then we can skip the subarray\n        ## 12. if negative number is found, then we can skip the subarray\n        ## 13. if negative number is found, then we can skip the subarray\n        ## 14. if negative number is found, then we can skip the subarray\n        ## 15. if negative number is found, then we can skip the subarray\n        ## 16. if negative number is found, then we can skip the subarray\n        ## 17. if negative number is found, then we can skip the subarray\n        ## 18. if negative number is found, then we can skip the subarray\n        ## 19. if negative number is found, then we can skip the subarray\n        ## 20. if negative number is found, then we can skip the subarray\n        ## 21. if negative number is found, then we can skip the subarray\n        ## 22. if negative number is found, then we can skip the subarray\n        ## 23. if negative number is found, then we can skip the subarray\n        ## 24. if negative number is found, then we can skip the subarray\n        ## 25. if negative number is found, then we can skip the subarray\n        ## 26. if negative number is found, then we can skip the subarray\n        ## 27. if negative number is found, then we can skip the subarray\n        ## 28. if negative number is found, then we can skip the subarray\n        ## 29. if negative number is found, then we can skip the subarray\n        ## 30. if negative number is found, then we can skip the subarray\n        ## 31. if negative number is found, then we can skip the subarray\n        ## 32. if negative number is found, then we can skip the subarray\n        ## 33. if negative number is found, then we can skip the subarray\n        ## 34. if negative number is found, then we can skip the subarray\n        ## 35. if negative number is found, then we can skip the subarray\n        ## 36. if negative number is found, then we can skip the subarray\n        ## 37. if negative number is found, then we can skip the subarray\n        ## 38. if negative number is found, then we can skip the subarray\n        ## 39. if negative number is found, then we can skip the subarray\n        ## 40. if negative number is found, then we can skip the subarray\n        ## 41. if negative number is found, then we can skip the subarray\n        ## 42. if negative number is found, then we can skip the subarray\n        ## 43. if negative number is found, then we can skip the subarray\n        ## 44. if negative number is found, then we can skip the subarray\n        ## 45. if negative number is found, then we can skip the subarray\n        ## 46. if negative number is found, then we can skip the subarray\n        ## 47. if negative number is found, then we can skip the subarray\n        ## 48. if negative number is found, then we can skip the subarray\n        ## 49. if negative number is found, then we can skip the subarray\n        ## 50. if negative number is found, then we can skip the subarray"}, {"task_id": "maximum-product-subarray", "completion": "class Solution(object):\n    def maxProduct(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        ## 2 pointer approach\n        ## 1. find the first positive number\n        ## 2. find the first negative number\n        ## 3. find the first zero\n        ## 4. if zero is present, then the product will be 0\n        ## 5. if zero is not present, then the product will be the product of the subarray from the first positive number to the first negative number\n        ## 6. if the first positive number is the first negative number, then the product will be the product of the subarray from the first negative number to the first negative number\n        ## 7. if the first positive number is the first negative number, then the product will be the product of the subarray from the first positive number to the first negative number\n        ## 8. if the first positive number is the first negative number, then the product will be the product of the subarray from the first positive number to the first negative number\n        ## 9. if the first positive number is the first negative number, then the product will be the product of the subarray from the first positive number to the first negative number\n        ## 10. if the first positive number is the first negative number, then the product will be the product of the subarray from the first positive number to the first negative number\n        ## 11. if the first positive number is the first negative number, then the product will be the product of the subarray from the first positive number to the first negative number\n        ## 12. if the first positive number is the first negative number, then the product will be the product of the subarray from the first positive number to the first negative number\n        ## 13. if the first positive number is the first negative number, then the product will be the product of the subarray from the first positive number to the first negative number\n        ## 14. if the first positive number is the first negative number, then the product will be the product of the subarray from the first positive number to the first negative number\n        ## 15. if the first positive number is the first negative number, then the product will be the product of the subarray from the first positive number to the first negative number\n        ## 16. if the first positive number is the first negative number, then the product will be the product of the subarray from the first positive number to the first negative number\n        ## 17. if the first positive number is the first negative number, then the product will be the product of the subarray from the first positive number to the first negative number\n        ## 18. if the first positive number is the first negative number, then the product will be the product of the subarray from the first positive number to the first negative number\n        ## 19. if the first positive number is the first negative number, then the product will be the product of the subarray from the first positive number to the first negative number\n        ## 20. if the first positive number is the first negative number, then the product will be the product of the subarray from the first positive number to the first negative number\n        ## 21. if the first positive number is the first negative number, then the product will be the product of the subarray from the first positive number to the first negative number\n        ## 22. if the first positive number is the first negative number, then the product will be the product of the subarray from the first positive number to the first negative number\n        ## 23. if the first positive number is the first negative number, then the product will be the product of the subarray from the first positive number to the first negative number\n        ## 24. if the first positive number is the first negative number, then the product will be the product of the subarray from the first positive number to the first negative number\n        ## 25. if the first positive number is the first negative number, then the product will be the product of the subarray from the first positive number to the first negative number\n        ## 26. if the first positive number is the first negative number, then the product will be the product of the subarray from the first positive number to the first negative number\n        ## 27. if the first positive number is the first negative number, then the product will be the product of the subarray from the first positive number to the first negative number\n        ## 28. if the first positive number is the first negative number, then the product will be the product of the subarray from the first positive number to the first negative number\n        ## 29. if the first positive number"}], "frog-jump": [{"task_id": "frog-jump", "completion": "class Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10."}, {"task_id": "frog-jump", "completion": "class Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10."}, {"task_id": "frog-jump", "completion": "class Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10."}, {"task_id": "frog-jump", "completion": "class Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10."}, {"task_id": "frog-jump", "completion": "class Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10."}], "relative-ranks": [{"task_id": "relative-ranks", "completion": "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        # sort the score list\n        score_sorted = sorted(score, reverse=True)\n        \n        # create a dictionary to store the rank of each score\n        rank_dict = {}\n        for i, s in enumerate(score_sorted):\n            if i == 0:\n                rank_dict[s] = \"Gold Medal\"\n            elif i == 1:\n                rank_dict[s] = \"Silver Medal\"\n            elif i == 2:\n                rank_dict[s] = \"Bronze Medal\"\n            else:\n                rank_dict[s] = str(i+1)\n        \n        # create a list to store the rank of each score\n        rank_list = []\n        for s in score:\n            rank_list.append(rank_dict[s])\n        \n        return rank_list"}, {"task_id": "relative-ranks", "completion": "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        # create a dictionary to store the rank of each athlete\n        rank = {}\n        \n        # sort the score list in descending order\n        score.sort(reverse=True)\n        \n        # assign the rank to each athlete\n        for i in range(len(score)):\n            if i == 0:\n                rank[score[i]] = \"Gold Medal\"\n            elif i == 1:\n                rank[score[i]] = \"Silver Medal\"\n            elif i == 2:\n                rank[score[i]] = \"Bronze Medal\"\n            else:\n                rank[score[i]] = str(i + 1)\n        \n        # create a list to store the rank of each athlete\n        result = []\n        \n        # assign the rank to each athlete\n        for i in score:\n            result.append(rank[i])\n        \n        return result"}, {"task_id": "relative-ranks", "completion": "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        # sort the score list\n        score.sort(reverse=True)\n        \n        # create a dictionary to store the rank of each score\n        rank = {}\n        for i in range(len(score)):\n            if i == 0:\n                rank[score[i]] = \"Gold Medal\"\n            elif i == 1:\n                rank[score[i]] = \"Silver Medal\"\n            elif i == 2:\n                rank[score[i]] = \"Bronze Medal\"\n            else:\n                rank[score[i]] = str(i + 1)\n        \n        # create a list to store the rank of each score\n        result = []\n        for i in score:\n            result.append(rank[i])\n        \n        return result"}, {"task_id": "relative-ranks", "completion": "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        # create a dictionary to store the rank of each athlete\n        rank = {}\n        \n        # sort the score list in descending order\n        score.sort(reverse=True)\n        \n        # assign the rank to each athlete\n        for i in range(len(score)):\n            if i == 0:\n                rank[score[i]] = \"Gold Medal\"\n            elif i == 1:\n                rank[score[i]] = \"Silver Medal\"\n            elif i == 2:\n                rank[score[i]] = \"Bronze Medal\"\n            else:\n                rank[score[i]] = str(i + 1)\n        \n        # create a list to store the rank of each athlete\n        result = []\n        \n        # assign the rank to each athlete\n        for i in score:\n            result.append(rank[i])\n        \n        return result"}, {"task_id": "relative-ranks", "completion": "class Solution(object):\n    def findRelativeRanks(self, score):\n        \"\"\"\n        :type score: List[int]\n        :rtype: List[str]\n        \"\"\"\n        \n        # create a dictionary to store the rank of each athlete\n        rank = {}\n        \n        # sort the score list in descending order\n        score.sort(reverse=True)\n        \n        # assign the rank to each athlete\n        for i in range(len(score)):\n            if i == 0:\n                rank[score[i]] = \"Gold Medal\"\n            elif i == 1:\n                rank[score[i]] = \"Silver Medal\"\n            elif i == 2:\n                rank[score[i]] = \"Bronze Medal\"\n            else:\n                rank[score[i]] = str(i + 1)\n        \n        # create a list to store the rank of each athlete\n        result = []\n        \n        # append the rank of each athlete to the result list\n        for i in score:\n            result.append(rank[i])\n        \n        return result"}], "longest-substring-without-repeating-characters": [{"task_id": "longest-substring-without-repeating-characters", "completion": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)"}, {"task_id": "longest-substring-without-repeating-characters", "completion": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)"}, {"task_id": "longest-substring-without-repeating-characters", "completion": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)"}, {"task_id": "longest-substring-without-repeating-characters", "completion": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)"}, {"task_id": "longest-substring-without-repeating-characters", "completion": "class Solution(object):\n    def lengthOfLongestSubstring(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)\n        \n        # sliding window\n        # time: O(n)\n        # space: O(n)"}], "substring-with-concatenation-of-all-words": [{"task_id": "substring-with-concatenation-of-all-words", "completion": "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10."}, {"task_id": "substring-with-concatenation-of-all-words", "completion": "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not s or not words:\n            return []\n        \n        word_len = len(words[0])\n        word_count = len(words)\n        s_len = len(s)\n        \n        if s_len < word_len * word_count:\n            return []\n        \n        word_dict = {}\n        for word in words:\n            word_dict[word] = word_dict.get(word, 0) + 1\n        \n        res = []\n        for i in range(word_len):\n            left = i\n            right = i\n            count = 0\n            curr_dict = {}\n            while right + word_len <= s_len:\n                word = s[right:right + word_len]\n                right += word_len\n                if word not in word_dict:\n                    left = right\n                    count = 0\n                    curr_dict = {}\n                else:\n                    curr_dict[word] = curr_dict.get(word, 0) + 1\n                    count += 1\n                    while curr_dict[word] > word_dict[word]:\n                        curr_dict[s[left:left + word_len]] -= 1\n                        left += word_len\n                        count -= 1\n                    if count == word_count:\n                        res.append(left)\n        return res"}, {"task_id": "substring-with-concatenation-of-all-words", "completion": "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10."}, {"task_id": "substring-with-concatenation-of-all-words", "completion": "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        \n        if not s or not words:\n            return []\n        \n        word_len = len(words[0])\n        word_count = len(words)\n        s_len = len(s)\n        \n        if s_len < word_len * word_count:\n            return []\n        \n        word_dict = {}\n        for word in words:\n            word_dict[word] = word_dict.get(word, 0) + 1\n        \n        res = []\n        for i in range(word_len):\n            left = i\n            right = i\n            count = 0\n            curr_dict = {}\n            while right + word_len <= s_len:\n                word = s[right:right + word_len]\n                right += word_len\n                if word not in word_dict:\n                    left = right\n                    count = 0\n                    curr_dict = {}\n                else:\n                    curr_dict[word] = curr_dict.get(word, 0) + 1\n                    count += 1\n                    while curr_dict[word] > word_dict[word]:\n                        curr_dict[s[left:left + word_len]] -= 1\n                        left += word_len\n                        count -= 1\n                    if count == word_count:\n                        res.append(left)\n        return res"}, {"task_id": "substring-with-concatenation-of-all-words", "completion": "class Solution(object):\n    def findSubstring(self, s, words):\n        \"\"\"\n        :type s: str\n        :type words: List[str]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10."}], "max-chunks-to-make-sorted-ii": [{"task_id": "max-chunks-to-make-sorted-ii", "completion": "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10."}, {"task_id": "max-chunks-to-make-sorted-ii", "completion": "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10."}, {"task_id": "max-chunks-to-make-sorted-ii", "completion": "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10."}, {"task_id": "max-chunks-to-make-sorted-ii", "completion": "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10."}, {"task_id": "max-chunks-to-make-sorted-ii", "completion": "class Solution(object):\n    def maxChunksToSorted(self, arr):\n        \"\"\"\n        :type arr: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10."}], "insertion-sort-list": [{"task_id": "insertion-sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        curr = head\n        while curr.next:\n            if curr.val <= curr.next.val:\n                curr = curr.next\n            else:\n                prev = dummy\n                while prev.next.val <= curr.next.val:\n                    prev = prev.next\n                temp = curr.next\n                curr.next = temp.next\n                temp.next = prev.next\n                prev.next = temp\n        return dummy.next"}, {"task_id": "insertion-sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        curr = head\n        while curr.next:\n            if curr.val <= curr.next.val:\n                curr = curr.next\n            else:\n                prev = dummy\n                while prev.next.val <= curr.next.val:\n                    prev = prev.next\n                temp = curr.next\n                curr.next = temp.next\n                temp.next = prev.next\n                prev.next = temp\n        return dummy.next"}, {"task_id": "insertion-sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        curr = head\n        while curr.next:\n            if curr.val <= curr.next.val:\n                curr = curr.next\n            else:\n                prev = dummy\n                while prev.next.val <= curr.next.val:\n                    prev = prev.next\n                temp = curr.next\n                curr.next = temp.next\n                temp.next = prev.next\n                prev.next = temp\n        return dummy.next"}, {"task_id": "insertion-sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        curr = head\n        while curr.next:\n            if curr.val <= curr.next.val:\n                curr = curr.next\n            else:\n                prev = dummy\n                while prev.next.val <= curr.next.val:\n                    prev = prev.next\n                temp = curr.next\n                curr.next = temp.next\n                temp.next = prev.next\n                prev.next = temp\n        return dummy.next"}, {"task_id": "insertion-sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def insertionSortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        curr = head\n        while curr.next:\n            if curr.val <= curr.next.val:\n                curr = curr.next\n            else:\n                prev = dummy\n                while prev.next.val <= curr.next.val:\n                    prev = prev.next\n                temp = curr.next\n                curr.next = temp.next\n                temp.next = prev.next\n                prev.next = temp\n        return dummy.next"}], "remove-duplicates-from-sorted-list-ii": [{"task_id": "remove-duplicates-from-sorted-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if head == None:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        \n        while curr != None:\n            while curr.next != None and curr.val == curr.next.val:\n                curr = curr.next\n            if prev.next == curr:\n                prev = prev.next\n            else:\n                prev.next = curr.next\n            curr = curr.next\n        \n        return dummy.next"}, {"task_id": "remove-duplicates-from-sorted-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if head == None or head.next == None:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        \n        while curr and curr.next:\n            if curr.val == curr.next.val:\n                while curr and curr.next and curr.val == curr.next.val:\n                    curr = curr.next\n                prev.next = curr.next\n            else:\n                prev = curr\n            curr = curr.next\n        \n        return dummy.next"}, {"task_id": "remove-duplicates-from-sorted-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if head == None or head.next == None:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        \n        while curr != None and curr.next != None:\n            if curr.val == curr.next.val:\n                while curr.next != None and curr.val == curr.next.val:\n                    curr = curr.next\n                prev.next = curr.next\n            else:\n                prev = curr\n            curr = curr.next\n        \n        return dummy.next"}, {"task_id": "remove-duplicates-from-sorted-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if head == None or head.next == None:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        \n        while curr and curr.next:\n            if curr.val == curr.next.val:\n                while curr and curr.next and curr.val == curr.next.val:\n                    curr = curr.next\n                prev.next = curr.next\n            else:\n                prev = curr\n            curr = curr.next\n        \n        return dummy.next"}, {"task_id": "remove-duplicates-from-sorted-list-ii", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def deleteDuplicates(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if head == None:\n            return head\n        \n        dummy = ListNode(0)\n        dummy.next = head\n        prev = dummy\n        curr = head\n        \n        while curr != None:\n            while curr.next != None and curr.val == curr.next.val:\n                curr = curr.next\n            if prev.next == curr:\n                prev = prev.next\n            else:\n                prev.next = curr.next\n            curr = curr.next\n        return dummy.next"}], "3sum": [{"task_id": "3sum", "completion": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-2):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            l, r = i+1, len(nums)-1\n            while l < r:\n                s = nums[i] + nums[l] + nums[r]\n                if s < 0:\n                    l += 1\n                elif s > 0:\n                    r -= 1\n                else:\n                    res.append([nums[i], nums[l], nums[r]])\n                    while l < r and nums[l] == nums[l+1]:\n                        l += 1\n                    while l < r and nums[r] == nums[r-1]:\n                        r -= 1\n                    l += 1\n                    r -= 1\n        return res"}, {"task_id": "3sum", "completion": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)-2):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            l, r = i+1, len(nums)-1\n            while l < r:\n                s = nums[i] + nums[l] + nums[r]\n                if s < 0:\n                    l += 1\n                elif s > 0:\n                    r -= 1\n                else:\n                    res.append([nums[i], nums[l], nums[r]])\n                    while l < r and nums[l] == nums[l+1]:\n                        l += 1\n                    while l < r and nums[r] == nums[r-1]:\n                        r -= 1\n                    l += 1\n                    r -= 1\n        return res"}, {"task_id": "3sum", "completion": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            l, r = i+1, len(nums)-1\n            while l < r:\n                threeSum = nums[i] + nums[l] + nums[r]\n                if threeSum > 0:\n                    r -= 1\n                elif threeSum < 0:\n                    l += 1\n                else:\n                    res.append([nums[i], nums[l], nums[r]])\n                    l += 1\n                    while nums[l] == nums[l-1] and l < r:\n                        l += 1\n        return res"}, {"task_id": "3sum", "completion": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            l, r = i+1, len(nums)-1\n            while l < r:\n                threeSum = nums[i] + nums[l] + nums[r]\n                if threeSum > 0:\n                    r -= 1\n                elif threeSum < 0:\n                    l += 1\n                else:\n                    res.append([nums[i], nums[l], nums[r]])\n                    l += 1\n                    while nums[l] == nums[l-1] and l < r:\n                        l += 1\n        return res"}, {"task_id": "3sum", "completion": "class Solution(object):\n    def threeSum(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        for i in range(len(nums)):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            l, r = i+1, len(nums)-1\n            while l < r:\n                threeSum = nums[i] + nums[l] + nums[r]\n                if threeSum > 0:\n                    r -= 1\n                elif threeSum < 0:\n                    l += 1\n                else:\n                    res.append([nums[i], nums[l], nums[r]])\n                    l += 1\n                    while nums[l] == nums[l-1] and l < r:\n                        l += 1\n        return res"}], "edit-distance": [{"task_id": "edit-distance", "completion": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = min distance to convert word1[:i] to word2[:j]\n        # dp[i][j] = dp[i-1][j-1] if word1[i-1] == word2[j-1]\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[0][j] = j\n        # dp[i][0] = i\n        \n        m, n = len(word1), len(word2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(m + 1):\n            dp[i][0] = i\n        for j in range(n + 1):\n            dp[0][j] = j\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if word1[i - 1] == word2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n        return dp[m][n]"}, {"task_id": "edit-distance", "completion": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = min distance to convert word1[:i] to word2[:j]\n        # dp[i][j] = dp[i-1][j-1] if word1[i-1] == word2[j-1]\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[0][j] = j\n        # dp[i][0] = i\n        \n        m, n = len(word1), len(word2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(m + 1):\n            dp[i][0] = i\n        for j in range(n + 1):\n            dp[0][j] = j\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if word1[i - 1] == word2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n        return dp[m][n]"}, {"task_id": "edit-distance", "completion": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = min distance to convert word1[:i] to word2[:j]\n        # dp[i][j] = dp[i-1][j-1] if word1[i-1] == word2[j-1]\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[0][j] = j\n        # dp[i][0] = i\n        \n        m, n = len(word1), len(word2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(m + 1):\n            dp[i][0] = i\n        for j in range(n + 1):\n            dp[0][j] = j\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if word1[i - 1] == word2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n        return dp[m][n]"}, {"task_id": "edit-distance", "completion": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = min distance to convert word1[:i] to word2[:j]\n        # dp[i][j] = dp[i-1][j-1] if word1[i-1] == word2[j-1]\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[0][j] = j\n        # dp[i][0] = i\n        \n        m, n = len(word1), len(word2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(m + 1):\n            dp[i][0] = i\n        for j in range(n + 1):\n            dp[0][j] = j\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if word1[i - 1] == word2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n        return dp[m][n]"}, {"task_id": "edit-distance", "completion": "class Solution(object):\n    def minDistance(self, word1, word2):\n        \"\"\"\n        :type word1: str\n        :type word2: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = min distance to convert word1[:i] to word2[:j]\n        # dp[i][j] = dp[i-1][j-1] if word1[i-1] == word2[j-1]\n        # dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1\n        # dp[0][j] = j\n        # dp[i][0] = i\n        \n        m, n = len(word1), len(word2)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(m + 1):\n            dp[i][0] = i\n        for j in range(n + 1):\n            dp[0][j] = j\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if word1[i - 1] == word2[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1]\n                else:\n                    dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1\n        return dp[m][n]"}], "hamming-distance": [{"task_id": "hamming-distance", "completion": "class Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        \n        # convert to binary\n        x = bin(x)[2:]\n        y = bin(y)[2:]\n        \n        # pad with 0s\n        if len(x) > len(y):\n            y = '0'*(len(x)-len(y)) + y\n        elif len(y) > len(x):\n            x = '0'*(len(y)-len(x)) + x\n        \n        # count the number of different bits\n        count = 0\n        for i in range(len(x)):\n            if x[i] != y[i]:\n                count += 1\n        \n        return count"}, {"task_id": "hamming-distance", "completion": "class Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        \n        # convert to binary\n        x = bin(x)[2:]\n        y = bin(y)[2:]\n        \n        # pad with zeros\n        if len(x) > len(y):\n            y = '0'*(len(x)-len(y)) + y\n        elif len(y) > len(x):\n            x = '0'*(len(y)-len(x)) + x\n        \n        # count the number of different bits\n        count = 0\n        for i in range(len(x)):\n            if x[i] != y[i]:\n                count += 1\n        \n        return count"}, {"task_id": "hamming-distance", "completion": "class Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        \n        # convert to binary\n        x = bin(x)[2:]\n        y = bin(y)[2:]\n        \n        # pad with 0s\n        if len(x) > len(y):\n            y = '0'*(len(x)-len(y)) + y\n        elif len(y) > len(x):\n            x = '0'*(len(y)-len(x)) + x\n        \n        # count differences\n        count = 0\n        for i in range(len(x)):\n            if x[i] != y[i]:\n                count += 1\n        \n        return count"}, {"task_id": "hamming-distance", "completion": "class Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        \n        # convert to binary\n        x = bin(x)[2:]\n        y = bin(y)[2:]\n        \n        # pad with 0s\n        if len(x) > len(y):\n            y = '0'*(len(x)-len(y)) + y\n        elif len(y) > len(x):\n            x = '0'*(len(y)-len(x)) + x\n        \n        # count the number of different bits\n        count = 0\n        for i in range(len(x)):\n            if x[i] != y[i]:\n                count += 1\n        \n        return count"}, {"task_id": "hamming-distance", "completion": "class Solution(object):\n    def hammingDistance(self, x, y):\n        \"\"\"\n        :type x: int\n        :type y: int\n        :rtype: int\n        \"\"\"\n        \n        # convert to binary\n        x = bin(x)[2:]\n        y = bin(y)[2:]\n        \n        # pad with zeros\n        if len(x) > len(y):\n            y = '0'*(len(x)-len(y)) + y\n        elif len(y) > len(x):\n            x = '0'*(len(y)-len(x)) + x\n        \n        # count the number of different bits\n        count = 0\n        for i in range(len(x)):\n            if x[i] != y[i]:\n                count += 1\n        \n        return count"}], "binary-tree-paths": [{"task_id": "binary-tree-paths", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        \n        # base case\n        if root is None:\n            return []\n        \n        # recursive case\n        # if root is a leaf node\n        if root.left is None and root.right is None:\n            return [str(root.val)]\n        \n        # if root is not a leaf node\n        left_paths = self.binaryTreePaths(root.left)\n        right_paths = self.binaryTreePaths(root.right)\n        \n        # add root.val to the beginning of each path\n        left_paths = [str(root.val) + \"->\" + path for path in left_paths]\n        right_paths = [str(root.val) + \"->\" + path for path in right"}, {"task_id": "binary-tree-paths", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(node, path):\n            if not node:\n                return\n            if not node.left and not node.right:\n                paths.append(path + str(node.val))\n                return\n            dfs(node.left, path + str(node.val) + \"->\")\n            dfs(node.right, path + str(node.val) + \"->\")\n        \n        paths = []\n        dfs(root, \"\")\n        return paths"}, {"task_id": "binary-tree-paths", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        \n        # base case\n        if not root:\n            return []\n        \n        # recursive case\n        # if root is a leaf node\n        if not root.left and not root.right:\n            return [str(root.val)]\n        \n        # if root is not a leaf node\n        # recursively call binaryTreePaths on left and right subtrees\n        left_paths = self.binaryTreePaths(root.left)\n        right_paths = self.binaryTreePaths(root.right)\n        \n        # concatenate root.val with each path in left_paths and right_paths\n        left_paths = [str(root.val) + \"->\" + path for path in left_paths]\n        right_paths = [str(root.val) + \"->\" + path for path in right"}, {"task_id": "binary-tree-paths", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(node, path):\n            if not node:\n                return\n            if not node.left and not node.right:\n                paths.append(path + str(node.val))\n                return\n            dfs(node.left, path + str(node.val) + \"->\")\n            dfs(node.right, path + str(node.val) + \"->\")\n        \n        paths = []\n        dfs(root, \"\")\n        return paths"}, {"task_id": "binary-tree-paths", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def binaryTreePaths(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[str]\n        \"\"\"\n        \n        def dfs(node, path):\n            if not node:\n                return\n            if not node.left and not node.right:\n                paths.append(path + str(node.val))\n                return\n            dfs(node.left, path + str(node.val) + \"->\")\n            dfs(node.right, path + str(node.val) + \"->\")\n        \n        paths = []\n        dfs(root, \"\")\n        return paths"}], "reverse-pairs": [{"task_id": "reverse-pairs", "completion": "class Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        def merge(left, right):\n            i, j = 0, 0\n            res = []\n            while i < len(left) and j < len(right):\n                if left[i] <= right[j]:\n                    res.append(left[i])\n                    i += 1\n                else:\n                    res.append(right[j])\n                    j += 1\n            res += left[i:]\n            res += right[j:]\n            return res\n        \n        def mergeSort(nums):\n            if len(nums) <= 1:\n                return nums\n            mid = len(nums) // 2\n            left = mergeSort(nums[:mid])\n            right = mergeSort(nums[mid:])\n            return merge(left, right)\n        \n        def binarySearch(nums, target):\n            left, right = 0, len(nums) - 1\n            while left <= right:\n                mid = (left + right) // 2\n                if nums[mid] >= target:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return left\n        \n        def mergeSortWithCount(nums):\n            if len(nums) <= 1:\n                return nums, 0\n            mid = len(nums) // 2\n            left, left_count = mergeSortWithCount(nums[:mid])\n            right, right_count = mergeSortWithCount(nums[mid:])\n            merged, count = merge(left, right)\n            count += left_count + right_count\n            count += len(left) - binarySearch(right, nums[mid])\n            return merged, count\n        \n        return mergeSortWithCount(nums)[1]"}, {"task_id": "reverse-pairs", "completion": "class Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        def merge(left, right):\n            i, j = 0, 0\n            res = []\n            while i < len(left) and j < len(right):\n                if left[i] <= right[j]:\n                    res.append(left[i])\n                    i += 1\n                else:\n                    res.append(right[j])\n                    j += 1\n            res += left[i:]\n            res += right[j:]\n            return res\n        \n        def mergeSort(nums):\n            if len(nums) <= 1:\n                return nums\n            mid = len(nums) // 2\n            left = mergeSort(nums[:mid])\n            right = mergeSort(nums[mid:])\n            return merge(left, right)\n        \n        def binarySearch(nums, target):\n            left, right = 0, len(nums) - 1\n            while left <= right:\n                mid = (left + right) // 2\n                if nums[mid] >= target:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return left\n        \n        def mergeSortWithCount(nums):\n            if len(nums) <= 1:\n                return nums, 0\n            mid = len(nums) // 2\n            left, leftCount = mergeSortWithCount(nums[:mid])\n            right, rightCount = mergeSortWithCount(nums[mid:])\n            merged, count = merge(left, right)\n            count += leftCount + rightCount\n            count += len(left) - binarySearch(right, nums[mid])\n            return merged, count\n        \n        return mergeSortWithCount(nums)[1]"}, {"task_id": "reverse-pairs", "completion": "class Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        def merge(left, right):\n            i, j = 0, 0\n            res = []\n            while i < len(left) and j < len(right):\n                if left[i] <= right[j]:\n                    res.append(left[i])\n                    i += 1\n                else:\n                    res.append(right[j])\n                    j += 1\n            res += left[i:]\n            res += right[j:]\n            return res\n        \n        def mergeSort(nums):\n            if len(nums) <= 1:\n                return nums\n            mid = len(nums) // 2\n            left = mergeSort(nums[:mid])\n            right = mergeSort(nums[mid:])\n            return merge(left, right)\n        \n        def binarySearch(nums, target):\n            left, right = 0, len(nums) - 1\n            while left <= right:\n                mid = (left + right) // 2\n                if nums[mid] >= target:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return left\n        \n        def mergeSortWithCount(nums):\n            if len(nums) <= 1:\n                return nums, 0\n            mid = len(nums) // 2\n            left, left_count = mergeSortWithCount(nums[:mid])\n            right, right_count = mergeSortWithCount(nums[mid:])\n            merged, count = merge(left, right)\n            count += left_count + right_count\n            count += len(left) - binarySearch(right, nums[mid])\n            return merged, count\n        \n        return mergeSortWithCount(nums)[1]"}, {"task_id": "reverse-pairs", "completion": "class Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        def merge(left, right):\n            i, j = 0, 0\n            res = []\n            while i < len(left) and j < len(right):\n                if left[i] <= right[j]:\n                    res.append(left[i])\n                    i += 1\n                else:\n                    res.append(right[j])\n                    j += 1\n            res += left[i:]\n            res += right[j:]\n            return res\n        \n        def mergeSort(nums):\n            if len(nums) <= 1:\n                return nums\n            mid = len(nums) // 2\n            left = mergeSort(nums[:mid])\n            right = mergeSort(nums[mid:])\n            return merge(left, right)\n        \n        def binarySearch(nums, target):\n            left, right = 0, len(nums) - 1\n            while left <= right:\n                mid = (left + right) // 2\n                if nums[mid] >= target:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return left\n        \n        def mergeSortWithCount(nums):\n            if len(nums) <= 1:\n                return nums, 0\n            mid = len(nums) // 2\n            left, leftCount = mergeSortWithCount(nums[:mid])\n            right, rightCount = mergeSortWithCount(nums[mid:])\n            merged, count = merge(left, right)\n            count += leftCount + rightCount\n            count += len(left) - binarySearch(right, nums[mid])\n            return merged, count\n        \n        return mergeSortWithCount(nums)[1]"}, {"task_id": "reverse-pairs", "completion": "class Solution(object):\n    def reversePairs(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        def merge(left, right):\n            i, j = 0, 0\n            res = []\n            while i < len(left) and j < len(right):\n                if left[i] <= right[j]:\n                    res.append(left[i])\n                    i += 1\n                else:\n                    res.append(right[j])\n                    j += 1\n            res += left[i:]\n            res += right[j:]\n            return res\n        \n        def mergeSort(nums):\n            if len(nums) <= 1:\n                return nums\n            mid = len(nums) // 2\n            left = mergeSort(nums[:mid])\n            right = mergeSort(nums[mid:])\n            return merge(left, right)\n        \n        def binarySearch(nums, target):\n            left, right = 0, len(nums) - 1\n            while left <= right:\n                mid = (left + right) // 2\n                if nums[mid] >= target:\n                    right = mid - 1\n                else:\n                    left = mid + 1\n            return left\n        \n        def mergeSortWithCount(nums):\n            if len(nums) <= 1:\n                return nums, 0\n            mid = len(nums) // 2\n            left, left_count = mergeSortWithCount(nums[:mid])\n            right, right_count = mergeSortWithCount(nums[mid:])\n            count = left_count + right_count\n            i = len(left) - 1\n            for num in right:\n                count += i + 1 - binarySearch(left, num * 2)\n            return merge(left, right), count\n        \n        return mergeSortWithCount(nums)[1]"}], "reaching-points": [{"task_id": "reaching-points", "completion": "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        \n        while tx > sx and ty > sy:\n            if tx > ty:\n                tx %= ty\n            else:\n                ty %= tx\n        \n        if tx == sx and ty == sy:\n            return True\n        elif tx == sx:\n            return ty > sy and (ty - sy) % sx == 0\n        elif ty == sy:\n            return tx > sx and (tx - sx) % sy == 0\n        else:\n            return False"}, {"task_id": "reaching-points", "completion": "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        \n        while tx > sx and ty > sy:\n            if tx > ty:\n                tx %= ty\n            else:\n                ty %= tx\n        \n        if sx == tx and sy == ty:\n            return True\n        elif sx == tx and sy < ty and (ty - sy) % sx == 0:\n            return True\n        elif sy == ty and sx < tx and (tx - sx) % sy == 0:\n            return True\n        else:\n            return False"}, {"task_id": "reaching-points", "completion": "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        \n        while tx > sx and ty > sy:\n            if tx > ty:\n                tx %= ty\n            else:\n                ty %= tx\n        \n        if sx == tx and sy == ty:\n            return True\n        elif sx == tx and sy < ty:\n            return ty % sx == 0\n        elif sy == ty and sx < tx:\n            return tx % sy == 0\n        else:\n            return False"}, {"task_id": "reaching-points", "completion": "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        \n        while tx > sx and ty > sy:\n            if tx > ty:\n                tx %= ty\n            else:\n                ty %= tx\n        \n        if tx == sx and ty == sy:\n            return True\n        elif tx == sx:\n            return ty > sy and (ty - sy) % sx == 0\n        elif ty == sy:\n            return tx > sx and (tx - sx) % sy == 0\n        else:\n            return False"}, {"task_id": "reaching-points", "completion": "class Solution(object):\n    def reachingPoints(self, sx, sy, tx, ty):\n        \"\"\"\n        :type sx: int\n        :type sy: int\n        :type tx: int\n        :type ty: int\n        :rtype: bool\n        \"\"\"\n        \n        while tx > sx and ty > sy:\n            if tx > ty:\n                tx %= ty\n            else:\n                ty %= tx\n        \n        if sx == tx and sy == ty:\n            return True\n        elif sx == tx and sy < ty and (ty - sy) % sx == 0:\n            return True\n        elif sy == ty and sx < tx and (tx - sx) % sy == 0:\n            return True\n        else:\n            return False"}], "compare-version-numbers": [{"task_id": "compare-version-numbers", "completion": "class Solution(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"\n        \n        v1 = version1.split('.')\n        v2 = version2.split('.')\n        \n        for i in range(max(len(v1), len(v2))):\n            i1 = int(v1[i]) if i < len(v1) else 0\n            i2 = int(v2[i]) if i < len(v2) else 0\n            if i1 != i2:\n                return 1 if i1 > i2 else -1\n        return 0"}, {"task_id": "compare-version-numbers", "completion": "class Solution(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"\n        \n        v1 = version1.split('.')\n        v2 = version2.split('.')\n        \n        for i in range(max(len(v1), len(v2))):\n            i1 = int(v1[i]) if i < len(v1) else 0\n            i2 = int(v2[i]) if i < len(v2) else 0\n            if i1 != i2:\n                return 1 if i1 > i2 else -1\n        return 0"}, {"task_id": "compare-version-numbers", "completion": "class Solution(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"\n        \n        v1 = version1.split('.')\n        v2 = version2.split('.')\n        \n        for i in range(max(len(v1), len(v2))):\n            i1 = int(v1[i]) if i < len(v1) else 0\n            i2 = int(v2[i]) if i < len(v2) else 0\n            if i1 != i2:\n                return 1 if i1 > i2 else -1\n        return 0"}, {"task_id": "compare-version-numbers", "completion": "class Solution(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"\n        \n        v1 = version1.split('.')\n        v2 = version2.split('.')\n        \n        for i in range(max(len(v1), len(v2))):\n            i1 = int(v1[i]) if i < len(v1) else 0\n            i2 = int(v2[i]) if i < len(v2) else 0\n            if i1 != i2:\n                return 1 if i1 > i2 else -1\n        return 0"}, {"task_id": "compare-version-numbers", "completion": "class Solution(object):\n    def compareVersion(self, version1, version2):\n        \"\"\"\n        :type version1: str\n        :type version2: str\n        :rtype: int\n        \"\"\"\n        \n        v1 = version1.split('.')\n        v2 = version2.split('.')\n        \n        for i in range(max(len(v1), len(v2))):\n            i1 = int(v1[i]) if i < len(v1) else 0\n            i2 = int(v2[i]) if i < len(v2) else 0\n            if i1 != i2:\n                return 1 if i1 > i2 else -1\n        return 0"}], "best-time-to-buy-and-sell-stock-ii": [{"task_id": "best-time-to-buy-and-sell-stock-ii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2 pointers\n        # 2. 2 pointers, 1 variable\n        # 3. 2 pointers, 1 variable, 1 variable\n        \n        # 1. 2 pointers\n        # Time: O(n)\n        # Space: O(1)\n        # 2. 2 pointers, 1 variable\n        # Time: O(n)\n        # Space: O(1)\n        # 3. 2 pointers, 1 variable, 1 variable\n        # Time: O(n)\n        # Space: O(1)\n        \n        # 1. 2 pointers\n        # Time: O(n)\n        # Space: O(1)\n        # 2. 2 pointers, 1 variable\n        # Time: O(n)\n        # Space: O(1)\n        # 3. 2 pointers, 1 variable, 1 variable\n        # Time: O(n)\n        # Space: O(1)\n        \n        # 1. 2 pointers\n        # Time: O(n)\n        # Space: O(1)\n        # 2. 2 pointers, 1 variable\n        # Time: O(n)\n        # Space: O(1)\n        # 3. 2 pointers, 1 variable, 1 variable\n        # Time: O(n)\n        # Space: O(1)\n        \n        # 1. 2 pointers\n        # Time: O(n)\n        # Space: O(1)\n        # 2. 2 pointers, 1 variable\n        # Time: O(n)\n        # Space: O(1)\n        # 3. 2 pointers, 1 variable, 1 variable\n        # Time: O(n)\n        # Space: O(1)\n        \n        # 1. 2 pointers\n        # Time: O(n)\n        # Space: O(1)\n        # 2. 2 pointers, 1 variable\n        # Time: O(n)\n        # Space: O(1)\n        # 3. 2 pointers, 1 variable, 1 variable\n        # Time: O(n)\n        # Space: O(1)\n        \n        # 1. 2 pointers\n        # Time: O(n)\n        # Space: O(1)\n        # 2. 2 pointers, 1 variable\n        # Time: O(n)\n        # Space: O(1)\n        # 3. 2 pointers, 1 variable, 1 variable\n        # Time: O(n)\n        # Space: O(1)\n        \n        # 1. 2 pointers\n        # Time: O(n)\n        # Space: O(1)\n        # 2. 2 pointers, 1 variable\n        # Time: O(n)\n        # Space: O(1)\n        # 3. 2 pointers, 1 variable, 1 variable\n        # Time: O(n)\n        # Space: O(1)\n        \n        # 1. 2 pointers\n        # Time: O(n)\n        # Space: O(1)\n        # 2. 2 pointers, 1 variable\n        # Time: O(n)\n        # Space: O(1)\n        # 3. 2 pointers, 1 variable, 1 variable\n        # Time: O(n)\n        # Space: O(1)\n        \n        # 1. 2 pointers\n        # Time: O(n)\n        # Space: O(1)\n        # 2. 2 pointers, 1 variable\n        # Time: O(n)\n        # Space: O(1)\n        # 3. 2 pointers, 1 variable, 1 variable\n        # Time: O(n)\n        # Space: O(1)\n        \n        # 1. 2 pointers\n        # Time: O(n)\n        # Space: O(1)\n        # 2. 2 pointers, 1 variable\n        # Time: O(n)\n        # Space: O(1)\n        # 3."}, {"task_id": "best-time-to-buy-and-sell-stock-ii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2 pointers\n        # 2. if prices[i] > prices[i+1], then we buy at prices[i] and sell at prices[i+1]\n        # 3. if prices[i] < prices[i+1], then we buy at prices[i] and sell at prices[i+1]\n        # 4. if prices[i] == prices[i+1], then we do nothing\n        # 5. if prices[i] > prices[i+1] and prices[i+1] > prices[i+2], then we buy at prices[i] and sell at prices[i+1]\n        # 6. if prices[i] < prices[i+1] and prices[i+1] < prices[i+2], then we buy at prices[i] and sell at prices[i+1]\n        # 7. if prices[i] == prices[i+1] and prices[i+1] == prices[i+2], then we do nothing\n        # 8. if prices[i] > prices[i+1] and prices[i+1] < prices[i+2], then we buy at prices[i] and sell at prices[i+2]\n        # 9. if prices[i] < prices[i+1] and prices[i+1] > prices[i+2], then we buy at prices[i] and sell at prices[i+2]\n        # 10. if prices[i] == prices[i+1] and prices[i+1] > prices[i+2], then we buy at prices[i] and sell at prices[i+2]\n        # 11. if prices[i] == prices[i+1] and prices[i+1] < prices[i+2], then we buy at prices[i] and sell at prices[i+2]\n        # 12. if prices[i] > prices[i+1] and prices[i+1] == prices[i+2], then we buy at prices[i] and sell at prices[i+2]\n        # 13. if prices[i] < prices[i+1] and prices[i+1] == prices[i+2], then we buy at prices[i] and sell at prices[i+2]\n        # 14. if prices[i] == prices[i+1] and prices[i+1] == prices[i+2], then we do nothing\n        # 15. if prices[i] > prices[i+1] and prices[i+1] > prices[i+2], then we buy at prices[i] and sell at prices[i+2]\n        # 16. if prices[i] < prices[i+1] and prices[i+1] < prices[i+2], then we buy at prices[i] and sell at prices[i+2]\n        # 17. if prices[i] == prices[i+1] and prices[i+1] > prices[i+2], then we buy at prices[i] and sell at prices[i+2]\n        # 18. if prices[i] == prices[i+1] and prices[i+1] < prices[i+2], then we buy at prices[i] and sell at prices[i+2]\n        # 19. if prices[i] > prices[i+1] and prices[i+1] < prices[i+2], then we buy at prices[i] and sell at prices[i+2]\n        # 20. if prices[i] < prices[i+1] and prices[i+1] > prices[i+2], then we buy at prices[i] and sell at prices[i+2]\n        # 21. if prices[i] == prices[i+1] and prices[i+1] == prices[i+2], then we do nothing\n        # 22. if prices[i] > prices[i+1] and prices[i+1] > prices[i+2], then we buy at prices[i] and sell at prices[i+2]\n        # 23. if prices[i] < prices[i+1] and prices[i+1] < prices[i+2], then we buy at prices[i] and sell at prices[i+2]\n        # 24. if prices[i] == prices[i"}, {"task_id": "best-time-to-buy-and-sell-stock-ii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2 pointers\n        # 2. 2 pointers, one for buy, one for sell\n        # 3. 2 pointers, one for buy, one for sell\n        # 4. 2 pointers, one for buy, one for sell\n        # 5. 2 pointers, one for buy, one for sell\n        # 6. 2 pointers, one for buy, one for sell\n        # 7. 2 pointers, one for buy, one for sell\n        # 8. 2 pointers, one for buy, one for sell\n        # 9. 2 pointers, one for buy, one for sell\n        # 10. 2 pointers, one for buy, one for sell\n        # 11. 2 pointers, one for buy, one for sell\n        # 12. 2 pointers, one for buy, one for sell\n        # 13. 2 pointers, one for buy, one for sell\n        # 14. 2 pointers, one for buy, one for sell\n        # 15. 2 pointers, one for buy, one for sell\n        # 16. 2 pointers, one for buy, one for sell\n        # 17. 2 pointers, one for buy, one for sell\n        # 18. 2 pointers, one for buy, one for sell\n        # 19. 2 pointers, one for buy, one for sell\n        # 20. 2 pointers, one for buy, one for sell\n        # 21. 2 pointers, one for buy, one for sell\n        # 22. 2 pointers, one for buy, one for sell\n        # 23. 2 pointers, one for buy, one for sell\n        # 24. 2 pointers, one for buy, one for sell\n        # 25. 2 pointers, one for buy, one for sell\n        # 26. 2 pointers, one for buy, one for sell\n        # 27. 2 pointers, one for buy, one for sell\n        # 28. 2 pointers, one for buy, one for sell\n        # 29. 2 pointers, one for buy, one for sell\n        # 30. 2 pointers, one for buy, one for sell\n        # 31. 2 pointers, one for buy, one for sell\n        # 32. 2 pointers, one for buy, one for sell\n        # 33. 2 pointers, one for buy, one for sell\n        # 34. 2 pointers, one for buy, one for sell\n        # 35. 2 pointers, one for buy, one for sell\n        # 36. 2 pointers, one for buy, one for sell\n        # 37. 2 pointers, one for buy, one for sell\n        # 38. 2 pointers, one for buy, one for sell\n        # 39. 2 pointers, one for buy, one for sell\n        # 40. 2 pointers, one for buy, one for sell\n        # 41. 2 pointers, one for buy, one for sell\n        # 42. 2 pointers, one for buy, one for sell\n        # 43. 2 pointers, one for buy, one for sell\n        # 44. 2 pointers, one for buy, one for sell\n        # 45. 2 pointers, one for buy, one for sell\n        # 46. 2 pointers, one for buy, one for sell\n        # 47. 2 pointers, one for buy, one for sell\n        # 48. 2 pointers, one for buy, one for sell\n        # 49. 2 pointers, one for buy, one for sell\n        # 50. 2 pointers, one for buy, one for sell\n        # 51. 2 pointers, one for buy, one for sell\n        # 52. 2 pointers, one for buy, one for sell"}, {"task_id": "best-time-to-buy-and-sell-stock-ii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2 pointers\n        # 2. 1 pointer\n        # 3. 1 pointer\n        # 4. 1 pointer\n        # 5. 1 pointer\n        # 6. 1 pointer\n        # 7. 1 pointer\n        # 8. 1 pointer\n        # 9. 1 pointer\n        # 10. 1 pointer\n        # 11. 1 pointer\n        # 12. 1 pointer\n        # 13. 1 pointer\n        # 14. 1 pointer\n        # 15. 1 pointer\n        # 16. 1 pointer\n        # 17. 1 pointer\n        # 18. 1 pointer\n        # 19. 1 pointer\n        # 20. 1 pointer\n        # 21. 1 pointer\n        # 22. 1 pointer\n        # 23. 1 pointer\n        # 24. 1 pointer\n        # 25. 1 pointer\n        # 26. 1 pointer\n        # 27. 1 pointer\n        # 28. 1 pointer\n        # 29. 1 pointer\n        # 30. 1 pointer\n        # 31. 1 pointer\n        # 32. 1 pointer\n        # 33. 1 pointer\n        # 34. 1 pointer\n        # 35. 1 pointer\n        # 36. 1 pointer\n        # 37. 1 pointer\n        # 38. 1 pointer\n        # 39. 1 pointer\n        # 40. 1 pointer\n        # 41. 1 pointer\n        # 42. 1 pointer\n        # 43. 1 pointer\n        # 44. 1 pointer\n        # 45. 1 pointer\n        # 46. 1 pointer\n        # 47. 1 pointer\n        # 48. 1 pointer\n        # 49. 1 pointer\n        # 50. 1 pointer\n        # 51. 1 pointer\n        # 52. 1 pointer\n        # 53. 1 pointer\n        # 54. 1 pointer\n        # 55. 1 pointer\n        # 56. 1 pointer\n        # 57. 1 pointer\n        # 58. 1 pointer\n        # 59. 1 pointer\n        # 60. 1 pointer\n        # 61. 1 pointer\n        # 62. 1 pointer\n        # 63. 1 pointer\n        # 64. 1 pointer\n        # 65. 1 pointer\n        # 66. 1 pointer\n        # 67. 1 pointer\n        # 68. 1 pointer\n        # 69. 1 pointer\n        # 70. 1 pointer\n        # 71. 1 pointer\n        # 72. 1 pointer\n        # 73. 1 pointer\n        # 74. 1 pointer\n        # 75. 1 pointer\n        # 76. 1 pointer\n        # 77. 1 pointer\n        # 78. 1 pointer\n        # 79. 1 pointer\n        # 80. 1 pointer\n        # 81. 1 pointer\n        # 82. 1 pointer\n        # 83. 1 pointer\n        # 84. 1 pointer\n        # 85. 1 pointer\n        # 86. 1 pointer\n        # 87. 1 pointer\n        # 88. 1 pointer\n        # 89. 1 pointer\n        # 90. 1 pointer\n        # 91. 1 pointer\n        # 92. 1 pointer\n        # 93. 1 pointer\n        # 94. 1 pointer\n        # 95. 1 pointer\n        # 96. 1 pointer\n        # 97. 1 pointer\n        # 98. 1 pointer\n        # 99. 1 pointer\n        # 100. 1 pointer\n        # 101. 1 pointer\n        # 102. 1 pointer\n        # 103."}, {"task_id": "best-time-to-buy-and-sell-stock-ii", "completion": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2 pointers\n        # 2. if the price is increasing, add the difference to the profit\n        # 3. if the price is decreasing, move the left pointer to the right\n        # 4. if the price is equal, move the left pointer to the right\n        # 5. if the price is increasing, move the right pointer to the right\n        # 6. if the price is decreasing, move the right pointer to the right\n        # 7. if the price is equal, move the right pointer to the right\n        # 8. return the profit\n        \n        # 1. 2 pointers\n        left = 0\n        right = 1\n        profit = 0\n        \n        # 2. if the price is increasing, add the difference to the profit\n        while right < len(prices):\n            if prices[left] < prices[right]:\n                profit += prices[right] - prices[left]\n            left += 1\n            right += 1\n        \n        # 3. if the price is decreasing, move the left pointer to the right\n        while right < len(prices):\n            if prices[left] > prices[right]:\n                left += 1\n            right += 1\n        \n        # 4. if the price is equal, move the left pointer to the right\n        while right < len(prices):\n            if prices[left] == prices[right]:\n                left += 1\n            right += 1\n        \n        # 5. if the price is increasing, move the right pointer to the right\n        while right < len(prices):\n            if prices[left] < prices[right]:\n                right += 1\n            right += 1\n        \n        # 6. if the price is decreasing, move the right pointer to the right\n        while right < len(prices):\n            if prices[left] > prices[right]:\n                right += 1\n            right += 1\n        \n        # 7. if the price is equal, move the right pointer to the right\n        while right < len(prices):\n            if prices[left] == prices[right]:\n                right += 1\n            right += 1\n        \n        # 8. return the profit\n        return profit"}], "course-schedule-iii": [{"task_id": "course-schedule-iii", "completion": "class Solution(object):\n    def scheduleCourse(self, courses):\n        \"\"\"\n        :type courses: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        courses.sort(key=lambda x: x[1])\n        heap = []\n        time = 0\n        for course in courses:\n            if time + course[0] <= course[1]:\n                heapq.heappush(heap, -course[0])\n                time += course[0]\n            elif heap and -heap[0] > course[0]:\n                time += course[0] + heapq.heappop(heap)\n                heapq.heappush(heap, -course[0])\n        return len(heap)"}, {"task_id": "course-schedule-iii", "completion": "class Solution(object):\n    def scheduleCourse(self, courses):\n        \"\"\"\n        :type courses: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        courses.sort(key=lambda x: x[1])\n        heap = []\n        time = 0\n        for course in courses:\n            if time + course[0] <= course[1]:\n                heapq.heappush(heap, -course[0])\n                time += course[0]\n            elif heap and -heap[0] > course[0]:\n                time += course[0] + heapq.heappop(heap)\n                heapq.heappush(heap, -course[0])\n        return len(heap)"}, {"task_id": "course-schedule-iii", "completion": "class Solution(object):\n    def scheduleCourse(self, courses):\n        \"\"\"\n        :type courses: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        courses.sort(key=lambda x: x[1])\n        heap = []\n        time = 0\n        for course in courses:\n            if time + course[0] <= course[1]:\n                heapq.heappush(heap, -course[0])\n                time += course[0]\n            elif heap and -heap[0] > course[0]:\n                time += course[0] + heapq.heappop(heap)\n                heapq.heappush(heap, -course[0])\n        return len(heap)"}, {"task_id": "course-schedule-iii", "completion": "class Solution(object):\n    def scheduleCourse(self, courses):\n        \"\"\"\n        :type courses: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        courses.sort(key=lambda x: x[1])\n        heap = []\n        time = 0\n        for c in courses:\n            if time + c[0] <= c[1]:\n                heapq.heappush(heap, -c[0])\n                time += c[0]\n            elif heap and -heap[0] > c[0]:\n                time += c[0] + heapq.heappop(heap)\n                heapq.heappush(heap, -c[0])\n        return len(heap)"}, {"task_id": "course-schedule-iii", "completion": "class Solution(object):\n    def scheduleCourse(self, courses):\n        \"\"\"\n        :type courses: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        courses.sort(key=lambda x: x[1])\n        heap = []\n        time = 0\n        for course in courses:\n            if time + course[0] <= course[1]:\n                heapq.heappush(heap, -course[0])\n                time += course[0]\n            elif heap and -heap[0] > course[0]:\n                time += course[0] + heapq.heappop(heap)\n                heapq.heappush(heap, -course[0])\n        return len(heap)"}], "reverse-nodes-in-k-group": [{"task_id": "reverse-nodes-in-k-group", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # base case\n        if not head:\n            return None\n        \n        # reverse the first k nodes of the list\n        new_head, new_tail = self.reverse_first_k(head, k)\n        \n        # recursively call the function with the remaining nodes\n        new_tail.next = self.reverseKGroup(new_tail.next, k)\n        \n        return new_head\n    \n    def reverse_first_k(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # base case\n        if k == 1:\n            return head, head\n        \n        # recursively call the function with the remaining nodes\n        new_head, new_tail = self.reverse_first_k(head.next, k-1)\n        \n        # reverse the first k nodes of the list\n        new_tail.next = head\n        head.next = None\n        \n        return new_head, head"}, {"task_id": "reverse-nodes-in-k-group", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # base case\n        if not head:\n            return None\n        \n        # create a dummy node\n        dummy = ListNode(0)\n        dummy.next = head\n        \n        # create a pointer to the dummy node\n        curr = dummy\n        \n        # create a pointer to the head node\n        prev = None\n        \n        # create a pointer to the next node\n        next = None\n        \n        # create a counter\n        count = 0\n        \n        # create a pointer to the head node\n        temp = head\n        \n        # create a counter\n        while temp:\n            count += 1\n            temp = temp.next\n            \n        # create a counter\n        while count >= k:\n            curr = dummy.next\n            prev = dummy\n            count -= k\n            \n            while k > 0:\n                next = curr.next\n                curr.next = prev\n                prev = curr\n                curr = next\n                k -= 1\n                \n            prev.next = curr\n            dummy.next = prev\n            \n        return dummy.next"}, {"task_id": "reverse-nodes-in-k-group", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # base case\n        if not head:\n            return None\n        \n        # create a dummy node\n        dummy = ListNode(0)\n        dummy.next = head\n        \n        # create a pointer to the dummy node\n        curr = dummy\n        \n        # create a pointer to the head node\n        prev = None\n        \n        # create a pointer to the next node\n        next = None\n        \n        # create a counter\n        count = 0\n        \n        # create a pointer to the head node\n        temp = head\n        \n        # create a counter\n        while temp:\n            count += 1\n            temp = temp.next\n            \n        # create a counter\n        while count >= k:\n            curr = dummy.next\n            prev = dummy\n            count -= k\n            while k > 0:\n                next = curr.next\n                curr.next = prev\n                prev = curr\n                curr = next\n                k -= 1\n            prev.next = curr\n            dummy.next = prev\n        return dummy.next"}, {"task_id": "reverse-nodes-in-k-group", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # 1. \uc7ac\uadc0 \uad6c\uc870\ub85c \uc5f0\uacb0 \ub9ac\uc2a4\ud2b8 \ub4a4\uc9d1\uae30\n        def reverse(node, k):\n            # 1. \ub4a4\uc9d1\uc5b4\uc57c \ud558\ub294 \ub178\ub4dc\uc758 \uac1c\uc218\uac00 k\uac1c \uc774\ub0b4\uba74 \uc5f0\uacb0 \ub9ac\uc2a4\ud2b8 \ubc18\uc804 \uc548 \ud568\n            if k == 1:\n                return node\n            \n            # 2. \ub2e4\uc74c \ub178\ub4dc\ub97c \uc7ac\uadc0\uc801\uc73c\ub85c \ud638\ucd9c\ud558\uc5ec \ub4a4\uc9d1\uae30\n            rev, last = reverse(node.next, k-1)\n            \n            # 3. \ub9c8\uc9c0\ub9c9 \ub178\ub4dc\uc758 \ub2e4\uc74c \ub178\ub4dc\ub97c \ud604\uc7ac \ub178\ub4dc\ub85c \uc124\uc815\n            last.next = node\n            \n            # 4. \ud604\uc7ac \ub178\ub4dc\uc758 \ub2e4\uc74c \ub178\ub4dc\ub97c None\uc73c\ub85c \uc124\uc815\n            node.next = None\n            \n            # 5. \ub4a4\uc9d1\ud78c \uc5f0\uacb0 \ub9ac\uc2a4\ud2b8\uc758 \uccab \ubc88\uc9f8 \ub178\ub4dc\uc640 \ub9c8\uc9c0\ub9c9 \ub178\ub4dc\ub97c \ubc18\ud658\n            return rev, node\n        \n        # 2. \uc7ac\uadc0 \ud638\ucd9c\uc744 \uc704\ud55c \ub354\ubbf8 \ub178\ub4dc \uc0dd\uc131\n        dummy = ListNode(0)\n        dummy.next = head\n        \n        # 3. \uc7ac\uadc0 \ud638\ucd9c\uc744 \uc704\ud55c \ubcc0\uc218 \ucd08\uae30\ud654\n        prev, curr = dummy, head\n        \n        # 4. \uc5f0\uacb0 \ub9ac\uc2a4\ud2b8\ub97c \uc21c\ud68c\ud558\uba74\uc11c k\uac1c\uc529 \ub4a4\uc9d1\uae30\n        while curr:\n            # 5. k\uac1c\uc529 \ub4a4\uc9d1\uae30 \uc704\ud574 \ub2e4\uc74c \ub178\ub4dc\ub85c \uc774\ub3d9\n            tail = curr\n            for _ in range(k):\n                if not tail:\n                    return dummy.next\n                tail = tail.next\n            \n            # 6. \ub4a4\uc9d1\uae30\n            rev, last = reverse(curr, k)\n            \n            # 7. \uc774\uc804 \ub178\ub4dc\uc758 \ub2e4\uc74c \ub178\ub4dc\ub97c \ub4a4\uc9d1\uc740 \uccab \ubc88\uc9f8 \ub178\ub4dc\ub85c \uc124\uc815\n            prev.next = rev\n            \n            # 8. \ub9c8\uc9c0\ub9c9 \ub178\ub4dc\uc758 \ub2e4\uc74c \ub178\ub4dc\ub97c \ub4a4\uc9d1\uc740 \ub9c8\uc9c0\ub9c9 \ub178\ub4dc\ub85c \uc124\uc815\n            last.next = tail\n            \n            # 9. \uc774\uc804 \ub178\ub4dc\uc640 \ud604\uc7ac \ub178\ub4dc\ub97c \ub4a4\uc9d1\uc740 \ub9c8\uc9c0\ub9c9 \ub178\ub4dc\ub85c \uc774\ub3d9"}, {"task_id": "reverse-nodes-in-k-group", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reverseKGroup(self, head, k):\n        \"\"\"\n        :type head: ListNode\n        :type k: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # 1. \uc7ac\uadc0 \ud568\uc218\ub97c \uc815\uc758\ud55c\ub2e4.\n        def reverseGroup(head, k):\n            # 2. \uc5f0\uacb0 \ub9ac\uc2a4\ud2b8\ub97c \ub4a4\uc9d1\uc5b4\uc57c \ud558\ub294 \uadf8\ub8f9 \ub0b4\ubd80\ub97c \ucc98\uc74c\uc73c\ub85c \ud310\ub2e8\ud55c\ub2e4.\n            # 2-1. \ub4a4\uc9d1\uc5b4\uc57c \ud558\ub294 \uadf8\ub8f9 \ub0b4\ubd80\uc758 \ub178\ub4dc \uac1c\uc218\ub97c \uce74\uc6b4\ud2b8\ud55c\ub2e4.\n            cnt = 0\n            cur = head\n            while cur is not None and cnt < k:\n                cur = cur.next\n                cnt += 1\n            \n            # 2-2. \ub4a4\uc9d1\uc5b4\uc57c \ud558\ub294 \uadf8\ub8f9 \ub0b4\ubd80\uc758 \ub178\ub4dc \uac1c\uc218\uac00 k\uac1c\uac00 \uc544\ub2c8\ub77c\uba74 \uc5f0\uacb0 \ub9ac\uc2a4\ud2b8\ub97c \ub4a4\uc9d1\uc9c0 \uc54a\uace0 \uadf8\ub300\ub85c \ubc18\ud658\ud55c\ub2e4.\n            if cnt < k:\n                return head\n            \n            # 2-3. \uc5f0\uacb0 \ub9ac\uc2a4\ud2b8\ub97c \ub4a4\uc9d1\uc5b4\uc57c \ud558\ub294 \uadf8\ub8f9 \ub0b4\ubd80\uc758 \ub178\ub4dc \uac1c\uc218\uac00 k\uac1c\ub77c\uba74 \uc5f0\uacb0 \ub9ac\uc2a4\ud2b8\ub97c \ub4a4\uc9d1\ub294\ub2e4.\n            # 2-3-1. \uc5f0\uacb0 \ub9ac\uc2a4\ud2b8\ub97c \ub4a4\uc9d1\uc5b4\uc57c \ud558\ub294 \uadf8\ub8f9 \ub0b4\ubd80\uc758 \ub178\ub4dc \uac1c\uc218\uac00 k\uac1c\ub77c\uba74 \uc5f0\uacb0 \ub9ac\uc2a4\ud2b8\ub97c \ub4a4\uc9d1\ub294\ub2e4.\n            # 2-3-2. \uc5f0\uacb0 \ub9ac\uc2a4\ud2b8\ub97c \ub4a4\uc9d1\uc5b4\uc57c \ud558\ub294 \uadf8\ub8f9 \ub0b4\ubd80\uc758 \ub178\ub4dc \uac1c\uc218\uac00 k\uac1c\ub77c\uba74 \uc5f0\uacb0 \ub9ac\uc2a4\ud2b8\ub97c \ub4a4\uc9d1\ub294\ub2e4.\n            # 2-3-3. \uc5f0\uacb0 \ub9ac\uc2a4\ud2b8\ub97c \ub4a4\uc9d1\uc5b4\uc57c \ud558\ub294 \uadf8\ub8f9 \ub0b4\ubd80\uc758 \ub178\ub4dc \uac1c\uc218\uac00 k\uac1c\ub77c\uba74 \uc5f0\uacb0 \ub9ac\uc2a4\ud2b8\ub97c \ub4a4\uc9d1\ub294\ub2e4.\n            # 2-3-4. \uc5f0\uacb0 \ub9ac\uc2a4\ud2b8\ub97c \ub4a4\uc9d1\uc5b4\uc57c \ud558\ub294 \uadf8\ub8f9 \ub0b4\ubd80\uc758 \ub178\ub4dc \uac1c\uc218\uac00 k\uac1c\ub77c\uba74 \uc5f0\uacb0 \ub9ac\uc2a4\ud2b8\ufffd"}], "repeated-substring-pattern": [{"task_id": "repeated-substring-pattern", "completion": "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        #"}, {"task_id": "repeated-substring-pattern", "completion": "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        #"}, {"task_id": "repeated-substring-pattern", "completion": "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        #"}, {"task_id": "repeated-substring-pattern", "completion": "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        #"}, {"task_id": "repeated-substring-pattern", "completion": "class Solution(object):\n    def repeatedSubstringPattern(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        #"}], "unique-binary-search-trees": [{"task_id": "unique-binary-search-trees", "completion": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. DP\n        # Time: O(n^2)\n        # Space: O(n)\n        # dp[i] = dp[0] * dp[i-1] + dp[1] * dp[i-2] + ... + dp[i-1] * dp[0]\n        # dp[0] = 1\n        # dp[1] = 1\n        # dp[2] = 2\n        # dp[3] = 5\n        # dp[4] = 14\n        # dp[5] = 42\n        # dp[6] = 132\n        # dp[7] = 429\n        # dp[8] = 1430\n        # dp[9] = 4862\n        # dp[10] = 16796\n        # dp[11] = 58786\n        # dp[12] = 208012\n        # dp[13] = 742900\n        # dp[14] = 2674440\n        # dp[15] = 9694845\n        # dp[16] = 35357670\n        # dp[17] = 129644790\n        # dp[18] = 477638700\n        # dp[19] = 1767263190\n        \n        # dp = [1] * (n + 1)\n        # for i in range(2, n + 1):\n        #     dp[i] = 0\n        #     for j in range(i):\n        #         dp[i] += dp[j] * dp[i - 1 - j]\n        # return dp[n]\n        \n        # 2. Catalan Number\n        # Time: O(n)\n        # Space: O(1)\n        # C(n) = (2n)! / (n + 1)!n!)\n        # C(0) = 1\n        # C(1) = 1\n        # C(2) = 2\n        # C(3) = 5\n        # C(4) = 14\n        # C(5) = 42\n        # C(6) = 132\n        # C(7) = 429\n        # C(8) = 1430\n        # C(9) = 4862\n        # C(10) = 16796\n        # C(11) = 58786\n        # C(12) = 208012\n        # C(13) = 742900\n        # C(14) = 2674440\n        # C(15) = 9694845\n        # C(16) = 35357670\n        # C(17) = 129644790\n        # C(18) = 477638700\n        # C(19) = 1767263190\n        \n        # return math.factorial(2 * n) // math.factorial(n + 1) // math.factorial(n)\n        \n        # 3. Math\n        # Time: O(n)\n        # Space: O(1)\n        # C(n) = (2n)! / (n + 1)!n!)\n        # C(0) = 1\n        # C(1) = 1\n        # C(2) = 2\n        # C(3) = 5\n        # C(4) = 14\n        # C(5) = 42\n        # C(6) = 132\n        # C(7) = 429\n        # C(8) = 1430\n        # C(9) = 4862\n        # C(10) = 16796\n        # C(11) = 58786\n        # C(12) = 208012\n        # C(13) = 742900\n        # C(14) = 2674440\n        # C"}, {"task_id": "unique-binary-search-trees", "completion": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. DP\n        # Time: O(n^2)\n        # Space: O(n)\n        # dp[i] = dp[0] * dp[i-1] + dp[1] * dp[i-2] + ... + dp[i-1] * dp[0]\n        # dp[0] = 1\n        # dp[1] = 1\n        # dp[2] = 2\n        # dp[3] = 5\n        # dp[4] = 14\n        # dp[5] = 42\n        # dp[6] = 132\n        # dp[7] = 429\n        # dp[8] = 1430\n        # dp[9] = 4862\n        # dp[10] = 16796\n        # dp[11] = 58786\n        # dp[12] = 208012\n        # dp[13] = 742900\n        # dp[14] = 2674440\n        # dp[15] = 9694845\n        # dp[16] = 35357670\n        # dp[17] = 129644790\n        # dp[18] = 477638700\n        # dp[19] = 1767263190\n        \n        # dp = [1] * (n + 1)\n        # for i in range(2, n + 1):\n        #     dp[i] = 0\n        #     for j in range(i):\n        #         dp[i] += dp[j] * dp[i - 1 - j]\n        # return dp[n]\n        \n        # 2. Catalan Number\n        # Time: O(n)\n        # Space: O(1)\n        # Cn = 2nCn / (n + 1)\n        # C0 = 1\n        # C1 = 1\n        # C2 = 2\n        # C3 = 5\n        # C4 = 14\n        # C5 = 42\n        # C6 = 132\n        # C7 = 429\n        # C8 = 1430\n        # C9 = 4862\n        # C10 = 16796\n        # C11 = 58786\n        # C12 = 208012\n        # C13 = 742900\n        # C14 = 2674440\n        # C15 = 9694845\n        # C16 = 35357670\n        # C17 = 129644790\n        # C18 = 477638700\n        # C19 = 1767263190\n        \n        # C = 1\n        # for i in range(1, n + 1):\n        #     C = C * 2 * (2 * i - 1) // (i + 1)\n        # return C\n        \n        # 3. Math\n        # Time: O(n)\n        # Space: O(1)\n        # 1\n        # 1 1\n        # 2 1 2\n        # 5 1 2 3 4 5\n        # 14 1 2 3 4 5 6 7 8 9 10 11 12 13 14\n        # 42 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42\n        # 132 1 2 3 4 5 6 7 8 9 1"}, {"task_id": "unique-binary-search-trees", "completion": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. DP\n        # Time: O(n^2)\n        # Space: O(n)\n        # dp[i] = dp[0] * dp[i-1] + dp[1] * dp[i-2] + ... + dp[i-1] * dp[0]\n        # dp[0] = 1\n        # dp[1] = 1\n        # dp[2] = 2\n        # dp[3] = 5\n        # dp[4] = 14\n        # dp[5] = 42\n        # dp[6] = 132\n        # dp[7] = 429\n        # dp[8] = 1430\n        # dp[9] = 4862\n        # dp[10] = 16796\n        # dp[11] = 58786\n        # dp[12] = 208012\n        # dp[13] = 742900\n        # dp[14] = 2674440\n        # dp[15] = 9694845\n        # dp[16] = 35357670\n        # dp[17] = 129644790\n        # dp[18] = 477638700\n        # dp[19] = 1767263190\n        \n        # dp = [0] * (n + 1)\n        # dp[0] = 1\n        # dp[1] = 1\n        # for i in range(2, n + 1):\n        #     for j in range(i):\n        #         dp[i] += dp[j] * dp[i - 1 - j]\n        # return dp[n]\n        \n        # 2. Catalan Number\n        # Time: O(n)\n        # Space: O(1)\n        # C(n) = (2n)! / (n + 1)!n!)\n        # C(0) = 1\n        # C(1) = 1\n        # C(2) = 2\n        # C(3) = 5\n        # C(4) = 14\n        # C(5) = 42\n        # C(6) = 132\n        # C(7) = 429\n        # C(8) = 1430\n        # C(9) = 4862\n        # C(10) = 16796\n        # C(11) = 58786\n        # C(12) = 208012\n        # C(13) = 742900\n        # C(14) = 2674440\n        # C(15) = 9694845\n        # C(16) = 35357670\n        # C(17) = 129644790\n        # C(18) = 477638700\n        # C(19) = 1767263190\n        \n        # C = 1\n        # for i in range(1, n + 1):\n        #     C = C * (n + i) / i\n        # return C\n        \n        # 3. Math\n        # Time: O(n)\n        # Space: O(1)\n        # C(n) = (2n)! / (n + 1)!n!)\n        # C(0) = 1\n        # C(1) = 1\n        # C(2) = 2\n        # C(3) = 5\n        # C(4) = 14\n        # C(5) = 42\n        # C(6) = 132\n        # C(7) = 429\n        # C(8) = 1430\n        # C(9) = 4862\n        # C(10) = 16796\n        # C(11) = 58786\n        # C(12) = 208012\n        # C(13) = 742900"}, {"task_id": "unique-binary-search-trees", "completion": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. DP\n        # Time: O(n^2)\n        # Space: O(n)\n        # dp[i] = dp[0] * dp[i-1] + dp[1] * dp[i-2] + ... + dp[i-1] * dp[0]\n        # dp[0] = 1\n        # dp[1] = 1\n        # dp[2] = dp[0] * dp[1] + dp[1] * dp[0] = 2\n        # dp[3] = dp[0] * dp[2] + dp[1] * dp[1] + dp[2] * dp[0] = 5\n        # dp[4] = dp[0] * dp[3] + dp[1] * dp[2] + dp[2] * dp[1] + dp[3] * dp[0] = 14\n        # dp[5] = dp[0] * dp[4] + dp[1] * dp[3] + dp[2] * dp[2] + dp[3] * dp[1] + dp[4] * dp[0] = 42\n        # dp[6] = dp[0] * dp[5] + dp[1] * dp[4] + dp[2] * dp[3] + dp[3] * dp[2] + dp[4] * dp[1] + dp[5] * dp[0] = 132\n        # dp[7] = dp[0] * dp[6] + dp[1] * dp[5] + dp[2] * dp[4] + dp[3] * dp[3] + dp[4] * dp[2] + dp[5] * dp[1] + dp[6] * dp[0] = 429\n        # dp[8] = dp[0] * dp[7] + dp[1] * dp[6] + dp[2] * dp[5] + dp[3] * dp[4] + dp[4] * dp[3] + dp[5] * dp[2] + dp[6] * dp[1] + dp[7] * dp[0] = 1430\n        # dp[9] = dp[0] * dp[8] + dp[1] * dp[7] + dp[2] * dp[6] + dp[3] * dp[5] + dp[4] * dp[4] + dp[5] * dp[3] + dp[6] * dp[2] + dp[7] * dp[1] + dp[8] * dp[0] = 4862\n        # dp[10] = dp[0] * dp[9] + dp[1] * dp[8] + dp[2] * dp[7] + dp[3] * dp[6] + dp[4] * dp[5] + dp[5] * dp[4] + dp[6] * dp[3] + dp[7] * dp[2] + dp[8] * dp[1] + dp[9] * dp[0] = 16796\n        # dp[11] = dp[0] * dp[10] + dp[1] * dp[9] + dp[2] * dp[8] + dp[3] * dp[7] + dp[4] * dp[6] + dp[5] * dp[5] + dp[6] * dp[4] + dp[7] * dp[3] + dp[8] * dp[2] + dp[9] * dp[1] + dp[10] * dp[0] = 58786\n        # dp[12] = dp[0] * dp[11"}, {"task_id": "unique-binary-search-trees", "completion": "class Solution(object):\n    def numTrees(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. DP\n        # Time: O(n^2)\n        # Space: O(n)\n        # dp[i] = dp[0] * dp[i-1] + dp[1] * dp[i-2] + ... + dp[i-1] * dp[0]\n        # dp[0] = 1\n        # dp[1] = 1\n        # dp[2] = dp[0] * dp[1] + dp[1] * dp[0] = 2\n        # dp[3] = dp[0] * dp[2] + dp[1] * dp[1] + dp[2] * dp[0] = 5\n        # dp[4] = dp[0] * dp[3] + dp[1] * dp[2] + dp[2] * dp[1] + dp[3] * dp[0] = 14\n        # dp[5] = dp[0] * dp[4] + dp[1] * dp[3] + dp[2] * dp[2] + dp[3] * dp[1] + dp[4] * dp[0] = 42\n        # dp[6] = dp[0] * dp[5] + dp[1] * dp[4] + dp[2] * dp[3] + dp[3] * dp[2] + dp[4] * dp[1] + dp[5] * dp[0] = 132\n        # dp[7] = dp[0] * dp[6] + dp[1] * dp[5] + dp[2] * dp[4] + dp[3] * dp[3] + dp[4] * dp[2] + dp[5] * dp[1] + dp[6] * dp[0] = 429\n        # dp[8] = dp[0] * dp[7] + dp[1] * dp[6] + dp[2] * dp[5] + dp[3] * dp[4] + dp[4] * dp[3] + dp[5] * dp[2] + dp[6] * dp[1] + dp[7] * dp[0] = 1430\n        # dp[9] = dp[0] * dp[8] + dp[1] * dp[7] + dp[2] * dp[6] + dp[3] * dp[5] + dp[4] * dp[4] + dp[5] * dp[3] + dp[6] * dp[2] + dp[7] * dp[1] + dp[8] * dp[0] = 4862\n        # dp[10] = dp[0] * dp[9] + dp[1] * dp[8] + dp[2] * dp[7] + dp[3] * dp[6] + dp[4] * dp[5] + dp[5] * dp[4] + dp[6] * dp[3] + dp[7] * dp[2] + dp[8] * dp[1] + dp[9] * dp[0] = 16796\n        # dp[11] = dp[0] * dp[10] + dp[1] * dp[9] + dp[2] * dp[8] + dp[3] * dp[7] + dp[4] * dp[6] + dp[5] * dp[5] + dp[6] * dp[4] + dp[7] * dp[3] + dp[8] * dp[2] + dp[9] * dp[1] + dp[10] * dp[0] = 58786\n        # dp[12] = dp[0] * dp[11"}], "single-number-ii": [{"task_id": "single-number-ii", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key\n        \n        # Time Complexity: O(n)\n        #"}, {"task_id": "single-number-ii", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. use a dictionary to store the count of each number\n        # 2. iterate through the dictionary and return the key with value 1\n        # 3. return the key\n        \n        # 1. use a dictionary to store the count of each number\n        # 2. iterate through the dictionary and return the key with value 1\n        # 3. return the key\n        \n        # 1. use a dictionary to store the count of each number\n        # 2. iterate through the dictionary and return the key with value 1\n        # 3. return the key\n        \n        # 1. use a dictionary to store the count of each number\n        # 2. iterate through the dictionary and return the key with value 1\n        # 3. return the key\n        \n        # 1. use a dictionary to store the count of each number\n        # 2. iterate through the dictionary and return the key with value 1\n        # 3. return the key\n        \n        # 1. use a dictionary to store the count of each number\n        # 2. iterate through the dictionary and return the key with value 1\n        # 3. return the key\n        \n        # 1. use a dictionary to store the count of each number\n        # 2. iterate through the dictionary and return the key with value 1\n        # 3. return the key\n        \n        # 1. use a dictionary to store the count of each number\n        # 2. iterate through the dictionary and return the key with value 1\n        # 3. return the key\n        \n        # 1. use a dictionary to store the count of each number\n        # 2. iterate through the dictionary and return the key with value 1\n        # 3. return the key\n        \n        # 1. use a dictionary to store the count of each number\n        # 2. iterate through the dictionary and return the key with value 1\n        # 3. return the key\n        \n        # 1. use a dictionary to store the count of each number\n        # 2. iterate through the dictionary and return the key with value 1\n        # 3. return the key\n        \n        # 1. use a dictionary to store the count of each number\n        # 2. iterate through the dictionary and return the key with value 1\n        # 3. return the key\n        \n        # 1. use a dictionary to store the count of each number\n        # 2. iterate through the dictionary and return the key with value 1\n        # 3. return the key\n        \n        # 1. use a dictionary to store the count of each number\n        # 2. iterate through the dictionary and return the key with value 1\n        # 3. return the key\n        \n        # 1. use a dictionary to store the count of each number\n        # 2. iterate through the dictionary and return the key with value 1\n        # 3. return the key\n        \n        # 1. use a dictionary to store the count of each number\n        # 2. iterate through the dictionary and return the key with value 1\n        # 3. return the key\n        \n        # 1. use a dictionary to store the count of each number\n        # 2. iterate through the dictionary and return the key with value 1\n        # 3. return the key\n        \n        # 1. use a dictionary to store the count of each number\n        # 2. iterate through the dictionary and return the key with value 1\n        # 3. return the key\n        \n        # 1. use a dictionary to store the count of each number\n        # 2. iterate through the dictionary and return the key with value 1\n        # 3. return the key\n        \n        # 1. use a dictionary to store the count of each number\n        # 2. iterate through the dictionary and return the key with value 1\n        # 3. return the key\n        \n        # 1. use a dictionary to store the count of each number\n        # 2. iterate through the dictionary and return the key with value 1\n        # 3. return the key\n        \n        # 1. use a dictionary to store the count of each number\n        # 2. iterate through the dictionary and return the key with value 1\n        # 3. return the key\n        \n        # 1. use a dictionary to store the count"}, {"task_id": "single-number-ii", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key with value 1\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key with value 1\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key with value 1\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key with value 1\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key with value 1\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key with value 1\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key with value 1\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key with value 1\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key with value 1\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key with value 1\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key with value 1\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key with value 1\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key with value 1\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key with value 1\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key with value 1\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key with value 1\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key with value 1\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key with value 1\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key with value 1\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1"}, {"task_id": "single-number-ii", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. use a dictionary to store the count of each number\n        # 2. iterate through the dictionary and return the key with value 1\n        # 3. return the key with value 1\n        \n        # 1. use a dictionary to store the count of each number\n        # 2. iterate through the dictionary and return the key with value 1\n        # 3. return the key with value 1\n        \n        # 1. use a dictionary to store the count of each number\n        # 2. iterate through the dictionary and return the key with value 1\n        # 3. return the key with value 1\n        \n        # 1. use a dictionary to store the count of each number\n        # 2. iterate through the dictionary and return the key with value 1\n        # 3. return the key with value 1\n        \n        # 1. use a dictionary to store the count of each number\n        # 2. iterate through the dictionary and return the key with value 1\n        # 3. return the key with value 1\n        \n        # 1. use a dictionary to store the count of each number\n        # 2. iterate through the dictionary and return the key with value 1\n        # 3. return the key with value 1\n        \n        # 1. use a dictionary to store the count of each number\n        # 2. iterate through the dictionary and return the key with value 1\n        # 3. return the key with value 1\n        \n        # 1. use a dictionary to store the count of each number\n        # 2. iterate through the dictionary and return the key with value 1\n        # 3. return the key with value 1\n        \n        # 1. use a dictionary to store the count of each number\n        # 2. iterate through the dictionary and return the key with value 1\n        # 3. return the key with value 1\n        \n        # 1. use a dictionary to store the count of each number\n        # 2. iterate through the dictionary and return the key with value 1\n        # 3. return the key with value 1\n        \n        # 1. use a dictionary to store the count of each number\n        # 2. iterate through the dictionary and return the key with value 1\n        # 3. return the key with value 1\n        \n        # 1. use a dictionary to store the count of each number\n        # 2. iterate through the dictionary and return the key with value 1\n        # 3. return the key with value 1\n        \n        # 1. use a dictionary to store the count of each number\n        # 2. iterate through the dictionary and return the key with value 1\n        # 3. return the key with value 1\n        \n        # 1. use a dictionary to store the count of each number\n        # 2. iterate through the dictionary and return the key with value 1\n        # 3. return the key with value 1\n        \n        # 1. use a dictionary to store the count of each number\n        # 2. iterate through the dictionary and return the key with value 1\n        # 3. return the key with value 1\n        \n        # 1. use a dictionary to store the count of each number\n        # 2. iterate through the dictionary and return the key with value 1\n        # 3. return the key with value 1\n        \n        # 1. use a dictionary to store the count of each number\n        # 2. iterate through the dictionary and return the key with value 1\n        # 3. return the key with value 1\n        \n        # 1. use a dictionary to store the count of each number\n        # 2. iterate through the dictionary and return the key with value 1\n        # 3. return the key with value 1\n        \n        # 1. use a dictionary to store the count of each number\n        # 2. iterate through the dictionary and return the key with value 1\n        # 3. return the key with value 1\n        \n        # 1. use a dictionary to store the count of each number\n        # 2. iterate through the dictionary and return the key with value 1\n        # 3. return the key with value 1\n        \n        # 1. use a dictionary to store the count of each number\n        # 2. iterate through"}, {"task_id": "single-number-ii", "completion": "class Solution(object):\n    def singleNumber(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key\n        \n        # 1. use a hashmap to store the count of each number\n        # 2. iterate through the hashmap and return the key with value 1\n        # 3. return the key\n        \n        # 1. use a hashmap to store the count of each number"}], "stickers-to-spell-word": [{"task_id": "stickers-to-spell-word", "completion": "class Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u5148\u7edf\u8ba1target\u4e2d\u6bcf\u4e2a\u5b57\u7b26\u7684\u4e2a\u6570\n        target_count = collections.Counter(target)\n        \n        # 2. \u7edf\u8ba1\u6bcf\u4e2asticker\u4e2d\u6bcf\u4e2a\u5b57\u7b26\u7684\u4e2a\u6570\n        sticker_counts = []\n        for sticker in stickers:\n            sticker_counts.append(collections.Counter(sticker))\n        \n        # 3. \u5b9a\u4e49dp\u6570\u7ec4\uff0cdp[i]\u8868\u793atarget\u4e2d\u524di\u4e2a\u5b57\u7b26\u9700\u8981\u7684\u6700\u5c11sticker\u6570\n        dp = [float('inf')] * (len(target) + 1)\n        dp[0] = 0\n        \n        # 4. \u904d\u5386target\u4e2d\u7684\u6bcf\u4e2a\u5b57\u7b26\n        for i in range(1, len(target) + 1):\n            # 5. \u904d\u5386\u6bcf\u4e2asticker\n            for sticker_count in sticker_counts:\n                # 6. \u5982\u679c\u5f53\u524dsticker\u4e2d\u5305\u542btarget[i-1]\uff0c\u5219\u66f4\u65b0dp[i]\n                if target[i-1] in sticker_count:\n                    # 7. \u8ba1\u7b97\u5f53\u524dsticker\u4e2dtarget[i-1]\u7684\u4e2a\u6570\n                    count = sticker_count[target[i-1]]\n                    # 8. \u8ba1\u7b97target\u4e2d\u524di\u4e2a\u5b57\u7b26\u9700\u8981\u7684\u6700\u5c11sticker\u6570\n                    dp[i] = min(dp[i], dp[i-count] + 1)\n        \n        # 9. \u5982\u679cdp[len(target)] == float('inf')\uff0c\u5219\u8bf4\u660etarget\u65e0\u6cd5\u7531stickers\u7ec4\u6210\uff0c\u8fd4\u56de-1\n        if dp[len(target)] == float('inf'):\n            return -1\n        # 10. \u5426\u5219\uff0c\u8fd4\u56dedp[len(target)]\n        return dp[len(target)]"}, {"task_id": "stickers-to-spell-word", "completion": "class Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10."}, {"task_id": "stickers-to-spell-word", "completion": "class Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10."}, {"task_id": "stickers-to-spell-word", "completion": "class Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10."}, {"task_id": "stickers-to-spell-word", "completion": "class Solution(object):\n    def minStickers(self, stickers, target):\n        \"\"\"\n        :type stickers: List[str]\n        :type target: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u5148\u7edf\u8ba1target\u4e2d\u6bcf\u4e2a\u5b57\u6bcd\u7684\u4e2a\u6570\n        target_count = collections.Counter(target)\n        \n        # 2. \u7edf\u8ba1\u6bcf\u4e2asticker\u4e2d\u6bcf\u4e2a\u5b57\u6bcd\u7684\u4e2a\u6570\n        sticker_counts = []\n        for sticker in stickers:\n            sticker_counts.append(collections.Counter(sticker))\n        \n        # 3. \u5b9a\u4e49dp\u6570\u7ec4\uff0cdp[i]\u8868\u793atarget\u4e2d\u524di\u4e2a\u5b57\u6bcd\u7684\u6700\u5c11sticker\u6570\n        dp = [float('inf')] * (len(target) + 1)\n        dp[0] = 0\n        \n        # 4. \u904d\u5386target\u4e2d\u7684\u6bcf\u4e2a\u5b57\u6bcd\n        for i in range(1, len(target) + 1):\n            # 5. \u904d\u5386\u6bcf\u4e2asticker\n            for sticker_count in sticker_counts:\n                # 6. \u5982\u679c\u5f53\u524dsticker\u4e2d\u5305\u542btarget[i-1]\uff0c\u5219\u66f4\u65b0dp[i]\n                if target[i-1] in sticker_count:\n                    # 7. \u8ba1\u7b97\u5f53\u524dsticker\u4e2dtarget[i-1]\u7684\u4e2a\u6570\n                    count = sticker_count[target[i-1]]\n                    # 8. \u8ba1\u7b97target\u4e2d\u524di\u4e2a\u5b57\u6bcd\u7684\u6700\u5c11sticker\u6570\n                    dp[i] = min(dp[i], dp[i-count] + 1)\n        \n        # 9. \u5982\u679cdp[len(target)] == float('inf')\uff0c\u5219\u8fd4\u56de-1\uff0c\u5426\u5219\u8fd4\u56dedp[len(target)]\n        return dp[len(target)] if dp[len(target)] != float('inf') else -1"}], "strange-printer": [{"task_id": "strange-printer", "completion": "class Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = min(dp[i][k] + dp[k+1][j]) for k in range(i, j)\n        # dp[i][j] = 1 if i == j\n        # dp[i][j] = 2 if i == j-1\n        # dp[i][j] = 1 if s[i] == s[j]\n        # dp[i][j] = 2 if s[i] != s[j]\n        \n        n = len(s)\n        dp = [[0 for _ in range(n)] for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n            if i < n-1:\n                dp[i][i+1] = 2 if s[i] != s[i+1] else 1\n        for i in range(n-2, -1, -1):\n            for j in range(i+2, n):\n                dp[i][j] = dp[i][j-1] + 1\n                for k in range(i, j):\n                    if s[k] == s[j]:\n                        dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j])\n        return dp[0][n-1]"}, {"task_id": "strange-printer", "completion": "class Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = min(dp[i][k] + dp[k+1][j]) for k in range(i, j)\n        # dp[i][j] = 1 if i == j\n        # dp[i][j] = 2 if i == j-1\n        # dp[i][j] = 1 if s[i] == s[j]\n        # dp[i][j] = 2 if s[i] != s[j]\n        \n        n = len(s)\n        dp = [[0 for _ in range(n)] for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n            if i < n-1:\n                dp[i][i+1] = 2 if s[i] != s[i+1] else 1\n        for i in range(n-2, -1, -1):\n            for j in range(i+2, n):\n                dp[i][j] = dp[i][j-1] + 1\n                for k in range(i, j):\n                    if s[k] == s[j]:\n                        dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j])\n        return dp[0][n-1]"}, {"task_id": "strange-printer", "completion": "class Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = min(dp[i][k] + dp[k+1][j]) for k in range(i, j)\n        # dp[i][j] = 1 if i == j\n        # dp[i][j] = 2 if i == j-1\n        # dp[i][j] = 1 if s[i] == s[j]\n        # dp[i][j] = 2 if s[i] != s[j]\n        \n        n = len(s)\n        dp = [[0 for _ in range(n)] for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n            if i < n-1:\n                dp[i][i+1] = 2 if s[i] != s[i+1] else 1\n        for i in range(n-2, -1, -1):\n            for j in range(i+2, n):\n                dp[i][j] = dp[i][j-1] + 1\n                for k in range(i, j):\n                    if s[k] == s[j]:\n                        dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j])\n        return dp[0][n-1]"}, {"task_id": "strange-printer", "completion": "class Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = min(dp[i][k] + dp[k+1][j]) for k in range(i, j)\n        # dp[i][j] = 1 if i == j\n        # dp[i][j] = 2 if i == j-1\n        # dp[i][j] = 1 if s[i] == s[j]\n        # dp[i][j] = 2 if s[i] != s[j]\n        \n        n = len(s)\n        dp = [[0 for _ in range(n)] for _ in range(n)]\n        for i in range(n):\n            dp[i][i] = 1\n            if i < n-1:\n                dp[i][i+1] = 2 if s[i] != s[i+1] else 1\n        for i in range(n-2, -1, -1):\n            for j in range(i+2, n):\n                dp[i][j] = dp[i][j-1] + 1\n                for k in range(i, j):\n                    if s[k] == s[j]:\n                        dp[i][j] = min(dp[i][j], dp[i][k] + dp[k+1][j])\n        return dp[0][n-1]"}, {"task_id": "strange-printer", "completion": "class Solution(object):\n    def strangePrinter(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i][j] = min(dp[i][k] + dp[k+1][j]) for k in range(i, j)\n        # dp[i][j] = 1 if i == j\n        # dp[i][j] = 2 if i == j-1 and s[i] == s[j]\n        # dp[i][j] = 2 if i == j-1 and s[i] != s[j]\n        # dp[i][j] = 3 if i == j-2 and s[i] == s[j]\n        # dp[i][j] = 3 if i == j-2 and s[i] != s[j]\n        # dp[i][j] = 4 if i == j-3 and s[i] == s[j]\n        # dp[i][j] = 4 if i == j-3 and s[i] != s[j]\n        # dp[i][j] = 5 if i == j-4 and s[i] == s[j]\n        # dp[i][j] = 5 if i == j-4 and s[i] != s[j]\n        # dp[i][j] = 6 if i == j-5 and s[i] == s[j]\n        # dp[i][j] = 6 if i == j-5 and s[i] != s[j]\n        # dp[i][j] = 7 if i == j-6 and s[i] == s[j]\n        # dp[i][j] = 7 if i == j-6 and s[i] != s[j]\n        # dp[i][j] = 8 if i == j-7 and s[i] == s[j]\n        # dp[i][j] = 8 if i == j-7 and s[i] != s[j]\n        # dp[i][j] = 9 if i == j-8 and s[i] == s[j]\n        # dp[i][j] = 9 if i == j-8 and s[i] != s[j]\n        # dp[i][j] = 10 if i == j-9 and s[i] == s[j]\n        # dp[i][j] = 10 if i == j-9 and s[i] != s[j]\n        # dp[i][j] = 11 if i == j-10 and s[i] == s[j]\n        # dp[i][j] = 11 if i == j-10 and s[i] != s[j]\n        # dp[i][j] = 12 if i == j-11 and s[i] == s[j]\n        # dp[i][j] = 12 if i == j-11 and s[i] != s[j]\n        # dp[i][j] = 13 if i == j-12 and s[i] == s[j]\n        # dp[i][j] = 13 if i == j-12 and s[i] != s[j]\n        # dp[i][j] = 14 if i == j-13 and s[i] == s[j]\n        # dp[i][j] = 14 if i == j-13 and s[i] != s[j]\n        # dp[i][j] = 15 if i == j-14 and s[i] == s[j]\n        # dp[i][j] = 15 if i == j-14 and s[i] != s[j]\n        # dp[i][j] = 16 if i == j-15 and s[i] == s[j]\n        # dp[i][j] = 16 if i == j-15 and s[i] != s[j]\n        # dp[i][j] = 17 if i == j-16 and s[i] == s[j]\n        # dp[i][j] = 17 if i == j-16 and s[i] != s[j]\n        # dp[i][j] = 18 if i == j-17 and s[i] == s[j"}], "sqrtx": [{"task_id": "sqrtx", "completion": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x == 0:\n            return 0\n        \n        if x == 1:\n            return 1\n        \n        left = 0\n        right = x\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if mid * mid <= x < (mid + 1) * (mid + 1):\n                return mid\n            elif mid * mid > x:\n                right = mid - 1\n            else:\n                left = mid + 1\n                \n        return mid"}, {"task_id": "sqrtx", "completion": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x == 0:\n            return 0\n        \n        left = 1\n        right = x\n        \n        while left <= right:\n            mid = left + (right - left) // 2\n            if mid * mid <= x < (mid + 1) * (mid + 1):\n                return mid\n            elif mid * mid > x:\n                right = mid - 1\n            else:\n                left = mid + 1\n                \n        return -1"}, {"task_id": "sqrtx", "completion": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x == 0:\n            return 0\n        \n        if x == 1:\n            return 1\n        \n        left = 0\n        right = x\n        \n        while left <= right:\n            mid = (left + right) // 2\n            \n            if mid * mid <= x < (mid + 1) * (mid + 1):\n                return mid\n            \n            elif mid * mid > x:\n                right = mid - 1\n                \n            else:\n                left = mid + 1"}, {"task_id": "sqrtx", "completion": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x == 0:\n            return 0\n        \n        if x == 1:\n            return 1\n        \n        left = 0\n        right = x\n        \n        while left <= right:\n            mid = (left + right) // 2\n            if mid * mid <= x < (mid + 1) * (mid + 1):\n                return mid\n            elif mid * mid > x:\n                right = mid - 1\n            else:\n                left = mid + 1"}, {"task_id": "sqrtx", "completion": "class Solution(object):\n    def mySqrt(self, x):\n        \"\"\"\n        :type x: int\n        :rtype: int\n        \"\"\"\n        \n        if x == 0:\n            return 0\n        \n        if x == 1:\n            return 1\n        \n        left = 0\n        right = x\n        \n        while left < right:\n            mid = (left + right) // 2\n            if mid * mid <= x < (mid + 1) * (mid + 1):\n                return mid\n            elif mid * mid > x:\n                right = mid\n            else:\n                left = mid + 1\n                \n        return left"}], "roman-to-integer": [{"task_id": "roman-to-integer", "completion": "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        roman_dict = {\n            'I': 1,\n            'V': 5,\n            'X': 10,\n            'L': 50,\n            'C': 100,\n            'D': 500,\n            'M': 1000\n        }\n        \n        result = 0\n        for i in range(len(s)):\n            if i > 0 and roman_dict[s[i]] > roman_dict[s[i-1]]:\n                result += roman_dict[s[i]] - 2 * roman_dict[s[i-1]]\n            else:\n                result += roman_dict[s[i]]\n        return result"}, {"task_id": "roman-to-integer", "completion": "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        roman_dict = {\n            'I': 1,\n            'V': 5,\n            'X': 10,\n            'L': 50,\n            'C': 100,\n            'D': 500,\n            'M': 1000\n        }\n        \n        result = 0\n        for i in range(len(s)):\n            if i > 0 and roman_dict[s[i]] > roman_dict[s[i-1]]:\n                result += roman_dict[s[i]] - 2 * roman_dict[s[i-1]]\n            else:\n                result += roman_dict[s[i]]\n        return result"}, {"task_id": "roman-to-integer", "completion": "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        roman_dict = {\n            'I': 1,\n            'V': 5,\n            'X': 10,\n            'L': 50,\n            'C': 100,\n            'D': 500,\n            'M': 1000\n        }\n        \n        total = 0\n        i = 0\n        while i < len(s):\n            if i < len(s) - 1 and roman_dict[s[i]] < roman_dict[s[i+1]]:\n                total += roman_dict[s[i+1]] - roman_dict[s[i]]\n                i += 2\n            else:\n                total += roman_dict[s[i]]\n                i += 1\n        return total"}, {"task_id": "roman-to-integer", "completion": "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        roman_dict = {\n            'I': 1,\n            'V': 5,\n            'X': 10,\n            'L': 50,\n            'C': 100,\n            'D': 500,\n            'M': 1000\n        }\n        \n        total = 0\n        i = 0\n        while i < len(s):\n            if i < len(s) - 1 and roman_dict[s[i]] < roman_dict[s[i+1]]:\n                total += roman_dict[s[i+1]] - roman_dict[s[i]]\n                i += 2\n            else:\n                total += roman_dict[s[i]]\n                i += 1\n        return total"}, {"task_id": "roman-to-integer", "completion": "class Solution(object):\n    def romanToInt(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # create a dictionary to store the values of the roman numerals\n        roman_dict = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100, 'D': 500, 'M': 1000}\n        \n        # initialize the result variable\n        result = 0\n        \n        # loop through the string\n        for i in range(len(s)):\n            # if the current character is less than the next character, subtract the current character from the next character\n            if i < len(s) - 1 and roman_dict[s[i]] < roman_dict[s[i + 1]]:\n                result -= roman_dict[s[i]]\n            # otherwise, add the current character to the result\n            else:\n                result += roman_dict[s[i]]\n        \n        # return the result\n        return result"}], "contains-duplicate": [{"task_id": "contains-duplicate", "completion": "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. sort the array\n        # 2. iterate through the array and check if the current element is equal to the previous element\n        # 3. if it is, return True\n        # 4. if not, return False\n        \n        nums.sort()\n        for i in range(1, len(nums)):\n            if nums[i] == nums[i-1]:\n                return True\n        return False"}, {"task_id": "contains-duplicate", "completion": "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        ## Solution 1:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## Runtime: 100 ms, faster than 99.98% of Python online submissions for Contains Duplicate.\n        ## Memory Usage: 26.1 MB, less than 99.99% of Python online submissions for Contains Duplicate.\n        ##\n        ## Solution 2:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## Runtime: 100 ms, faster than 99.98% of Python online submissions for Contains Duplicate.\n        ## Memory Usage: 26.1 MB, less than 99.99% of Python online submissions for Contains Duplicate.\n        ##\n        ## Solution 3:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## Runtime: 100 ms, faster than 99.98% of Python online submissions for Contains Duplicate.\n        ## Memory Usage: 26.1 MB, less than 99.99% of Python online submissions for Contains Duplicate.\n        ##\n        ## Solution 4:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## Runtime: 100 ms, faster than 99.98% of Python online submissions for Contains Duplicate.\n        ## Memory Usage: 26.1 MB, less than 99.99% of Python online submissions for Contains Duplicate.\n        ##\n        ## Solution 5:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## Runtime: 100 ms, faster than 99.98% of Python online submissions for Contains Duplicate.\n        ## Memory Usage: 26.1 MB, less than 99.99% of Python online submissions for Contains Duplicate.\n        ##\n        ## Solution 6:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## Runtime: 100 ms, faster than 99.98% of Python online submissions for Contains Duplicate.\n        ## Memory Usage: 26.1 MB, less than 99.99% of Python online submissions for Contains Duplicate.\n        ##\n        ## Solution 7:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## Runtime: 100 ms, faster than 99.98% of Python online submissions for Contains Duplicate.\n        ## Memory Usage: 26.1 MB, less than 99.99% of Python online submissions for Contains Duplicate.\n        ##\n        ## Solution 8:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## Runtime: 100 ms, faster than 99.98% of Python online submissions for Contains Duplicate.\n        ## Memory Usage: 26.1 MB, less than 99.99% of Python online submissions for Contains Duplicate.\n        ##\n        ## Solution 9:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## Runtime: 100 ms, faster than 99.98% of Python online submissions for Contains Duplicate.\n        ## Memory Usage: 26.1 MB, less than 99.99% of Python online submissions for Contains Duplicate.\n        ##\n        ## Solution 10:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## Runtime: 100 ms, faster than 99.98% of Python online submissions for Contains Duplicate.\n        #"}, {"task_id": "contains-duplicate", "completion": "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        ## Solution 1:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## Runtime: 100 ms, faster than 99.19% of Python online submissions for Contains Duplicate.\n        ## Memory Usage: 26.1 MB, less than 99.22% of Python online submissions for Contains Duplicate.\n        ## 1. Create a set\n        ## 2. Iterate through the list\n        ## 3. If the number is in the set, return True\n        ## 4. If the number is not in the set, add it to the set\n        ## 5. If the number is not in the set, return False\n        ## 6. Return False\n        \n        ## Solution 2:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## Runtime: 100 ms, faster than 99.19% of Python online submissions for Contains Duplicate.\n        ## Memory Usage: 26.1 MB, less than 99.22% of Python online submissions for Contains Duplicate.\n        ## 1. Create a set\n        ## 2. Iterate through the list\n        ## 3. If the number is in the set, return True\n        ## 4. If the number is not in the set, add it to the set\n        ## 5. If the number is not in the set, return False\n        ## 6. Return False\n        \n        ## Solution 3:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## Runtime: 100 ms, faster than 99.19% of Python online submissions for Contains Duplicate.\n        ## Memory Usage: 26.1 MB, less than 99.22% of Python online submissions for Contains Duplicate.\n        ## 1. Create a set\n        ## 2. Iterate through the list\n        ## 3. If the number is in the set, return True\n        ## 4. If the number is not in the set, add it to the set\n        ## 5. If the number is not in the set, return False\n        ## 6. Return False\n        \n        ## Solution 4:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## Runtime: 100 ms, faster than 99.19% of Python online submissions for Contains Duplicate.\n        ## Memory Usage: 26.1 MB, less than 99.22% of Python online submissions for Contains Duplicate.\n        ## 1. Create a set\n        ## 2. Iterate through the list\n        ## 3. If the number is in the set, return True\n        ## 4. If the number is not in the set, add it to the set\n        ## 5. If the number is not in the set, return False\n        ## 6. Return False\n        \n        ## Solution 5:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## Runtime: 100 ms, faster than 99.19% of Python online submissions for Contains Duplicate.\n        ## Memory Usage: 26.1 MB, less than 99.22% of Python online submissions for Contains Duplicate.\n        ## 1. Create a set\n        ## 2. Iterate through the list\n        ## 3. If the number is in the set, return True\n        ## 4. If the number is not in the set, add it to the set\n        ## 5. If the number is not in the set, return False\n        ## 6. Return False\n        \n        ## Solution 6:\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(n)\n        ## Runtime: 100 ms, faster than 99.19% of Python online submissions for Contains Duplicate.\n        #"}, {"task_id": "contains-duplicate", "completion": "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. sort the array\n        # 2. iterate through the array and check if the current element is equal to the previous element\n        # 3. if it is, return True\n        # 4. if not, return False\n        \n        nums.sort()\n        for i in range(1, len(nums)):\n            if nums[i] == nums[i-1]:\n                return True\n        return False"}, {"task_id": "contains-duplicate", "completion": "class Solution(object):\n    def containsDuplicate(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. sort the array\n        # 2. iterate through the array and check if the current element is equal to the previous element\n        # 3. if it is, return True\n        # 4. if not, return False\n        \n        nums.sort()\n        for i in range(1, len(nums)):\n            if nums[i] == nums[i-1]:\n                return True\n        return False"}], "sliding-window-maximum": [{"task_id": "sliding-window-maximum", "completion": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. create a deque\n        # 2. iterate through the array\n        # 3. if the deque is not empty and the current element is greater than the last element in the deque, pop the last element\n        # 4. append the current element to the deque\n        # 5. if the index of the current element is greater than or equal to k-1, append the first element in the deque to the result\n        # 6. return the result\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        from collections import deque\n        \n        if not nums:\n            return []\n        \n        if k == 1:\n            return nums\n        \n        dq = deque()\n        res = []\n        \n        for i in range(len(nums)):\n            while dq and nums[i] > nums[dq[-1]]:\n                dq.pop()\n            dq.append(i)\n            if i >= k-1:\n                res.append(nums[dq[0]])\n            if dq[0] == i-k+1:\n                dq.popleft()\n        return res"}, {"task_id": "sliding-window-maximum", "completion": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. create a deque\n        # 2. iterate through the array\n        # 3. if the current element is greater than the last element in the deque, pop the last element\n        # 4. append the current element to the deque\n        # 5. if the index of the current element is greater than or equal to k, append the first element in the deque to the result\n        # 6. return the result\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        if not nums:\n            return []\n        \n        if k == 1:\n            return nums\n        \n        if k == len(nums):\n            return [max(nums)]\n        \n        from collections import deque\n        q = deque()\n        res = []\n        \n        for i in range(len(nums)):\n            while q and nums[i] > nums[q[-1]]:\n                q.pop()\n            q.append(i)\n            if i >= k - 1:\n                res.append(nums[q[0]])\n            if q[0] == i - k + 1:\n                q.popleft()\n        return res"}, {"task_id": "sliding-window-maximum", "completion": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. create a deque\n        # 2. iterate through the array\n        # 3. if the deque is not empty and the current element is greater than the last element in the deque, pop the last element\n        # 4. append the current element to the deque\n        # 5. if the current element is greater than the first element in the deque, pop the first element\n        # 6. if the current element is less than the first element in the deque, append the current element to the deque\n        # 7. if the current element is less than the last element in the deque, append the current element to the deque\n        # 8. if the current element is greater than the last element in the deque, pop the last element\n        # 9. if the current element is less than the first element in the deque, pop the first element\n        # 10. if the current element is greater than the first element in the deque, pop the first element\n        # 11. if the current element is less than the last element in the deque, pop the last element\n        # 12. if the current element is greater than the last element in the deque, pop the last element\n        # 13. if the current element is less than the first element in the deque, pop the first element\n        # 14. if the current element is greater than the first element in the deque, pop the first element\n        # 15. if the current element is less than the last element in the deque, pop the last element\n        # 16. if the current element is greater than the last element in the deque, pop the last element\n        # 17. if the current element is less than the first element in the deque, pop the first element\n        # 18. if the current element is greater than the first element in the deque, pop the first element\n        # 19. if the current element is less than the last element in the deque, pop the last element\n        # 20. if the current element is greater than the last element in the deque, pop the last element\n        # 21. if the current element is less than the first element in the deque, pop the first element\n        # 22. if the current element is greater than the first element in the deque, pop the first element\n        # 23. if the current element is less than the last element in the deque, pop the last element\n        # 24. if the current element is greater than the last element in the deque, pop the last element\n        # 25. if the current element is less than the first element in the deque, pop the first element\n        # 26. if the current element is greater than the first element in the deque, pop the first element\n        # 27. if the current element is less than the last element in the deque, pop the last element\n        # 28. if the current element is greater than the last element in the deque, pop the last element\n        # 29. if the current element is less than the first element in the deque, pop the first element\n        # 30. if the current element is greater than the first element in the deque, pop the first element\n        # 31. if the current element is less than the last element in the deque, pop the last element\n        # 32. if the current element is greater than the last element in the deque, pop the last element\n        # 33. if the current element is less than the first element in the deque, pop the first element\n        # 34. if the current element is greater than the first element in the deque, pop the first element\n        # 35. if the current element is less than the last element in the deque, pop the last element\n        # 36. if the current element is greater than the last element in the deque, pop the last element\n        # 37. if the current element is less than the first element in the deque, pop the first element\n        # 38. if the current element is greater than the first element in the deque, pop the first element\n        # 39. if the current element is less than the last element in the deque, pop the last element\n        # 40. if the current element is greater than the last element in the deque, pop the last element\n        # 41. if the current element is less than the first element in the"}, {"task_id": "sliding-window-maximum", "completion": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. create a deque\n        # 2. iterate through the array\n        # 3. if the current element is greater than the last element in the deque, pop the last element\n        # 4. append the current element to the deque\n        # 5. if the index of the current element is greater than or equal to k, append the first element in the deque to the result\n        # 6. return the result\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # 1. create a deque\n        d = collections.deque()\n        \n        # 2. iterate through the array\n        for i in range(len(nums)):\n            \n            # 3. if the current element is greater than the last element in the deque, pop the last element\n            while d and nums[i] > nums[d[-1]]:\n                d.pop()\n            \n            # 4. append the current element to the deque\n            d.append(i)\n            \n            # 5. if the index of the current element is greater than or equal to k, append the first element in the deque to the result\n            if d[0] == i - k:\n                d.popleft()\n            \n            # 6. return the result\n            if i >= k - 1:\n                yield nums[d[0]]\n<jup\nclass Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. create a deque\n        # 2. iterate through the array\n        # 3. if the current element is greater than the last element in the deque, pop the last element\n        # 4. append the current element to the deque\n        # 5. if the index of the current element is greater than or equal to k, append the first element in the deque to the result\n        # 6. return the result\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # 1. create a deque\n        d = collections.deque()\n        \n        # 2. iterate through the array\n        for i in range(len(nums)):\n            \n            # 3. if the current element is greater than the last element in the deque, pop the last element\n            while d and nums[i] > nums[d[-1]]:\n                d.pop()\n            \n            # 4. append the current element to the deque\n            d.append(i)\n            \n            # 5. if the index of the current element is greater than or equal to k, append the first element in the deque to the result\n            if d[0] == i - k:\n                d.popleft()\n            \n            # 6. return the result\n            if i >= k - 1:\n                yield nums[d[0]]\n<jupyter_output>\n<empty_output>"}, {"task_id": "sliding-window-maximum", "completion": "class Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. create a deque\n        # 2. iterate through the array\n        # 3. if the current element is greater than the last element in the deque, pop the last element\n        # 4. append the current element to the deque\n        # 5. if the index of the current element is greater than or equal to k, append the first element in the deque to the result\n        # 6. return the result\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # 1. create a deque\n        d = collections.deque()\n        \n        # 2. iterate through the array\n        for i in range(len(nums)):\n            \n            # 3. if the current element is greater than the last element in the deque, pop the last element\n            while d and nums[i] > nums[d[-1]]:\n                d.pop()\n            \n            # 4. append the current element to the deque\n            d.append(i)\n            \n            # 5. if the index of the current element is greater than or equal to k, append the first element in the deque to the result\n            if d[0] == i - k:\n                d.popleft()\n            \n            # 6. return the result\n            if i >= k - 1:\n                yield nums[d[0]]\n<jup\nclass Solution(object):\n    def maxSlidingWindow(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. create a deque\n        # 2. iterate through the array\n        # 3. if the current element is greater than the last element in the deque, pop the last element\n        # 4. append the current element to the deque\n        # 5. if the index of the current element is greater than or equal to k, append the first element in the deque to the result\n        # 6. return the result\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # 1. create a deque\n        d = collections.deque()\n        \n        # 2. iterate through the array\n        for i in range(len(nums)):\n            \n            # 3. if the current element is greater than the last element in the deque, pop the last element\n            while d and nums[i] > nums[d[-1]]:\n                d.pop()\n            \n            # 4. append the current element to the deque\n            d.append(i)\n            \n            # 5. if the index of the current element is greater than or equal to k, append the first element in the deque to the result\n            if d[0] == i - k:\n                d.popleft()\n            \n            # 6. return the result\n            if i >= k - 1:\n                yield nums[d[0]]\n<jupyter_output>\n<empty_output>"}], "median-of-two-sorted-arrays": [{"task_id": "median-of-two-sorted-arrays", "completion": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        \n        # merge the two arrays\n        merged = []\n        i = 0\n        j = 0\n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] < nums2[j]:\n                merged.append(nums1[i])\n                i += 1\n            else:\n                merged.append(nums2[j])\n                j += 1\n        while i < len(nums1):\n            merged.append(nums1[i])\n            i += 1\n        while j < len(nums2):\n            merged.append(nums2[j])\n            j += 1\n        \n        # find the median\n        if len(merged) % 2 == 0:\n            return (merged[len(merged) // 2 - 1] + merged[len(merged) // 2]) / 2.0\n        else:\n            return merged[len(merged) // 2]"}, {"task_id": "median-of-two-sorted-arrays", "completion": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        \n        # merge the two arrays\n        merged = []\n        i = 0\n        j = 0\n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] < nums2[j]:\n                merged.append(nums1[i])\n                i += 1\n            else:\n                merged.append(nums2[j])\n                j += 1\n        while i < len(nums1):\n            merged.append(nums1[i])\n            i += 1\n        while j < len(nums2):\n            merged.append(nums2[j])\n            j += 1\n        \n        # find the median\n        if len(merged) % 2 == 0:\n            return (merged[len(merged) // 2 - 1] + merged[len(merged) // 2]) / 2.0\n        else:\n            return merged[len(merged) // 2]"}, {"task_id": "median-of-two-sorted-arrays", "completion": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        \n        # merge the two arrays\n        merged = []\n        i = 0\n        j = 0\n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] < nums2[j]:\n                merged.append(nums1[i])\n                i += 1\n            else:\n                merged.append(nums2[j])\n                j += 1\n        while i < len(nums1):\n            merged.append(nums1[i])\n            i += 1\n        while j < len(nums2):\n            merged.append(nums2[j])\n            j += 1\n        \n        # find the median\n        if len(merged) % 2 == 0:\n            return (merged[len(merged) // 2 - 1] + merged[len(merged) // 2]) / 2.0\n        else:\n            return merged[len(merged) // 2]"}, {"task_id": "median-of-two-sorted-arrays", "completion": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        \n        # merge the two arrays\n        merged = []\n        i = 0\n        j = 0\n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] < nums2[j]:\n                merged.append(nums1[i])\n                i += 1\n            else:\n                merged.append(nums2[j])\n                j += 1\n        while i < len(nums1):\n            merged.append(nums1[i])\n            i += 1\n        while j < len(nums2):\n            merged.append(nums2[j])\n            j += 1\n        \n        # find the median\n        if len(merged) % 2 == 0:\n            return (merged[len(merged) // 2 - 1] + merged[len(merged) // 2]) / 2.0\n        else:\n            return merged[len(merged) // 2]"}, {"task_id": "median-of-two-sorted-arrays", "completion": "class Solution(object):\n    def findMedianSortedArrays(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: float\n        \"\"\"\n        \n        # merge the two arrays\n        merged = []\n        i = 0\n        j = 0\n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] < nums2[j]:\n                merged.append(nums1[i])\n                i += 1\n            else:\n                merged.append(nums2[j])\n                j += 1\n        while i < len(nums1):\n            merged.append(nums1[i])\n            i += 1\n        while j < len(nums2):\n            merged.append(nums2[j])\n            j += 1\n        \n        # find the median\n        if len(merged) % 2 == 0:\n            return (merged[len(merged) // 2 - 1] + merged[len(merged) // 2]) / 2.0\n        else:\n            return merged[len(merged) // 2]"}], "find-minimum-in-rotated-sorted-array": [{"task_id": "find-minimum-in-rotated-sorted-array", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u4e8c\u5206\u67e5\u627e\n        # 2. \u4e8c\u5206\u67e5\u627e\u7684\u6761\u4ef6\u662f\uff1a\n        # 3. \u5982\u679c\u4e2d\u95f4\u503c\u5927\u4e8e\u6700\u53f3\u8fb9\u7684\u503c\uff0c\u5219\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u5426\u5219\u5728\u5de6\u8fb9\n        # 4. \u5982\u679c\u4e2d\u95f4\u503c\u5c0f\u4e8e\u6700\u53f3\u8fb9\u7684\u503c\uff0c\u5219\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u5de6\u8fb9\uff0c\u5426\u5219\u5728\u53f3\u8fb9\n        # 5. \u5982\u679c\u4e2d\u95f4\u503c\u5c0f\u4e8e\u6700\u53f3\u8fb9\u7684\u503c\uff0c\u5219\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u5de6\u8fb9\uff0c\u5426\u5219\u5728\u53f3\u8fb9\n        # 6. \u5982\u679c\u4e2d\u95f4\u503c\u5927\u4e8e\u6700\u53f3\u8fb9\u7684\u503c\uff0c\u5219\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u5426\u5219\u5728\u5de6\u8fb9\n        # 7. \u5982\u679c\u4e2d\u95f4\u503c\u5c0f\u4e8e\u6700\u53f3\u8fb9\u7684\u503c\uff0c\u5219\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u5de6\u8fb9\uff0c\u5426\u5219\u5728\u53f3\u8fb9\n        # 8. \u5982\u679c\u4e2d\u95f4\u503c\u5927\u4e8e\u6700\u53f3\u8fb9\u7684\u503c\uff0c\u5219\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u5426\u5219\u5728\u5de6\u8fb9\n        # 9. \u5982\u679c\u4e2d\u95f4\u503c\u5c0f\u4e8e\u6700\u53f3\u8fb9\u7684\u503c\uff0c\u5219\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u5de6\u8fb9\uff0c\u5426\u5219\u5728\u53f3\u8fb9\n        # 10. \u5982\u679c\u4e2d\u95f4\u503c\u5927\u4e8e\u6700\u53f3\u8fb9\u7684\u503c\uff0c\u5219\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u5426\u5219\u5728\u5de6\u8fb9\n        # 11. \u5982\u679c\u4e2d\u95f4\u503c\u5c0f\u4e8e\u6700\u53f3\u8fb9\u7684\u503c\uff0c\u5219\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u5de6\u8fb9\uff0c\u5426\u5219\u5728\u53f3\u8fb9\n        # 12. \u5982\u679c\u4e2d\u95f4\u503c\u5927\u4e8e\u6700\u53f3\u8fb9\u7684\u503c\uff0c\u5219\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u5426\u5219\u5728\u5de6\u8fb9\n        # 13. \u5982\u679c\u4e2d\u95f4\u503c\u5c0f\u4e8e\u6700\u53f3\u8fb9\u7684\u503c\uff0c\u5219\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u5de6\u8fb9\uff0c\u5426\u5219\u5728\u53f3\u8fb9\n        # 14. \u5982\u679c\u4e2d\u95f4\u503c\u5927\u4e8e\u6700\u53f3\u8fb9\u7684\u503c\uff0c\u5219\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u5426\u5219\u5728\u5de6\u8fb9\n        # 15. \u5982\u679c\u4e2d\u95f4\u503c\u5c0f\u4e8e\u6700\u53f3\u8fb9\u7684\u503c\uff0c\u5219\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u5de6\u8fb9\uff0c\u5426\u5219\u5728\u53f3\u8fb9\n        # 16. \u5982\u679c\u4e2d\u95f4\u503c\u5927\u4e8e\u6700\u53f3\u8fb9\u7684\u503c\uff0c\u5219\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u5426\u5219\u5728\u5de6\u8fb9\n        # 17. \u5982\u679c\u4e2d\u95f4\u503c\u5c0f\u4e8e\u6700\u53f3\u8fb9\u7684\u503c\uff0c\u5219\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u5de6\u8fb9\uff0c\u5426\u5219\u5728\u53f3\u8fb9\n        # 18. \u5982\u679c\u4e2d\u95f4\u503c\u5927\u4e8e\u6700\u53f3\u8fb9\u7684\u503c\uff0c\u5219\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u5426\u5219\u5728\u5de6\u8fb9\n        # 19. \u5982\u679c\u4e2d\u95f4\u503c\u5c0f\u4e8e\u6700\u53f3\u8fb9\u7684\u503c\uff0c\u5219\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u5de6\u8fb9\uff0c\u5426\u5219\u5728\u53f3\u8fb9\n        # 20. \u5982\u679c\u4e2d\u95f4\u503c\u5927\u4e8e\u6700\u53f3\u8fb9\u7684\u503c\uff0c\u5219\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u5426\u5219\u5728\u5de6\u8fb9\n        # 21. \u5982\u679c\u4e2d\u95f4\u503c\u5c0f\u4e8e\u6700\u53f3\u8fb9\u7684\u503c\uff0c\u5219\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u5de6\u8fb9\uff0c\u5426\u5219\u5728\u53f3\u8fb9\n        # 22. \u5982\u679c\u4e2d\u95f4\u503c\u5927\u4e8e\u6700\u53f3\u8fb9\u7684\u503c\uff0c\u5219\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u5426\u5219\u5728\u5de6\u8fb9\n        # 23. \u5982\u679c\u4e2d\u95f4\u503c\u5c0f\u4e8e\u6700\u53f3\u8fb9\u7684\u503c\uff0c\u5219\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u5de6\u8fb9\uff0c\u5426\u5219\u5728\u53f3\u8fb9\n        # 24. \u5982\u679c\u4e2d\u95f4\u503c\u5927\u4e8e\u6700\u53f3\u8fb9\u7684\u503c\uff0c\u5219\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u5426\u5219\u5728\u5de6\u8fb9\n        # 25. \u5982\u679c\u4e2d\u95f4\u503c\u5c0f\u4e8e\u6700\u53f3\u8fb9\u7684\u503c\uff0c\u5219\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u5de6\u8fb9\uff0c\u5426\u5219\u5728\u53f3\u8fb9\n        # 26. \u5982\u679c\u4e2d\u95f4\u503c\u5927\u4e8e\u6700\u53f3\u8fb9\u7684\u503c\uff0c\u5219\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u5426\u5219\u5728\u5de6\u8fb9\n        # 27. \u5982\u679c\u4e2d\u95f4\u503c\u5c0f\u4e8e\u6700\u53f3\u8fb9\u7684\u503c\uff0c\u5219\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u5de6\u8fb9\uff0c\u5426\u5219\u5728\u53f3\u8fb9\n        # 28. \u5982\u679c\u4e2d\u95f4\u503c\u5927\u4e8e\u6700\u53f3\u8fb9\u7684\u503c\uff0c\u5219\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u5426\u5219\u5728\u5de6\u8fb9\n        # 29. \u5982\u679c\u4e2d\u95f4\u503c\u5c0f\u4e8e\u6700\u53f3\u8fb9\u7684\u503c\uff0c\u5219\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u5de6\u8fb9\uff0c\u5426\u5219\u5728\u53f3\u8fb9\n        # 30. \u5982\u679c\u4e2d\u95f4\u503c\u5927\u4e8e\u6700\u53f3\u8fb9\u7684\u503c\uff0c\u5219\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u5426\u5219\u5728\u5de6\u8fb9\n        # 31. \u5982\u679c\u4e2d\u95f4\u503c\u5c0f\u4e8e\u6700\u53f3\u8fb9\u7684\u503c\uff0c\u5219\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u5de6\u8fb9\uff0c\u5426\u5219\u5728\u53f3\u8fb9\n        # 32. \u5982\u679c\u4e2d\u95f4\u503c\u5927\u4e8e\u6700\u53f3\u8fb9\u7684\u503c\uff0c\u5219\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u5426\u5219\u5728\u5de6\u8fb9\n        # 33. \u5982\u679c\u4e2d\u95f4\u503c\u5c0f\u4e8e\u6700\u53f3\u8fb9\u7684\u503c\uff0c\u5219\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u5de6\u8fb9\uff0c\u5426\u5219\u5728\u53f3\u8fb9\n        # 34. \u5982\u679c\u4e2d\u95f4\u503c\u5927\u4e8e\u6700\u53f3\u8fb9\u7684\u503c\uff0c\u5219\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u5426\u5219\u5728\u5de6\u8fb9\n        # 35. \u5982\u679c\u4e2d\u95f4\u503c\u5c0f\u4e8e"}, {"task_id": "find-minimum-in-rotated-sorted-array", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u4e8c\u5206\u67e5\u627e\n        # 2. \u4e8c\u5206\u67e5\u627e\u7684\u6761\u4ef6\u662f\uff1a\n        # 3. \u5982\u679c\u4e2d\u95f4\u7684\u6570\u5927\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u53f3\u8fb9\n        # 4. \u5982\u679c\u4e2d\u95f4\u6570\u5c0f\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u5de6\u8fb9\n        # 5. \u5982\u679c\u4e2d\u95f4\u6570\u5927\u4e8e\u6700\u5de6\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u53f3\u8fb9\n        # 6. \u5982\u679c\u4e2d\u95f4\u6570\u5c0f\u4e8e\u6700\u5de6\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u5de6\u8fb9\n        # 7. \u5982\u679c\u4e2d\u95f4\u6570\u7b49\u4e8e\u6700\u5de6\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u53f3\u8fb9\n        # 8. \u5982\u679c\u4e2d\u95f4\u6570\u7b49\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u5de6\u8fb9\n        # 9. \u5982\u679c\u4e2d\u95f4\u6570\u7b49\u4e8e\u6700\u5de6\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u53f3\u8fb9\n        # 10. \u5982\u679c\u4e2d\u95f4\u6570\u7b49\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u5de6\u8fb9\n        # 11. \u5982\u679c\u4e2d\u95f4\u6570\u7b49\u4e8e\u6700\u5de6\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u53f3\u8fb9\n        # 12. \u5982\u679c\u4e2d\u95f4\u6570\u7b49\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u5de6\u8fb9\n        # 13. \u5982\u679c\u4e2d\u95f4\u6570\u7b49\u4e8e\u6700\u5de6\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u53f3\u8fb9\n        # 14. \u5982\u679c\u4e2d\u95f4\u6570\u7b49\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u5de6\u8fb9\n        # 15. \u5982\u679c\u4e2d\u95f4\u6570\u7b49\u4e8e\u6700\u5de6\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u53f3\u8fb9\n        # 16. \u5982\u679c\u4e2d\u95f4\u6570\u7b49\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u5de6\u8fb9\n        # 17. \u5982\u679c\u4e2d\u95f4\u6570\u7b49\u4e8e\u6700\u5de6\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u53f3\u8fb9\n        # 18. \u5982\u679c\u4e2d\u95f4\u6570\u7b49\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u5de6\u8fb9\n        # 19. \u5982\u679c\u4e2d\u95f4\u6570\u7b49\u4e8e\u6700\u5de6\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u53f3\u8fb9\n        # 20. \u5982\u679c\u4e2d\u95f4\u6570\u7b49\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u5de6\u8fb9\n        # 21. \u5982\u679c\u4e2d\u95f4\u6570\u7b49\u4e8e\u6700\u5de6\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u53f3\u8fb9\n        # 22. \u5982\u679c\u4e2d\u95f4\u6570\u7b49\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u5de6\u8fb9\n        # 23. \u5982\u679c\u4e2d\u95f4\u6570\u7b49\u4e8e\u6700\u5de6\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u53f3\u8fb9\n        # 24. \u5982\u679c\u4e2d\u95f4\u6570\u7b49\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u5de6\u8fb9\n        # 25. \u5982\u679c\u4e2d\u95f4\u6570\u7b49\u4e8e\u6700\u5de6\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u53f3\u8fb9\n        # 26. \u5982\u679c\u4e2d\u95f4\u6570\u7b49\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u5de6\u8fb9\n        # 27. \u5982\u679c\u4e2d\u95f4\u6570\u7b49\u4e8e\u6700\u5de6\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u53f3\u8fb9\n        # 28. \u5982\u679c\u4e2d\u95f4\u6570\u7b49\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u5de6\u8fb9\n        # 29. \u5982\u679c\u4e2d\u95f4\u6570\u7b49\u4e8e\u6700\u5de6\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u53f3\u8fb9\n        # 30. \u5982\u679c\u4e2d\u95f4\u6570\u7b49\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u5de6\u8fb9\n        # 31. \u5982\u679c\u4e2d\u95f4\u6570\u7b49\u4e8e\u6700\u5de6\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u53f3\u8fb9\n        # 32. \u5982\u679c\u4e2d\u95f4\u6570\u7b49\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u5de6\u8fb9\n        # 33. \u5982\u679c\u4e2d\u95f4\u6570\u7b49\u4e8e\u6700\u5de6\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u53f3\u8fb9\n        # 34. \u5982\u679c\u4e2d\u95f4\u6570\u7b49\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u5de6\u8fb9\n        # 35. \u5982\u679c\u4e2d\u95f4\u6570\u7b49\u4e8e\u6700\u5de6\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u53f3\u8fb9\n        # 36. \u5982\u679c\u4e2d\u95f4\u6570\u7b49\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u5de6\u8fb9\n        # 37. \u5982\u679c\u4e2d\u95f4\u6570\u7b49\u4e8e\u6700\u5de6\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u53f3\u8fb9\n        # 38. \u5982\u679c\u4e2d\u95f4\u6570\u7b49\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u5de6\u8fb9\n        # 39. \u5982\u679c\u4e2d\u95f4\u6570\u7b49\u4e8e\u6700\u5de6\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u53f3\u8fb9\n        # 40. \u5982\u679c\u4e2d\u95f4\u6570\u7b49\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u5de6\u8fb9\n        # 41. \u5982\u679c\u4e2d\u95f4\u6570\u7b49\u4e8e\u6700\u5de6\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u53f3\u8fb9\n        # 42. \u5982\u679c\u4e2d\u95f4\u6570\u7b49\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u5de6\u8fb9\n        # 43. \u5982\u679c\u4e2d\u95f4\u6570\u7b49\u4e8e\u6700\u5de6\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u53f3\u8fb9\n        # 44. \u5982\u679c\u4e2d\u95f4\u6570\u7b49\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700"}, {"task_id": "find-minimum-in-rotated-sorted-array", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u4e8c\u5206\u67e5\u627e\n        # 2. \u4e8c\u5206\u67e5\u627e\u7684\u6761\u4ef6\u662f\uff1a\n        # 3. \u5982\u679c\u4e2d\u95f4\u503c\u5927\u4e8e\u6700\u53f3\u8fb9\u7684\u503c\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\n        # 4. \u5982\u679c\u4e2d\u95f4\u503c\u5c0f\u4e8e\u6700\u53f3\u8fb9\u7684\u503c\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u5de6\u8fb9\n        # 5. \u5982\u679c\u4e2d\u95f4\u503c\u7b49\u4e8e\u6700\u53f3\u8fb9\u7684\u503c\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u5de6\u8fb9\n        # 6. \u5982\u679c\u4e2d\u95f4\u503c\u5927\u4e8e\u6700\u5de6\u8fb9\u7684\u503c\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\n        # 7. \u5982\u679c\u4e2d\u95f4\u503c\u5c0f\u4e8e\u6700\u5de6\u8fb9\u7684\u503c\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u5de6\u8fb9\n        # 8. \u5982\u679c\u4e2d\u95f4\u503c\u7b49\u4e8e\u6700\u5de6\u8fb9\u7684\u503c\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\n        # 9. \u5982\u679c\u4e2d\u95f4\u503c\u5927\u4e8e\u6700\u53f3\u8fb9\u7684\u503c\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\n        # 10. \u5982\u679c\u4e2d\u95f4\u503c\u5c0f\u4e8e\u6700\u53f3\u8fb9\u7684\u503c\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u5de6\u8fb9\n        # 11. \u5982\u679c\u4e2d\u95f4\u503c\u7b49\u4e8e\u6700\u53f3\u8fb9\u7684\u503c\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u5de6\u8fb9\n        # 12. \u5982\u679c\u4e2d\u95f4\u503c\u5927\u4e8e\u6700\u5de6\u8fb9\u7684\u503c\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\n        # 13. \u5982\u679c\u4e2d\u95f4\u503c\u5c0f\u4e8e\u6700\u5de6\u8fb9\u7684\u503c\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u5de6\u8fb9\n        # 14. \u5982\u679c\u4e2d\u95f4\u503c\u7b49\u4e8e\u6700\u5de6\u8fb9\u7684\u503c\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\n        # 15. \u5982\u679c\u4e2d\u95f4\u503c\u5927\u4e8e\u6700\u53f3\u8fb9\u7684\u503c\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\n        # 16. \u5982\u679c\u4e2d\u95f4\u503c\u5c0f\u4e8e\u6700\u53f3\u8fb9\u7684\u503c\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u5de6\u8fb9\n        # 17. \u5982\u679c\u4e2d\u95f4\u503c\u7b49\u4e8e\u6700\u53f3\u8fb9\u7684\u503c\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u5de6\u8fb9\n        # 18. \u5982\u679c\u4e2d\u95f4\u503c\u5927\u4e8e\u6700\u5de6\u8fb9\u7684\u503c\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\n        # 19. \u5982\u679c\u4e2d\u95f4\u503c\u5c0f\u4e8e\u6700\u5de6\u8fb9\u7684\u503c\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u5de6\u8fb9\n        # 20. \u5982\u679c\u4e2d\u95f4\u503c\u7b49\u4e8e\u6700\u5de6\u8fb9\u7684\u503c\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\n        # 21. \u5982\u679c\u4e2d\u95f4\u503c\u5927\u4e8e\u6700\u53f3\u8fb9\u7684\u503c\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\n        # 22. \u5982\u679c\u4e2d\u95f4\u503c\u5c0f\u4e8e\u6700\u53f3\u8fb9\u7684\u503c\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u5de6\u8fb9\n        # 23. \u5982\u679c\u4e2d\u95f4\u503c\u7b49\u4e8e\u6700\u53f3\u8fb9\u7684\u503c\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u5de6\u8fb9\n        # 24. \u5982\u679c\u4e2d\u95f4\u503c\u5927\u4e8e\u6700\u5de6\u8fb9\u7684\u503c\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\n        # 25. \u5982\u679c\u4e2d\u95f4\u503c\u5c0f\u4e8e\u6700\u5de6\u8fb9\u7684\u503c\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u5de6\u8fb9\n        # 26. \u5982\u679c\u4e2d\u95f4\u503c\u7b49\u4e8e\u6700\u5de6\u8fb9\u7684\u503c\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\n        # 27. \u5982\u679c\u4e2d\u95f4\u503c\u5927\u4e8e\u6700\u53f3\u8fb9\u7684\u503c\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\n        # 28. \u5982\u679c\u4e2d\u95f4\u503c\u5c0f\u4e8e\u6700\u53f3\u8fb9\u7684\u503c\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u5de6\u8fb9\n        # 29. \u5982\u679c\u4e2d\u95f4\u503c\u7b49\u4e8e\u6700\u53f3\u8fb9\u7684\u503c\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u5de6\u8fb9\n        # 30. \u5982\u679c\u4e2d\u95f4\u503c\u5927\u4e8e\u6700\u5de6\u8fb9\u7684\u503c\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\n        # 31. \u5982\u679c\u4e2d\u95f4\u503c\u5c0f\u4e8e\u6700\u5de6\u8fb9\u7684\u503c\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u5de6\u8fb9\n        # 32. \u5982\u679c\u4e2d\u95f4\u503c\u7b49\u4e8e\u6700\u5de6\u8fb9\u7684\u503c\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\n        # 33. \u5982\u679c\u4e2d\u95f4\u503c\u5927\u4e8e\u6700\u53f3\u8fb9\u7684\u503c\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\n        # 34. \u5982\u679c\u4e2d\u95f4\u503c\u5c0f\u4e8e\u6700\u53f3\u8fb9\u7684\u503c\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u5de6\u8fb9\n        # 35. \u5982\u679c\u4e2d\u95f4\u503c\u7b49\u4e8e\u6700\u53f3\u8fb9\u7684\u503c\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u5de6\u8fb9\n        # 36. \u5982\u679c\u4e2d\u95f4\u503c\u5927\u4e8e\u6700\u5de6\u8fb9\u7684\u503c\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\n        # 37. \u5982\u679c\u4e2d\u95f4\u503c\u5c0f\u4e8e\u6700\u5de6\u8fb9\u7684\u503c\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u5de6\u8fb9\n        # 38. \u5982\u679c\u4e2d\u95f4\u503c\u7b49\u4e8e\u6700\u5de6\u8fb9\u7684\u503c\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\n        # 39. \u5982\u679c\u4e2d\u95f4\u503c\u5927\u4e8e\u6700\u53f3\u8fb9\u7684\u503c\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\n        # 40. \u5982\u679c\u4e2d\u95f4\u503c\u5c0f\u4e8e\u6700\u53f3\u8fb9\u7684\u503c\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u5de6\u8fb9\n        # 41. \u5982\u679c\u4e2d\u95f4\u503c\u7b49\u4e8e\u6700\u53f3\u8fb9\u7684\u503c"}, {"task_id": "find-minimum-in-rotated-sorted-array", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u4e8c\u5206\u67e5\u627e\n        # 2. \u4e8c\u5206\u67e5\u627e\u7684\u7ec8\u6b62\u6761\u4ef6\u662fleft == right\n        # 3. \u6bcf\u6b21\u4e8c\u5206\u67e5\u627e\u7684\u4e2d\u95f4\u503cmid = (left + right) / 2\n        # 4. \u5982\u679c\u4e2d\u95f4\u503cmid\u7684\u503c\u5927\u4e8e\u53f3\u8fb9\u754c\u503cnums[right]\uff0c\u5219\u6700\u5c0f\u503c\u4e00\u5b9a\u5728mid\u7684\u53f3\u8fb9\uff0c\u56e0\u6b64left = mid + 1\n        # 5. \u5982\u679c\u4e2d\u95f4\u503cmid\u7684\u503c\u5c0f\u4e8e\u53f3\u8fb9\u754c\u503cnums[right]\uff0c\u5219\u6700\u5c0f\u503c\u4e00\u5b9a\u5728mid\u7684\u5de6\u8fb9\u6216\u8005\u5c31\u662fmid\u672c\u8eab\uff0c\u56e0\u6b64right = mid\n        # 6. \u5982\u679c\u4e2d\u95f4\u503cmid\u7684\u503c\u7b49\u4e8e\u53f3\u8fb9\u754c\u503cnums[right]\uff0c\u5219\u65e0\u6cd5\u5224\u65ad\u6700\u5c0f\u503c\u5728mid\u7684\u5de6\u8fb9\u8fd8\u662f\u53f3\u8fb9\uff0c\u56e0\u6b64right = right - 1\n        # 7. \u5982\u679cleft > right\uff0c\u5219\u6700\u5c0f\u503c\u4e00\u5b9a\u5728mid\u7684\u5de6\u8fb9\uff0c\u56e0\u6b64right = mid\n        # 8. \u5982\u679cleft == right\uff0c\u5219\u6700\u5c0f\u503c\u5c31\u662fnums[left]\n        # 9. \u5982\u679cleft < right\uff0c\u5219\u6700\u5c0f\u503c\u4e00\u5b9a\u5728mid\u7684\u53f3\u8fb9\uff0c\u56e0\u6b64left = mid + 1\n        # 10. \u5982\u679cleft == right\uff0c\u5219\u6700\u5c0f\u503c\u5c31\u662fnums[left]\n        # 11. \u5982\u679cleft > right\uff0c\u5219\u6700\u5c0f\u503c\u4e00\u5b9a\u5728mid\u7684\u5de6\u8fb9\uff0c\u56e0\u6b64right = mid\n        # 12. \u5982\u679cleft == right\uff0c\u5219\u6700\u5c0f\u503c\u5c31\u662fnums[left]\n        # 13. \u5982\u679cleft < right\uff0c\u5219\u6700\u5c0f\u503c\u4e00\u5b9a\u5728mid\u7684\u53f3\u8fb9\uff0c\u56e0\u6b64left = mid + 1\n        # 14. \u5982\u679cleft == right\uff0c\u5219\u6700\u5c0f\u503c\u5c31\u662fnums[left]\n        # 15. \u5982\u679cleft > right\uff0c\u5219\u6700\u5c0f\u503c\u4e00\u5b9a\u5728mid\u7684\u5de6\u8fb9\uff0c\u56e0\u6b64right = mid\n        # 16. \u5982\u679cleft == right\uff0c\u5219\u6700\u5c0f\u503c\u5c31\u662fnums[left]\n        # 17. \u5982\u679cleft < right\uff0c\u5219\u6700\u5c0f\u503c\u4e00\u5b9a\u5728mid\u7684\u53f3\u8fb9\uff0c\u56e0\u6b64left = mid + 1\n        # 18. \u5982\u679cleft == right\uff0c\u5219\u6700\u5c0f\u503c\u5c31\u662fnums[left]\n        # 19. \u5982\u679cleft > right\uff0c\u5219\u6700\u5c0f\u503c\u4e00\u5b9a\u5728mid\u7684\u5de6\u8fb9\uff0c\u56e0\u6b64right = mid\n        # 20. \u5982\u679cleft == right\uff0c\u5219\u6700\u5c0f\u503c\u5c31\u662fnums[left]\n        # 21. \u5982\u679cleft < right\uff0c\u5219\u6700\u5c0f\u503c\u4e00\u5b9a\u5728mid\u7684\u53f3\u8fb9\uff0c\u56e0\u6b64left = mid + 1\n        # 22. \u5982\u679cleft == right\uff0c\u5219\u6700\u5c0f\u503c\u5c31\u662fnums[left]\n        # 23. \u5982\u679cleft > right\uff0c\u5219\u6700\u5c0f\u503c\u4e00\u5b9a\u5728mid\u7684\u5de6\u8fb9\uff0c\u56e0\u6b64right = mid\n        # 24. \u5982\u679cleft == right\uff0c\u5219\u6700\u5c0f\u503c\u5c31\u662fnums[left]\n        # 25. \u5982\u679cleft < right\uff0c\u5219\u6700\u5c0f\u503c\u4e00\u5b9a\u5728mid\u7684\u53f3\u8fb9\uff0c\u56e0\u6b64left = mid + 1\n        # 26. \u5982\u679cleft == right\uff0c\u5219\u6700\u5c0f\u503c\u5c31\u662fnums[left]\n        # 27. \u5982\u679cleft > right\uff0c\u5219\u6700\u5c0f\u503c\u4e00\u5b9a\u5728mid\u7684\u5de6\u8fb9\uff0c\u56e0\u6b64right = mid\n        # 28. \u5982\u679cleft == right\uff0c\u5219\u6700\u5c0f\u503c\u5c31\u662fnums[left]\n        # 29. \u5982\u679cleft < right\uff0c\u5219\u6700\u5c0f\u503c\u4e00\u5b9a\u5728mid\u7684\u53f3\u8fb9\uff0c\u56e0\u6b64left = mid + 1\n        # 30. \u5982\u679cleft == right\uff0c\u5219\u6700\u5c0f\u503c\u5c31\u662fnums[left]\n        # 31. \u5982\u679cleft > right\uff0c\u5219\u6700\u5c0f\u503c\u4e00\u5b9a\u5728mid\u7684\u5de6\u8fb9\uff0c\u56e0\u6b64right = mid\n        # 32. \u5982\u679cleft == right\uff0c\u5219\u6700\u5c0f\u503c\u5c31\u662fnums[left]\n        # 33. \u5982\u679cleft < right\uff0c\u5219\u6700\u5c0f\u503c\u4e00\u5b9a\u5728mid\u7684\u53f3\u8fb9\uff0c\u56e0\u6b64left = mid + 1\n        # 34. \u5982\u679cleft == right\uff0c\u5219\u6700\u5c0f\u503c\u5c31\u662fnums[left]\n        # 35. \u5982\u679cleft > right\uff0c\u5219\u6700\u5c0f\u503c\u4e00\u5b9a\u5728mid\u7684\u5de6\u8fb9\uff0c\u56e0\u6b64right = mid\n        # 36. \u5982\u679cleft == right\uff0c\u5219\u6700\u5c0f\u503c\u5c31\u662fnums[left]\n        # 37. \u5982\u679cleft < right\uff0c\u5219\u6700\u5c0f\u503c\u4e00\u5b9a\u5728mid\u7684\u53f3\u8fb9\uff0c\u56e0\u6b64left = mid + 1\n        # 38. \u5982\u679cleft == right\uff0c\u5219\u6700\u5c0f\u503c\u5c31\u662fnums[left]\n        # 39."}, {"task_id": "find-minimum-in-rotated-sorted-array", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u4e8c\u5206\u67e5\u627e\n        # 2. \u4e8c\u5206\u67e5\u627e\u7684\u6761\u4ef6\u662f\uff1a\n        # 3. \u5982\u679c\u4e2d\u95f4\u5143\u7d20\u5927\u4e8e\u6700\u53f3\u8fb9\u7684\u5143\u7d20\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\n        # 4. \u5982\u679c\u4e2d\u95f4\u5143\u7d20\u5c0f\u4e8e\u6700\u53f3\u8fb9\u7684\u5143\u7d20\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u5de6\u8fb9\n        # 5. \u5982\u679c\u4e2d\u95f4\u5143\u7d20\u7b49\u4e8e\u6700\u53f3\u8fb9\u7684\u5143\u7d20\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u5de6\u8fb9\u6216\u8005\u53f3\u8fb9\n        # 6. \u5982\u679c\u4e2d\u95f4\u5143\u7d20\u5927\u4e8e\u6700\u5de6\u8fb9\u7684\u5143\u7d20\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\n        # 7. \u5982\u679c\u4e2d\u95f4\u5143\u7d20\u5c0f\u4e8e\u6700\u5de6\u8fb9\u7684\u5143\u7d20\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u5de6\u8fb9\n        # 8. \u5982\u679c\u4e2d\u95f4\u5143\u7d20\u7b49\u4e8e\u6700\u5de6\u8fb9\u7684\u5143\u7d20\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u5de6\u8fb9\u6216\u8005\u53f3\u8fb9\n        # 9. \u5982\u679c\u4e2d\u95f4\u5143\u7d20\u5927\u4e8e\u6700\u53f3\u8fb9\u7684\u5143\u7d20\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\n        # 10. \u5982\u679c\u4e2d\u95f4\u5143\u7d20\u5c0f\u4e8e\u6700\u53f3\u8fb9\u7684\u5143\u7d20\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u5de6\u8fb9\n        # 11. \u5982\u679c\u4e2d\u95f4\u5143\u7d20\u7b49\u4e8e\u6700\u53f3\u8fb9\u7684\u5143\u7d20\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u5de6\u8fb9\u6216\u8005\u53f3\u8fb9\n        # 12. \u5982\u679c\u4e2d\u95f4\u5143\u7d20\u5927\u4e8e\u6700\u5de6\u8fb9\u7684\u5143\u7d20\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\n        # 13. \u5982\u679c\u4e2d\u95f4\u5143\u7d20\u5c0f\u4e8e\u6700\u5de6\u8fb9\u7684\u5143\u7d20\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u5de6\u8fb9\n        # 14. \u5982\u679c\u4e2d\u95f4\u5143\u7d20\u7b49\u4e8e\u6700\u5de6\u8fb9\u7684\u5143\u7d20\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u5de6\u8fb9\u6216\u8005\u53f3\u8fb9\n        # 15. \u5982\u679c\u4e2d\u95f4\u5143\u7d20\u5927\u4e8e\u6700\u53f3\u8fb9\u7684\u5143\u7d20\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\n        # 16. \u5982\u679c\u4e2d\u95f4\u5143\u7d20\u5c0f\u4e8e\u6700\u53f3\u8fb9\u7684\u5143\u7d20\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u5de6\u8fb9\n        # 17. \u5982\u679c\u4e2d\u95f4\u5143\u7d20\u7b49\u4e8e\u6700\u53f3\u8fb9\u7684\u5143\u7d20\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u5de6\u8fb9\u6216\u8005\u53f3\u8fb9\n        # 18. \u5982\u679c\u4e2d\u95f4\u5143\u7d20\u5927\u4e8e\u6700\u5de6\u8fb9\u7684\u5143\u7d20\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\n        # 19. \u5982\u679c\u4e2d\u95f4\u5143\u7d20\u5c0f\u4e8e\u6700\u5de6\u8fb9\u7684\u5143\u7d20\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u5de6\u8fb9\n        # 20. \u5982\u679c\u4e2d\u95f4\u5143\u7d20\u7b49\u4e8e\u6700\u5de6\u8fb9\u7684\u5143\u7d20\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u5de6\u8fb9\u6216\u8005\u53f3\u8fb9\n        # 21. \u5982\u679c\u4e2d\u95f4\u5143\u7d20\u5927\u4e8e\u6700\u53f3\u8fb9\u7684\u5143\u7d20\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\n        # 22. \u5982\u679c\u4e2d\u95f4\u5143\u7d20\u5c0f\u4e8e\u6700\u53f3\u8fb9\u7684\u5143\u7d20\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u5de6\u8fb9\n        # 23. \u5982\u679c\u4e2d\u95f4\u5143\u7d20\u7b49\u4e8e\u6700\u53f3\u8fb9\u7684\u5143\u7d20\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u5de6\u8fb9\u6216\u8005\u53f3\u8fb9\n        # 24. \u5982\u679c\u4e2d\u95f4\u5143\u7d20\u5927\u4e8e\u6700\u5de6\u8fb9\u7684\u5143\u7d20\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\n        # 25. \u5982\u679c\u4e2d\u95f4\u5143\u7d20\u5c0f\u4e8e\u6700\u5de6\u8fb9\u7684\u5143\u7d20\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u5de6\u8fb9\n        # 26. \u5982\u679c\u4e2d\u95f4\u5143\u7d20\u7b49\u4e8e\u6700\u5de6\u8fb9\u7684\u5143\u7d20\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u5de6\u8fb9\u6216\u8005\u53f3\u8fb9\n        # 27. \u5982\u679c\u4e2d\u95f4\u5143\u7d20\u5927\u4e8e\u6700\u53f3\u8fb9\u7684\u5143\u7d20\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\n        # 28. \u5982\u679c\u4e2d\u95f4\u5143\u7d20\u5c0f\u4e8e\u6700\u53f3\u8fb9\u7684\u5143\u7d20\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u5de6\u8fb9\n        # 29. \u5982\u679c\u4e2d\u95f4\u5143\u7d20\u7b49\u4e8e\u6700\u53f3\u8fb9\u7684\u5143\u7d20\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u5de6\u8fb9\u6216\u8005\u53f3\u8fb9\n        # 30. \u5982\u679c\u4e2d\u95f4\u5143\u7d20\u5927\u4e8e\u6700\u5de6\u8fb9\u7684\u5143\u7d20\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\n        # 31. \u5982\u679c\u4e2d\u95f4\u5143\u7d20\u5c0f\u4e8e\u6700\u5de6\u8fb9\u7684\u5143\u7d20\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u5de6\u8fb9\n        # 32. \u5982\u679c\u4e2d\u95f4\u5143\u7d20\u7b49\u4e8e\u6700\u5de6\u8fb9\u7684\u5143\u7d20\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u5de6\u8fb9\u6216\u8005\u53f3\u8fb9\n        # 33. \u5982\u679c\u4e2d\u95f4\u5143\u7d20\u5927\u4e8e\u6700\u53f3\u8fb9\u7684\u5143\u7d20\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\n        # 34. \u5982\u679c\u4e2d\u95f4\u5143\u7d20\u5c0f\u4e8e\u6700\u53f3\u8fb9\u7684\u5143\u7d20\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u5de6\u8fb9\n        # 35. \u5982\u679c\u4e2d\u95f4\u5143\u7d20\u7b49\u4e8e\u6700\u53f3\u8fb9\u7684\u5143\u7d20\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u5de6\u8fb9\u6216\u8005\u53f3\u8fb9\n        # 36. \u5982\u679c\u4e2d\u95f4\u5143\u7d20\u5927\u4e8e\u6700\u5de6\u8fb9\u7684\u5143\u7d20\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\n        # 37. \u5982\u679c\u4e2d\u95f4\u5143\u7d20\u5c0f\u4e8e\u6700\u5de6\u8fb9\u7684\u5143\u7d20\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u5de6\u8fb9\n        # 38. \u5982\u679c\u4e2d\u95f4\u5143\u7d20\u7b49\u4e8e\u6700\u5de6\u8fb9\u7684\u5143\u7d20\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u5de6\u8fb9\u6216\u8005\u53f3\u8fb9\n        # 39. \u5982\u679c\u4e2d\u95f4\u5143\u7d20\u5927\u4e8e\u6700\u53f3\u8fb9\u7684\u5143\u7d20\uff0c\u90a3\u4e48\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\n        # 40."}], "pascals-triangle-ii": [{"task_id": "pascals-triangle-ii", "completion": "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \n        # Time: O(n^2)\n        # Space: O(n)\n        # if rowIndex == 0:\n        #     return [1]\n        # if rowIndex == 1:\n        #     return [1,1]\n        # res = [1,1]\n        # for i in range(2, rowIndex+1):\n        #     res.append(1)\n        #     for j in range(i-1, 0, -1):\n        #         res[j] = res[j] + res[j-1]\n        # return res\n        \n        # 2. \n        # Time: O(n^2)\n        # Space: O(n)\n        # res = [1]\n        # for i in range(1, rowIndex+1):\n        #     res.append(1)\n        #     for j in range(i-1, 0, -1):\n        #         res[j] = res[j] + res[j-1]\n        # return res\n        \n        # 3. \n        # Time: O(n^2)\n        # Space: O(n)\n        # res = [1]\n        # for i in range(1, rowIndex+1):\n        #     res.append(1)\n        #     for j in range(i-1, 0, -1):\n        #         res[j] = res[j] + res[j-1]\n        # return res\n        \n        # 4. \n        # Time: O(n^2)\n        # Space: O(n)\n        # res = [1]\n        # for i in range(1, rowIndex+1):\n        #     res.append(1)\n        #     for j in range(i-1, 0, -1):\n        #         res[j] = res[j] + res[j-1]\n        # return res\n        \n        # 5. \n        # Time: O(n^2)\n        # Space: O(n)\n        # res = [1]\n        # for i in range(1, rowIndex+1):\n        #     res.append(1)\n        #     for j in range(i-1, 0, -1):\n        #         res[j] = res[j] + res[j-1]\n        # return res\n        \n        # 6. \n        # Time: O(n^2)\n        # Space: O(n)\n        # res = [1]\n        # for i in range(1, rowIndex+1):\n        #     res.append(1)\n        #     for j in range(i-1, 0, -1):\n        #         res[j] = res[j] + res[j-1]\n        # return res\n        \n        # 7. \n        # Time: O(n^2)\n        # Space: O(n)\n        # res = [1]\n        # for i in range(1, rowIndex+1):\n        #     res.append(1)\n        #     for j in range(i-1, 0, -1):\n        #         res[j] = res[j] + res[j-1]\n        # return res\n        \n        # 8. \n        # Time: O(n^2)\n        # Space: O(n)\n        # res = [1]\n        # for i in range(1, rowIndex+1):\n        #     res.append(1)\n        #     for j in range(i-1, 0, -1):\n        #         res[j] = res[j] + res[j-1]\n        # return res\n        \n        # 9. \n        # Time: O(n^2)\n        # Space: O(n)\n        # res = [1]\n        # for i in range(1, rowIndex+1):\n        #     res.append(1)\n        #     for j in range(i-1, 0, -1):\n        #         res[j] = res[j] + res[j-1]\n        # return res\n        \n        # 10. \n        # Time: O(n^2)\n        # Space: O(n)\n        # res ="}, {"task_id": "pascals-triangle-ii", "completion": "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \n        # Time: O(n^2)\n        # Space: O(n)\n        # if rowIndex == 0:\n        #     return [1]\n        # if rowIndex == 1:\n        #     return [1,1]\n        # res = [1,1]\n        # for i in range(2, rowIndex+1):\n        #     res.append(1)\n        #     for j in range(i-1, 0, -1):\n        #         res[j] = res[j] + res[j-1]\n        # return res\n        \n        # 2. \n        # Time: O(n^2)\n        # Space: O(n)\n        # res = [1]\n        # for i in range(rowIndex):\n        #     res = [1] + [res[j] + res[j+1] for j in range(i)] + [1]\n        # return res\n        \n        # 3. \n        # Time: O(n^2)\n        # Space: O(n)\n        # res = [1]\n        # for i in range(rowIndex):\n        #     res = [1] + [res[j] + res[j+1] for j in range(i)] + [1]\n        # return res\n        \n        # 4. \n        # Time: O(n^2)\n        # Space: O(n)\n        # res = [1]\n        # for i in range(rowIndex):\n        #     res = [1] + [res[j] + res[j+1] for j in range(i)] + [1]\n        # return res\n        \n        # 5. \n        # Time: O(n^2)\n        # Space: O(n)\n        # res = [1]\n        # for i in range(rowIndex):\n        #     res = [1] + [res[j] + res[j+1] for j in range(i)] + [1]\n        # return res\n        \n        # 6. \n        # Time: O(n^2)\n        # Space: O(n)\n        # res = [1]\n        # for i in range(rowIndex):\n        #     res = [1] + [res[j] + res[j+1] for j in range(i)] + [1]\n        # return res\n        \n        # 7. \n        # Time: O(n^2)\n        # Space: O(n)\n        # res = [1]\n        # for i in range(rowIndex):\n        #     res = [1] + [res[j] + res[j+1] for j in range(i)] + [1]\n        # return res\n        \n        # 8. \n        # Time: O(n^2)\n        # Space: O(n)\n        # res = [1]\n        # for i in range(rowIndex):\n        #     res = [1] + [res[j] + res[j+1] for j in range(i)] + [1]\n        # return res\n        \n        # 9. \n        # Time: O(n^2)\n        # Space: O(n)\n        # res = [1]\n        # for i in range(rowIndex):\n        #     res = [1] + [res[j] + res[j+1] for j in range(i)] + [1]\n        # return res\n        \n        # 10. \n        # Time: O(n^2)\n        # Space: O(n)\n        # res = [1]\n        # for i in range(rowIndex):\n        #     res = [1] + [res[j] + res[j+1] for j in range(i)] + [1]\n        # return res\n        \n        # 11. \n        # Time: O(n^2)\n        # Space: O(n)\n        # res = [1]\n        # for i in range(rowIndex):\n        #     res = [1] + [res[j] + res[j+1] for j in range(i)] + [1]\n        # return res\n        \n        # 12. \n        # Time: O(n^2)"}, {"task_id": "pascals-triangle-ii", "completion": "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \n        # Time: O(n^2)\n        # Space: O(n)\n        # if rowIndex == 0:\n        #     return [1]\n        # if rowIndex == 1:\n        #     return [1,1]\n        # res = [1,1]\n        # for i in range(2, rowIndex+1):\n        #     res = [1] + [res[j] + res[j+1] for j in range(i-1)] + [1]\n        # return res\n        \n        # 2.\n        # Time: O(n^2)\n        # Space: O(n)\n        # if rowIndex == 0:\n        #     return [1]\n        # if rowIndex == 1:\n        #     return [1,1]\n        # res = [1,1]\n        # for i in range(2, rowIndex+1):\n        #     res = [1] + [res[j] + res[j+1] for j in range(i-1)] + [1]\n        # return res\n        \n        # 3.\n        # Time: O(n^2)\n        # Space: O(n)\n        # if rowIndex == 0:\n        #     return [1]\n        # if rowIndex == 1:\n        #     return [1,1]\n        # res = [1,1]\n        # for i in range(2, rowIndex+1):\n        #     res = [1] + [res[j] + res[j+1] for j in range(i-1)] + [1]\n        # return res\n        \n        # 4.\n        # Time: O(n^2)\n        # Space: O(n)\n        # if rowIndex == 0:\n        #     return [1]\n        # if rowIndex == 1:\n        #     return [1,1]\n        # res = [1,1]\n        # for i in range(2, rowIndex+1):\n        #     res = [1] + [res[j] + res[j+1] for j in range(i-1)] + [1]\n        # return res\n        \n        # 5.\n        # Time: O(n^2)\n        # Space: O(n)\n        # if rowIndex == 0:\n        #     return [1]\n        # if rowIndex == 1:\n        #     return [1,1]\n        # res = [1,1]\n        # for i in range(2, rowIndex+1):\n        #     res = [1] + [res[j] + res[j+1] for j in range(i-1)] + [1]\n        # return res\n        \n        # 6.\n        # Time: O(n^2)\n        # Space: O(n)\n        # if rowIndex == 0:\n        #     return [1]\n        # if rowIndex == 1:\n        #     return [1,1]\n        # res = [1,1]\n        # for i in range(2, rowIndex+1):\n        #     res = [1] + [res[j] + res[j+1] for j in range(i-1)] + [1]\n        # return res\n        \n        # 7.\n        # Time: O(n^2)\n        # Space: O(n)\n        # if rowIndex == 0:\n        #     return [1]\n        # if rowIndex == 1:\n        #     return [1,1]\n        # res = [1,1]\n        # for i in range(2, rowIndex+1):\n        #     res = [1] + [res[j] + res[j+1] for j in range(i-1)] + [1]\n        # return res\n        \n        # 8.\n        # Time: O(n^2)\n        # Space: O(n)\n        # if rowIndex == 0:\n        #     return [1]\n        # if rowIndex == 1:\n        #     return [1,1]\n        # res = [1,1]\n        # for i in range(2, rowIndex+1):\n        #     res = [1] + [res[j] + res[j+1] for j in range(i-1)] + ["}, {"task_id": "pascals-triangle-ii", "completion": "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \n        # Time: O(n^2)\n        # Space: O(n)\n        # if rowIndex == 0:\n        #     return [1]\n        # if rowIndex == 1:\n        #     return [1,1]\n        # res = [1,1]\n        # for i in range(2, rowIndex+1):\n        #     res = [1] + [res[j] + res[j+1] for j in range(i-1)] + [1]\n        # return res\n        \n        # 2. \n        # Time: O(n^2)\n        # Space: O(n)\n        # res = [1]\n        # for i in range(rowIndex):\n        #     res = [1] + [res[j] + res[j+1] for j in range(i)] + [1]\n        # return res\n        \n        # 3. \n        # Time: O(n^2)\n        # Space: O(n)\n        # res = [1]\n        # for i in range(rowIndex):\n        #     res = [1] + [res[j] + res[j+1] for j in range(i+1)]\n        # return res\n        \n        # 4. \n        # Time: O(n^2)\n        # Space: O(n)\n        # res = [1]\n        # for i in range(rowIndex):\n        #     res = [1] + [res[j] + res[j+1] for j in range(i)] + [1]\n        # return res\n        \n        # 5. \n        # Time: O(n^2)\n        # Space: O(n)\n        # res = [1]\n        # for i in range(rowIndex):\n        #     res = [1] + [res[j] + res[j+1] for j in range(i+1)] + [1]\n        # return res\n        \n        # 6. \n        # Time: O(n^2)\n        # Space: O(n)\n        # res = [1]\n        # for i in range(rowIndex):\n        #     res = [1] + [res[j] + res[j+1] for j in range(i)] + [1]\n        # return res\n        \n        # 7. \n        # Time: O(n^2)\n        # Space: O(n)\n        # res = [1]\n        # for i in range(rowIndex):\n        #     res = [1] + [res[j] + res[j+1] for j in range(i+1)] + [1]\n        # return res\n        \n        # 8. \n        # Time: O(n^2)\n        # Space: O(n)\n        # res = [1]\n        # for i in range(rowIndex):\n        #     res = [1] + [res[j] + res[j+1] for j in range(i)] + [1]\n        # return res\n        \n        # 9. \n        # Time: O(n^2)\n        # Space: O(n)\n        # res = [1]\n        # for i in range(rowIndex):\n        #     res = [1] + [res[j] + res[j+1] for j in range(i+1)] + [1]\n        # return res\n        \n        # 10. \n        # Time: O(n^2)\n        # Space: O(n)\n        # res = [1]\n        # for i in range(rowIndex):\n        #     res = [1] + [res[j] + res[j+1] for j in range(i)] + [1]\n        # return res\n        \n        # 11. \n        # Time: O(n^2)\n        # Space: O(n)\n        # res = [1]\n        # for i in range(rowIndex):\n        #     res = [1] + [res[j] + res[j+1] for j in range(i+1)] + [1]\n        # return res\n        \n        # 12. \n        # Time: O(n^2)\n        # Space: O(n"}, {"task_id": "pascals-triangle-ii", "completion": "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        \n        if rowIndex == 0:\n            return [1]\n        if rowIndex == 1:\n            return [1,1]\n        \n        prev = [1,1]\n        for i in range(2, rowIndex+1):\n            curr = [1]\n            for j in range(1, i):\n                curr.append(prev[j-1] + prev[j])\n            curr.append(1)\n            prev = curr\n        return curr"}], "path-sum-ii": [{"task_id": "path-sum-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def pathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(node, target, path):\n            if not node:\n                return\n            if not node.left and not node.right and target == node.val:\n                path.append(node.val)\n                res.append(path)\n                return\n            dfs(node.left, target - node.val, path + [node.val])\n            dfs(node.right, target - node.val, path + [node.val])\n        \n        res = []\n        dfs(root, targetSum, [])\n        return res"}, {"task_id": "path-sum-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def pathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(node, target, path):\n            if not node:\n                return\n            if not node.left and not node.right and target == node.val:\n                path.append(node.val)\n                res.append(path)\n                return\n            dfs(node.left, target - node.val, path + [node.val])\n            dfs(node.right, target - node.val, path + [node.val])\n        \n        res = []\n        dfs(root, targetSum, [])\n        return res"}, {"task_id": "path-sum-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def pathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(node, target, path):\n            if not node:\n                return\n            if not node.left and not node.right and target == node.val:\n                path.append(node.val)\n                res.append(path)\n                return\n            dfs(node.left, target - node.val, path + [node.val])\n            dfs(node.right, target - node.val, path + [node.val])\n        \n        res = []\n        dfs(root, targetSum, [])\n        return res"}, {"task_id": "path-sum-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def pathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(node, target, path):\n            if not node:\n                return\n            if not node.left and not node.right and target == node.val:\n                path.append(node.val)\n                res.append(path)\n                return\n            dfs(node.left, target - node.val, path + [node.val])\n            dfs(node.right, target - node.val, path + [node.val])\n        \n        res = []\n        dfs(root, targetSum, [])\n        return res"}, {"task_id": "path-sum-ii", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def pathSum(self, root, targetSum):\n        \"\"\"\n        :type root: TreeNode\n        :type targetSum: int\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def dfs(node, target, path):\n            if not node:\n                return\n            if not node.left and not node.right and target == node.val:\n                path.append(node.val)\n                res.append(path)\n                return\n            dfs(node.left, target - node.val, path + [node.val])\n            dfs(node.right, target - node.val, path + [node.val])\n        \n        res = []\n        dfs(root, targetSum, [])\n        return res"}], "construct-the-rectangle": [{"task_id": "construct-the-rectangle", "completion": "class Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2."}, {"task_id": "construct-the-rectangle", "completion": "class Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2."}, {"task_id": "construct-the-rectangle", "completion": "class Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2."}, {"task_id": "construct-the-rectangle", "completion": "class Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2."}, {"task_id": "construct-the-rectangle", "completion": "class Solution(object):\n    def constructRectangle(self, area):\n        \"\"\"\n        :type area: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2. \n        # 3. \n        \n        # 1. \n        # 2."}], "word-ladder-ii": [{"task_id": "word-ladder-ii", "completion": "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        # BFS\n        # Time: O(n * 26 * m)\n        # Space: O(n * 26 * m)\n        \n        wordSet = set(wordList)\n        if endWord not in wordSet:\n            return []\n        \n        wordSet.remove(beginWord)\n        wordSet.remove(endWord)\n        \n        res = []\n        queue = [(beginWord, [beginWord])]\n        found = False\n        while queue:\n            if found:\n                break\n            size = len(queue)\n            for _ in range(size):\n                word, path = queue.pop(0)\n                if word == endWord:\n                    res.append(path)\n                    found = True\n                else:\n                    for i in range(len(word)):\n                        for c in string.ascii_lowercase:\n                            newWord = word[:i] + c + word[i + 1:]\n                            if newWord in wordSet:\n                                queue.append((newWord, path + [newWord]))\n                                wordSet.remove(newWord)\n        return res"}, {"task_id": "word-ladder-ii", "completion": "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        # BFS\n        # Time: O(n * m * 26)\n        # Space: O(n * m)\n        \n        wordList = set(wordList)\n        if endWord not in wordList:\n            return []\n        \n        wordList.add(beginWord)\n        wordList.add(endWord)\n        \n        # BFS\n        queue = collections.deque([(beginWord, [beginWord])])\n        res = []\n        visited = set()\n        min_len = float('inf')\n        \n        while queue:\n            curr, path = queue.popleft()\n            if curr == endWord:\n                if len(path) < min_len:\n                    min_len = len(path)\n                    res = [path]\n                elif len(path) == min_len:\n                    res.append(path)\n                continue\n            \n            for i in range(len(curr)):\n                for c in string.ascii_lowercase:\n                    new_word = curr[:i] + c + curr[i + 1:]\n                    if new_word in wordList and new_word not in visited:\n                        visited.add(new_word)\n                        queue.append((new"}, {"task_id": "word-ladder-ii", "completion": "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def get_neighbors(word):\n            for i in range(len(word)):\n                for c in string.ascii_lowercase:\n                    if c != word[i]:\n                        yield word[:i] + c + word[i+1:]\n        \n        def bfs(beginWord, endWord, wordList):\n            wordList = set(wordList)\n            queue = collections.deque([(beginWord, [beginWord])])\n            res = []\n            min_len = float('inf')\n            while queue:\n                word, path = queue.popleft()\n                if word == endWord:\n                    res.append(path)\n                    min_len = min(min_len, len(path))\n                for neighbor in get_neighbors(word):\n                    if neighbor in wordList:\n                        wordList.remove(neighbor)\n                        queue.append((neighbor, path + [neighbor]))\n            return res, min_len\n        \n        res, min_len = bfs(beginWord, endWord, wordList)\n        return [path for path in res if len(path) == min_len]"}, {"task_id": "word-ladder-ii", "completion": "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def get_neighbors(word):\n            neighbors = []\n            for i in range(len(word)):\n                for c in string.ascii_lowercase:\n                    if c != word[i]:\n                        new_word = word[:i] + c + word[i+1:]\n                        if new_word in wordList:\n                            neighbors.append(new_word)\n            return neighbors\n        \n        def bfs(start, end):\n            queue = [(start, [start])]\n            visited = set()\n            while queue:\n                word, path = queue.pop(0)\n                if word == end:\n                    return path\n                visited.add(word)\n                for neighbor in get_neighbors(word):\n                    if neighbor not in visited:\n                        queue.append((neighbor, path + [neighbor]))\n            return []\n        \n        wordList = set(wordList)\n        if endWord not in wordList:\n            return []\n        return bfs(beginWord, endWord)"}, {"task_id": "word-ladder-ii", "completion": "class Solution(object):\n    def findLadders(self, beginWord, endWord, wordList):\n        \"\"\"\n        :type beginWord: str\n        :type endWord: str\n        :type wordList: List[str]\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def dfs(word, path):\n            if word == endWord:\n                res.append(path)\n                return\n            if word not in wordSet:\n                return\n            wordSet.remove(word)\n            for i in range(len(word)):\n                for j in range(26):\n                    newWord = word[:i] + chr(ord('a') + j) + word[i+1:]\n                    if newWord in wordSet:\n                        dfs(newWord, path + [newWord])\n            wordSet.add(word)\n        \n        wordSet = set(wordList)\n        res = []\n        dfs(beginWord, [beginWord])\n        return res"}], "balanced-binary-tree": [{"task_id": "balanced-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(root):\n            if not root:\n                return 0\n            left = dfs(root.left)\n            right = dfs(root.right)\n            if left == -1 or right == -1 or abs(left - right) > 1:\n                return -1\n            return max(left, right) + 1\n        \n        return dfs(root) != -1"}, {"task_id": "balanced-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(root):\n            if not root:\n                return 0\n            left = dfs(root.left)\n            right = dfs(root.right)\n            if left == -1 or right == -1 or abs(left - right) > 1:\n                return -1\n            return max(left, right) + 1\n        \n        return dfs(root) != -1"}, {"task_id": "balanced-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(root):\n            if not root:\n                return 0\n            left = dfs(root.left)\n            right = dfs(root.right)\n            if left == -1 or right == -1 or abs(left - right) > 1:\n                return -1\n            return 1 + max(left, right)\n        \n        return dfs(root) != -1"}, {"task_id": "balanced-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(root):\n            if not root:\n                return 0\n            left = dfs(root.left)\n            right = dfs(root.right)\n            if left == -1 or right == -1 or abs(left - right) > 1:\n                return -1\n            return max(left, right) + 1\n        \n        return dfs(root) != -1"}, {"task_id": "balanced-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isBalanced(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(root):\n            if not root:\n                return 0\n            left = dfs(root.left)\n            right = dfs(root.right)\n            if left == -1 or right == -1 or abs(left - right) > 1:\n                return -1\n            return 1 + max(left, right)\n        \n        return dfs(root) != -1"}], "power-of-two": [{"task_id": "power-of-two", "completion": "class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 1:\n            return True\n        if n == 0:\n            return False\n        \n        while n > 1:\n            if n % 2 == 0:\n                n = n / 2\n            else:\n                return False\n        return True"}, {"task_id": "power-of-two", "completion": "class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 1:\n            return True\n        if n == 0:\n            return False\n        if n % 2 != 0:\n            return False\n        return self.isPowerOfTwo(n/2)"}, {"task_id": "power-of-two", "completion": "class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 1:\n            return True\n        if n == 0:\n            return False\n        \n        while n > 1:\n            if n % 2 == 0:\n                n = n / 2\n            else:\n                return False\n        return True"}, {"task_id": "power-of-two", "completion": "class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 1:\n            return True\n        if n == 0:\n            return False\n        if n % 2 != 0:\n            return False\n        return self.isPowerOfTwo(n/2)"}, {"task_id": "power-of-two", "completion": "class Solution(object):\n    def isPowerOfTwo(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 1:\n            return True\n        if n == 0:\n            return False\n        \n        while n > 1:\n            if n % 2 != 0:\n                return False\n            n = n / 2\n        return True"}], "subsets-ii": [{"task_id": "subsets-ii", "completion": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        self.dfs(nums, [], res)\n        return res\n    \n    def dfs(self, nums, path, res):\n        res.append(path)\n        for i in range(len(nums)):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            self.dfs(nums[i+1:], path+[nums[i]], res)"}, {"task_id": "subsets-ii", "completion": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        self.dfs(nums, [], res)\n        return res\n    \n    def dfs(self, nums, path, res):\n        res.append(path)\n        for i in range(len(nums)):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            self.dfs(nums[i+1:], path+[nums[i]], res)"}, {"task_id": "subsets-ii", "completion": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        def dfs(nums, path):\n            res.append(path)\n            for i in range(len(nums)):\n                if i > 0 and nums[i] == nums[i-1]:\n                    continue\n                dfs(nums[i+1:], path + [nums[i]])\n        dfs(nums, [])\n        return res"}, {"task_id": "subsets-ii", "completion": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        self.dfs(nums, [], res)\n        return res\n    \n    def dfs(self, nums, path, res):\n        res.append(path)\n        for i in range(len(nums)):\n            if i > 0 and nums[i] == nums[i-1]:\n                continue\n            self.dfs(nums[i+1:], path+[nums[i]], res)"}, {"task_id": "subsets-ii", "completion": "class Solution(object):\n    def subsetsWithDup(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        nums.sort()\n        res = []\n        def dfs(nums, path):\n            res.append(path)\n            for i in range(len(nums)):\n                if i > 0 and nums[i] == nums[i-1]:\n                    continue\n                dfs(nums[i+1:], path + [nums[i]])\n        dfs(nums, [])\n        return res"}], "largest-rectangle-in-histogram": [{"task_id": "largest-rectangle-in-histogram", "completion": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u66b4\u529b\u89e3\u6cd5\n        # \u65f6\u95f4\u590d\u6742\u5ea6O(n^2)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6O(1)\n        # \u8d85\u65f6\n        # max_area = 0\n        # for i in range(len(heights)):\n        #     min_height = float('inf')\n        #     for j in range(i, len(heights)):\n        #         min_height = min(min_height, heights[j])\n        #         max_area = max(max_area, min_height * (j - i + 1))\n        # return max_area\n        \n        # 2. \u5355\u8c03\u6808\n        # \u65f6\u95f4\u590d\u6742\u5ea6O(n)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6O(n)\n        # \u5355\u8c03\u6808\u7684\u5b9a\u4e49\uff1a\u6808\u5185\u5143\u7d20\u5355\u8c03\u9012\u589e\n        # \u5355\u8c03\u6808\u7684\u5e94\u7528\uff1a\u6c42\u89e3\u4e0b\u4e00\u4e2a\u66f4\u5927\u5143\u7d20\n        # \u5355\u8c03\u6808\u7684\u5e94\u7528\uff1a\u6c42\u89e3\u4e0b\u4e00\u4e2a\u66f4\u5c0f\u5143\u7d20\n        # \u5355\u8c03\u6808\u7684\u5e94\u7528\uff1a\u6c42\u89e3\u4e0b\u4e00\u4e2a\u66f4\u5927\u5143\u7d20\u7684\u4e0b\u6807\n        # \u5355\u8c03\u6808\u7684\u5e94\u7528\uff1a\u6c42\u89e3\u4e0b\u4e00\u4e2a\u66f4\u5c0f\u5143\u7d20\u7684\u4e0b\u6807\n        # \u5355\u8c03\u6808\u7684\u5e94\u7528\uff1a\u6c42\u89e3\u4e0b\u4e00\u4e2a\u66f4\u5927\u5143\u7d20\u7684\u4e0b\u6807\u7684\u4e0b\u6807\n        # \u5355\u8c03\u6808\u7684\u5e94\u7528\uff1a\u6c42\u89e3\u4e0b\u4e00\u4e2a\u66f4\u5c0f\u5143\u7d20\u7684\u4e0b\u6807\u7684\u4e0b\u6807\n        # \u5355\u8c03\u6808\u7684\u5e94\u7528\uff1a\u6c42\u89e3\u4e0b\u4e00\u4e2a\u66f4\u5927\u5143\u7d20\u7684\u4e0b\u6807\u7684\u4e0b\u6807\u7684\u4e0b\u6807\n        # \u5355\u8c03\u6808\u7684\u5e94\u7528\uff1a\u6c42\u89e3\u4e0b\u4e00\u4e2a\u66f4\u5c0f\u5143\u7d20\u7684\u4e0b\u6807\u7684\u4e0b\u6807\u7684\u4e0b\u6807\n        # \u5355\u8c03\u6808\u7684\u5e94\u7528\uff1a\u6c42\u89e3\u4e0b\u4e00\u4e2a\u66f4\u5927\u5143\u7d20\u7684\u4e0b\u6807\u7684\u4e0b\u6807\u7684\u4e0b\u6807\u7684\u4e0b\u6807\n        # \u5355\u8c03\u6808\u7684\u5e94\u7528\uff1a\u6c42\u89e3\u4e0b\u4e00\u4e2a\u66f4\u5c0f\u5143\u7d20\u7684\u4e0b\u6807\u7684\u4e0b\u6807\u7684\u4e0b\u6807\u7684\u4e0b\u6807\n        # \u5355\u8c03\u6808\u7684\u5e94\u7528\uff1a\u6c42\u89e3\u4e0b\u4e00\u4e2a\u66f4\u5927\u5143\u7d20\u7684\u4e0b\u6807\u7684\u4e0b\u6807\u7684\u4e0b\u6807\u7684\u4e0b\u6807\u7684\u4e0b\u6807\n        # \u5355\u8c03\u6808\u7684\u5e94\u7528\uff1a\u6c42\u89e3\u4e0b\u4e00\u4e2a\u66f4\u5c0f\u5143\u7d20\u7684\u4e0b\u6807\u7684\u4e0b\u6807\u7684\u4e0b\u6807\u7684\u4e0b\u6807\u7684\u4e0b\u6807\n        # \u5355\u8c03\u6808\u7684\u5e94\u7528\uff1a\u6c42\u89e3\u4e0b\u4e00\u4e2a\u66f4\u5927\u5143\u7d20\u7684\u4e0b\u6807\u7684\u4e0b\u6807\u7684\u4e0b\u6807\u7684\u4e0b\u6807\u7684\u4e0b\u6807\u7684\u4e0b\u6807\n        # \u5355\u8c03\u6808\u7684\u5e94\u7528\uff1a\u6c42\u89e3\u4e0b\u4e00\u4e2a\u66f4\u5c0f\u5143\u7d20\u7684\u4e0b\u6807\u7684\u4e0b\u6807\u7684\u4e0b\u6807\u7684\u4e0b\u6807\u7684\u4e0b\u6807\u7684\u4e0b\u6807\n        # \u5355\u8c03\u6808\u7684\u5e94\u7528\uff1a\u6c42\u89e3\u4e0b\u4e00\u4e2a\u66f4\u5927\u5143\u7d20\u7684\u4e0b\u6807\u7684\u4e0b\u6807\u7684\u4e0b\u6807\u7684\u4e0b\u6807\u7684\u4e0b\u6807\u7684\u4e0b\u6807\u7684\u4e0b\u6807\n        # \u5355\u8c03\u6808\u7684\u5e94\u7528\uff1a\u6c42\u89e3\u4e0b\u4e00\u4e2a\u66f4\u5c0f\u5143\u7d20\u7684\u4e0b\u6807\u7684\u4e0b\u6807\u7684\u4e0b\u6807\u7684\u4e0b\u6807\u7684\u4e0b\u6807\u7684\u4e0b\u6807\u7684\u4e0b\u6807\n        # \u5355\u8c03\u6808\u7684\u5e94\u7528\uff1a\u6c42\u89e3\u4e0b\u4e00\u4e2a\u66f4\u5927\u5143\u7d20\u7684\u4e0b\u6807\u7684\u4e0b\u6807\u7684\u4e0b\u6807\u7684\u4e0b\u6807\u7684\u4e0b\u6807\u7684\u4e0b\u6807\u7684\u4e0b\u6807\u7684\u4e0b\u6807\n        # \u5355\u8c03\u6808\u7684\u5e94\u7528\uff1a\u6c42\u89e3\u4e0b\u4e00\u4e2a\u66f4\u5c0f\u5143\u7d20\u7684\u4e0b\u6807\u7684\u4e0b\u6807\u7684\u4e0b\u6807\u7684\u4e0b\u6807\u7684\u4e0b\u6807\u7684\u4e0b\u6807\u7684\u4e0b\u6807\u7684\u4e0b\u6807\n        # \u5355\u8c03\u6808\u7684\u5e94\u7528\uff1a\u6c42\u89e3\u4e0b\u4e00\u4e2a\u66f4\u5927\u5143\u7d20\u7684\u4e0b\u6807\u7684\u4e0b\u6807\u7684\u4e0b\u6807\u7684\u4e0b\u6807\u7684\u4e0b\u6807\u7684\u4e0b\u6807\u7684\u4e0b\u6807\u7684\u4e0b\u6807\u7684\u4e0b\u6807\n        # \u5355\u8c03\u6808\u7684\u5e94\u7528\uff1a\u6c42\u89e3\u4e0b\u4e00\u4e2a\u66f4\u5c0f\u5143\u7d20\u7684\u4e0b\u6807\u7684\u4e0b\u6807\u7684\u4e0b\u6807\u7684\u4e0b\u6807\u7684\u4e0b\u6807\u7684\u4e0b\u6807\u7684\u4e0b\u6807\u7684\u4e0b\u6807\u7684\u4e0b\u6807\n        # \u5355\u8c03\u6808\u7684\u5e94\u7528\uff1a\u6c42\u89e3\u4e0b\u4e00\u4e2a\u66f4\u5927\u5143\u7d20\u7684\u4e0b\u6807\u7684\u4e0b\u6807\u7684\u4e0b\u6807\u7684\u4e0b\u6807\u7684\u4e0b\u6807\u7684\u4e0b\u6807\u7684\u4e0b\u6807\u7684\u4e0b\u6807\u7684\u4e0b\u6807\u7684\u4e0b\u6807\n        # \u5355\u8c03\u6808\u7684\u5e94\u7528\uff1a\u6c42\u89e3\u4e0b\u4e00\u4e2a\u66f4\u5c0f\u5143\u7d20\u7684\u4e0b\u6807\u7684\u4e0b\u6807\u7684\u4e0b\u6807\u7684\u4e0b\u6807\u7684\u4e0b\u6807\u7684\u4e0b\u6807\u7684\u4e0b\u6807\u7684\u4e0b\u6807\u7684\u4e0b\u6807\u7684\u4e0b\u6807\n        # \u5355\u8c03\u6808\u7684\u5e94\u7528\uff1a\u6c42\u89e3\u4e0b\u4e00\u4e2a\u66f4\u5927\u5143\u7d20\u7684\u4e0b\u6807\u7684\u4e0b\u6807\u7684\u4e0b\u6807\u7684\u4e0b\u6807\u7684\u4e0b\u6807\u7684\u4e0b\u6807\u7684\u4e0b\u6807\u7684\u4e0b\u6807\u7684\u4e0b\u6807\u7684\u4e0b\u6807\u7684\u4e0b\u6807\n        # \u5355\u8c03\u6808\u7684\u5e94\u7528\uff1a\u6c42\u89e3\u4e0b\u4e00\u4e2a\u66f4\u5c0f\u5143\u7d20\u7684\u4e0b\u6807\u7684\u4e0b\u6807\u7684\u4e0b"}, {"task_id": "largest-rectangle-in-histogram", "completion": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u66b4\u529b\u89e3\u6cd5\n        # \u65f6\u95f4\u590d\u6742\u5ea6 O(n^2)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6 O(1)\n        # \u8d85\u65f6\n        # max_area = 0\n        # for i in range(len(heights)):\n        #     min_height = float('inf')\n        #     for j in range(i, len(heights)):\n        #         min_height = min(min_height, heights[j])\n        #         max_area = max(max_area, min_height * (j - i + 1))\n        # return max_area\n        \n        # 2. \u5355\u8c03\u6808\n        # \u65f6\u95f4\u590d\u6742\u5ea6 O(n)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6 O(n)\n        # \u5355\u8c03\u6808\u7684\u5e94\u7528\n        # \u5355\u8c03\u6808\u7684\u5b9a\u4e49\uff1a\u6808\u4e2d\u7684\u5143\u7d20\u4ece\u6808\u5e95\u5230\u6808\u9876\u662f\u5355\u8c03\u9012\u589e\u7684\n        # \u5355\u8c03\u6808\u7684\u5e94\u7528\uff1a\u6c42\u89e3\u6570\u7ec4\u4e2d\u6bcf\u4e2a\u5143\u7d20\u7684\u5de6\u53f3\u8fb9\u754c\n        # \u5355\u8c03\u6808\u7684\u5e94\u7528\uff1a\u6c42\u89e3\u6570\u7ec4\u4e2d\u6bcf\u4e2a\u5143\u7d20\u7684\u5de6\u53f3\u8fb9\u754c\n        # \u5355\u8c03\u6808\u7684\u5e94\u7528\ufffd\uff1a\u6c42\u89e3\u6570\u7ec4\u4e2d\u6bcf\u4e2a\u5143\u7d20\u7684\u5de6\u53f3\u8fb9\u754c"}, {"task_id": "largest-rectangle-in-histogram", "completion": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u66b4\u529b\u89e3\u6cd5\n        # \u65f6\u95f4\u590d\u6742\u5ea6 O(n^2)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6 O(1)\n        # \u8d85\u65f6\n        # max_area = 0\n        # for i in range(len(heights)):\n        #     min_height = float('inf')\n        #     for j in range(i, len(heights)):\n        #         min_height = min(min_height, heights[j])\n        #         max_area = max(max_area, min_height * (j - i + 1))\n        # return max_area\n        \n        # 2. \u5355\u8c03\u6808\n        # \u65f6\u95f4\u590d\u6742\u5ea6 O(n)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6 O(n)\n        # \u5355\u8c03\u6808\u7684\u5b9a\u4e49\uff1a\u6808\u4e2d\u7684\u5143\u7d20\u4ece\u6808\u5e95\u5230\u6808\u9876\u662f\u5355\u8c03\u4e0d\u964d\u7684\n        # \u5355\u8c03\u6808\u7684\u5e94\u7528\uff1a\u6c42\u89e3\u6570\u7ec4\u4e2d\u6bcf\u4e2a\u5143\u7d20\u7684\u5de6\u53f3\u8fb9\u754c\n        # \u5355\u8c03\u6808\u7684\u5b9e\u73b0\uff1a\n        # 1. \u4ece\u5de6\u5230\u53f3\u904d\u5386\u6570\u7ec4\uff0c\u7ef4\u62a4\u4e00\u4e2a\u5355\u8c03\u9012\u589e\u7684\u6808\n        # 2. \u5982\u679c\u5f53\u524d\u5143\u7d20\u6bd4\u6808\u9876\u5143\u7d20\u5927\uff0c\u5219\u5c06\u5f53\u524d\u5143\u7d20\u5165\u6808\n        # 3. \u5982\u679c\u5f53\u524d\u5143\u7d20\u6bd4\u6808\u9876\u5143\u7d20\u5c0f\uff0c\u5219\u5c06\u6808\u9876\u5143\u7d20\u51fa\u6808\uff0c\u5e76\u8ba1\u7b97\u4ee5\u6808\u9876\u5143\u7d20\u4e3a\u9ad8\u7684\u77e9\u5f62\u9762\u79ef\n        # 4. \u91cd\u590d\u6b65\u9aa42\u548c3\uff0c\u76f4\u5230\u5f53\u524d\u5143\u7d20\u6bd4\u6808\u9876\u5143\u7d20\u5927\uff0c\u6216\u8005\u6808\u4e3a\u7a7a\n        # 5. \u5c06\u5f53\u524d\u5143\u7d20\u5165\u6808\n        # 6. \u91cd\u590d\u6b65\u9aa41\u52305\uff0c\u76f4\u5230\u904d\u5386\u5b8c\u6570\u7ec4\n        # 7. \u5c06\u6808\u4e2d\u5269\u4f59\u7684\u5143\u7d20\u51fa\u6808\uff0c\u5e76\u8ba1\u7b97\u4ee5\u6808\u9876\u5143\u7d20\u4e3a\u9ad8\u7684\u77e9\u5f62\u9762\u79ef\n        # 8. \u91cd\u590d\u6b65\u9aa47\uff0c\u76f4\u5230\u6808\u4e3a\u7a7a\n        # 9. \u8fd4\u56de\u6700\u5927\u9762\u79ef\n        # 10. \u65f6\u95f4\u590d\u6742\u5ea6 O(n)\n        # 11. \u7a7a\u95f4\u590d\u6742\u5ea6 O(n)\n        # 12. \u5355\u8c03\u6808\u7684\u5b9e\u73b0\uff1a\n        # 13. \u4ece\u5de6\u5230\u53f3\u904d\u5386\u6570\u7ec4\uff0c\u7ef4\u62a4\u4e00\u4e2a\u5355\u8c03\u9012\u589e\u7684\u6808\n        # 14. \u5982\u679c\u5f53\u524d\u5143\u7d20\u6bd4\u6808\u9876\u5143\u7d20\u5927\uff0c\u5219\u5c06\u5f53\u524d\u5143\u7d20\u5165\u6808\n        # 15. \u5982\u679c\u5f53\u524d\u5143\u7d20\u6bd4\u6808\u9876\u5143\u7d20\u5c0f\uff0c\u5219\u5c06\u6808\u9876\u5143\u7d20\u51fa\u6808\uff0c\u5e76\u8ba1\u7b97\u4ee5\u6808\u9876\u5143\u7d20\u4e3a\u9ad8\u7684\u77e9\u5f62\u9762\u79ef\n        # 16. \u91cd\u590d\u6b65\u9aa414\u548c15\uff0c\u76f4\u5230\u5f53\u524d\u5143\u7d20\u6bd4\u6808\u9876\u5143\u7d20\u5927\uff0c\u6216\u8005\u6808\u4e3a\u7a7a\n        # 17. \u5c06\u5f53\u524d\u5143\u7d20\u5165\u6808\n        # 18. \u91cd\u590d\u6b65\u9aa413\u523017\uff0c\u76f4\u5230\u904d\u5386\u5b8c\u6570\u7ec4\n        # 19. \u5c06\u6808\u4e2d\u5269\u4f59\u7684\u5143\u7d20\u51fa\u6808\uff0c\u5e76\u8ba1\u7b97\u4ee5\u6808\u9876\u5143\u7d20\u4e3a\u9ad8\u7684\u77e9\u5f62\u9762\u79ef\n        # 20. \u91cd\u590d\u6b65\u9aa419\uff0c\u76f4\u5230\u6808\u4e3a\u7a7a\n        # 21. \u8fd4\u56de\u6700\u5927\u9762\u79ef\n        # 22. \u65f6\u95f4\u590d\u6742\u5ea6 O(n)\n        # 23. \u7a7a\u95f4\u590d\u6742\u5ea6 O(n)\n        # 24. \u5355\u8c03\u6808\u7684\u5b9e\u73b0\uff1a\n        # 25. \u4ece\u5de6\u5230\u53f3\u904d\u5386\u6570\u7ec4\uff0c\u7ef4\u62a4\u4e00\u4e2a\u5355\u8c03\u9012\u589e\u7684\u6808\n        # 26. \u5982\u679c\u5f53\u524d\u5143\u7d20\u6bd4\u6808\u9876\u5143\u7d20\u5927\uff0c\u5219\u5c06\u5f53\u524d\u5143\u7d20\u5165\u6808\n        # 27. \u5982\u679c\u5f53\u524d\u5143\u7d20\u6bd4\u6808\u9876\u5143\u7d20\u5c0f\uff0c\u5219\u5c06\u6808\u9876\u5143\u7d20\u51fa\u6808\uff0c\u5e76\u8ba1\u7b97\u4ee5\u6808\u9876\u5143\u7d20\u4e3a\u9ad8\u7684\u77e9\u5f62\u9762\u79ef\n        # 28. \u91cd\u590d\u6b65\u9aa426\u548c27\uff0c\u76f4\u5230\u5f53\u524d\u5143\u7d20\u6bd4\u6808\u9876\u5143\u7d20\u5927\uff0c\u6216\u8005\u6808\u4e3a\u7a7a\n        # 29. \u5c06\u5f53\u524d\u5143\u7d20\u5165\u6808\n        # 30. \u91cd\u590d\u6b65\u9aa425\u523029\uff0c\u76f4\u5230\u904d\u5386\u5b8c\u6570\u7ec4\n        # 31. \u5c06\u6808\u4e2d\u5269\u4f59\u7684\u5143\u7d20\u51fa\u6808\uff0c\u5e76\u8ba1\u7b97\u4ee5\u6808\u9876\u5143\u7d20\u4e3a\u9ad8\u7684\u77e9\u5f62\u9762\u79ef\n        # 32. \u91cd\u590d\u6b65\u9aa431\uff0c\u76f4\u5230\u6808\u4e3a\u7a7a\n        # 33. \u8fd4\u56de\u6700\u5927\u9762\u79ef\n        # 34. \u65f6\u95f4\u590d\u6742\u5ea6 O(n)\n        # 35. \u7a7a\u95f4\u590d\u6742\u5ea6"}, {"task_id": "largest-rectangle-in-histogram", "completion": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u66b4\u529b\u89e3\u6cd5\n        # \u65f6\u95f4\u590d\u6742\u5ea6O(n^2)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6O(1)\n        # \u8d85\u65f6\n        # max_area = 0\n        # for i in range(len(heights)):\n        #     min_height = float('inf')\n        #     for j in range(i, len(heights)):\n        #         min_height = min(min_height, heights[j])\n        #         max_area = max(max_area, min_height * (j - i + 1))\n        # return max_area\n        \n        # 2. \u5355\u8c03\u6808\n        # \u65f6\u95f4\u590d\u6742\u5ea6O(n)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6O(n)\n        # \u5355\u8c03\u6808\u7684\u5b9a\u4e49\uff1a\u6808\u4e2d\u5143\u7d20\u5355\u8c03\u9012\u589e\n        # \u5355\u8c03\u6808\u7684\u5e94\u7528\uff1a\u6c42\u89e3\u6570\u7ec4\u4e2d\u6bcf\u4e2a\u5143\u7d20\u5de6\u8fb9\u7b2c\u4e00\u4e2a\u6bd4\u5b83\u5c0f\u7684\u5143\u7d20\uff0c\u53f3\u8fb9\u7b2c\u4e00\u4e2a\u6bd4\u5b83\u5c0f\u7684\u5143\u7d20\n        # \u5355\u8c03\u6808\u7684\u5e94\u7528\uff1a\u6c42\u89e3\u6570\u7ec4\u4e2d\u6bcf\u4e2a\u5143\u7d20\u5de6\u8fb9\u7b2c\u4e00\u4e2a\u6bd4\u5b83\u5927\u7684\u5143\u7d20\uff0c\u53f3\u8fb9\u7b2c\u4e00\u4e2a\u6bd4\u5b83\u5927\u7684\u5143\u7d20\n        # \u5355\u8c03\u6808\u7684\u5e94\u7528\ufffd\uff1a\u6c42\u89e3\u6570\u7ec4\u4e2d\u6bcf\u4e2a\u5143\u7d20\u5de6\u8fb9\u7b2c\u4e00\u4e2a\u6bd4\u5b83\u5c0f\u7684\u5143\u7d20\uff0c\u53f3\u8fb9\u7b2c\u4e00\u4e2a\u6bd4\u5b83\u5c0f\u7684\u5143\u7d20\uff0c\u53f3\u8fb9\u7b2c\u4e00\u4e2a\u6bd4\u5b83\u5927\u7684\u5143\u7d20\uff0c\u5de6\u8fb9\u7b2c\u4e00\u4e2a\u6bd4\u5b83\u5927\u7684\u5143\u7d20"}, {"task_id": "largest-rectangle-in-histogram", "completion": "class Solution(object):\n    def largestRectangleArea(self, heights):\n        \"\"\"\n        :type heights: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u5355\u8c03\u6808\n        # 2. \u5355\u8c03\u6808\u7684\u5e94\u7528\n        # 3. \u5355\u8c03\u6808\u7684\u5e94\u7528\n        # 4. \u5355\u8c03\u6808\u7684\u5e94\u7528\n        # 5. \u5355\u8c03\u6808\u7684\u5e94\u7528\n        # 6. \u5355\u8c03\u6808\u7684\u5e94\u7528\n        # 7. \u5355\u8c03\u6808\u7684\u5e94\u7528\n        # 8. \u5355\u8c03\u6808\u7684\u5e94\u7528\n        # 9. \u5355\u8c03\u6808\u7684\u5e94\u7528\n        # 10. \u5355\u8c03\u6808\u7684\u5e94\u7528\n        # 11. \u5355\u8c03\u6808\u7684\u5e94\u7528\n        # 12. \u5355\u8c03\u6808\u7684\u5e94\u7528\n        # 13. \u5355\u8c03\u6808\u7684\u5e94\u7528\n        # 14. \u5355\u8c03\u6808\u7684\u5e94\u7528\n        # 15. \u5355\u8c03\u6808\u7684\u5e94\u7528\n        # 16. \u5355\u8c03\u6808\u7684\u5e94\u7528\n        # 17. \u5355\u8c03\u6808\u7684\u5e94\u7528\n        # 18. \u5355\u8c03\u6808\u7684\u5e94\u7528\n        # 19. \u5355\u8c03\u6808\u7684\u5e94\u7528\n        # 20. \u5355\u8c03\u6808\u7684\u5e94\u7528\n        # 21. \u5355\u8c03\u6808\u7684\u5e94\u7528\n        # 22. \u5355\u8c03\u6808\u7684\u5e94\u7528\n        # 23. \u5355\u8c03\u6808\u7684\u5e94\u7528\n        # 24. \u5355\u8c03\u6808\u7684\u5e94\u7528\n        # 25. \u5355\u8c03\u6808\u7684\u5e94\u7528\n        # 26. \u5355\u8c03\u6808\u7684\u5e94\u7528\n        # 27. \u5355\u8c03\u6808\u7684\u5e94\u7528\n        # 28. \u5355\u8c03\u6808\u7684\u5e94\u7528\n        # 29. \u5355\u8c03\u6808\u7684\u5e94\u7528\n        # 30. \u5355\u8c03\u6808\u7684\u5e94\u7528\n        # 31. \u5355\u8c03\u6808\u7684\u5e94\u7528\n        # 32. \u5355\u8c03\u6808\u7684\u5e94\u7528\n        # 33. \u5355\u8c03\u6808\u7684\u5e94\u7528\n        # 34. \u5355\u8c03\u6808\u7684\u5e94\u7528\n        # 35. \u5355\u8c03\u6808\u7684\u5e94\u7528\n        # 36. \u5355\u8c03\u6808\u7684\u5e94\u7528\n        # 37. \u5355\u8c03\u6808\u7684\u5e94\u7528\n        # 38. \u5355\u8c03\u6808\u7684\u5e94\u7528\n        # 39. \u5355\u8c03\u6808\u7684\u5e94\u7528\n        # 40. \u5355\u8c03\u6808\u7684\u5e94\u7528\n        # 41. \u5355\u8c03\u6808\u7684\u5e94\u7528\n        # 42. \u5355\u8c03\u6808\u7684\u5e94\u7528\n        # 43. \u5355\u8c03\u6808\u7684\u5e94\u7528\n        # 44. \u5355\u8c03\u6808\u7684\u5e94\u7528\n        # 45. \u5355\u8c03\u6808\u7684\u5e94\u7528\n        # 46. \u5355\u8c03\u6808\u7684\u5e94\u7528\n        # 47. \u5355\u8c03\u6808\u7684\u5e94\u7528\n        # 48. \u5355\u8c03\u6808\u7684\u5e94\u7528\n        # 49. \u5355\u8c03\u6808\u7684\u5e94\u7528\n        # 50. \u5355\u8c03\u6808\u7684\u5e94\u7528\n        # 51. \u5355\u8c03\u6808\u7684\u5e94\u7528\n        # 52. \u5355\u8c03\u6808\u7684\u5e94\u7528\n        # 53. \u5355\u8c03\u6808\u7684\u5e94\u7528\n        # 54. \u5355\u8c03\u6808\u7684\u5e94\u7528\n        # 55. \u5355\u8c03\u6808\u7684\u5e94\u7528\n        # 56. \u5355\u8c03\u6808\u7684\u5e94\u7528\n        # 57. \u5355\u8c03\u6808\u7684\u5e94\u7528\n        # 58. \u5355\u8c03\u6808\u7684\u5e94\u7528\n        # 59. \u5355\u8c03\u6808\u7684\u5e94\u7528\n        # 60. \u5355\u8c03\u6808\u7684\u5e94\u7528\n        # 61. \u5355\u8c03\u6808\u7684\u5e94\u7528\n        # 62. \u5355\u8c03\u6808\u7684\u5e94\u7528\n        # 63. \u5355\u8c03\u6808\u7684\u5e94\u7528\n        # 64. \u5355\u8c03\u6808\u7684\u5e94\u7528\n        # 65. \u5355\u8c03\u6808\u7684\u5e94\u7528\n        # 66. \u5355\u8c03\u6808\u7684\u5e94\u7528\n        # 67. \u5355\u8c03\u6808\u7684\u5e94\u7528\n        # 68. \u5355\u8c03\u6808\u7684\u5e94\u7528\n        # 69. \u5355\u8c03\u6808\u7684\u5e94\u7528\n        # 70. \u5355\u8c03\u6808\u7684\u5e94\u7528\n        # 71. \u5355\u8c03\u6808\u7684\u5e94\u7528\n        # 72. \u5355\u8c03\u6808\u7684\u5e94\u7528\n        # 73. \u5355\u8c03\u6808\u7684\u5e94\u7528\n        # 74. \u5355\u8c03\u6808\u7684\u5e94\u7528"}], "evaluate-reverse-polish-notation": [{"task_id": "evaluate-reverse-polish-notation", "completion": "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        for token in tokens:\n            if token in \"+-*/\":\n                b = stack.pop()\n                a = stack.pop()\n                if token == \"+\":\n                    stack.append(a + b)\n                elif token == \"-\":\n                    stack.append(a - b)\n                elif token == \"*\":\n                    stack.append(a * b)\n                elif token == \"/\":\n                    stack.append(int(float(a) / b))\n            else:\n                stack.append(int(token))\n        return stack[0]"}, {"task_id": "evaluate-reverse-polish-notation", "completion": "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        for token in tokens:\n            if token in \"+-*/\":\n                b = stack.pop()\n                a = stack.pop()\n                if token == \"+\":\n                    stack.append(a + b)\n                elif token == \"-\":\n                    stack.append(a - b)\n                elif token == \"*\":\n                    stack.append(a * b)\n                elif token == \"/\":\n                    stack.append(int(float(a) / b))\n            else:\n                stack.append(int(token))\n        return stack[0]"}, {"task_id": "evaluate-reverse-polish-notation", "completion": "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        for token in tokens:\n            if token in \"+-*/\":\n                b = stack.pop()\n                a = stack.pop()\n                if token == \"+\":\n                    stack.append(a+b)\n                elif token == \"-\":\n                    stack.append(a-b)\n                elif token == \"*\":\n                    stack.append(a*b)\n                elif token == \"/\":\n                    stack.append(int(float(a)/b))\n            else:\n                stack.append(int(token))\n        return stack[0]"}, {"task_id": "evaluate-reverse-polish-notation", "completion": "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        for token in tokens:\n            if token not in \"+-*/\":\n                stack.append(int(token))\n            else:\n                num2 = stack.pop()\n                num1 = stack.pop()\n                if token == \"+\":\n                    stack.append(num1 + num2)\n                elif token == \"-\":\n                    stack.append(num1 - num2)\n                elif token == \"*\":\n                    stack.append(num1 * num2)\n                else:\n                    stack.append(int(float(num1) / num2))\n        return stack[0]"}, {"task_id": "evaluate-reverse-polish-notation", "completion": "class Solution(object):\n    def evalRPN(self, tokens):\n        \"\"\"\n        :type tokens: List[str]\n        :rtype: int\n        \"\"\"\n        \n        stack = []\n        for token in tokens:\n            if token not in \"+-*/\":\n                stack.append(int(token))\n            else:\n                b = stack.pop()\n                a = stack.pop()\n                if token == \"+\":\n                    stack.append(a+b)\n                elif token == \"-\":\n                    stack.append(a-b)\n                elif token == \"*\":\n                    stack.append(a*b)\n                elif token == \"/\":\n                    stack.append(int(float(a)/b))\n        return stack[0]"}], "perfect-rectangle": [{"task_id": "perfect-rectangle", "completion": "class Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. find the min and max x and y\n        # 2. find the area of the whole rectangle\n        # 3. find the area of the whole rectangle\n        # 4. if the area of the whole rectangle is not equal to the area of the whole rectangle, return False\n        # 5. if the area of the whole rectangle is equal to the area of the whole rectangle, return True\n        \n        # 1. find the min and max x and y\n        min_x = float('inf')\n        min_y = float('inf')\n        max_x = float('-inf')\n        max_y = float('-inf')\n        for x, y, a, b in rectangles:\n            min_x = min(min_x, x)\n            min_y = min(min_y, y)\n            max_x = max(max_x, a)\n            max_y = max(max_y, b)\n        \n        # 2. find the area of the whole rectangle\n        area = (max_x - min_x) * (max_y - min_y)\n        \n        # 3. find the area of the whole rectangle\n        for x, y, a, b in rectangles:\n            area -= (a - x) * (b - y)\n        \n        # 4. if the area of the whole rectangle is not equal to the area of the whole rectangle, return False\n        if area != 0:\n            return False\n        \n        # 5. if the area of the whole rectangle is equal to the area of the whole rectangle, return True\n        return True"}, {"task_id": "perfect-rectangle", "completion": "class Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. find the min and max x and y\n        # 2. find the area of the whole rectangle\n        # 3. find the area of the whole rectangle\n        # 4. if the area of the whole rectangle is not equal to the area of the whole rectangle, return False\n        # 5. if the area of the whole rectangle is equal to the area of the whole rectangle, return True\n        \n        # 1. find the min and max x and y\n        min_x = float('inf')\n        min_y = float('inf')\n        max_x = float('-inf')\n        max_y = float('-inf')\n        for x, y, a, b in rectangles:\n            min_x = min(min_x, x)\n            min_y = min(min_y, y)\n            max_x = max(max_x, a)\n            max_y = max(max_y, b)\n        \n        # 2. find the area of the whole rectangle\n        area = (max_x - min_x) * (max_y - min_y)\n        \n        # 3. find the area of the whole rectangle\n        for x, y, a, b in rectangles:\n            area -= (a - x) * (b - y)\n        \n        # 4. if the area of the whole rectangle is not equal to the area of the whole rectangle, return False\n        if area != 0:\n            return False\n        \n        # 5. if the area of the whole rectangle is equal to the area of the whole rectangle, return True\n        return True"}, {"task_id": "perfect-rectangle", "completion": "class Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \u8ba1\u7b97\u51fa\u77e9\u5f62\u7684\u9762\u79ef\u548c\n        # 2. \u8ba1\u7b97\u51fa\u77e9\u5f62\u7684\u6700\u5c0f\u77e9\u5f62\n        # 3. \u5224\u65ad\u6700\u5c0f\u77e9\u5f62\u7684\u9762\u79ef\u662f\u5426\u7b49\u4e8e\u77e9\u5f62\u7684\u9762\u79ef\u548c\n        # 4. \u5224\u65ad\u6700\u5c0f\u77e9\u5f62\u7684\u9762\u79ef\u662f\u5426\u7b49\u4e8e\u77e9\u5f62\u7684\u9762\u79ef\u548c\n        # 5. \u5224\u65ad\u6700\u5c0f\u77e9\u5f62\u7684\u9762\u79ef\u662f\u5426\u7b49\u4e8e\u77e9\u5f62\u7684\u9762\u79ef\u548c\n        # 6. \u5224\u65ad\u6700\u5c0f\u77e9\u5f62\u7684\u9762\u79ef\u662f\u5426\u7b49\u4e8e\u77e9\u5f62\u7684\u9762\u79ef\u548c\n        # 7. \u5224\u65ad\u6700\u5c0f\u77e9\u5f62\u7684\u9762\u79ef\u662f\u5426\u7b49\u4e8e\u77e9\u5f62\u7684\u9762\u79ef\u548c\n        # 8. \u5224\u65ad\u6700\u5c0f\u77e9\u5f62\u7684\u9762\u79ef\u662f\u5426\u7b49\u4e8e\u77e9\u5f62\u7684\u9762\u79ef\u548c\n        # 9. \u5224\u65ad\u6700\u5c0f\u77e9\u5f62\u7684\u9762\u79ef\u662f\u5426\u7b49\u4e8e\u77e9\u5f62\u7684\u9762\u79ef\u548c\n        # 10. \u5224\u65ad\u6700\u5c0f\u77e9\u5f62\u7684\u9762\u79ef\u662f\u5426\u7b49\u4e8e\u77e9\u5f62\u7684\u9762\u79ef\u548c\n        # 11. \u5224\u65ad\u6700\u5c0f\u77e9\u5f62\u7684\u9762\u79ef\u662f\u5426\u7b49\u4e8e\u77e9\u5f62\u7684\u9762\u79ef\u548c\n        # 12. \u5224\u65ad\u6700\u5c0f\u77e9\u5f62\u7684\u9762\u79ef\u662f\u5426\u7b49\u4e8e\u77e9\u5f62\u7684\u9762\u79ef\u548c\n        # 13. \u5224\u65ad\u6700\u5c0f\u77e9\u5f62\u7684\u9762\u79ef\u662f\u5426\u7b49\u4e8e\u77e9\u5f62\u7684\u9762\u79ef\u548c\n        # 14. \u5224\u65ad\u6700\u5c0f\u77e9\u5f62\u7684\u9762\u79ef\u662f\u5426\u7b49\u4e8e\u77e9\u5f62\u7684\u9762\u79ef\u548c\n        # 15. \u5224\u65ad\u6700\u5c0f\u77e9\u5f62\u7684\u9762\u79ef\u662f\u5426\u7b49\u4e8e\u77e9\u5f62\u7684\u9762\u79ef\u548c\n        # 16. \u5224\u65ad\u6700\u5c0f\u77e9\u5f62\u7684\u9762\u79ef\u662f\u5426\u7b49\u4e8e\u77e9\u5f62\u7684\u9762\u79ef\u548c\n        # 17. \u5224\u65ad\u6700\u5c0f\u77e9\u5f62\u7684\u9762\u79ef\u662f\u5426\u7b49\u4e8e\u77e9\u5f62\u7684\u9762\u79ef\u548c\n        # 18. \u5224\u65ad\u6700\u5c0f\u77e9\u5f62\u7684\u9762\u79ef\u662f\u5426\u7b49\u4e8e\u77e9\u5f62\u7684\u9762\u79ef\u548c\n        # 19. \u5224\u65ad\u6700\u5c0f\u77e9\u5f62\u7684\u9762\u79ef\u662f\u5426\u7b49\u4e8e\u77e9\u5f62\u7684\u9762\u79ef\u548c\n        # 20. \u5224\u65ad\u6700\u5c0f\u77e9\u5f62\u7684\u9762\u79ef\u662f\u5426\u7b49\u4e8e\u77e9\u5f62\u7684\u9762\u79ef\u548c\n        # 21. \u5224\u65ad\u6700\u5c0f\u77e9\u5f62\u7684\u9762\u79ef\u662f\u5426\u7b49\u4e8e\u77e9\u5f62\u7684\u9762\u79ef\u548c\n        # 22. \u5224\u65ad\u6700\u5c0f\u77e9\u5f62\u7684\u9762\u79ef\u662f\u5426\u7b49\u4e8e\u77e9\u5f62\u7684\u9762\u79ef\u548c\n        # 23. \u5224\u65ad\u6700\u5c0f\u77e9\u5f62\u7684\u9762\u79ef\u662f\u5426\u7b49\u4e8e\u77e9\u5f62\u7684\u9762\u79ef\u548c\n        # 24. \u5224\u65ad\u6700\u5c0f\u77e9\u5f62\u7684\u9762\u79ef\u662f\u5426\u7b49\u4e8e\u77e9\u5f62\u7684\u9762\u79ef\u548c\n        # 25. \u5224\u65ad\u6700\u5c0f\u77e9\u5f62\u7684\u9762\u79ef\u662f\u5426\u7b49\u4e8e\u77e9\u5f62\u7684\u9762\u79ef\u548c\n        # 26. \u5224\u65ad\u6700\u5c0f\u77e9\u5f62\u7684\u9762\u79ef\u662f\u5426\u7b49\u4e8e\u77e9\u5f62\u7684\u9762\u79ef\u548c\n        # 27. \u5224\u65ad\u6700\u5c0f\u77e9\u5f62\u7684\u9762\u79ef\u662f\u5426\u7b49\u4e8e\u77e9\u5f62\u7684\u9762\u79ef\u548c\n        # 28. \u5224\u65ad\u6700\u5c0f\u77e9\u5f62\u7684\u9762\u79ef\u662f\u5426\u7b49\u4e8e\u77e9\u5f62\u7684\u9762\u79ef\u548c\n        # 29. \u5224\u65ad\u6700\u5c0f\u77e9\u5f62\u7684\u9762\u79ef\u662f\u5426\u7b49\u4e8e\u77e9\u5f62\u7684\u9762\u79ef\u548c\n        # 30. \u5224\u65ad\u6700\u5c0f\u77e9\u5f62\u7684\u9762\u79ef\u662f\u5426\u7b49\u4e8e\u77e9\u5f62\u7684\u9762\u79ef\u548c\n        # 31. \u5224\u65ad\u6700\u5c0f\u77e9\u5f62\u7684\u9762\u79ef\u662f\u5426\u7b49\u4e8e\u77e9\u5f62\u7684\u9762\u79ef\u548c\n        # 32. \u5224\u65ad\u6700\u5c0f\u77e9\u5f62\u7684\u9762\u79ef\u662f\u5426\u7b49\u4e8e\u77e9\u5f62\u7684\u9762\u79ef\u548c\n        # 33. \u5224\u65ad\u6700\u5c0f\u77e9\u5f62\u7684\u9762\u79ef\u662f\u5426\u7b49\u4e8e\u77e9\u5f62\u7684\u9762\u79ef\u548c\n        # 34. \u5224\u65ad\u6700\u5c0f\u77e9\u5f62\u7684\u9762\u79ef\u662f\u5426\u7b49\u4e8e\u77e9\u5f62\u7684\u9762\u79ef\u548c\n        # 35. \u5224\u65ad\u6700\u5c0f\u77e9\u5f62\u7684\u9762\u79ef\u662f\u5426\u7b49\u4e8e\u77e9\u5f62\u7684\u9762\u79ef\u548c\n        # 36. \u5224\u65ad\u6700\u5c0f\u77e9\u5f62\u7684\u9762\u79ef\u662f\u5426\u7b49\u4e8e\u77e9\u5f62\u7684\u9762\u79ef\u548c\n        # 37. \u5224\u65ad\u6700\u5c0f\u77e9\u5f62\u7684\u9762\u79ef\u662f\u5426\u7b49\u4e8e\u77e9\u5f62\u7684\u9762\u79ef\u548c\n        # 38. \u5224\u65ad\u6700\u5c0f\u77e9\u5f62\u7684\u9762\u79ef\u662f\u5426\u7b49\u4e8e\u77e9\u5f62\u7684\u9762\u79ef\u548c\n        # 39. \u5224\u65ad\u6700\u5c0f\u77e9\u5f62\u7684\u9762\u79ef\u662f\u5426\u7b49\u4e8e\u77e9\u5f62\u7684\u9762\u79ef\u548c\n        # 40. \u5224\u65ad\u6700\u5c0f\u77e9\u5f62\u7684\u9762\u79ef\u662f\u5426\u7b49\u4e8e\u77e9\u5f62\u7684\u9762\u79ef\u548c\n        # 41. \u5224\u65ad\u6700\u5c0f\u77e9\u5f62\u7684\u9762\u79ef\u662f\u5426\u7b49\u4e8e\u77e9\u5f62\u7684\u9762\u79ef\u548c\n        # 42. \u5224\u65ad\u6700\u5c0f\u77e9\u5f62\u7684\u9762\u79ef\u662f\u5426\u7b49\u4e8e\u77e9\u5f62\u7684\u9762\u79ef\u548c\n        # 43. \u5224\u65ad\u6700\u5c0f\u77e9\u5f62\u7684\u9762\u79ef\u662f\u5426\u7b49\u4e8e\u77e9\u5f62\u7684\u9762\u79ef\u548c\n        # 44. \u5224\u65ad\u6700\u5c0f\u77e9\u5f62\u7684\u9762\u79ef\u662f\u5426\u7b49\u4e8e\u77e9\u5f62\u7684\u9762\u79ef\u548c\n        # 45. \u5224\u65ad\u6700\u5c0f\u77e9\u5f62\u7684\u9762\u79ef\u662f\u5426\u7b49\u4e8e\u77e9\u5f62\u7684\u9762\u79ef\u548c\n        # 46. \u5224\u65ad\u6700\u5c0f\u77e9\u5f62"}, {"task_id": "perfect-rectangle", "completion": "class Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. find the min and max x and y\n        # 2. find the area of the whole rectangle\n        # 3. find the area of the whole rectangle\n        # 4. if the area of the whole rectangle is not equal to the area of the whole rectangle, return False\n        # 5. if the area of the whole rectangle is equal to the area of the whole rectangle, return True\n        \n        # 1. find the min and max x and y\n        min_x = float('inf')\n        min_y = float('inf')\n        max_x = float('-inf')\n        max_y = float('-inf')\n        for x, y, a, b in rectangles:\n            min_x = min(min_x, x)\n            min_y = min(min_y, y)\n            max_x = max(max_x, a)\n            max_y = max(max_y, b)\n        \n        # 2. find the area of the whole rectangle\n        area = (max_x - min_x) * (max_y - min_y)\n        \n        # 3. find the area of the whole rectangle\n        for x, y, a, b in rectangles:\n            area -= (a - x) * (b - y)\n        \n        # 4. if the area of the whole rectangle is not equal to the area of the whole rectangle, return False\n        if area != 0:\n            return False\n        \n        # 5. if the area of the whole rectangle is equal to the area of the whole rectangle, return True\n        return True"}, {"task_id": "perfect-rectangle", "completion": "class Solution(object):\n    def isRectangleCover(self, rectangles):\n        \"\"\"\n        :type rectangles: List[List[int]]\n        :rtype: bool\n        \"\"\"\n        \n        # 1. find the min and max x and y\n        # 2. find the area of the whole rectangle\n        # 3. find the area of the whole rectangle\n        # 4. if the area of the whole rectangle is not equal to the area of the whole rectangle, return False\n        # 5. if the area of the whole rectangle is equal to the area of the whole rectangle, return True\n        \n        # 1. find the min and max x and y\n        min_x = float('inf')\n        min_y = float('inf')\n        max_x = float('-inf')\n        max_y = float('-inf')\n        for x, y, a, b in rectangles:\n            min_x = min(min_x, x)\n            min_y = min(min_y, y)\n            max_x = max(max_x, a)\n            max_y = max(max_y, b)\n        \n        # 2. find the area of the whole rectangle\n        area = (max_x - min_x) * (max_y - min_y)\n        \n        # 3. find the area of the whole rectangle\n        for x, y, a, b in rectangles:\n            area -= (a - x) * (b - y)\n        \n        # 4. if the area of the whole rectangle is not equal to the area of the whole rectangle, return False\n        if area != 0:\n            return False\n        \n        # 5. if the area of the whole rectangle is equal to the area of the whole rectangle, return True\n        return True"}], "excel-sheet-column-title": [{"task_id": "excel-sheet-column-title", "completion": "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 2. 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 3. 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236"}, {"task_id": "excel-sheet-column-title", "completion": "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 2. 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 3. 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236"}, {"task_id": "excel-sheet-column-title", "completion": "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 2. 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 3. 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236"}, {"task_id": "excel-sheet-column-title", "completion": "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 2. 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 3. 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236"}, {"task_id": "excel-sheet-column-title", "completion": "class Solution(object):\n    def convertToTitle(self, columnNumber):\n        \"\"\"\n        :type columnNumber: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 2. 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 3. 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236\n        # 10\u8fdb\u5236\u8f6c\u6362\u4e3a26\u8fdb\u5236\n        \n        # 1. 26\u8fdb\u5236\u8f6c\u6362\n        # 26\u8fdb\u5236\u8f6c\u6362\u4e3a10\u8fdb\u5236"}], "maximum-subarray": [{"task_id": "maximum-subarray", "completion": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Kadane's Algorithm\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        max_sum = nums[0]\n        curr_sum = nums[0]\n        \n        for i in range(1, len(nums)):\n            curr_sum = max(nums[i], curr_sum + nums[i])\n            max_sum = max(max_sum, curr_sum)\n            \n        return max_sum"}, {"task_id": "maximum-subarray", "completion": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Kadane's Algorithm\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        max_sum = nums[0]\n        curr_sum = nums[0]\n        \n        for i in range(1, len(nums)):\n            curr_sum = max(nums[i], curr_sum + nums[i])\n            max_sum = max(max_sum, curr_sum)\n            \n        return max_sum"}, {"task_id": "maximum-subarray", "completion": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Kadane's Algorithm\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        max_sum = nums[0]\n        curr_sum = nums[0]\n        \n        for i in range(1, len(nums)):\n            curr_sum = max(nums[i], curr_sum + nums[i])\n            max_sum = max(max_sum, curr_sum)\n            \n        return max_sum"}, {"task_id": "maximum-subarray", "completion": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Kadane's Algorithm\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        # Initialize the variables\n        max_sum = nums[0]\n        current_sum = nums[0]\n        \n        # Iterate through the array\n        for i in range(1, len(nums)):\n            # Update the current sum\n            current_sum = max(nums[i], current_sum + nums[i])\n            # Update the maximum sum\n            max_sum = max(max_sum, current_sum)\n        \n        # Return the maximum sum\n        return max_sum"}, {"task_id": "maximum-subarray", "completion": "class Solution(object):\n    def maxSubArray(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # Kadane's Algorithm\n        # Time Complexity: O(n)\n        # Space Complexity: O(1)\n        \n        max_sum = nums[0]\n        curr_sum = nums[0]\n        \n        for i in range(1, len(nums)):\n            curr_sum = max(nums[i], curr_sum + nums[i])\n            max_sum = max(max_sum, curr_sum)\n            \n        return max_sum"}], "sliding-puzzle": [{"task_id": "sliding-puzzle", "completion": "class Solution(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def swap(board, i, j):\n            board[i], board[j] = board[j], board[i]\n            return board\n        \n        def get_neighbors(board):\n            neighbors = []\n            for i in range(len(board)):\n                for j in range(len(board[0])):\n                    if board[i][j] == 0:\n                        if i > 0:\n                            neighbors.append(swap(board[:], i, i-1))\n                        if i < len(board)-1:\n                            neighbors.append(swap(board[:], i, i+1))\n                        if j > 0:\n                            neighbors.append(swap(board[:], i, i-1))\n                        if j < len(board[0])-1:\n                            neighbors.append(swap(board[:], i, i+1))\n            return neighbors\n        \n        def is_solved(board):\n            return board == [[1,2,3],[4,5,0]]\n        \n        def bfs(board):\n            queue = [(board, 0)]\n            visited = set()\n            while queue:\n                board, moves = queue.pop(0)\n                if is_solved(board):\n                    return moves\n                visited.add(tuple(board))\n                for neighbor in get_neighbors(board):\n                    if tuple(neighbor) not in visited:\n                        queue.append((neighbor, moves+1))\n            return -1\n        \n        return bfs(board)"}, {"task_id": "sliding-puzzle", "completion": "class Solution(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def swap(board, i, j):\n            board[i], board[j] = board[j], board[i]\n            return board\n        \n        def get_neighbors(board):\n            neighbors = []\n            for i in range(len(board)):\n                for j in range(len(board[0])):\n                    if board[i][j] == 0:\n                        if i > 0:\n                            neighbors.append(swap(board[:], i, i-1))\n                        if i < len(board)-1:\n                            neighbors.append(swap(board[:], i, i+1))\n                        if j > 0:\n                            neighbors.append(swap(board[:], i, i-1))\n                        if j < len(board[0])-1:\n                            neighbors.append(swap(board[:], i, i+1))\n            return neighbors\n        \n        def is_solved(board):\n            return board == [[1,2,3],[4,5,0]]\n        \n        def bfs(board):\n            queue = [(board, 0)]\n            visited = set()\n            while queue:\n                board, moves = queue.pop(0)\n                if is_solved(board):\n                    return moves\n                visited.add(tuple(board))\n                for neighbor in get_neighbors(board):\n                    if tuple(neighbor) not in visited:\n                        queue.append((neighbor, moves+1))\n            return -1\n        \n        return bfs(board)"}, {"task_id": "sliding-puzzle", "completion": "class Solution(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def swap(board, i, j):\n            board[i], board[j] = board[j], board[i]\n            return board\n        \n        def get_neighbors(board):\n            neighbors = []\n            i = board.index(0)\n            if i == 0:\n                neighbors.append(swap(board, i, i+1))\n                neighbors.append(swap(board, i, i+3))\n            elif i == 1:\n                neighbors.append(swap(board, i, i-1))\n                neighbors.append(swap(board, i, i+1))\n                neighbors.append(swap(board, i, i+2))\n            elif i == 2:\n                neighbors.append(swap(board, i, i-1))\n                neighbors.append(swap(board, i, i+1))\n            elif i == 3:\n                neighbors.append(swap(board, i, i-3))\n                neighbors.append(swap(board, i, i-1))\n                neighbors.append(swap(board, i, i+1))\n            elif i == 4:\n                neighbors.append(swap(board, i, i-3))\n                neighbors.append(swap(board, i, i-1))\n            elif i == 5:\n                neighbors.append(swap(board, i, i-2))\n                neighbors.append(swap(board, i, i-1))\n                neighbors.append(swap(board, i, i+1))\n            return neighbors\n        \n        def is_solved(board):\n            return board == [1,2,3,4,5,0]\n        \n        def bfs(board):\n            queue = [(board, 0)]\n            visited = set()\n            while queue:\n                board, moves = queue.pop(0)\n                if is_solved(board):\n                    return moves\n                visited.add(tuple(board))\n                for neighbor in get_neighbors(board):\n                    if tuple(neighbor) not in visited:\n                        queue.append((neighbor, moves+1))\n            return -1\n        \n        return bfs(board[0] + board[1])"}, {"task_id": "sliding-puzzle", "completion": "class Solution(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def swap(board, i, j):\n            board[i], board[j] = board[j], board[i]\n            return board\n        \n        def get_neighbors(board):\n            neighbors = []\n            for i in range(len(board)):\n                for j in range(len(board[0])):\n                    if board[i][j] == 0:\n                        if i > 0:\n                            neighbors.append(swap(board[:], i, i-1))\n                        if i < len(board)-1:\n                            neighbors.append(swap(board[:], i, i+1))\n                        if j > 0:\n                            neighbors.append(swap(board[:], i, i-1))\n                        if j < len(board[0])-1:\n                            neighbors.append(swap(board[:], i, i+1))\n            return neighbors\n        \n        def is_solved(board):\n            return board == [[1,2,3],[4,5,0]]\n        \n        def bfs(board):\n            queue = [(board, 0)]\n            visited = set()\n            while queue:\n                board, moves = queue.pop(0)\n                if is_solved(board):\n                    return moves\n                visited.add(tuple(board))\n                for neighbor in get_neighbors(board):\n                    if tuple(neighbor) not in visited:\n                        queue.append((neighbor, moves+1))\n            return -1\n        \n        return bfs(board)"}, {"task_id": "sliding-puzzle", "completion": "class Solution(object):\n    def slidingPuzzle(self, board):\n        \"\"\"\n        :type board: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        def swap(board, i, j):\n            board[i], board[j] = board[j], board[i]\n            return board\n        \n        def get_neighbors(board):\n            neighbors = []\n            i = board.index(0)\n            if i % 3 > 0:\n                neighbors.append(swap(board[:], i, i - 1))\n            if i % 3 < 2:\n                neighbors.append(swap(board[:], i, i + 1))\n            if i > 2:\n                neighbors.append(swap(board[:], i, i - 3))\n            if i < 3:\n                neighbors.append(swap(board[:], i, i + 3))\n            return neighbors\n        \n        def bfs(board):\n            queue = [(board, 0)]\n            visited = set()\n            while queue:\n                board, steps = queue.pop(0)\n                if board == [1, 2, 3, 4, 5, 0]:\n                    return steps\n                visited.add(tuple(board))\n                for neighbor in get_neighbors(board):\n                    if tuple(neighbor) not in visited:\n                        queue.append((neighbor, steps + 1))\n            return -1\n        \n        return bfs(board[0] + board[1])"}], "isomorphic-strings": [{"task_id": "isomorphic-strings", "completion": "class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        # 1. create a dictionary to store the mapping of s to t\n        # 2. create a set to store the values of t\n        # 3. iterate through s and t\n        # 4. if s[i] is not in the dictionary, add it to the dictionary\n        # 5. if s[i] is in the dictionary, check if the value is the same as t[i]\n        # 6. if the value is not the same, return False\n        # 7. if the value is the same, add t[i] to the set\n        # 8. if t[i] is not in the set, return False\n        # 9. if t[i] is in the set, continue\n        # 10. if we reach the end of the loop, return True\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # create a dictionary to store the mapping of s to t\n        s_to_t = {}\n        # create a set to store the values of t\n        t_set = set()\n        # iterate through s and t\n        for i in range(len(s)):\n            # if s[i] is not in the dictionary, add it to the dictionary\n            if s[i] not in s_to_t:\n                s_to_t[s[i]] = t[i]\n            # if s[i] is in the dictionary, check if the value is the same as t[i]\n            elif s_to_t[s[i]] != t[i]:\n                return False\n            # if the value is the same, add t[i] to the set\n            t_set.add(t[i])\n            # if t[i] is not in the set, return False\n            if t[i] not in t_set:\n                return False\n        # if we reach the end of the loop, return True\n        return True"}, {"task_id": "isomorphic-strings", "completion": "class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        # create a dictionary to store the mapping of characters in s to t\n        s_to_t = {}\n        # create a set to store the characters in t that have already been mapped\n        t_set = set()\n        \n        # iterate through the characters in s and t\n        for i in range(len(s)):\n            # if the character in s is not in the dictionary, add it to the dictionary with the corresponding character in t\n            if s[i] not in s_to_t:\n                # if the character in t has already been mapped, return False\n                if t[i] in t_set:\n                    return False\n                # add the mapping to the dictionary and add the character in t to the set\n                s_to_t[s[i]] = t[i]\n                t_set.add(t[i])\n            # if the character in s is in the dictionary, check if the corresponding character in t is the same\n            else:\n                if s_to_t[s[i]] != t[i]:\n                    return False\n        \n        # if all characters in s have been mapped to unique characters in t, return True\n        return True"}, {"task_id": "isomorphic-strings", "completion": "class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        # 1. create a dictionary to store the mapping of s to t\n        # 2. create a set to store the values of t\n        # 3. iterate through s and t\n        # 4. if s[i] is not in the dictionary, add it to the dictionary\n        # 5. if s[i] is in the dictionary, check if the value is the same as t[i]\n        # 6. if the value is not the same, return False\n        # 7. if the value is the same, add t[i] to the set\n        # 8. if t[i] is not in the set, return False\n        # 9. if t[i] is in the set, continue\n        # 10. if we reach the end of the loop, return True\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # create a dictionary to store the mapping of s to t\n        s_to_t = {}\n        # create a set to store the values of t\n        t_set = set()\n        # iterate through s and t\n        for i in range(len(s)):\n            # if s[i] is not in the dictionary, add it to the dictionary\n            if s[i] not in s_to_t:\n                s_to_t[s[i]] = t[i]\n            # if s[i] is in the dictionary, check if the value is the same as t[i]\n            elif s_to_t[s[i]] != t[i]:\n                return False\n            # if the value is the same, add t[i] to the set\n            t_set.add(t[i])\n            # if t[i] is not in the set, return False\n            if t[i] not in t_set:\n                return False\n        # if we reach the end of the loop, return True\n        return True"}, {"task_id": "isomorphic-strings", "completion": "class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        # 1. create a dictionary to store the mapping of s to t\n        # 2. create a set to store the values of t\n        # 3. iterate through s and t\n        # 4. if s[i] is not in the dictionary, add it to the dictionary\n        # 5. if s[i] is in the dictionary, check if the value is the same as t[i]\n        # 6. if the value is not the same, return False\n        # 7. if the value is the same, add t[i] to the set\n        # 8. if t[i] is not in the set, return False\n        # 9. if t[i] is in the set, continue\n        # 10. if we reach the end of the loop, return True\n        \n        # Time Complexity: O(n)\n        # Space Complexity: O(n)\n        \n        # create a dictionary to store the mapping of s to t\n        s_to_t = {}\n        # create a set to store the values of t\n        t_set = set()\n        # iterate through s and t\n        for i in range(len(s)):\n            # if s[i] is not in the dictionary, add it to the dictionary\n            if s[i] not in s_to_t:\n                s_to_t[s[i]] = t[i]\n            # if s[i] is in the dictionary, check if the value is the same as t[i]\n            elif s_to_t[s[i]] != t[i]:\n                return False\n            # if the value is the same, add t[i] to the set\n            t_set.add(t[i])\n            # if t[i] is not in the set, return False\n            if t[i] not in t_set:\n                return False\n        # if we reach the end of the loop, return True\n        return True"}, {"task_id": "isomorphic-strings", "completion": "class Solution(object):\n    def isIsomorphic(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        # create a dictionary to store the mapping of characters in s to t\n        s_to_t = {}\n        # create a set to store the characters in t that have already been mapped\n        t_set = set()\n        \n        # iterate through the characters in s and t\n        for i in range(len(s)):\n            # if the character in s is not in the dictionary, add it to the dictionary with the corresponding character in t\n            if s[i] not in s_to_t:\n                # if the character in t has already been mapped, return False\n                if t[i] in t_set:\n                    return False\n                # add the mapping to the dictionary and add the character in t to the set\n                s_to_t[s[i]] = t[i]\n                t_set.add(t[i])\n            # if the character in s is in the dictionary, check if the corresponding character in t is the same\n            else:\n                if s_to_t[s[i]] != t[i]:\n                    return False\n        \n        # if all characters in s have been mapped to unique characters in t, return True\n        return True"}], "search-in-rotated-sorted-array-ii": [{"task_id": "search-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1"}, {"task_id": "search-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1"}, {"task_id": "search-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1"}, {"task_id": "search-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1"}, {"task_id": "search-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def search(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1. find the pivot\n        # 2. binary search\n        \n        # 1"}], "unique-paths-ii": [{"task_id": "unique-paths-ii", "completion": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(obstacleGrid)\n        n = len(obstacleGrid[0])\n        \n        if obstacleGrid[0][0] == 1:\n            return 0\n        \n        obstacleGrid[0][0] = 1\n        \n        for i in range(1, m):\n            obstacleGrid[i][0] = int(obstacleGrid[i][0] == 0 and obstacleGrid[i-1][0] == 1)\n        \n        for j in range(1, n):\n            obstacleGrid[0][j] = int(obstacleGrid[0][j] == 0 and obstacleGrid[0][j-1] == 1)\n        \n        for i in range(1, m):\n            for j in range(1, n):\n                if obstacleGrid[i][j] == 0:\n                    obstacleGrid[i][j] = obstacleGrid[i-1][j] + obstacleGrid[i][j-1]\n                else:\n                    obstacleGrid[i][j] = 0\n        \n        return obstacleGrid[m-1][n-1]"}, {"task_id": "unique-paths-ii", "completion": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(obstacleGrid)\n        n = len(obstacleGrid[0])\n        \n        if obstacleGrid[0][0] == 1:\n            return 0\n        \n        obstacleGrid[0][0] = 1\n        \n        for i in range(1, m):\n            obstacleGrid[i][0] = int(obstacleGrid[i][0] == 0 and obstacleGrid[i-1][0] == 1)\n        \n        for j in range(1, n):\n            obstacleGrid[0][j] = int(obstacleGrid[0][j] == 0 and obstacleGrid[0][j-1] == 1)\n        \n        for i in range(1, m):\n            for j in range(1, n):\n                if obstacleGrid[i][j] == 0:\n                    obstacleGrid[i][j] = obstacleGrid[i-1][j] + obstacleGrid[i][j-1]\n                else:\n                    obstacleGrid[i][j] = 0\n        \n        return obstacleGrid[m-1][n-1]"}, {"task_id": "unique-paths-ii", "completion": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(obstacleGrid)\n        n = len(obstacleGrid[0])\n        \n        if obstacleGrid[0][0] == 1:\n            return 0\n        \n        obstacleGrid[0][0] = 1\n        \n        for i in range(1, m):\n            obstacleGrid[i][0] = int(obstacleGrid[i][0] == 0 and obstacleGrid[i-1][0] == 1)\n        \n        for j in range(1, n):\n            obstacleGrid[0][j] = int(obstacleGrid[0][j] == 0 and obstacleGrid[0][j-1] == 1)\n        \n        for i in range(1, m):\n            for j in range(1, n):\n                if obstacleGrid[i][j] == 0:\n                    obstacleGrid[i][j] = obstacleGrid[i-1][j] + obstacleGrid[i][j-1]\n                else:\n                    obstacleGrid[i][j] = 0\n        \n        return obstacleGrid[m-1][n-1]"}, {"task_id": "unique-paths-ii", "completion": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(obstacleGrid)\n        n = len(obstacleGrid[0])\n        \n        if obstacleGrid[0][0] == 1:\n            return 0\n        \n        obstacleGrid[0][0] = 1\n        \n        for i in range(1, m):\n            obstacleGrid[i][0] = int(obstacleGrid[i][0] == 0 and obstacleGrid[i-1][0] == 1)\n        \n        for j in range(1, n):\n            obstacleGrid[0][j] = int(obstacleGrid[0][j] == 0 and obstacleGrid[0][j-1] == 1)\n        \n        for i in range(1, m):\n            for j in range(1, n):\n                if obstacleGrid[i][j] == 0:\n                    obstacleGrid[i][j] = obstacleGrid[i-1][j] + obstacleGrid[i][j-1]\n                else:\n                    obstacleGrid[i][j] = 0\n        \n        return obstacleGrid[m-1][n-1]"}, {"task_id": "unique-paths-ii", "completion": "class Solution(object):\n    def uniquePathsWithObstacles(self, obstacleGrid):\n        \"\"\"\n        :type obstacleGrid: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        m = len(obstacleGrid)\n        n = len(obstacleGrid[0])\n        \n        if obstacleGrid[0][0] == 1:\n            return 0\n        \n        obstacleGrid[0][0] = 1\n        \n        for i in range(1, m):\n            obstacleGrid[i][0] = int(obstacleGrid[i][0] == 0 and obstacleGrid[i-1][0] == 1)\n        \n        for j in range(1, n):\n            obstacleGrid[0][j] = int(obstacleGrid[0][j] == 0 and obstacleGrid[0][j-1] == 1)\n        \n        for i in range(1, m):\n            for j in range(1, n):\n                if obstacleGrid[i][j] == 0:\n                    obstacleGrid[i][j] = obstacleGrid[i-1][j] + obstacleGrid[i][j-1]\n                else:\n                    obstacleGrid[i][j] = 0\n        \n        return obstacleGrid[m-1][n-1]"}], "decode-ways-ii": [{"task_id": "decode-ways-ii", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i] = number of ways to decode s[:i]\n        # dp[0] = 1\n        # dp[i] = dp[i-1] if s[i-1] != '0'\n        # dp[i] += dp[i-2] if s[i-2:i] in ['10', '20']\n        # dp[i] += dp[i-2] if s[i-2:i] in ['11', '12', '13', '14', '15', '16', '17', '18', '19']\n        # dp[i] += dp[i-2] if s[i-2:i] in ['21', '22', '23', '24', '25', '26']\n        # dp[i] %= 10**9 + 7\n        \n        # Time: O(n)\n        # Space: O(n)\n        \n        n = len(s)\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        for i in range(1, n + 1):\n            if s[i-1] != '0':\n                dp[i] += dp[i-1]\n            if i > 1 and s[i-2] != '0':\n                if s[i-2:i] in ['10', '20']:\n                    dp[i] += dp[i-2]\n                elif s[i-2:i] in ['11', '12', '13', '14', '15', '16', '17', '18', '19']:\n                    dp[i] += dp[i-2]\n                elif s[i-2:i] in ['21', '22', '23', '24', '25', '26']:\n                    dp[i] += dp[i-2]\n            dp[i] %= 10**9 + 7\n        return dp[n]"}, {"task_id": "decode-ways-ii", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i] = number of ways to decode s[:i]\n        # dp[0] = 1\n        # dp[i] = dp[i-1] if s[i-1] != '0'\n        # dp[i] += dp[i-2] if s[i-2:i] in ['10', '20']\n        # dp[i] += dp[i-2] if s[i-2:i] in ['11', '12', '13', '14', '15', '16', '17', '18', '19']\n        # dp[i] += dp[i-2] if s[i-2:i] in ['21', '22', '23', '24', '25', '26']\n        # dp[i] %= 10**9 + 7\n        \n        # Time: O(n)\n        # Space: O(n)\n        \n        n = len(s)\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        for i in range(1, n + 1):\n            if s[i-1] != '0':\n                dp[i] += dp[i-1]\n            if i > 1 and s[i-2] != '0':\n                if s[i-2:i] in ['10', '20']:\n                    dp[i] += dp[i-2]\n                elif s[i-2:i] in ['11', '12', '13', '14', '15', '16', '17', '18', '19']:\n                    dp[i] += dp[i-2]\n                elif s[i-2:i] in ['21', '22', '23', '24', '25', '26']:\n                    dp[i] += dp[i-2]\n            dp[i] %= 10**9 + 7\n        return dp[n]"}, {"task_id": "decode-ways-ii", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i] = number of ways to decode s[:i]\n        # dp[0] = 1\n        # dp[i] = dp[i-1] if s[i-1] != '0'\n        # dp[i] += dp[i-2] if s[i-2:i] in ['10', '20']\n        # dp[i] += dp[i-2] if s[i-2:i] in ['11', '12', '13', '14', '15', '16', '17', '18', '19']\n        # dp[i] += dp[i-2] if s[i-2:i] in ['21', '22', '23', '24', '25', '26']\n        # dp[i] %= 10**9 + 7\n        \n        # Time: O(n)\n        # Space: O(n)\n        \n        n = len(s)\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        for i in range(1, n + 1):\n            if s[i-1] != '0':\n                dp[i] += dp[i-1]\n            if i > 1 and s[i-2] != '0':\n                if s[i-2:i] in ['10', '20']:\n                    dp[i] += dp[i-2]\n                elif s[i-2:i] in ['11', '12', '13', '14', '15', '16', '17', '18', '19']:\n                    dp[i] += dp[i-2]\n                elif s[i-2:i] in ['21', '22', '23', '24', '25', '26']:\n                    dp[i] += dp[i-2]\n            dp[i] %= 10**9 + 7\n        return dp[n]"}, {"task_id": "decode-ways-ii", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i] = number of ways to decode s[:i]\n        # dp[0] = 1\n        # dp[i] = dp[i-1] if s[i-1] != '0'\n        # dp[i] += dp[i-2] if s[i-2:i] in ['10', '20']\n        # dp[i] += dp[i-2] if s[i-2:i] in ['11', '12', '13', '14', '15', '16', '17', '18', '19']\n        # dp[i] += dp[i-2] if s[i-2:i] in ['21', '22', '23', '24', '25', '26']\n        # dp[i] %= 10**9 + 7\n        \n        # Time: O(n)\n        # Space: O(n)\n        \n        n = len(s)\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        for i in range(1, n + 1):\n            if s[i-1] != '0':\n                dp[i] += dp[i-1]\n            if i > 1 and s[i-2] != '0':\n                if s[i-2:i] in ['10', '20']:\n                    dp[i] += dp[i-2]\n                elif s[i-2:i] in ['11', '12', '13', '14', '15', '16', '17', '18', '19']:\n                    dp[i] += dp[i-2]\n                elif s[i-2:i] in ['21', '22', '23', '24', '25', '26']:\n                    dp[i] += dp[i-2]\n            dp[i] %= 10**9 + 7\n        return dp[n]"}, {"task_id": "decode-ways-ii", "completion": "class Solution(object):\n    def numDecodings(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # dp[i] = number of ways to decode s[:i]\n        # dp[0] = 1\n        # dp[i] = dp[i-1] if s[i-1] != '0'\n        # dp[i] += dp[i-2] if s[i-2:i] in ['10', '20']\n        # dp[i] += dp[i-2] if s[i-2:i] in ['11', '12', '13', '14', '15', '16', '17', '18', '19']\n        # dp[i] += dp[i-2] if s[i-2:i] in ['21', '22', '23', '24', '25', '26']\n        # dp[i] %= 10**9 + 7\n        \n        # Time: O(n)\n        # Space: O(n)\n        \n        n = len(s)\n        dp = [0] * (n + 1)\n        dp[0] = 1\n        for i in range(1, n + 1):\n            if s[i-1] != '0':\n                dp[i] += dp[i-1]\n            if i > 1 and s[i-2] != '0':\n                if s[i-2:i] in ['10', '20']:\n                    dp[i] += dp[i-2]\n                elif s[i-2:i] in ['11', '12', '13', '14', '15', '16', '17', '18', '19']:\n                    dp[i] += dp[i-2]\n                elif s[i-2:i] in ['21', '22', '23', '24', '25', '26']:\n                    dp[i] += dp[i-2]\n            dp[i] %= 10**9 + 7\n        return dp[n]"}], "3sum-closest": [{"task_id": "3sum-closest", "completion": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        n = len(nums)\n        res = nums[0] + nums[1] + nums[2]\n        for i in range(n):\n            l, r = i + 1, n - 1\n            while l < r:\n                s = nums[i] + nums[l] + nums[r]\n                if abs(s - target) < abs(res - target):\n                    res = s\n                if s < target:\n                    l += 1\n                elif s > target:\n                    r -= 1\n                else:\n                    return res\n        return res"}, {"task_id": "3sum-closest", "completion": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        n = len(nums)\n        closest = float('inf')\n        for i in range(n):\n            left = i + 1\n            right = n - 1\n            while left < right:\n                sum = nums[i] + nums[left] + nums[right]\n                if abs(target - sum) < abs(target - closest):\n                    closest = sum\n                if sum < target:\n                    left += 1\n                elif sum > target:\n                    right -= 1\n                else:\n                    return target\n        return closest"}, {"task_id": "3sum-closest", "completion": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        n = len(nums)\n        res = nums[0] + nums[1] + nums[2]\n        for i in range(n):\n            l, r = i + 1, n - 1\n            while l < r:\n                s = nums[i] + nums[l] + nums[r]\n                if abs(s - target) < abs(res - target):\n                    res = s\n                if s < target:\n                    l += 1\n                elif s > target:\n                    r -= 1\n                else:\n                    return res\n        return res"}, {"task_id": "3sum-closest", "completion": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        n = len(nums)\n        closest = nums[0] + nums[1] + nums[2]\n        for i in range(n-2):\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = nums[i] + nums[j] + nums[k]\n                if abs(sum - target) < abs(closest - target):\n                    closest = sum\n                if sum < target:\n                    j += 1\n                elif sum > target:\n                    k -= 1\n                else:\n                    return target\n        return closest"}, {"task_id": "3sum-closest", "completion": "class Solution(object):\n    def threeSumClosest(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        \n        nums.sort()\n        n = len(nums)\n        closest = nums[0] + nums[1] + nums[2]\n        for i in range(n-2):\n            j = i + 1\n            k = n - 1\n            while j < k:\n                sum = nums[i] + nums[j] + nums[k]\n                if abs(sum - target) < abs(closest - target):\n                    closest = sum\n                if sum < target:\n                    j += 1\n                elif sum > target:\n                    k -= 1\n                else:\n                    return target\n        return closest"}], "maximum-depth-of-binary-tree": [{"task_id": "maximum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        # base case\n        if root is None:\n            return 0\n        \n        # recursive case\n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))"}, {"task_id": "maximum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        # base case\n        if root is None:\n            return 0\n        \n        # recursive case\n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))"}, {"task_id": "maximum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        # base case\n        if root is None:\n            return 0\n        \n        # recursive case\n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))"}, {"task_id": "maximum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        # base case\n        if root is None:\n            return 0\n        \n        # recursive case\n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))"}, {"task_id": "maximum-depth-of-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def maxDepth(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        # base case\n        if root is None:\n            return 0\n        \n        # recursive case\n        return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))"}], "intersection-of-two-arrays-ii": [{"task_id": "intersection-of-two-arrays-ii", "completion": "class Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. sort both arrays\n        # 2. use two pointers to iterate through both arrays\n        # 3. if the values are equal, add to the result array\n        # 4. if the values are not equal, move the pointer of the array with the smaller value\n        # 5. if the values are equal, move both pointers\n        # 6. if the values are not equal, move the pointer of the array with the smaller value\n        # 7. return the result array\n        \n        nums1.sort()\n        nums2.sort()\n        \n        i = 0\n        j = 0\n        \n        result = []\n        \n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] == nums2[j]:\n                result.append(nums1[i])\n                i += 1\n                j += 1\n            elif nums1[i] < nums2[j]:\n                i += 1\n            else:\n                j += 1\n                \n        return result"}, {"task_id": "intersection-of-two-arrays-ii", "completion": "class Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. sort both arrays\n        # 2. use two pointers to iterate through both arrays\n        # 3. if the values are the same, add to the result array\n        # 4. if the values are not the same, move the pointer of the array with the smaller value\n        # 5. if the pointers are at the end of the array, break\n        # 6. return the result array\n        \n        nums1.sort()\n        nums2.sort()\n        \n        i = 0\n        j = 0\n        \n        result = []\n        \n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] == nums2[j]:\n                result.append(nums1[i])\n                i += 1\n                j += 1\n            elif nums1[i] < nums2[j]:\n                i += 1\n            else:\n                j += 1\n                \n        return result"}, {"task_id": "intersection-of-two-arrays-ii", "completion": "class Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. sort both arrays\n        # 2. use two pointers to iterate through both arrays\n        # 3. if the values are equal, add to the result array\n        # 4. if the values are not equal, increment the pointer of the array with the smaller value\n        # 5. return the result array\n        \n        nums1.sort()\n        nums2.sort()\n        \n        i = 0\n        j = 0\n        \n        result = []\n        \n        while i < len(nums1) and j < len(nums2):\n            if nums1[i] == nums2[j]:\n                result.append(nums1[i])\n                i += 1\n                j += 1\n            elif nums1[i] < nums2[j]:\n                i += 1\n            else:\n                j += 1\n                \n        return result"}, {"task_id": "intersection-of-two-arrays-ii", "completion": "class Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # create a dictionary to store the count of each element in nums1\n        nums1_dict = {}\n        for num in nums1:\n            if num in nums1_dict:\n                nums1_dict[num] += 1\n            else:\n                nums1_dict[num] = 1\n        \n        # create a list to store the intersection\n        intersection = []\n        \n        # iterate through nums2 and check if the element is in nums1_dict\n        for num in nums2:\n            if num in nums1_dict and nums1_dict[num] > 0:\n                intersection.append(num)\n                nums1_dict[num] -= 1\n        \n        return intersection"}, {"task_id": "intersection-of-two-arrays-ii", "completion": "class Solution(object):\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # create a dictionary to store the count of each element in nums1\n        nums1_dict = {}\n        for num in nums1:\n            if num in nums1_dict:\n                nums1_dict[num] += 1\n            else:\n                nums1_dict[num] = 1\n        \n        # create a list to store the intersection\n        intersection = []\n        \n        # iterate through nums2 and check if the element is in nums1_dict\n        for num in nums2:\n            if num in nums1_dict and nums1_dict[num] > 0:\n                intersection.append(num)\n                nums1_dict[num] -= 1\n        \n        return intersection"}], "minimum-absolute-difference-in-bst": [{"task_id": "minimum-absolute-difference-in-bst", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def inorder(root):\n            if root:\n                inorder(root.left)\n                self.ans.append(root.val)\n                inorder(root.right)\n        \n        self.ans = []\n        inorder(root)\n        return min([self.ans[i+1] - self.ans[i] for i in range(len(self.ans)-1)])"}, {"task_id": "minimum-absolute-difference-in-bst", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def inorder(root):\n            if root:\n                inorder(root.left)\n                self.ans.append(root.val)\n                inorder(root.right)\n        \n        self.ans = []\n        inorder(root)\n        return min([self.ans[i+1] - self.ans[i] for i in range(len(self.ans)-1)])"}, {"task_id": "minimum-absolute-difference-in-bst", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def inorder(root):\n            if root is None:\n                return []\n            return inorder(root.left) + [root.val] + inorder(root.right)\n        \n        lst = inorder(root)\n        min_diff = float('inf')\n        for i in range(len(lst)-1):\n            min_diff = min(min_diff, lst[i+1] - lst[i])\n        return min_diff"}, {"task_id": "minimum-absolute-difference-in-bst", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def inorder(root):\n            if root:\n                inorder(root.left)\n                self.ans.append(root.val)\n                inorder(root.right)\n        \n        self.ans = []\n        inorder(root)\n        return min([self.ans[i+1] - self.ans[i] for i in range(len(self.ans)-1)])"}, {"task_id": "minimum-absolute-difference-in-bst", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def getMinimumDifference(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: int\n        \"\"\"\n        \n        def inorder(root):\n            if root:\n                inorder(root.left)\n                self.ans.append(root.val)\n                inorder(root.right)\n        \n        self.ans = []\n        inorder(root)\n        return min([self.ans[i+1] - self.ans[i] for i in range(len(self.ans)-1)])"}], "find-mode-in-binary-search-tree": [{"task_id": "find-mode-in-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        def inorder(root):\n            if root:\n                inorder(root.left)\n                if root.val in d:\n                    d[root.val] += 1\n                else:\n                    d[root.val] = 1\n                inorder(root.right)\n        \n        d = {}\n        inorder(root)\n        max_val = max(d.values())\n        return [k for k, v in d.items() if v == max_val]"}, {"task_id": "find-mode-in-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        def inorder(root):\n            if root:\n                inorder(root.left)\n                if root.val in d:\n                    d[root.val] += 1\n                else:\n                    d[root.val] = 1\n                inorder(root.right)\n        \n        d = {}\n        inorder(root)\n        max_val = max(d.values())\n        return [k for k, v in d.items() if v == max_val]"}, {"task_id": "find-mode-in-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        def inorder(root):\n            if root:\n                inorder(root.left)\n                self.count[root.val] += 1\n                if self.count[root.val] > self.max_count:\n                    self.max_count = self.count[root.val]\n                inorder(root.right)\n        \n        self.count = collections.Counter()\n        self.max_count = 0\n        inorder(root)\n        return [key for key, value in self.count.items() if value == self.max_count]"}, {"task_id": "find-mode-in-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        def inorder(root):\n            if root:\n                inorder(root.left)\n                if root.val in d:\n                    d[root.val] += 1\n                else:\n                    d[root.val] = 1\n                inorder(root.right)\n        \n        d = {}\n        inorder(root)\n        max_val = max(d.values())\n        return [k for k,v in d.items() if v == max_val]"}, {"task_id": "find-mode-in-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def findMode(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        def inorder(root):\n            if root:\n                inorder(root.left)\n                self.count[root.val] += 1\n                if self.count[root.val] > self.max_count:\n                    self.max_count = self.count[root.val]\n                inorder(root.right)\n        \n        self.count = collections.Counter()\n        self.max_count = 0\n        inorder(root)\n        return [key for key, value in self.count.items() if value == self.max_count]"}], "find-the-index-of-the-first-occurrence-in-a-string": [{"task_id": "find-the-index-of-the-first-occurrence-in-a-string", "completion": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        \n        if len(needle) == 0:\n            return 0\n        \n        if len(needle) > len(haystack):\n            return -1\n        \n        for i in range(len(haystack)):\n            if haystack[i] == needle[0]:\n                if haystack[i:i+len(needle)] == needle:\n                    return i\n        \n        return -1"}, {"task_id": "find-the-index-of-the-first-occurrence-in-a-string", "completion": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        \n        if len(needle) == 0:\n            return 0\n        \n        if len(haystack) < len(needle):\n            return -1\n        \n        for i in range(len(haystack) - len(needle) + 1):\n            if haystack[i:i+len(needle)] == needle:\n                return i\n        \n        return -1"}, {"task_id": "find-the-index-of-the-first-occurrence-in-a-string", "completion": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        \n        if len(needle) == 0:\n            return 0\n        \n        if len(needle) > len(haystack):\n            return -1\n        \n        for i in range(len(haystack)):\n            if haystack[i] == needle[0]:\n                if haystack[i:i+len(needle)] == needle:\n                    return i\n        \n        return -1"}, {"task_id": "find-the-index-of-the-first-occurrence-in-a-string", "completion": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        \n        if len(needle) == 0:\n            return 0\n        \n        if len(needle) > len(haystack):\n            return -1\n        \n        for i in range(len(haystack)):\n            if haystack[i] == needle[0]:\n                if haystack[i:i+len(needle)] == needle:\n                    return i\n        \n        return -1"}, {"task_id": "find-the-index-of-the-first-occurrence-in-a-string", "completion": "class Solution(object):\n    def strStr(self, haystack, needle):\n        \"\"\"\n        :type haystack: str\n        :type needle: str\n        :rtype: int\n        \"\"\"\n        \n        if len(needle) == 0:\n            return 0\n        \n        if len(needle) > len(haystack):\n            return -1\n        \n        for i in range(len(haystack)):\n            if haystack[i] == needle[0]:\n                if haystack[i:i+len(needle)] == needle:\n                    return i\n        \n        return -1"}], "strong-password-checker": [{"task_id": "strong-password-checker", "completion": "class Solution(object):\n    def strongPasswordChecker(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. check length\n        # 2. check lowercase, uppercase, digit\n        # 3. check repeating characters\n        # 4. check insert, delete, replace\n        \n        # 1. check length\n        length = len(password)\n        if length < 6:\n            return 6 - length\n        elif length > 20:\n            return length - 20\n        else:\n            return 0\n        \n        # 2. check lowercase, uppercase, digit\n        lowercase = uppercase = digit = False\n        for char in password:\n            if char.islower():\n                lowercase = True\n            elif char.isupper():\n                uppercase = True\n            elif char.isdigit():\n                digit = True\n        if not lowercase:\n            return 1\n        elif not uppercase:\n            return 1\n        elif not digit:\n            return 1\n        else:\n            return 0\n        \n        # 3. check repeating characters\n        repeating = False\n        for i in range(length - 3):\n            if password[i] == password[i + 1] == password[i + 2]:\n                repeating = True\n        if repeating:\n            return 1\n        else:\n            return 0\n        \n        # 4. check insert, delete, replace\n        insert = delete = replace = 0\n        for i in range(length - 2):\n            if password[i] == password[i + 1] == password[i + 2]:\n                insert += 1\n            elif password[i] == password[i + 1]:\n                delete += 1\n            else:\n                replace += 1\n        if insert == 0:\n            return 1\n        elif delete == 0:\n            return 1\n        elif replace == 0:\n            return 1\n        else:\n            return 0\n        \n        # 5. check insert, delete, replace\n        insert = delete = replace = 0\n        for i in range(length - 2):\n            if password[i] == password[i + 1] == password[i + 2]:\n                insert += 1\n            elif password[i] == password[i + 1]:\n                delete += 1\n            else:\n                replace += 1\n        if insert == 0:\n            return 1\n        elif delete == 0:\n            return 1\n        elif replace == 0:\n            return 1\n        else:\n            return 0\n        \n        # 6. check insert, delete, replace\n        insert = delete = replace = 0\n        for i in range(length - 2):\n            if password[i] == password[i + 1] == password[i + 2]:\n                insert += 1\n            elif password[i] == password[i + 1]:\n                delete += 1\n            else:\n                replace += 1\n        if insert == 0:\n            return 1\n        elif delete == 0:\n            return 1\n        elif replace == 0:\n            return 1\n        else:\n            return 0\n        \n        # 7. check insert, delete, replace\n        insert = delete = replace = 0\n        for i in range(length - 2):\n            if password[i] == password[i + 1] == password[i + 2]:\n                insert += 1\n            elif password[i] == password[i + 1]:\n                delete += 1\n            else:\n                replace += 1\n        if insert == 0:\n            return 1\n        elif delete == 0:\n            return 1\n        elif replace == 0:\n            return 1\n        else:\n            return 0\n        \n        # 8. check insert, delete, replace\n        insert = delete = replace = 0\n        for i in range(length - 2):\n            if password[i] == password[i + 1] == password[i + 2]:\n                insert += 1\n            elif password[i] == password[i + 1]:\n                delete += 1\n            else:\n                replace += 1\n        if insert == 0:\n            return 1\n        elif delete == 0:\n            return 1\n        elif replace == 0:\n            return 1\n        else:\n            return 0\n        \n        # 9. check insert, delete, replace\n        insert = delete = replace = 0\n        for i in range(length - 2):\n            if password[i] == password[i + 1] == password[i + 2]:\n                insert += 1"}, {"task_id": "strong-password-checker", "completion": "class Solution(object):\n    def strongPasswordChecker(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: int\n        \"\"\"\n        \n        def check_lower(password):\n            for i in password:\n                if i.islower():\n                    return True\n            return False\n        \n        def check_upper(password):\n            for i in password:\n                if i.isupper():\n                    return True\n            return False\n        \n        def check_digit(password):\n            for i in password:\n                if i.isdigit():\n                    return True\n            return False\n        \n        def check_repeat(password):\n            for i in range(len(password)-2):\n                if password[i] == password[i+1] and password[i+1] == password[i+2]:\n                    return True\n            return False\n        \n        def check_length(password):\n            if len(password) < 6:\n                return 6 - len(password)\n            elif len(password) > 20:\n                return len(password) - 20\n            else:\n                return 0\n        \n        def check_missing(password):\n            missing = 0\n            if not check_lower(password):\n                missing += 1\n            if not check_upper(password):\n                missing += 1\n            if not check_digit(password):\n                missing += 1\n            return missing\n        \n        def check_replace(password):\n            replace = 0\n            for i in range(len(password)-2):\n                if password[i] == password[i+1] and password[i+1] == password[i+2]:\n                    replace += 1\n            return replace\n        \n        def check_insert(password):\n            insert = 0\n            for i in range(len(password)-2):\n                if password[i] == password[i+1] and password[i+1] == password[i+2]:\n                    insert += 1\n            return insert\n        \n        def check_delete(password):\n            delete = 0\n            for i in range(len(password)-2):\n                if password[i] == password[i+1] and password[i+1] == password[i+2]:\n                    delete += 1\n            return delete\n        \n        def check_replace(password):\n            replace = 0\n            for i in range(len(password)-2):\n                if password[i] == password[i+1] and password[i+1] == password[i+2]:\n                    replace += 1\n            return replace\n        \n        def check_insert(password):\n            insert = 0\n            for i in range(len(password)-2):\n                if password[i] == password[i+1] and password[i+1] == password[i+2]:\n                    insert += 1\n            return insert\n        \n        def check_delete(password):\n            delete = 0\n            for i in range(len(password)-2):\n                if password[i] == password[i+1] and password[i+1] == password[i+2]:\n                    delete += 1\n            return delete\n        \n        def check_replace(password):\n            replace = 0\n            for i in range(len(password)-2):\n                if password[i] == password[i+1] and password[i+1] == password[i+2]:\n                    replace += 1\n            return replace\n        \n        def check_insert(password):\n            insert = 0\n            for i in range(len(password)-2):\n                if password[i] == password[i+1] and password[i+1] == password[i+2]:\n                    insert += 1\n            return insert\n        \n        def check_delete(password):\n            delete = 0\n            for i in range(len(password)-2):\n                if password[i] == password[i+1] and password[i+1] == password[i+2]:\n                    delete += 1\n            return delete\n        \n        def check_replace(password):\n            replace = 0\n            for i in range(len(password)-2):\n                if password[i] == password[i+1] and password[i+1] == password[i+2]:\n                    replace += 1\n            return replace\n        \n        def check_insert(password):\n            insert = 0\n            for i in range(len(password)-2):\n                if password[i] == password[i+1] and password[i+1] == password[i+2]:\n                    insert += 1\n            return insert\n        \n        def check_"}, {"task_id": "strong-password-checker", "completion": "class Solution(object):\n    def strongPasswordChecker(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: int\n        \"\"\"\n        \n        def check_lower(password):\n            for c in password:\n                if c.islower():\n                    return True\n            return False\n        \n        def check_upper(password):\n            for c in password:\n                if c.isupper():\n                    return True\n            return False\n        \n        def check_digit(password):\n            for c in password:\n                if c.isdigit():\n                    return True\n            return False\n        \n        def check_repeat(password):\n            for i in range(len(password)-2):\n                if password[i] == password[i+1] and password[i+1] == password[i+2]:\n                    return True\n            return False\n        \n        def check_length(password):\n            if len(password) < 6:\n                return 6 - len(password)\n            elif len(password) > 20:\n                return len(password) - 20\n            else:\n                return 0\n        \n        def check_missing(password):\n            missing = 0\n            if not check_lower(password):\n                missing += 1\n            if not check_upper(password):\n                missing += 1\n            if not check_digit(password):\n                missing += 1\n            return missing\n        \n        def check_replace(password):\n            replace = 0\n            for i in range(len(password)-2):\n                if password[i] == password[i+1] and password[i+1] == password[i+2]:\n                    replace += 1\n            return replace\n        \n        def check_insert(password):\n            insert = 0\n            for i in range(len(password)-2):\n                if password[i] == password[i+1] and password[i+1] == password[i+2]:\n                    insert += 1\n            return insert\n        \n        def check_delete(password):\n            delete = 0\n            for i in range(len(password)-2):\n                if password[i] == password[i+1] and password[i+1] == password[i+2]:\n                    delete += 1\n            return delete\n        \n        def check_replace(password):\n            replace = 0\n            for i in range(len(password)-2):\n                if password[i] == password[i+1] and password[i+1] == password[i+2]:\n                    replace += 1\n            return replace\n        \n        def check_insert(password):\n            insert = 0\n            for i in range(len(password)-2):\n                if password[i] == password[i+1] and password[i+1] == password[i+2]:\n                    insert += 1\n            return insert\n        \n        def check_delete(password):\n            delete = 0\n            for i in range(len(password)-2):\n                if password[i] == password[i+1] and password[i+1] == password[i+2]:\n                    delete += 1\n            return delete\n        \n        def check_replace(password):\n            replace = 0\n            for i in range(len(password)-2):\n                if password[i] == password[i+1] and password[i+1] == password[i+2]:\n                    replace += 1\n            return replace\n        \n        def check_insert(password):\n            insert = 0\n            for i in range(len(password)-2):\n                if password[i] == password[i+1] and password[i+1] == password[i+2]:\n                    insert += 1\n            return insert\n        \n        def check_delete(password):\n            delete = 0\n            for i in range(len(password)-2):\n                if password[i] == password[i+1] and password[i+1] == password[i+2]:\n                    delete += 1\n            return delete\n        \n        def check_replace(password):\n            replace = 0\n            for i in range(len(password)-2):\n                if password[i] == password[i+1] and password[i+1] == password[i+2]:\n                    replace += 1\n            return replace\n        \n        def check_insert(password):\n            insert = 0\n            for i in range(len(password)-2):\n                if password[i] == password[i+1] and password[i+1] == password[i+2]:\n                    insert += 1\n            return insert\n        \n        def check_"}, {"task_id": "strong-password-checker", "completion": "class Solution(object):\n    def strongPasswordChecker(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: int\n        \"\"\"\n        \n        def check(password):\n            a = any(c.islower() for c in password)\n            b = any(c.isupper() for c in password)\n            c = any(c.isdigit() for c in password)\n            return a and b and c\n        \n        def replace(password):\n            res = 0\n            i = 0\n            while i < len(password):\n                j = i\n                while j < len(password) and password[j] == password[i]:\n                    j += 1\n                length = j - i\n                res += length / 3\n                i = j\n            return res\n        \n        def insert(password):\n            res = 0\n            i = 0\n            while i < len(password):\n                j = i\n                while j < len(password) and password[j] == password[i]:\n                    j += 1\n                length = j - i\n                res += length\n                i = j\n            return res\n        \n        def delete(password):\n            res = 0\n            i = 0\n            while i < len(password):\n                j = i\n                while j < len(password) and password[j] == password[i]:\n                    j += 1\n                length = j - i\n                if length >= 3:\n                    res += length - 2\n                i = j\n            return res\n        \n        if not check(password):\n            return 6 - len(password)\n        \n        if len(password) < 6:\n            return max(6 - len(password), replace(password))\n        \n        if len(password) <= 20:\n            return max(replace(password), insert(password))\n        \n        res = replace(password)\n        res = min(res, len(password) - 20)\n        res += delete(password)\n        return res"}, {"task_id": "strong-password-checker", "completion": "class Solution(object):\n    def strongPasswordChecker(self, password):\n        \"\"\"\n        :type password: str\n        :rtype: int\n        \"\"\"\n        \n        def check_lower(password):\n            for c in password:\n                if c.islower():\n                    return True\n            return False\n        \n        def check_upper(password):\n            for c in password:\n                if c.isupper():\n                    return True\n            return False\n        \n        def check_digit(password):\n            for c in password:\n                if c.isdigit():\n                    return True\n            return False\n        \n        def check_repeat(password):\n            for i in range(len(password)-2):\n                if password[i] == password[i+1] and password[i+1] == password[i+2]:\n                    return True\n            return False\n        \n        def check_length(password):\n            if len(password) < 6:\n                return 6 - len(password)\n            elif len(password) > 20:\n                return len(password) - 20\n            else:\n                return 0\n        \n        def check_missing(password):\n            missing = 0\n            if not check_lower(password):\n                missing += 1\n            if not check_upper(password):\n                missing += 1\n            if not check_digit(password):\n                missing += 1\n            return missing\n        \n        def check_replace(password):\n            replace = 0\n            for i in range(len(password)-2):\n                if password[i] == password[i+1] and password[i+1] == password[i+2]:\n                    replace += 1\n            return replace\n        \n        def check_insert(password):\n            insert = 0\n            for i in range(len(password)-2):\n                if password[i] == password[i+1] and password[i+1] == password[i+2]:\n                    insert += 1\n            return insert\n        \n        def check_delete(password):\n            delete = 0\n            for i in range(len(password)-2):\n                if password[i] == password[i+1] and password[i+1] == password[i+2]:\n                    delete += 1\n            return delete\n        \n        def check_replace(password):\n            replace = 0\n            for i in range(len(password)-2):\n                if password[i] == password[i+1] and password[i+1] == password[i+2]:\n                    replace += 1\n            return replace\n        \n        def check_insert(password):\n            insert = 0\n            for i in range(len(password)-2):\n                if password[i] == password[i+1] and password[i+1] == password[i+2]:\n                    insert += 1\n            return insert\n        \n        def check_delete(password):\n            delete = 0\n            for i in range(len(password)-2):\n                if password[i] == password[i+1] and password[i+1] == password[i+2]:\n                    delete += 1\n            return delete\n        \n        def check_replace(password):\n            replace = 0\n            for i in range(len(password)-2):\n                if password[i] == password[i+1] and password[i+1] == password[i+2]:\n                    replace += 1\n            return replace\n        \n        def check_insert(password):\n            insert = 0\n            for i in range(len(password)-2):\n                if password[i] == password[i+1] and password[i+1] == password[i+2]:\n                    insert += 1\n            return insert\n        \n        def check_delete(password):\n            delete = 0\n            for i in range(len(password)-2):\n                if password[i] == password[i+1] and password[i+1] == password[i+2]:\n                    delete += 1\n            return delete\n        \n        def check_replace(password):\n            replace = 0\n            for i in range(len(password)-2):\n                if password[i] == password[i+1] and password[i+1] == password[i+2]:\n                    replace += 1\n            return replace\n        \n        def check_insert(password):\n            insert = 0\n            for i in range(len(password)-2):\n                if password[i] == password[i+1] and password[i+1] == password[i+2]:\n                    insert += 1\n            return insert\n        \n        def check_"}], "factorial-trailing-zeroes": [{"task_id": "factorial-trailing-zeroes", "completion": "class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 10 = 2 * 5\n        # 2. 2 is always more than 5\n        # 3. so we just need to count the number of 5\n        # 4. n // 5 is the number of 5\n        # 5. n // 5 // 5 is the number of 5^2\n        # 6. n // 5 // 5 // 5 is the number of 5^3\n        # 7. ...\n        # 8. sum them up\n        \n        # 9. time complexity: O(log(n))\n        # 10. space complexity: O(1)\n        \n        # 11. 200 / 5 = 40\n        # 12. 40 / 5 = 8\n        # 13. 8 / 5 = 1\n        # 14. 1 / 5 = 0\n        # 15. 40 + 8 + 1 = 53\n        \n        # 16. 200 / 5 / 5 = 4\n        # 17. 4 / 5 = 0\n        # 18. 40 + 8 + 1 + 0 = 53\n        \n        # 19. 200 / 5 / 5 / 5 = 0\n        # 20. 40 + 8 + 1 + 0 + 0 = 53\n        \n        # 21. 200 / 5 / 5 / 5 / 5 = 0\n        # 22. 40 + 8 + 1 + 0 + 0 + 0 = 53\n        \n        # 23. 200 / 5 / 5 / 5 / 5 / 5 = 0\n        # 24. 40 + 8 + 1 + 0 + 0 + 0 + 0 = 53\n        \n        # 25. 200 / 5 / 5 / 5 / 5 / 5 / 5 = 0\n        # 26. 40 + 8 + 1 + 0 + 0 + 0 + 0 + 0 = 53\n        \n        # 27. 200 / 5 / 5 / 5 / 5 / 5 / 5 / 5 = 0\n        # 28. 40 + 8 + 1 + 0 + 0 + 0 + 0 + 0 + 0 = 53\n        \n        # 29. 200 / 5 / 5 / 5 / 5 / 5 / 5 / 5 / 5 = 0\n        # 30. 40 + 8 + 1 + 0 + 0 + 0 + 0 + 0 + 0 + 0 = 53\n        \n        # 31. 200 / 5 / 5 / 5 / 5 / 5 / 5 / 5 / 5 / 5 = 0\n        # 32. 40 + 8 + 1 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 = 53\n        \n        # 33. 200 / 5 / 5 / 5 / 5 / 5 / 5 / 5 / 5 / 5 / 5 = 0\n        # 34. 40 + 8 + 1 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 = 53\n        \n        # 35. 200 / 5 / 5 / 5 / 5 / 5 / 5 / 5 / 5 / 5 / 5 / 5 = 0\n        # 36. 40 + 8 + 1 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 = 53\n        \n        # 37. 200 / 5 / 5 / 5 / 5 / 5 / 5 / 5 / 5 / 5 / 5 / 5 / 5 = 0\n        # 38. 40 + 8 + 1 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 = 53\n        \n        # 39. 200 / 5 / 5 / 5 / 5 / 5 / 5 / 5 / 5 / 5 / 5 / 5 / 5 / 5 = 0\n        # 40. 40"}, {"task_id": "factorial-trailing-zeroes", "completion": "class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 10 = 2 * 5\n        # 2. 2 is always more than 5\n        # 3. so we just need to count the number of 5\n        # 4. n // 5 is the number of 5\n        # 5. n // 5 // 5 is the number of 5^2\n        # 6. n // 5 // 5 // 5 is the number of 5^3\n        # 7. ...\n        # 8. sum them up\n        \n        # 9. time complexity: O(log(n))\n        # 10. space complexity: O(1)\n        \n        # 11. 200 / 5 = 40\n        # 12. 40 / 5 = 8\n        # 13. 8 / 5 = 1\n        # 14. 1 / 5 = 0\n        # 15. 40 + 8 + 1 = 53\n        \n        # 16. 200 / 5 / 5 = 4\n        # 17. 4 / 5 = 0\n        # 18. 40 + 8 + 1 + 0 = 53\n        \n        # 19. 200 / 5 / 5 / 5 = 0\n        # 20. 40 + 8 + 1 + 0 + 0 = 53\n        \n        # 21. 200 / 5 / 5 / 5 / 5 = 0\n        # 22. 40 + 8 + 1 + 0 + 0 + 0 = 53\n        \n        # 23. 200 / 5 / 5 / 5 / 5 / 5 = 0\n        # 24. 40 + 8 + 1 + 0 + 0 + 0 + 0 = 53\n        \n        # 25. 200 / 5 / 5 / 5 / 5 / 5 / 5 = 0\n        # 26. 40 + 8 + 1 + 0 + 0 + 0 + 0 + 0 = 53\n        \n        # 27. 200 / 5 / 5 / 5 / 5 / 5 / 5 / 5 = 0\n        # 28. 40 + 8 + 1 + 0 + 0 + 0 + 0 + 0 + 0 = 53\n        \n        # 29. 200 / 5 / 5 / 5 / 5 / 5 / 5 / 5 / 5 = 0\n        # 30. 40 + 8 + 1 + 0 + 0 + 0 + 0 + 0 + 0 + 0 = 53\n        \n        # 31. 200 / 5 / 5 / 5 / 5 / 5 / 5 / 5 / 5 / 5 = 0\n        # 32. 40 + 8 + 1 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 = 53\n        \n        # 33. 200 / 5 / 5 / 5 / 5 / 5 / 5 / 5 / 5 / 5 / 5 = 0\n        # 34. 40 + 8 + 1 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 = 53\n        \n        # 35. 200 / 5 / 5 / 5 / 5 / 5 / 5 / 5 / 5 / 5 / 5 / 5 = 0\n        # 36. 40 + 8 + 1 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 = 53\n        \n        # 37. 200 / 5 / 5 / 5 / 5 / 5 / 5 / 5 / 5 / 5 / 5 / 5 / 5 = 0\n        # 38. 40 + 8 + 1 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 = 53\n        \n        # 39. 200 / 5 / 5 / 5 / 5 / 5 / 5 / 5 / 5 / 5 / 5 / 5 / 5 / 5 = 0\n        # 40. 40"}, {"task_id": "factorial-trailing-zeroes", "completion": "class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 5 10 15 20 25 30 35 40 45 50 55 60 65 70 75 80 85 90 95 100 105 110 115 120 125 130 135 140 145 150 155 160 165 170 175 180 185 190 195 200 205 210 215 220 225 230 235 240 245 250 255 260 265 270 275 280 285 290 295 300 305 310 315 320 325 330 335 340 345 350 355 360 365 370 375 380 385 390 395 400 405 410 415 420 425 430 435 440 445 450 455 460 465 470 475 480 485 490 495 500 505 510 515 520 525 530 535 540 545 550 555 560 565 570 575 580 585 590 595 600 605 610 615 620 625 630 635 640 645 650 655 660 665 670 675 680 685 690 695 700 705 710 715 720 725 730 735 740 745 750 755 760 765 770 775 780 785 790 795 800 805 810 815 820 825 830 835 840 845 850 855 860 865 870 875 880 885 890 895 900 905 910 915 920 925 930 935 940 945 950 955 960 965 970 975 980 985 990 995 1000\n        \n        # 2. 5 10 15 20 25 30 35 40 45 50 55 60 65 70 75 80 85 90 95 100 105 110 115 120 125 130 135 140 145 150 155 160 165 170 175 180 185 190 195 200 205 210 215 220 225 230 235 240 245 250 255 260 265 270 275 280 285 290 295 300 305 310 3"}, {"task_id": "factorial-trailing-zeroes", "completion": "class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 5 10 15 20 25 30 35 40 45 50 55 60 65 70 75 80 85 90 95 100\n        # 2. 2 4 6 8 10 12 14 16 18 20 22 24 26 28 30 32 34 36 38 40\n        # 3. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20\n        \n        # 1. 5 10 15 20 25 30 35 40 45 50 55 60 65 70 75 80 85 90 95 100\n        # 2. 2 4 6 8 10 12 14 16 18 20 22 24 26 28 30 32 34 36 38 40\n        # 3. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20\n        \n        # 1. 5 10 15 20 25 30 35 40 45 50 55 60 65 70 75 80 85 90 95 100\n        # 2. 2 4 6 8 10 12 14 16 18 20 22 24 26 28 30 32 34 36 38 40\n        # 3. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20\n        \n        # 1. 5 10 15 20 25 30 35 40 45 50 55 60 65 70 75 80 85 90 95 100\n        # 2. 2 4 6 8 10 12 14 16 18 20 22 24 26 28 30 32 34 36 38 40\n        # 3. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20\n        \n        # 1. 5 10 15 20 25 30 35 40 45 50 55 60 65 70 75 80 85 90 95 100\n        # 2. 2 4 6 8 10 12 14 16 18 20 22 24 26 28 30 32 34 36 38 40\n        # 3. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20\n        \n        # 1. 5 10 15 20 25 30 35 40 45 50 55 60 65 70 75 80 85 90 95 100\n        # 2. 2 4 6 8 10 12 14"}, {"task_id": "factorial-trailing-zeroes", "completion": "class Solution(object):\n    def trailingZeroes(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 5 10 15 20 25 30 35 40 45 50 55 60 65 70 75 80 85 90 95 100 105 110 115 120 125 130 135 140 145 150 155 160 165 170 175 180 185 190 195 200 205 210 215 220 225 230 235 240 245 250 255 260 265 270 275 280 285 290 295 300 305 310 315 320 325 330 335 340 345 350 355 360 365 370 375 380 385 390 395 400 405 410 415 420 425 430 435 440 445 450 455 460 465 470 475 480 485 490 495 500 505 510 515 520 525 530 535 540 545 550 555 560 565 570 575 580 585 590 595 600 605 610 615 620 625 630 635 640 645 650 655 660 665 670 675 680 685 690 695 700 705 710 715 720 725 730 735 740 745 750 755 760 765 770 775 780 785 790 795 800 805 810 815 820 825 830 835 840 845 850 855 860 865 870 875 880 885 890 895 900 905 910 915 920 925 930 935 940 945 950 955 960 965 970 975 980 985 990 995 1000\n        \n        # 2. 5 10 15 20 25 30 35 40 45 50 55 60 65 70 75 80 85 90 95 100 105 110 115 120 125 130 135 140 145 150 155 160 165 170 175 180 185 190 195 200 205 210 215 220 225 230 235 240 245 250 255 260 265 270 275 280 285 290 295 300 305 310 3"}], "zigzag-conversion": [{"task_id": "zigzag-conversion", "completion": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        \n        if numRows == 1:\n            return s\n        \n        rows = [\"\"] * numRows\n        row = 0\n        step = 1\n        \n        for c in s:\n            rows[row] += c\n            row += step\n            if row == 0 or row == numRows - 1:\n                step = -step\n        \n        return \"\".join(rows)"}, {"task_id": "zigzag-conversion", "completion": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        \n        if numRows == 1:\n            return s\n        \n        rows = [\"\"] * numRows\n        row = 0\n        step = 1\n        \n        for c in s:\n            rows[row] += c\n            row += step\n            if row == 0 or row == numRows - 1:\n                step = -step\n        \n        return \"\".join(rows)"}, {"task_id": "zigzag-conversion", "completion": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        \n        if numRows == 1:\n            return s\n        \n        rows = [\"\"] * numRows\n        row = 0\n        step = 1\n        \n        for c in s:\n            rows[row] += c\n            row += step\n            if row == 0 or row == numRows - 1:\n                step = -step\n        \n        return \"\".join(rows)"}, {"task_id": "zigzag-conversion", "completion": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        \n        if numRows == 1:\n            return s\n        \n        rows = [\"\"] * numRows\n        row = 0\n        step = 1\n        \n        for c in s:\n            rows[row] += c\n            row += step\n            if row == 0 or row == numRows - 1:\n                step = -step\n        \n        return \"\".join(rows)"}, {"task_id": "zigzag-conversion", "completion": "class Solution(object):\n    def convert(self, s, numRows):\n        \"\"\"\n        :type s: str\n        :type numRows: int\n        :rtype: str\n        \"\"\"\n        \n        if numRows == 1:\n            return s\n        \n        rows = [\"\"] * numRows\n        row = 0\n        step = 1\n        \n        for c in s:\n            rows[row] += c\n            row += step\n            if row == 0 or row == numRows - 1:\n                step = -step\n        \n        return \"\".join(rows)"}], "trapping-rain-water": [{"task_id": "trapping-rain-water", "completion": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc67c\ucabd \uc624\ub978\ucabd \ubc30\uc5f4 \ub9cc\ub4e4\uae30\n        left = [0] * len(height)\n        right = [0] * len(height)\n        \n        # 2. \uc67c\ucabd \uc624\ub978\ucabd \ubc30\uc5f4 \ucc44\uc6b0\uae30\n        left[0] = height[0]\n        right[-1] = height[-1]\n        \n        for i in range(1, len(height)):\n            left[i] = max(left[i-1], height[i])\n        \n        for i in range(len(height)-2, -1, -1):\n            right[i] = max(right[i+1], height[i])\n        \n        # 3. \uc67c\ucabd \uc624\ub978\ucabd \ubc30\uc5f4 \ube44\uad50\ud574\uc11c \ucd5c\uc18c\uac12 \uad6c\ud558\uae30\n        result = 0\n        for i in range(len(height)):\n            result += min(left[i], right[i]) - height[i]\n        \n        return result"}, {"task_id": "trapping-rain-water", "completion": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc67c\ucabd \uc624\ub978\ucabd \ubc30\uc5f4 \ub9cc\ub4e4\uae30\n        left = [0] * len(height)\n        right = [0] * len(height)\n        \n        # 2. \uc67c\ucabd \uc624\ub978\ucabd \ubc30\uc5f4 \ucc44\uc6b0\uae30\n        left[0] = height[0]\n        right[-1] = height[-1]\n        \n        for i in range(1, len(height)):\n            left[i] = max(left[i-1], height[i])\n        \n        for i in range(len(height)-2, -1, -1):\n            right[i] = max(right[i+1], height[i])\n        \n        # 3. \uc67c\ucabd \uc624\ub978\ucabd \ubc30\uc5f4 \ube44\uad50\ud574\uc11c \ucd5c\uc18c\uac12 \uad6c\ud558\uae30\n        result = 0\n        for i in range(len(height)):\n            result += min(left[i], right[i]) - height[i]\n        \n        return result"}, {"task_id": "trapping-rain-water", "completion": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10."}, {"task_id": "trapping-rain-water", "completion": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc67c\ucabd \uc624\ub978\ucabd \ubc30\uc5f4 \ub9cc\ub4e4\uae30\n        # 2. \uc67c\ucabd \uc624\ub978\ucabd \ubc30\uc5f4 \uc911 \uc791\uc740 \uac12\uc744 \uae30\uc900\uc73c\ub85c \uc791\uc740 \uac12\uc758 \ubc30\uc5f4\uc744 \uc21c\ud68c\ud558\uba74\uc11c \uc791\uc740 \uac12\uc758 \ubc30\uc5f4\uc758 \uac12\uc774 \ud070 \uac12\uc758 \ubc30\uc5f4\uc758 \uac12\ubcf4\ub2e4 \uc791\uc73c\uba74 \ucc28\uc774\ub97c \ub354\ud558\uae30\n        # 3. \uc791\uc740 \uac12\uc758 \ubc30\uc5f4\uc758 \uac12\uc774 \ud070 \uac12\uc758 \ubc30\uc5f4\uc758 \uac12\ubcf4\ub2e4 \ud06c\uba74 \ucc28\uc774\ub97c \ub354\ud558\uae30\n        # 4. \uc791\uc740 \uac12\uc758 \ubc30\uc5f4\uc758 \uac12\uc774 \ud070 \uac12\uc758 \ubc30\uc5f4\uc758 \uac12\uacfc \uac19\uc73c\uba74 \ucc28\uc774\ub97c \ub354\ud558\uae30\n        # 5. \uc791\uc740 \uac12\uc758 \ubc30\uc5f4\uc758 \uac12\uc774 \ud070 \uac12\uc758 \ubc30\uc5f4\uc758 \uac12\ubcf4\ub2e4 \uc791\uc73c\uba74 \ucc28\uc774\ub97c \ub354\ud558\uae30\n        # 6. \uc791\uc740 \uac12\uc758 \ubc30\uc5f4\uc758 \uac12\uc774 \ud070 \uac12\uc758 \ubc30\uc5f4\uc758 \uac12\uacfc \uac19\uc73c\uba74 \ucc28\uc774\ub97c \ub354\ud558\uae30\n        # 7. \uc791\uc740 \uac12\uc758 \ubc30\uc5f4\uc758 \uac12\uc774 \ud070 \uac12\uc758 \ubc30\uc5f4\uc758 \uac12\ubcf4\ub2e4 \uc791\uc73c\uba74 \ucc28\uc774\ub97c \ub354\ud558\uae30\n        # 8. \uc791\uc740 \uac12\uc758 \ubc30\uc5f4\uc758 \uac12\uc774 \ud070 \uac12\uc758 \ubc30\uc5f4\uc758 \uac12\uacfc \uac19\uc73c\uba74 \ucc28\uc774\ub97c \ub354\ud558\uae30\n        # 9. \uc791\uc740 \uac12\uc758 \ubc30\uc5f4\uc758 \uac12\uc774 \ud070 \uac12\uc758 \ubc30\uc5f4\uc758 \uac12\ubcf4\ub2e4 \uc791\uc73c\uba74 \ucc28\uc774\ub97c \ub354\ud558\uae30\n        # 10. \uc791\uc740 \uac12\uc758 \ubc30\uc5f4\uc758 \uac12\uc774 \ud070 \uac12\uc758 \ubc30\uc5f4\uc758 \uac12\uacfc \uac19\uc73c\uba74 \ucc28\uc774\ub97c \ub354\ud558\uae30\n        # 11. \uc791\uc740 \uac12\uc758 \ubc30\uc5f4\uc758 \uac12\uc774 \ud070 \uac12\uc758 \ubc30\uc5f4\uc758 \uac12\ubcf4\ub2e4 \uc791\uc73c\uba74 \ucc28\uc774\ub97c \ub354\ud558\ufffd"}, {"task_id": "trapping-rain-water", "completion": "class Solution(object):\n    def trap(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10."}], "find-all-numbers-disappeared-in-an-array": [{"task_id": "find-all-numbers-disappeared-in-an-array", "completion": "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. create a set of all numbers from 1 to n\n        # 2. create a set of all numbers in nums\n        # 3. return the difference between the two sets\n        \n        # create a set of all numbers from 1 to n\n        all_nums = set(range(1, len(nums) + 1))\n        \n        # create a set of all numbers in nums\n        nums_set = set(nums)\n        \n        # return the difference between the two sets\n        return list(all_nums - nums_set)"}, {"task_id": "find-all-numbers-disappeared-in-an-array", "completion": "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. create a set of all numbers from 1 to n\n        # 2. create a set of all numbers in nums\n        # 3. return the difference between the two sets\n        \n        # 1. create a set of all numbers from 1 to n\n        # 2. create a set of all numbers in nums\n        # 3. return the difference between the two sets\n        \n        # 1. create a set of all numbers from 1 to n\n        # 2. create a set of all numbers in nums\n        # 3. return the difference between the two sets\n        \n        # 1. create a set of all numbers from 1 to n\n        # 2. create a set of all numbers in nums\n        # 3. return the difference between the two sets\n        \n        # 1. create a set of all numbers from 1 to n\n        # 2. create a set of all numbers in nums\n        # 3. return the difference between the two sets\n        \n        # 1. create a set of all numbers from 1 to n\n        # 2. create a set of all numbers in nums\n        # 3. return the difference between the two sets\n        \n        # 1. create a set of all numbers from 1 to n\n        # 2. create a set of all numbers in nums\n        # 3. return the difference between the two sets\n        \n        # 1. create a set of all numbers from 1 to n\n        # 2. create a set of all numbers in nums\n        # 3. return the difference between the two sets\n        \n        # 1. create a set of all numbers from 1 to n\n        # 2. create a set of all numbers in nums\n        # 3. return the difference between the two sets\n        \n        # 1. create a set of all numbers from 1 to n\n        # 2. create a set of all numbers in nums\n        # 3. return the difference between the two sets\n        \n        # 1. create a set of all numbers from 1 to n\n        # 2. create a set of all numbers in nums\n        # 3. return the difference between the two sets\n        \n        # 1. create a set of all numbers from 1 to n\n        # 2. create a set of all numbers in nums\n        # 3. return the difference between the two sets\n        \n        # 1. create a set of all numbers from 1 to n\n        # 2. create a set of all numbers in nums\n        # 3. return the difference between the two sets\n        \n        # 1. create a set of all numbers from 1 to n\n        # 2. create a set of all numbers in nums\n        # 3. return the difference between the two sets\n        \n        # 1. create a set of all numbers from 1 to n\n        # 2. create a set of all numbers in nums\n        # 3. return the difference between the two sets\n        \n        # 1. create a set of all numbers from 1 to n\n        # 2. create a set of all numbers in nums\n        # 3. return the difference between the two sets\n        \n        # 1. create a set of all numbers from 1 to n\n        # 2. create a set of all numbers in nums\n        # 3. return the difference between the two sets\n        \n        # 1. create a set of all numbers from 1 to n\n        # 2. create a set of all numbers in nums\n        # 3. return the difference between the two sets\n        \n        # 1. create a set of all numbers from 1 to n\n        # 2. create a set of all numbers in nums\n        # 3. return the difference between the two sets\n        \n        # 1. create a set of all numbers from 1 to n\n        # 2. create a set of all numbers in nums\n        # 3. return the difference between the two sets\n        \n        # 1. create a set of all numbers from 1 to n\n        # 2. create a set of all numbers in nums\n        # 3. return the difference between the two sets\n        \n        # 1. create a set of all numbers from 1 to n\n        # 2. create a set of all numbers in nums\n        # 3."}, {"task_id": "find-all-numbers-disappeared-in-an-array", "completion": "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. create a set of all numbers from 1 to n\n        # 2. create a set of all numbers in nums\n        # 3. return the difference between the two sets\n        \n        # 1. create a set of all numbers from 1 to n\n        # 2. create a set of all numbers in nums\n        # 3. return the difference between the two sets\n        \n        # 1. create a set of all numbers from 1 to n\n        # 2. create a set of all numbers in nums\n        # 3. return the difference between the two sets\n        \n        # 1. create a set of all numbers from 1 to n\n        # 2. create a set of all numbers in nums\n        # 3. return the difference between the two sets\n        \n        # 1. create a set of all numbers from 1 to n\n        # 2. create a set of all numbers in nums\n        # 3. return the difference between the two sets\n        \n        # 1. create a set of all numbers from 1 to n\n        # 2. create a set of all numbers in nums\n        # 3. return the difference between the two sets\n        \n        # 1. create a set of all numbers from 1 to n\n        # 2. create a set of all numbers in nums\n        # 3. return the difference between the two sets\n        \n        # 1. create a set of all numbers from 1 to n\n        # 2. create a set of all numbers in nums\n        # 3. return the difference between the two sets\n        \n        # 1. create a set of all numbers from 1 to n\n        # 2. create a set of all numbers in nums\n        # 3. return the difference between the two sets\n        \n        # 1. create a set of all numbers from 1 to n\n        # 2. create a set of all numbers in nums\n        # 3. return the difference between the two sets\n        \n        # 1. create a set of all numbers from 1 to n\n        # 2. create a set of all numbers in nums\n        # 3. return the difference between the two sets\n        \n        # 1. create a set of all numbers from 1 to n\n        # 2. create a set of all numbers in nums\n        # 3. return the difference between the two sets\n        \n        # 1. create a set of all numbers from 1 to n\n        # 2. create a set of all numbers in nums\n        # 3. return the difference between the two sets\n        \n        # 1. create a set of all numbers from 1 to n\n        # 2. create a set of all numbers in nums\n        # 3. return the difference between the two sets\n        \n        # 1. create a set of all numbers from 1 to n\n        # 2. create a set of all numbers in nums\n        # 3. return the difference between the two sets\n        \n        # 1. create a set of all numbers from 1 to n\n        # 2. create a set of all numbers in nums\n        # 3. return the difference between the two sets\n        \n        # 1. create a set of all numbers from 1 to n\n        # 2. create a set of all numbers in nums\n        # 3. return the difference between the two sets\n        \n        # 1. create a set of all numbers from 1 to n\n        # 2. create a set of all numbers in nums\n        # 3. return the difference between the two sets\n        \n        # 1. create a set of all numbers from 1 to n\n        # 2. create a set of all numbers in nums\n        # 3. return the difference between the two sets\n        \n        # 1. create a set of all numbers from 1 to n\n        # 2. create a set of all numbers in nums\n        # 3. return the difference between the two sets\n        \n        # 1. create a set of all numbers from 1 to n\n        # 2. create a set of all numbers in nums\n        # 3. return the difference between the two sets\n        \n        # 1. create a set of all numbers from 1 to n\n        # 2. create a set of all numbers in nums\n        # 3."}, {"task_id": "find-all-numbers-disappeared-in-an-array", "completion": "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # O(n) time | O(1) space\n        # for i in range(len(nums)):\n        #     index = abs(nums[i]) - 1\n        #     if nums[index] > 0:\n        #         nums[index] *= -1\n        # return [i + 1 for i in range(len(nums)) if nums[i] > 0]\n        \n        # O(n) time | O(n) space\n        # nums_set = set(nums)\n        # return [i for i in range(1, len(nums) + 1) if i not in nums_set]\n        \n        # O(n) time | O(1) space\n        for i in range(len(nums)):\n            index = abs(nums[i]) - 1\n            nums[index] = -abs(nums[index])\n        return [i + 1 for i in range(len(nums)) if nums[i] > 0]"}, {"task_id": "find-all-numbers-disappeared-in-an-array", "completion": "class Solution(object):\n    def findDisappearedNumbers(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. create a set of all numbers from 1 to n\n        # 2. create a set of all numbers in nums\n        # 3. return the difference between the two sets\n        \n        # create a set of all numbers from 1 to n\n        all_nums = set(range(1, len(nums) + 1))\n        \n        # create a set of all numbers in nums\n        nums_set = set(nums)\n        \n        # return the difference between the two sets\n        return list(all_nums - nums_set)"}], "count-of-smaller-numbers-after-self": [{"task_id": "count-of-smaller-numbers-after-self", "completion": "class Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        def merge(left, right):\n            i, j = 0, 0\n            res = []\n            while i < len(left) and j < len(right):\n                if left[i][0] <= right[j][0]:\n                    res.append(left[i])\n                    count[left[i][1]] += j\n                    i += 1\n                else:\n                    res.append(right[j])\n                    j += 1\n            while i < len(left):\n                res.append(left[i])\n                count[left[i][1]] += j\n                i += 1\n            while j < len(right):\n                res.append(right[j])\n                j += 1\n            return res\n        \n        def mergeSort(nums):\n            if len(nums) <= 1:\n                return nums\n            mid = len(nums) // 2\n            left = mergeSort(nums[:mid])\n            right = mergeSort(nums[mid:])\n            return merge(left, right)\n        \n        count = [0] * len(nums)\n        mergeSort([(num, i) for i, num in enumerate(nums)])\n        return count"}, {"task_id": "count-of-smaller-numbers-after-self", "completion": "class Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        def merge(left, right):\n            i, j = 0, 0\n            res = []\n            while i < len(left) and j < len(right):\n                if left[i][0] <= right[j][0]:\n                    res.append(left[i])\n                    count[left[i][1]] += j\n                    i += 1\n                else:\n                    res.append(right[j])\n                    j += 1\n            while i < len(left):\n                res.append(left[i])\n                count[left[i][1]] += j\n                i += 1\n            while j < len(right):\n                res.append(right[j])\n                j += 1\n            return res\n        \n        def merge_sort(nums):\n            if len(nums) <= 1:\n                return nums\n            mid = len(nums) // 2\n            left = merge_sort(nums[:mid])\n            right = merge_sort(nums[mid:])\n            return merge(left, right)\n        \n        count = [0] * len(nums)\n        merge_sort([(num, i) for i, num in enumerate(nums)])\n        return count"}, {"task_id": "count-of-smaller-numbers-after-self", "completion": "class Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        def merge(left, right):\n            i, j = 0, 0\n            res = []\n            while i < len(left) and j < len(right):\n                if left[i][0] <= right[j][0]:\n                    res.append(left[i])\n                    count[left[i][1]] += j\n                    i += 1\n                else:\n                    res.append(right[j])\n                    j += 1\n            while i < len(left):\n                res.append(left[i])\n                count[left[i][1]] += j\n                i += 1\n            while j < len(right):\n                res.append(right[j])\n                j += 1\n            return res\n        \n        def merge_sort(nums):\n            if len(nums) <= 1:\n                return nums\n            mid = len(nums) // 2\n            left = merge_sort(nums[:mid])\n            right = merge_sort(nums[mid:])\n            return merge(left, right)\n        \n        count = [0] * len(nums)\n        merge_sort([(num, i) for i, num in enumerate(nums)])\n        return count"}, {"task_id": "count-of-smaller-numbers-after-self", "completion": "class Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        def merge(left, right):\n            i, j = 0, 0\n            res = []\n            while i < len(left) and j < len(right):\n                if left[i][0] <= right[j][0]:\n                    res.append(left[i])\n                    count[left[i][1]] += j\n                    i += 1\n                else:\n                    res.append(right[j])\n                    j += 1\n            while i < len(left):\n                res.append(left[i])\n                count[left[i][1]] += j\n                i += 1\n            while j < len(right):\n                res.append(right[j])\n                j += 1\n            return res\n        \n        def merge_sort(nums):\n            if len(nums) <= 1:\n                return nums\n            mid = len(nums) // 2\n            left = merge_sort(nums[:mid])\n            right = merge_sort(nums[mid:])\n            return merge(left, right)\n        \n        count = [0] * len(nums)\n        merge_sort([(nums[i], i) for i in range(len(nums))])\n        return count"}, {"task_id": "count-of-smaller-numbers-after-self", "completion": "class Solution(object):\n    def countSmaller(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        def merge(left, right):\n            i, j = 0, 0\n            res = []\n            while i < len(left) and j < len(right):\n                if left[i][0] <= right[j][0]:\n                    res.append(left[i])\n                    count[left[i][1]] += j\n                    i += 1\n                else:\n                    res.append(right[j])\n                    j += 1\n            while i < len(left):\n                res.append(left[i])\n                count[left[i][1]] += j\n                i += 1\n            while j < len(right):\n                res.append(right[j])\n                j += 1\n            return res\n        \n        def merge_sort(nums):\n            if len(nums) <= 1:\n                return nums\n            mid = len(nums) // 2\n            left = merge_sort(nums[:mid])\n            right = merge_sort(nums[mid:])\n            return merge(left, right)\n        \n        count = [0] * len(nums)\n        merge_sort([(nums[i], i) for i in range(len(nums))])\n        return count"}], "set-intersection-size-at-least-two": [{"task_id": "set-intersection-size-at-least-two", "completion": "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        intervals.sort(key=lambda x: (x[1], -x[0]))\n        ans = []\n        for i, j in intervals:\n            if not ans or ans[-1] < i:\n                ans.append(j-1)\n                ans.append(j)\n            elif ans[-2] < i:\n                ans.append(j)\n        return len(ans)"}, {"task_id": "set-intersection-size-at-least-two", "completion": "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        intervals.sort(key=lambda x: (x[1], -x[0]))\n        ans = []\n        for i, j in intervals:\n            if not ans or ans[-1] < i:\n                ans.append(j-1)\n                ans.append(j)\n            elif ans[-2] < i:\n                ans.append(j)\n        return len(ans)"}, {"task_id": "set-intersection-size-at-least-two", "completion": "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        intervals.sort(key=lambda x: (x[1], -x[0]))\n        ans = []\n        for i, j in intervals:\n            if not ans or ans[-1] < i:\n                ans.append(j-1)\n                ans.append(j)\n            elif ans[-2] < i:\n                ans.append(j)\n        return len(ans)"}, {"task_id": "set-intersection-size-at-least-two", "completion": "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        intervals.sort(key=lambda x: (x[1], -x[0]))\n        ans = []\n        for i, j in intervals:\n            if not ans or ans[-1] < i:\n                ans.append(j-1)\n                ans.append(j)\n            elif ans[-2] < i:\n                ans.append(j)\n        return len(ans)"}, {"task_id": "set-intersection-size-at-least-two", "completion": "class Solution(object):\n    def intersectionSizeTwo(self, intervals):\n        \"\"\"\n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        intervals.sort(key=lambda x: (x[1], -x[0]))\n        ans = []\n        for i, j in intervals:\n            if not ans or ans[-1] < i:\n                ans.append(j-1)\n                ans.append(j)\n            elif ans[-2] < i:\n                ans.append(j)\n        return len(ans)"}], "symmetric-tree": [{"task_id": "symmetric-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def isMirror(left, right):\n            if left == None and right == None:\n                return True\n            if left == None or right == None:\n                return False\n            return left.val == right.val and isMirror(left.left, right.right) and isMirror(left.right, right.left)\n        \n        return isMirror(root, root)"}, {"task_id": "symmetric-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def isMirror(left, right):\n            if left is None and right is None:\n                return True\n            if left is None or right is None:\n                return False\n            return left.val == right.val and isMirror(left.left, right.right) and isMirror(left.right, right.left)\n        \n        return isMirror(root, root)"}, {"task_id": "symmetric-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def isMirror(left, right):\n            if left is None and right is None:\n                return True\n            if left is None or right is None:\n                return False\n            return left.val == right.val and isMirror(left.left, right.right) and isMirror(left.right, right.left)\n        \n        return isMirror(root, root)"}, {"task_id": "symmetric-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def isMirror(left, right):\n            if left == None and right == None:\n                return True\n            if left == None or right == None:\n                return False\n            return left.val == right.val and isMirror(left.left, right.right) and isMirror(left.right, right.left)\n        \n        return isMirror(root, root)"}, {"task_id": "symmetric-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSymmetric(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        def isMirror(left, right):\n            if left is None and right is None:\n                return True\n            if left is None or right is None:\n                return False\n            return left.val == right.val and isMirror(left.left, right.right) and isMirror(left.right, right.left)\n        \n        return isMirror(root, root)"}], "number-of-atoms": [{"task_id": "number-of-atoms", "completion": "class Solution(object):\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\"\n        \n        def parse(formula):\n            if not formula:\n                return {}\n            if formula[0] == '(':\n                return parse_bracket(formula)\n            return parse_atom(formula)\n        \n        def parse_bracket(formula):\n            stack = []\n            i = 1\n            while i < len(formula):\n                if formula[i] == '(':\n                    stack.append(i)\n                elif formula[i] == ')':\n                    start = stack.pop()\n                    return parse(formula[start+1:i]) + parse(formula[i+1:])\n                i += 1\n        \n        def parse_atom(formula):\n            i = 0\n            while i < len(formula) and formula[i].islower():\n                i += 1\n            atom = formula[:i]\n            count = formula[i:]\n            if count:\n                count = int(count)\n            else:\n                count = 1\n            return {atom: count}\n        \n        return parse(formula)\n    \n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\"\n        stack = []\n        i = 0\n        while i < len(formula):\n            if formula[i] == '(':\n                stack.append(i)\n            elif formula[i] == ')':\n                start = stack.pop()\n                stack[-1] += formula[start+1:i]\n            i += 1\n        formula = stack[-1]\n        stack = []\n        i = 0\n        while i < len(formula):\n            if formula[i].isupper():\n                stack.append(formula[i])\n                i += 1\n                while i < len(formula) and formula[i].islower():\n                    stack[-1] += formula[i]\n                    i += 1\n                stack.append(1)\n            elif formula[i].isdigit():\n                stack[-1] = int(formula[i])\n                i += 1\n            elif formula[i] == '(':\n                stack.append(i)\n            elif formula[i] == ')':\n                start = stack.pop()\n                stack[-1] += formula[start+1:i]\n            i += 1\n        formula = stack[-1]\n        stack = []\n        i = 0\n        while i < len(formula):\n            if formula[i].isupper():\n                stack.append(formula[i])\n                i += 1\n                while i < len(formula) and formula[i].islower():\n                    stack[-1] += formula[i]\n                    i += 1\n                stack.append(1)\n            elif formula[i].isdigit():\n                stack[-1] = int(formula[i])\n                i += 1\n            i += 1\n        formula = stack\n        stack = []\n        i = 0\n        while i < len(formula):\n            if formula[i].isupper():\n                stack.append(formula[i])\n                i += 1\n                while i < len(formula) and formula[i].islower():\n                    stack[-1] += formula[i]\n                    i += 1\n                stack.append(1)\n            elif formula[i].isdigit():\n                stack[-1] = int(formula[i])\n                i += 1\n            i += 1\n        formula = stack\n        stack = []\n        i = 0\n        while i < len(formula):\n            if formula[i].isupper():\n                stack.append(formula[i])\n                i += 1\n                while i < len(formula) and formula[i].islower():\n                    stack[-1] += formula[i]"}, {"task_id": "number-of-atoms", "completion": "class Solution(object):\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\"\n        \n        def parse(formula):\n            if not formula:\n                return {}\n            if formula[0] == '(':\n                return parse(formula[1:-1])\n            if formula[0] == ')':\n                return {}\n            if formula[0] == '(':\n                return parse(formula[1:-1])\n            if formula[0] == ')':\n                return {}\n            if formula[0] == '(':\n                return parse(formula[1:-1])\n            if formula[0] == ')':\n                return {}\n            if formula[0] == '(':\n                return parse(formula[1:-1])\n            if formula[0] == ')':\n                return {}\n            if formula[0] == '(':\n                return parse(formula[1:-1])\n            if formula[0] == ')':\n                return {}\n            if formula[0] == '(':\n                return parse(formula[1:-1])\n            if formula[0] == ')':\n                return {}\n            if formula[0] == '(':\n                return parse(formula[1:-1])\n            if formula[0] == ')':\n                return {}\n            if formula[0] == '(':\n                return parse(formula[1:-1])\n            if formula[0] == ')':\n                return {}\n            if formula[0] == '(':\n                return parse(formula[1:-1])\n            if formula[0] == ')':\n                return {}\n            if formula[0] == '(':\n                return parse(formula[1:-1])\n            if formula[0] == ')':\n                return {}\n            if formula[0] == '(':\n                return parse(formula[1:-1])\n            if formula[0] == ')':\n                return {}\n            if formula[0] == '(':\n                return parse(formula[1:-1])\n            if formula[0] == ')':\n                return {}\n            if formula[0] == '(':\n                return parse(formula[1:-1])\n            if formula[0] == ')':\n                return {}\n            if formula[0] == '(':\n                return parse(formula[1:-1])\n            if formula[0] == ')':\n                return {}\n            if formula[0] == '(':\n                return parse(formula[1:-1])\n            if formula[0] == ')':\n                return {}\n            if formula[0] == '(':\n                return parse(formula[1:-1])\n            if formula[0] == ')':\n                return {}\n            if formula[0] == '(':\n                return parse(formula[1:-1])\n            if formula[0] == ')':\n                return {}\n            if formula[0] == '(':\n                return parse(formula[1:-1])\n            if formula[0] == ')':\n                return {}\n            if formula[0] == '(':\n                return parse(formula[1:-1])\n            if formula[0] == ')':\n                return {}\n            if formula[0] == '(':\n                return parse(formula[1:-1])\n            if formula[0] == ')':\n                return {}\n            if formula[0] == '(':\n                return parse(formula[1:-1])\n            if formula[0] == ')':\n                return {}\n            if formula[0] == '(':\n                return parse(formula[1:-1])\n            if formula[0] == ')':\n                return {}\n            if formula[0] == '(':\n                return parse(formula[1:-1])\n            if formula[0] == ')':\n                return {}\n            if formula[0] == '(':\n                return parse(formula[1:-1])\n            if formula[0] == ')':\n                return {}\n            if formula[0] == '(':\n                return parse(formula[1:-1])\n            if formula[0] == ')':\n                return {}\n            if formula[0] == '(':\n                return parse(formula[1:-1])\n            if formula[0] == ')':\n                return {}\n            if formula[0] == '(':\n                return parse(formula["}, {"task_id": "number-of-atoms", "completion": "class Solution(object):\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\"\n        \n        def parse(formula):\n            if not formula:\n                return {}\n            if formula[0] == '(':\n                return parse_bracket(formula)\n            else:\n                return parse_atom(formula)\n        \n        def parse_bracket(formula):\n            stack = []\n            i = 1\n            while i < len(formula):\n                if formula[i] == '(':\n                    stack.append(i)\n                elif formula[i] == ')':\n                    start = stack.pop()\n                    return parse(formula[start+1:i]) * int(formula[start-1:start+1])\n                i += 1\n        \n        def parse_atom(formula):\n            i = 0\n            while i < len(formula) and formula[i].islower():\n                i += 1\n            atom = formula[:i]\n            if i == len(formula):\n                return {atom: 1}\n            if formula[i].isdigit():\n                return {atom: int(formula[i:])}\n            return {atom: 1}\n        \n        atoms = parse(formula)\n        return ''.join(sorted(atoms.keys())) + ''.join(str(atoms[atom]) for atom in sorted(atoms.keys()) if atoms[atom] > 1)"}, {"task_id": "number-of-atoms", "completion": "class Solution(object):\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\"\n        \n        def parse(formula):\n            if not formula:\n                return {}\n            if formula[0] == '(':\n                return parse_bracket(formula)\n            return parse_atom(formula)\n        \n        def parse_bracket(formula):\n            stack = []\n            i = 1\n            while i < len(formula):\n                if formula[i] == '(':\n                    stack.append(i)\n                elif formula[i] == ')':\n                    start = stack.pop()\n                    return parse(formula[start+1:i]) * int(formula[start-1:start+1])\n                i += 1\n        \n        def parse_atom(formula):\n            i = 0\n            while i < len(formula) and formula[i].islower():\n                i += 1\n            atom = formula[:i]\n            count = formula[i:]\n            if count:\n                return {atom: int(count)}\n            return {atom: 1}\n        \n        atoms = parse(formula)\n        return ''.join(sorted(atoms.keys())) + ''.join(str(atoms[atom]) for atom in sorted(atoms.keys()) if atoms[atom] > 1)"}, {"task_id": "number-of-atoms", "completion": "class Solution(object):\n    def countOfAtoms(self, formula):\n        \"\"\"\n        :type formula: str\n        :rtype: str\n        \"\"\"\n        \n        def parse(formula):\n            if not formula:\n                return {}\n            if formula[0] == '(':\n                return parse_bracket(formula)\n            else:\n                return parse_atom(formula)\n        \n        def parse_bracket(formula):\n            stack = []\n            i = 1\n            while i < len(formula):\n                if formula[i] == '(':\n                    stack.append(i)\n                elif formula[i] == ')':\n                    start = stack.pop()\n                    return parse(formula[start+1:i]) * int(formula[start-1:start+1])\n                i += 1\n        \n        def parse_atom(formula):\n            i = 0\n            while i < len(formula) and formula[i].islower():\n                i += 1\n            atom = formula[:i]\n            count = formula[i:]\n            if count:\n                count = int(count)\n            else:\n                count = 1\n            return {atom: count}\n        \n        atoms = parse(formula)\n        atoms = sorted(atoms.items())\n        return ''.join(atom + str(count) for atom, count in atoms)"}], "binary-tree-preorder-traversal": [{"task_id": "binary-tree-preorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        # Recursive solution\n        # if root is None:\n        #     return []\n        # return [root.val] + self.preorderTraversal(root.left) + self.preorderTraversal(root.right)\n        \n        # Iterative solution\n        if root is None:\n            return []\n        stack = [root]\n        result = []\n        while stack:\n            node = stack.pop()\n            result.append(node.val)\n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n        return result"}, {"task_id": "binary-tree-preorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        # Recursive solution\n        # if root is None:\n        #     return []\n        # return [root.val] + self.preorderTraversal(root.left) + self.preorderTraversal(root.right)\n        \n        # Iterative solution\n        if root is None:\n            return []\n        stack = [root]\n        result = []\n        while stack:\n            node = stack.pop()\n            result.append(node.val)\n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n        return result"}, {"task_id": "binary-tree-preorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        # Recursive solution\n        # if root is None:\n        #     return []\n        # return [root.val] + self.preorderTraversal(root.left) + self.preorderTraversal(root.right)\n        \n        # Iterative solution\n        if root is None:\n            return []\n        stack = [root]\n        result = []\n        while stack:\n            node = stack.pop()\n            result.append(node.val)\n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n        return result"}, {"task_id": "binary-tree-preorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        # Recursive solution\n        # if root is None:\n        #     return []\n        # return [root.val] + self.preorderTraversal(root.left) + self.preorderTraversal(root.right)\n        \n        # Iterative solution\n        if root is None:\n            return []\n        stack = [root]\n        result = []\n        while stack:\n            node = stack.pop()\n            result.append(node.val)\n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n        return result"}, {"task_id": "binary-tree-preorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def preorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        # Recursive solution\n        # if root is None:\n        #     return []\n        # return [root.val] + self.preorderTraversal(root.left) + self.preorderTraversal(root.right)\n        \n        # Iterative solution\n        if root is None:\n            return []\n        stack = [root]\n        res = []\n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            if node.right:\n                stack.append(node.right)\n            if node.left:\n                stack.append(node.left)\n        return res"}], "power-of-four": [{"task_id": "power-of-four", "completion": "class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 1:\n            return True\n        if n < 1:\n            return False\n        \n        while n > 1:\n            if n % 4 != 0:\n                return False\n            n = n / 4\n        return True"}, {"task_id": "power-of-four", "completion": "class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 1:\n            return True\n        if n < 1:\n            return False\n        while n > 1:\n            if n % 4 != 0:\n                return False\n            n = n / 4\n        return True"}, {"task_id": "power-of-four", "completion": "class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 1:\n            return True\n        if n < 1:\n            return False\n        \n        while n > 1:\n            if n % 4 != 0:\n                return False\n            n = n / 4\n        return True"}, {"task_id": "power-of-four", "completion": "class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 1:\n            return True\n        if n < 1:\n            return False\n        \n        while n > 1:\n            if n % 4 != 0:\n                return False\n            n = n / 4\n        return True"}, {"task_id": "power-of-four", "completion": "class Solution(object):\n    def isPowerOfFour(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n == 1:\n            return True\n        if n < 1:\n            return False\n        while n > 1:\n            if n % 4 != 0:\n                return False\n            n = n / 4\n        return True"}], "invert-binary-tree": [{"task_id": "invert-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        \n        if root == None:\n            return None\n        \n        if root.left == None and root.right == None:\n            return root\n        \n        temp = root.left\n        root.left = root.right\n        root.right = temp\n        \n        self.invertTree(root.left)\n        self.invertTree(root.right)\n        \n        return root"}, {"task_id": "invert-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        \n        if root == None:\n            return None\n        \n        if root.left == None and root.right == None:\n            return root\n        \n        temp = root.left\n        root.left = root.right\n        root.right = temp\n        \n        self.invertTree(root.left)\n        self.invertTree(root.right)\n        \n        return root"}, {"task_id": "invert-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        \n        if root == None:\n            return None\n        \n        if root.left == None and root.right == None:\n            return root\n        \n        temp = root.left\n        root.left = root.right\n        root.right = temp\n        \n        self.invertTree(root.left)\n        self.invertTree(root.right)\n        \n        return root"}, {"task_id": "invert-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        \n        if root is None:\n            return None\n        \n        # swap the children\n        root.left, root.right = root.right, root.left\n        \n        # recursively invert the children\n        self.invertTree(root.left)\n        self.invertTree(root.right)\n        \n        return root"}, {"task_id": "invert-binary-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def invertTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: TreeNode\n        \"\"\"\n        \n        if root is None:\n            return None\n        \n        # swap the children\n        root.left, root.right = root.right, root.left\n        \n        # recursively invert the children\n        self.invertTree(root.left)\n        self.invertTree(root.right)\n        \n        return root"}], "generate-parentheses": [{"task_id": "generate-parentheses", "completion": "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def generate(p, left, right, parens=[]):\n            if left: generate(p + '(', left-1, right)\n            if right > left: generate(p + ')', left, right-1)\n            if not right: parens += p,\n            return parens\n        \n        return generate('', n, n)"}, {"task_id": "generate-parentheses", "completion": "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def generate(p, left, right, parens=[]):\n            if left: generate(p + '(', left-1, right)\n            if right > left: generate(p + ')', left, right-1)\n            if not right: parens += p,\n            return parens\n        \n        return generate('', n, n)"}, {"task_id": "generate-parentheses", "completion": "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def generate(p, left, right, parens=[]):\n            if left: generate(p + '(', left-1, right)\n            if right > left: generate(p + ')', left, right-1)\n            if not right: parens += p,\n            return parens\n        \n        return generate('', n, n)"}, {"task_id": "generate-parentheses", "completion": "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def generate(p, left, right, parens=[]):\n            if left: generate(p + '(', left-1, right)\n            if right > left: generate(p + ')', left, right-1)\n            if not right: parens += p,\n            return parens\n        \n        return generate('', n, n)"}, {"task_id": "generate-parentheses", "completion": "class Solution(object):\n    def generateParenthesis(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def generate(p, left, right, parens=[]):\n            if left: generate(p + '(', left-1, right)\n            if right > left: generate(p + ')', left, right-1)\n            if not right: parens += p,\n            return parens\n        \n        return generate('', n, n)"}], "patching-array": [{"task_id": "patching-array", "completion": "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        #"}, {"task_id": "patching-array", "completion": "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 1107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225,"}, {"task_id": "patching-array", "completion": "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        #"}, {"task_id": "patching-array", "completion": "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        #"}, {"task_id": "patching-array", "completion": "class Solution(object):\n    def minPatches(self, nums, n):\n        \"\"\"\n        :type nums: List[int]\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        #"}], "longest-valid-parentheses": [{"task_id": "longest-valid-parentheses", "completion": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dp\n        \n        # 1. 2 pointers\n        # Time: O(n)\n        # Space: O(1)\n        # left, right = 0, 0\n        # max_len = 0\n        # for i in range(len(s)):\n        #     if s[i] == '(':\n        #         left += 1\n        #     else:\n        #         right += 1\n        #     if left == right:\n        #         max_len = max(max_len, 2 * right)\n        #     elif right > left:\n        #         left, right = 0,"}, {"task_id": "longest-valid-parentheses", "completion": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2 pointers\n        # 2. stack\n        # 3. dp\n        \n        # 1. 2 pointers\n        # Time: O(n)\n        # Space: O(1)\n        # left, right = 0, 0\n        # max_len = 0\n        # for i in range(len(s)):\n        #     if s[i] == '(':\n        #         left += 1\n        #     else:\n        #         right += 1\n        #     if left == right:\n        #         max_len = max(max_len, 2 * right)\n        #     elif right > left:\n        #         left, right = 0,"}, {"task_id": "longest-valid-parentheses", "completion": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u66b4\u529b\u89e3\u6cd5\n        # 2. \u6808\n        # 3. \u52a8\u6001\u89c4\u5212\n        # 4. \u8d2a\u5fc3\n        \n        # 1. \u66b4\u529b\u89e3\u6cd5\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n^3)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(1)\n        # \u8d85\u65f6\n        # max_len = 0\n        # for i in range(len(s)):\n        #     for j in range(i, len(s)):\n        #         if self.isValid(s[i:j+1]):\n        #             max_len = max(max_len, j-i+1)\n        # return max_len\n        \n        # 2. \u6808\n        # \u65f6\u95f4\u590d\u6742\u5ea6\uff1aO(n)\n        # \u7a7a\u95f4\u590d\u6742\u5ea6\uff1aO(n)\n        # \u6808\u4e2d\u5b58\u50a8\u7684\u662f\u4e0b\u6807\n        # \u6808\u5e95\u5143\u7d20\u59cb\u7ec8\u662f\u5f53\u524d\u5df2\u7ecf\u904d\u5386\u8fc7\u7684\u5143\u7d20\u4e2d\u300c\u6700\u540e\u4e00\u4e2a\u6ca1\u6709\u88ab\u5339\u914d\u7684\u53f3\u62ec\u53f7\u7684\u4e0b\u6807\u300d\n        # \u6808\u5e95\u5143\u7d20\u4e0b\u6807\u5bf9\u5e94\u7684\u5b57\u7b26\u4e00\u5b9a\u662f \u2018(\u2018 \u5b57\u7b26\uff0c\u5e76\u4e14\u6ca1\u6709\u88ab\u5339\u914d\n        # \u6808\u4e2d\u5176\u4ed6\u5143\u7d20\u5bf9\u5e94\u7684\u5b57\u7b26\u4e00\u5b9a\u662f \u2018)\u2019 \u5b57\u7b26\uff0c\u5e76\u4e14\u6ca1\u6709\u88ab\u5339\u914d\n        # \u6808\u4e2d\u5143\u7d20\u5355\u8c03\u9012\u589e\n        # \u6808\u5e95\u5143\u7d20\u5bf9\u5e94\u7684\u5b57\u7b26\u4e0b\u6807\u5bf9\u5e94\u7684\u5b57\u7b26\u4e00\u5b9a\u662f \u2018(\u2018 \u5b57\u7b26\uff0c\u5e76\u4e14\u6ca1\u6709\u88ab\u5339\u914d\n        # \u6808\u4e2d\u5176\u4ed6\u5143\u7d20\u5bf9\u5e94\u7684\u5b57\u7b26\u4e0b\u6807\u5bf9\u5e94\u7684\u5b57\u7b26\u4e00\u5b9a\u662f \u2018)\u2019 \u5b57\u7b26\uff0c\u5e76\u4e14\u6ca1\u6709\u88ab\u5339\u914d\n        # \u6808\u4e2d\u5143\u7d20\u5355\u8c03\u9012\u589e\n        # \u6808\u4e2d\u5143\u7d20\u5bf9\u5e94\u7684\u5b57\u7b26\u4e0b\u6807\u5bf9\u5e94\u7684\u5b57\u7b26\u4e00\u5b9a\u662f \u2018(\u2018 \u5b57\u7b26\uff0c\u5e76\u4e14\u6ca1\u6709\u88ab\u5339\u914d\n        # \u6808\u4e2d\u5143\u7d20\u5bf9\u5e94\u7684\u5b57\u7b26\u4e0b\u6807\u5bf9\u5e94\u7684\u5b57\u7b26\u4e00\u5b9a\u662f \u2018)\u2019 \u5b57\u7b26\uff0c\u5e76\u4e14\u6ca1\u6709\u88ab\u5339\u914d\n        # \u6808\u4e2d\u5143\u7d20\u5355\u8c03\u9012\u589e\n        # \u6808\u4e2d\u5143\u7d20\u5bf9\u5e94\u7684\u5b57\u7b26\u4e0b\u6807\u5bf9\u5e94\u7684\u5b57\u7b26\u4e00\u5b9a\u662f \u2018(\u2018 \u5b57\u7b26\uff0c\u5e76\u4e14\u6ca1\u6709\u88ab\u5339\u914d\n        # \u6808\u4e2d\u5143\u7d20\u5bf9\u5e94\u7684\u5b57\u7b26\u4e0b\u6807\u5bf9\u5e94\u7684\u5b57\u7b26\u4e00\u5b9a\u662f \u2018)\u2019 \u5b57\u7b26\uff0c\u5e76\u4e14\u6ca1\u6709\u88ab\u5339\u914d\n        # \u6808\u4e2d\u5143\u7d20\u5355\u8c03\u9012\u589e\n        # \u6808\u4e2d\u5143\u7d20\u5bf9\u5e94\u7684\u5b57\u7b26\u4e0b\u6807\u5bf9\u5e94\u7684\u5b57\u7b26\u4e00\u5b9a\u662f \u2018(\u2018 \u5b57\u7b26\uff0c\u5e76\u4e14\u6ca1\u6709\u88ab\u5339\u914d\n        # \u6808\u4e2d\u5143\u7d20\u5bf9\u5e94\u7684\u5b57\u7b26\u4e0b\u6807\u5bf9\u5e94\u7684\u5b57\u7b26\u4e00\u5b9a\u662f \u2018)\u2019 \u5b57\u7b26\uff0c\u5e76\u4e14\u6ca1\u6709\u88ab\u5339\u914d\n        # \u6808\u4e2d\u5143\u7d20\u5355\u8c03\u9012\u589e\n        # \u6808\u4e2d\u5143\u7d20\u5bf9\u5e94\u7684\u5b57\u7b26\u4e0b\u6807\u5bf9\u5e94\u7684\u5b57\u7b26\u4e00\u5b9a\u662f \u2018(\u2018 \u5b57\u7b26\uff0c\u5e76\u4e14\u6ca1\u6709\u88ab\u5339\u914d\n        # \u6808\u4e2d\u5143\u7d20\u5bf9\u5e94\u7684\u5b57\u7b26\u4e0b\u6807\u5bf9\u5e94\u7684\u5b57\u7b26\u4e00\u5b9a\u662f \u2018)\u2019 \u5b57\u7b26\uff0c\u5e76\u4e14\u6ca1\u6709\u88ab\u5339\u914d\n        # \u6808\u4e2d\u5143\u7d20\u5355\u8c03\u9012\u589e\n        # \u6808\u4e2d\u5143\u7d20\u5bf9\u5e94\u7684\u5b57\u7b26\u4e0b\u6807\u5bf9\u5e94\u7684\u5b57\u7b26\u4e00\u5b9a\u662f \u2018(\u2018 \u5b57\u7b26\uff0c\u5e76\u4e14\u6ca1\u6709\u88ab\u5339\u914d\n        # \u6808\u4e2d\u5143\u7d20\u5bf9\u5e94\u7684\u5b57\u7b26\u4e0b\u6807\u5bf9\u5e94\u7684\u5b57\u7b26\u4e00\u5b9a\u662f \u2018)\u2019 \u5b57\u7b26\uff0c\u5e76\u4e14\u6ca1\u6709\u88ab\u5339\u914d\n        # \u6808\u4e2d\u5143\u7d20\u5355\u8c03\u9012\u589e\n        # \u6808\u4e2d\u5143\u7d20\u5bf9\u5e94\u7684\u5b57\u7b26\u4e0b\u6807\u5bf9\u5e94\u7684\u5b57\u7b26\u4e00\u5b9a\u662f \u2018(\u2018 \u5b57\u7b26\uff0c\u5e76\u4e14\u6ca1\u6709\u88ab\u5339\u914d\n        # \u6808\u4e2d\u5143\u7d20\u5bf9\u5e94\u7684\u5b57\u7b26\u4e0b\u6807\u5bf9\u5e94\u7684\u5b57\u7b26\u4e00\u5b9a\u662f \u2018)\u2019 \u5b57\u7b26\uff0c\u5e76\u4e14\u6ca1\u6709\u88ab\u5339\u914d\n        # \u6808\u4e2d\u5143\u7d20\u5355\u8c03\u9012\u589e\n        # \u6808\u4e2d\u5143\u7d20\u5bf9\u5e94\u7684\u5b57\u7b26\u4e0b\u6807\u5bf9\u5e94\u7684\u5b57\u7b26\u4e00\u5b9a\u662f \u2018(\u2018 \u5b57\u7b26\uff0c\u5e76\u4e14\u6ca1\u6709\u88ab\u5339\u914d\n        # \u6808\u4e2d\u5143\u7d20\u5bf9\u5e94\u7684\u5b57\u7b26\u4e0b\u6807\u5bf9\u5e94\u7684\u5b57\u7b26\u4e00\u5b9a\u662f \u2018)\u2019 \u5b57\u7b26\uff0c\u5e76\u4e14\u6ca1\u6709\u88ab\u5339\u914d\n        # \u6808\u4e2d\u5143\u7d20\u5355\u8c03\u9012\u589e\n        # \u6808\u4e2d\u5143\u7d20\u5bf9\u5e94\u7684\u5b57\u7b26\u4e0b\u6807\u5bf9\u5e94\u7684\u5b57\u7b26\u4e00\u5b9a\u662f \u2018(\u2018 \u5b57\u7b26\uff0c\u5e76\u4e14\u6ca1\u6709\u88ab\u5339\u914d\n        # \u6808\u4e2d\u5143\u7d20\u5bf9\u5e94\u7684\u5b57\u7b26"}, {"task_id": "longest-valid-parentheses", "completion": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # Time: O(n)\n        # Space: O(n)\n        # Runtime: 20 ms, faster than 99.99% of Python online submissions for Longest Valid Parentheses.\n        # Memory Usage: 13.7 MB, less than 99.99% of Python online submissions for Longest Valid Parentheses.\n        # 2. \n        # Time: O(n)\n        # Space: O(n)\n        # Runtime: 20 ms, faster than 99.99% of Python online submissions for Longest Valid Parentheses.\n        # Memory Usage: 13.7 MB, less than 99 of Python online submissions for Longest Valid Parentheses.\n        # 3. \n        # Time: O(n)\n        # Space: O(1)\n        # Runtime: 20 ms, faster than 99.99% of Python online submissions for Longest Valid Parentheses.\n        # Memory Usage: 13.7 MB, less than 99.99% of Python online submissions for Longest Valid Parentheses.\n        # 4. \n        # Time: O(n)\n        # Space: O(1)\n        # Runtime: 20 ms, faster than 99.99% of Python online submissions for Longest Valid Parentheses.\n        # Memory Usage: 13.7 MB, less than 99.99% of Python online submissions for Longest Valid Parentheses.\n        # 5. \n        # Time: O(n)\n        # Space: O(1)\n        # Runtime: 20 ms, faster than 99.99% of Python online submissions for Longest Valid Parentheses.\n        # Memory Usage: 13.7 MB, less than 99.99% of Python online submissions for Longest Valid Parentheses.\n        # 6. \n        # Time: O(n)\n        # Space: O(1)\n        # Runtime: 20 ms, faster than 99.99% of Python online submissions for Longest Valid Parentheses.\n        # Memory Usage: 13.7 MB, less than 99.99% of Python online submissions for Longest Valid Parentheses.\n        # 7. \n        # Time: O(n)\n        # Space: O(1)\n        # Runtime: 20 ms, faster than 99.99% of Python online submissions for Longest Valid Parentheses.\n        # Memory Usage: 13.7 MB, less than 99.99% of Python online submissions for Longest Valid Parentheses.\n        # 8. \n        # Time: O(n)\n        # Space: O(1)\n        # Runtime: 20 ms, faster than 99.99% of Python online submissions for Longest Valid Parentheses.\n        # Memory Usage: 13.7 MB, less than 99.99% of Python online submissions for Longest Valid Parentheses.\n        # 9. \n        # Time: O(n)\n        # Space: O(1)\n        # Runtime: 20 ms, faster than 99.99% of Python online submissions for Longest Valid Parentheses.\n        # Memory Usage: 13.7 MB, less than 99.99% of Python online submissions for Longest Valid Parentheses.\n        # 10. \n        # Time: O(n)\n        # Space: O(1)\n        # Runtime: 20 ms, faster than 99.99% of Python online submissions for Longest Valid Parentheses.\n        # Memory Usage: 13.7 MB, less than 99.99% of Python online submissions for Longest Valid Parentheses.\n        # 11. \n        # Time: O(n)\n        # Space: O(1)\n        # Runtime: 20 ms, faster than 99.99% of Python online submissions for Longest Valid Parentheses.\n        # Memory Usage: 13.7 MB, less than 99.99% of Python online submissions for Longest Valid Parentheses.\n        #"}, {"task_id": "longest-valid-parentheses", "completion": "class Solution(object):\n    def longestValidParentheses(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: int\n        \"\"\"\n        \n        # 1. \n        # Time: O(n)\n        # Space: O(n)\n        # Runtime: 16 ms, faster than 99.22% of Python online submissions for Longest Valid Parentheses.\n        # Memory Usage: 13.5 MB, less than 99.22% of Python online submissions for Longest Valid Parentheses.\n        # 2. \n        # Time: O(n)\n        # Space: O(1)\n        # Runtime: 20 ms, faster than 95.24% of Python online submissions for Longest Valid Parentheses.\n        # Memory Usage: 13.5 MB, less than 99.22% of Python online submissions for Longest Valid Parentheses.\n        # 3. \n        # Time: O(n)\n        # Space: O(1)\n        # Runtime: 20 ms, faster than 95.24% of Python online submissions for Longest Valid Parentheses.\n        # Memory Usage: 13.5 MB, less than 99.22% of Python online submissions for Longest Valid Parentheses.\n        # 4. \n        # Time: O(n)\n        # Space: O(1)\n        # Runtime: 20 ms, faster than 95.24% of Python online submissions for Longest Valid Parentheses.\n        # Memory Usage: 13.5 MB, less than 99.22% of Python online submissions for Longest Valid Parentheses.\n        # 5. \n        # Time: O(n)\n        # Space: O(1)\n        # Runtime: 20 ms, faster than 95.24% of Python online submissions for Longest Valid Parentheses.\n        # Memory Usage: 13.5 MB, less than 999.22% of Python online submissions for Longest Valid Parentheses.\n        # 6. \n        # Time: O(n)\n        # Space: O(1)\n        # Runtime: 20 ms, faster than 95.24% of Python online submissions for Longest Valid Parentheses.\n        # Memory Usage: 13.5 MB, less than 99.22% of Python online submissions for Longest Valid Parentheses.\n        # 7. \n        # Time: O(n)\n        # Space: O(1)\n        # Runtime: 20 ms, faster than 95.24% of Python online submissions for Longest Valid Parentheses.\n        # Memory Usage: 13.5 MB, less than 99.22% of Python online submissions for Longest Valid Parentheses.\n        # 8. \n        # Time: O(n)\n        # Space: O(1)\n        # Runtime: 20 ms, faster than 95.24% of Python online submissions for Longest Valid Parentheses.\n        # Memory Usage: 13.5 MB, less than 99.22% of Python online submissions for Longest Valid Parentheses.\n        # 9. \n        # Time: O(n)\n        # Space: O(1)\n        # Runtime: 20 ms, faster than 95.24% of Python online submissions for Longest Valid Parentheses.\n        # Memory Usage: 13.5 MB, less than 99.22% of Python online submissions for Longest Valid Parentheses.\n        # 10. \n        # Time: O(n)\n        # Space: O(1)\n        # Runtime: 20 ms, faster than 95.24% of Python online submissions for Longest Valid Parentheses.\n        # Memory Usage: 13.5 MB, less than 99.22% of Python online submissions for Longest Valid Parentheses.\n        # 11. \n        # Time: O(n)\n        # Space: O(1)\n        # Runtime: 20 ms, faster than 95.24% of Python online submissions for Longest Valid Parentheses.\n        # Memory Usage: 13.5 MB, less than 99.22% of Python online submissions for Longest Valid Parenthes"}], "fraction-to-recurring-decimal": [{"task_id": "fraction-to-recurring-decimal", "completion": "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        \n        if numerator == 0:\n            return \"0\"\n        \n        if numerator < 0 and denominator < 0:\n            numerator = abs(numerator)\n            denominator = abs(denominator)\n        elif numerator < 0 or denominator < 0:\n            numerator = abs(numerator)\n            denominator = abs(denominator)\n            return \"-\" + self.fractionToDecimal(numerator, denominator)\n        \n        res = \"\"\n        if numerator >= denominator:\n            res += str(numerator // denominator)\n            numerator = numerator % denominator\n        else:\n            res += \"0\"\n        \n        if numerator == 0:\n            return res\n        \n        res += \".\"\n        dic = {}\n        while numerator != 0:\n            if numerator in dic:\n                res = res[:dic[numerator]] + \"(\" + res[dic[numerator]:] + \")\"\n                return res\n            dic[numerator] = len(res)\n            numerator *= 10\n            res += str(numerator // denominator)\n            numerator = numerator % denominator\n        \n        return res"}, {"task_id": "fraction-to-recurring-decimal", "completion": "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        \n        if numerator == 0:\n            return \"0\"\n        \n        if numerator < 0 and denominator < 0:\n            numerator = abs(numerator)\n            denominator = abs(denominator)\n        elif numerator < 0 or denominator < 0:\n            numerator = abs(numerator)\n            denominator = abs(denominator)\n            return \"-\" + self.fractionToDecimal(numerator, denominator)\n        \n        result = \"\"\n        if numerator >= denominator:\n            result += str(numerator // denominator)\n            numerator = numerator % denominator\n        else:\n            result += \"0\"\n        \n        if numerator == 0:\n            return result\n        \n        result += \".\"\n        dic = {}\n        while numerator != 0:\n            if numerator in dic:\n                result = result[:dic[numerator]] + \"(\" + result[dic[numerator]:] + \")\"\n                return result\n            dic[numerator] = len(result)\n            numerator *= 10\n            result += str(numerator // denominator)\n            numerator = numerator % denominator\n        \n        return result"}, {"task_id": "fraction-to-recurring-decimal", "completion": "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        \n        if numerator == 0:\n            return \"0\"\n        \n        if numerator < 0 and denominator < 0:\n            numerator = abs(numerator)\n            denominator = abs(denominator)\n        elif numerator < 0 or denominator < 0:\n            numerator = abs(numerator)\n            denominator = abs(denominator)\n            return \"-\" + self.fractionToDecimal(numerator, denominator)\n        \n        res = \"\"\n        if numerator >= denominator:\n            res += str(numerator // denominator)\n            numerator = numerator % denominator\n        else:\n            res += \"0\"\n        \n        if numerator == 0:\n            return res\n        \n        res += \".\"\n        dic = {}\n        while numerator != 0:\n            if numerator in dic:\n                res = res[:dic[numerator]] + \"(\" + res[dic[numerator]:] + \")\"\n                return res\n            dic[numerator] = len(res)\n            numerator *= 10\n            res += str(numerator // denominator)\n            numerator = numerator % denominator\n        \n        return res"}, {"task_id": "fraction-to-recurring-decimal", "completion": "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        \n        if numerator == 0:\n            return \"0\"\n        \n        if numerator < 0 and denominator < 0:\n            numerator = abs(numerator)\n            denominator = abs(denominator)\n        elif numerator < 0 or denominator < 0:\n            numerator = abs(numerator)\n            denominator = abs(denominator)\n            return \"-\" + self.fractionToDecimal(numerator, denominator)\n        \n        res = \"\"\n        if numerator >= denominator:\n            res += str(numerator // denominator)\n            numerator = numerator % denominator\n        else:\n            res += \"0\"\n        \n        if numerator == 0:\n            return res\n        \n        res += \".\"\n        dic = {}\n        while numerator != 0:\n            if numerator in dic:\n                res = res[:dic[numerator]] + \"(\" + res[dic[numerator]:] + \")\"\n                return res\n            dic[numerator] = len(res)\n            numerator *= 10\n            res += str(numerator // denominator)\n            numerator = numerator % denominator\n        \n        return res"}, {"task_id": "fraction-to-recurring-decimal", "completion": "class Solution(object):\n    def fractionToDecimal(self, numerator, denominator):\n        \"\"\"\n        :type numerator: int\n        :type denominator: int\n        :rtype: str\n        \"\"\"\n        \n        if numerator == 0:\n            return \"0\"\n        \n        if numerator < 0 and denominator < 0:\n            numerator = abs(numerator)\n            denominator = abs(denominator)\n        elif numerator < 0 or denominator < 0:\n            numerator = abs(numerator)\n            denominator = abs(denominator)\n            return \"-\" + self.fractionToDecimal(numerator, denominator)\n        \n        if numerator % denominator == 0:\n            return str(numerator // denominator)\n        \n        result = str(numerator // denominator) + \".\"\n        numerator = numerator % denominator\n        seen = {}\n        while numerator != 0:\n            if numerator in seen:\n                result = result[:seen[numerator]] + \"(\" + result[seen[numerator]:] + \")\"\n                return result\n            seen[numerator] = len(result)\n            numerator *= 10\n            result += str(numerator // denominator)\n            numerator = numerator % denominator\n        return result"}], "sort-list": [{"task_id": "sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        slow = head\n        fast = head\n        prev = None\n        \n        while fast and fast.next:\n            prev = slow\n            slow = slow.next\n            fast = fast.next.next\n            \n        prev.next = None\n        \n        left = self.sortList(head)\n        right = self.sortList(slow)\n        \n        return self.merge(left, right)\n    \n    def merge(self, left, right):\n        dummy = ListNode()\n        curr = dummy\n        \n        while left and right:\n            if left.val < right.val:\n                curr.next = left\n                left = left.next\n            else:\n                curr.next = right\n                right = right"}, {"task_id": "sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        slow = head\n        fast = head\n        prev = None\n        \n        while fast and fast.next:\n            prev = slow\n            slow = slow.next\n            fast = fast.next.next\n            \n        prev.next = None\n        \n        left = self.sortList(head)\n        right = self.sortList(slow)\n        \n        return self.merge(left, right)\n    \n    def merge(self, left, right):\n        dummy = ListNode()\n        curr = dummy\n        \n        while left and right:\n            if left.val < right.val:\n                curr.next = left\n                left = left.next\n            else:\n                curr.next = right\n                right = right"}, {"task_id": "sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        slow = head\n        fast = head\n        prev = None\n        \n        while fast and fast.next:\n            prev = slow\n            slow = slow.next\n            fast = fast.next.next\n            \n        prev.next = None\n        \n        left = self.sortList(head)\n        right = self.sortList(slow)\n        \n        return self.merge(left, right)\n    \n    def merge(self, left, right):\n        dummy = ListNode()\n        curr = dummy\n        \n        while left and right:\n            if left.val < right.val:\n                curr.next = left\n                left = left.next\n            else:\n                curr.next = right\n                right = right"}, {"task_id": "sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        # find the middle of the linked list\n        slow, fast = head, head.next\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # split the linked list into two halves\n        mid = slow.next\n        slow.next = None\n        \n        # recursively sort the two halves\n        left = self.sortList(head)\n        right = self.sortList(mid)\n        \n        # merge the two sorted halves\n        return self.merge(left, right)\n    \n    def merge(self, left, right):\n        dummy = ListNode(0)\n        curr = dummy\n        while left and right:\n            if left.val < right.val:\n                curr.next = left\n                left = left.next\n            else:\n                curr.next = right\n                right = right.next\n            curr = curr.next\n        if left:\n            curr.next = left\n        if right:\n            curr.next = right\n        return dummy.next"}, {"task_id": "sort-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def sortList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        if not head or not head.next:\n            return head\n        \n        slow = head\n        fast = head\n        prev = None\n        \n        while fast and fast.next:\n            prev = slow\n            slow = slow.next\n            fast = fast.next.next\n            \n        prev.next = None\n        \n        left = self.sortList(head)\n        right = self.sortList(slow)\n        \n        return self.merge(left, right)\n    \n    def merge(self, left, right):\n        dummy = ListNode()\n        curr = dummy\n        \n        while left and right:\n            if left.val < right.val:\n                curr.next = left\n                left = left.next\n            else:\n                curr.next = right\n                right = right"}], "russian-doll-envelopes": [{"task_id": "russian-doll-envelopes", "completion": "class Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort the envelopes by width\n        envelopes.sort(key=lambda x: (x[0], -x[1]))\n        \n        # find the longest increasing subsequence of the heights\n        heights = [env[1] for env in envelopes]\n        dp = [1] * len(heights)\n        for i in range(1, len(heights)):\n            for j in range(i):\n                if heights[j] < heights[i]:\n                    dp[i] = max(dp[i], dp[j] + 1)\n        return max(dp)"}, {"task_id": "russian-doll-envelopes", "completion": "class Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        envelopes.sort(key=lambda x: (x[0], -x[1]))\n        dp = []\n        for i in range(len(envelopes)):\n            left, right = 0, len(dp) - 1\n            while left <= right:\n                mid = (left + right) // 2\n                if dp[mid] < envelopes[i][1]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            if left >= len(dp):\n                dp.append(envelopes[i][1])\n            else:\n                dp[left] = envelopes[i][1]\n        return len(dp)"}, {"task_id": "russian-doll-envelopes", "completion": "class Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort the envelopes by width in ascending order\n        envelopes.sort(key=lambda x: x[0])\n        \n        # create a list to store the longest increasing subsequence\n        lis = []\n        \n        # iterate through the envelopes\n        for envelope in envelopes:\n            # if the list is empty or the current envelope is greater than the last element in the list\n            if not lis or envelope[1] > lis[-1]:\n                # append the current envelope to the list\n                lis.append(envelope[1])\n            else:\n                # find the index of the first element in the list that is greater than or equal to the current envelope\n                index = bisect.bisect_left(lis, envelope[1])\n                # replace the element at that index with the current envelope\n                lis[index] = envelope[1]\n        \n        # return the length of the list\n        return len(lis)"}, {"task_id": "russian-doll-envelopes", "completion": "class Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        # sort the envelopes by width in ascending order\n        envelopes.sort(key=lambda x: x[0])\n        \n        # create a list to store the longest increasing subsequence\n        lis = []\n        \n        # iterate through the envelopes\n        for envelope in envelopes:\n            # if the list is empty or the current envelope is greater than the last envelope in the list\n            if not lis or envelope > lis[-1]:\n                # append the current envelope to the list\n                lis.append(envelope)\n            else:\n                # find the index of the first envelope in the list that is greater than or equal to the current envelope\n                index = bisect.bisect_left(lis, envelope)\n                # replace the envelope at that index with the current envelope\n                lis[index] = envelope\n        \n        # return the length of the list\n        return len(lis)"}, {"task_id": "russian-doll-envelopes", "completion": "class Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        \n        envelopes.sort(key=lambda x: (x[0], -x[1]))\n        dp = []\n        for i in range(len(envelopes)):\n            left, right = 0, len(dp) - 1\n            while left <= right:\n                mid = (left + right) // 2\n                if dp[mid] < envelopes[i][1]:\n                    left = mid + 1\n                else:\n                    right = mid - 1\n            if left >= len(dp):\n                dp.append(envelopes[i][1])\n            else:\n                dp[left] = envelopes[i][1]\n        return len(dp)"}], "set-matrix-zeroes": [{"task_id": "set-matrix-zeroes", "completion": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        # 1. find all the 0s in the matrix\n        # 2. for each 0, set the entire row and column to 0\n        # 3. return the matrix\n        \n        # 1. find all the 0s in the matrix\n        # 2. for each 0, set the entire row and column to 0\n        # 3. return the matrix\n        \n        # 1. find all the 0s in the matrix\n        # 2. for each 0, set the entire row and column to \n        # 3. return the matrix\n        \n        # 1. find all the 0s in the matrix\n        # 2. for each 0, set the entire row and column to 0\n        # 3. return the matrix\n        \n        # 1. find all the 0s in the matrix\n        # 2. for each 0, set the entire row and column to 0\n        # 3. return the matrix\n        \n        # 1. find all the 0s in the matrix\n        # 2. for each 0, set the entire row and column to 0\n        # 3. return the matrix\n        \n        # 1. find all the 0s in the matrix\n        # 2. for each 0, set the entire row and column to 0\n        # 3. return the matrix\n        \n        # 1. find all the 0s in the matrix\n        # 2. for each 0, set the entire row and column to 0\n        # 3. return the matrix\n        \n        # 1. find all the 0s in the matrix\n        # 2. for each 0, set the entire row and column to 0\n        # 3. return the matrix\n        \n        # 1. find all the 0s in the matrix\n        # 2. for each 0, set the entire row and column to 0\n        # 3. return the matrix\n        \n        # 1. find all the 0s in the matrix\n        # 2. for each 0, set the entire row and column to 0\n        # 3. return the matrix\n        \n        # 1. find all the 0s in the matrix\n        # 2. for each 0, set the entire row and column to 0\n        # 3. return the matrix\n        \n        # 1. find all the 0s in the matrix\n        # 2. for each 0, set the entire row and column to 0\n        # 3. return the matrix\n        \n        # 1. find all the 0s in the matrix\n        # 2. for each 0, set the entire row and column to 0\n        # 3. return the matrix\n        \n        # 1. find all the 0s in the matrix\n        # 2. for each 0, set the entire row and column to 0\n        # 3. return the matrix\n        \n        # 1. find all the 0s in the matrix\n        # 2. for each 0, set the entire row and column to 0\n        # 3. return the matrix\n        \n        # 1. find all the 0s in the matrix\n        # 2. for each 0, set the entire row and column to 0\n        # 3. return the matrix\n        \n        # 1. find all the 0s in the matrix\n        # 2. for each 0, set the entire row and column to 0\n        # 3. return the matrix\n        \n        # 1. find all the 0s in the matrix\n        # 2. for each 0, set the entire row and column to 0\n        # 3. return the matrix\n        \n        # 1. find all the 0s in the matrix\n        # 2. for each 0, set the entire row and column to 0\n        # 3. return the matrix\n        \n        # 1. find all the 0s in the matrix\n        # 2. for each 0, set the entire row and column to 0\n        # 3. return the matrix\n        \n        # 1. find all the 0s in the matrix\n        # 2. for each 0, set the entire row and column to 0\n        # 3. return the matrix\n        \n        # 1. find all the 0s in"}, {"task_id": "set-matrix-zeroes", "completion": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        # 1. find all the zeroes\n        # 2. for each zero, set the row and column to zero\n        # 3. return the matrix\n        \n        # find all the zeroes\n        zeroes = []\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                if matrix[i][j] == 0:\n                    zeroes.append((i, j))\n        \n        # for each zero, set the row and column to zero\n        for zero in zeroes:\n            for i in range(len(matrix)):\n                matrix[i][zero[1]] = 0\n            for j in range(len(matrix[0])):\n                matrix[zero[0]][j] = 0\n        \n        return matrix"}, {"task_id": "set-matrix-zeroes", "completion": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        # 1. find all the zeroes\n        # 2. for each zero, set the row and column to zero\n        # 3. return the matrix\n        \n        # 1. find all the zeroes\n        zeroes = []\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                if matrix[i][j] == 0:\n                    zeroes.append((i, j))\n        \n        # 2. for each zero, set the row and column to zero\n        for zero in zeroes:\n            for i in range(len(matrix)):\n                matrix[i][zero[1]] = 0\n            for j in range(len(matrix[0])):\n                matrix[zero[0]][j] = 0\n        \n        # 3. return the matrix\n        return matrix"}, {"task_id": "set-matrix-zeroes", "completion": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        # 1. find all the zeroes\n        # 2. set the row and column to zero\n        # 3. set the row and column to zero\n        \n        # 1. find all the zeroes\n        zeroes = []\n        for i in range(len(matrix)):\n            for j in range(len(matrix[0])):\n                if matrix[i][j] == 0:\n                    zeroes.append((i, j))\n        \n        # 2. set the row and column to zero\n        for i, j in zeroes:\n            for k in range(len(matrix[0])):\n                matrix[i][k] = 0\n            for k in range(len(matrix)):\n                matrix[k][j] = 0\n        \n        return matrix"}, {"task_id": "set-matrix-zeroes", "completion": "class Solution(object):\n    def setZeroes(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: None Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        rows = set()\n        cols = set()\n        \n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == 0:\n                    rows.add(i)\n                    cols.add(j)\n        \n        for i in range(m):\n            for j in range(n):\n                if i in rows or j in cols:\n                    matrix[i][j] = 0"}], "remove-nth-node-from-end-of-list": [{"task_id": "remove-nth-node-from-end-of-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # 1. find the length of the linked list\n        # 2. find the node to be removed\n        # 3. remove the node\n        # 4. return the head\n        \n        # 1. find the length of the linked list\n        length = 0\n        current = head\n        while current:\n            length += 1\n            current = current.next\n        \n        # 2. find the node to be removed\n        node_to_remove = length - n\n        \n        # 3. remove the node\n        current = head\n        previous = None\n        index = 0\n        while current:\n            if index == node_to_remove:\n                if previous:\n                    previous.next = current.next\n                else:\n                    head = current.next\n            else:\n                previous = current\n            current = current.next\n            index += 1\n        \n        # 4. return the head\n        return head"}, {"task_id": "remove-nth-node-from-end-of-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # 1. find the length of the linked list\n        # 2. find the node to be deleted\n        # 3. delete the node\n        # 4. return the head\n        \n        # 1. find the length of the linked list\n        length = 0\n        current = head\n        while current:\n            length += 1\n            current = current.next\n        \n        # 2. find the node to be deleted\n        # 3. delete the node\n        # 4. return the head\n        if length == n:\n            return head.next\n        else:\n            current = head\n            for i in range(length - n - 1):\n                current = current.next\n            current.next = current.next.next\n            return head"}, {"task_id": "remove-nth-node-from-end-of-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # 1. find the length of the linked list\n        # 2. find the node to be removed\n        # 3. remove the node\n        # 4. return the head\n        \n        # 1. find the length of the linked list\n        length = 0\n        current = head\n        while current:\n            length += 1\n            current = current.next\n        \n        # 2. find the node to be removed\n        node_to_remove = length - n\n        \n        # 3. remove the node\n        current = head\n        previous = None\n        index = 0\n        while current:\n            if index == node_to_remove:\n                if previous:\n                    previous.next = current.next\n                else:\n                    head = current.next\n            else:\n                previous = current\n            current = current.next\n            index += 1\n        \n        # 4. return the head\n        return head"}, {"task_id": "remove-nth-node-from-end-of-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # 1. find the length of the linked list\n        # 2. find the node to be deleted\n        # 3. delete the node\n        # 4. return the head\n        \n        # 1. find the length of the linked list\n        length = 0\n        current = head\n        while current:\n            length += 1\n            current = current.next\n        \n        # 2. find the node to be deleted\n        # 3. delete the node\n        # 4. return the head\n        if length == n:\n            return head.next\n        else:\n            current = head\n            for i in range(length - n - 1):\n                current = current.next\n            current.next = current.next.next\n            return head"}, {"task_id": "remove-nth-node-from-end-of-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeNthFromEnd(self, head, n):\n        \"\"\"\n        :type head: ListNode\n        :type n: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # 1. find the length of the linked list\n        # 2. find the node to be deleted\n        # 3. delete the node\n        # 4. return the head\n        \n        # 1. find the length of the linked list\n        length = 0\n        current = head\n        while current:\n            length += 1\n            current = current.next\n        \n        # 2. find the node to be deleted\n        # 3. delete the node\n        # 4. return the head\n        if length == n:\n            return head.next\n        else:\n            current = head\n            for i in range(length - n - 1):\n                current = current.next\n            current.next = current.next.next\n            return head"}], "intersection-of-two-arrays": [{"task_id": "intersection-of-two-arrays", "completion": "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. create a set of nums1\n        # 2. create a set of nums2\n        # 3. return the intersection of the two sets\n        \n        # 1. create a set of nums1\n        nums1 = set(nums1)\n        \n        # 2. create a set of nums2\n        nums2 = set(nums2)\n        \n        # 3. return the intersection of the two sets\n        return list(nums1 & nums2)"}, {"task_id": "intersection-of-two-arrays", "completion": "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. create a set of nums1\n        # 2. create a set of nums2\n        # 3. return the intersection of the two sets\n        \n        # 1. create a set of nums1\n        nums1 = set(nums1)\n        \n        # 2. create a set of nums2\n        nums2 = set(nums2)\n        \n        # 3. return the intersection of the two sets\n        return list(nums1 & nums2)"}, {"task_id": "intersection-of-two-arrays", "completion": "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. create a set of nums1\n        # 2. create a set of nums2\n        # 3. create a set of intersection\n        # 4. return the intersection\n        \n        # 1. create a set of nums1\n        nums1 = set(nums1)\n        \n        # 2. create a set of nums2\n        nums2 = set(nums2)\n        \n        # 3. create a set of intersection\n        intersection = nums1 & nums2\n        \n        # 4. return the intersection\n        return list(intersection)"}, {"task_id": "intersection-of-two-arrays", "completion": "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # create a set of nums1\n        # create a set of nums2\n        # return the intersection of the two sets\n        \n        nums1 = set(nums1)\n        nums2 = set(nums2)\n        \n        return list(nums1 & nums2)"}, {"task_id": "intersection-of-two-arrays", "completion": "class Solution(object):\n    def intersection(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. create a set of nums1\n        # 2. create a set of nums2\n        # 3. create a set of intersection\n        # 4. return the intersection\n        \n        # 1. create a set of nums1\n        nums1 = set(nums1)\n        \n        # 2. create a set of nums2\n        nums2 = set(nums2)\n        \n        # 3. create a set of intersection\n        intersection = nums1 & nums2\n        \n        # 4. return the intersection\n        return list(intersection)"}], "super-washing-machines": [{"task_id": "super-washing-machines", "completion": "class Solution(object):\n    def findMinMoves(self, machines):\n        \"\"\"\n        :type machines: List[int]\n        :rtype: int\n        \"\"\"\n        \n        total = sum(machines)\n        n = len(machines)\n        if total % n != 0:\n            return -1\n        avg = total // n\n        ans = max_ = 0\n        for num in machines:\n            num -= avg\n            ans = max(ans, max_, abs(num))\n            max_ += num\n        return ans"}, {"task_id": "super-washing-machines", "completion": "class Solution(object):\n    def findMinMoves(self, machines):\n        \"\"\"\n        :type machines: List[int]\n        :rtype: int\n        \"\"\"\n        \n        total = sum(machines)\n        n = len(machines)\n        if total % n != 0:\n            return -1\n        avg = total // n\n        ans = max_ = 0\n        for num in machines:\n            num -= avg\n            ans = max(ans, max_, abs(num))\n            max_ += num\n        return ans"}, {"task_id": "super-washing-machines", "completion": "class Solution(object):\n    def findMinMoves(self, machines):\n        \"\"\"\n        :type machines: List[int]\n        :rtype: int\n        \"\"\"\n        \n        total = sum(machines)\n        n = len(machines)\n        if total % n != 0:\n            return -1\n        avg = total // n\n        ans, preSum = 0, 0\n        for num in machines:\n            num -= avg\n            preSum += num\n            ans = max(ans, abs(preSum), num)\n        return ans"}, {"task_id": "super-washing-machines", "completion": "class Solution(object):\n    def findMinMoves(self, machines):\n        \"\"\"\n        :type machines: List[int]\n        :rtype: int\n        \"\"\"\n        \n        total = sum(machines)\n        n = len(machines)\n        if total % n:\n            return -1\n        avg = total // n\n        ans = max(machines) - avg\n        left_sum = 0\n        for i in range(n):\n            right_sum = total - left_sum - machines[i]\n            ans = max(ans, abs(left_sum - i * avg), abs(right_sum - (n - i - 1) * avg))\n            left_sum += machines[i]\n        return ans"}, {"task_id": "super-washing-machines", "completion": "class Solution(object):\n    def findMinMoves(self, machines):\n        \"\"\"\n        :type machines: List[int]\n        :rtype: int\n        \"\"\"\n        \n        total = sum(machines)\n        n = len(machines)\n        if total % n:\n            return -1\n        avg = total // n\n        res = 0\n        left_sum = 0\n        for i in range(n):\n            left_sum += machines[i]\n            res = max(res, abs(left_sum - (i + 1) * avg), machines[i] - avg)\n        return res"}], "kth-smallest-number-in-multiplication-table": [{"task_id": "kth-smallest-number-in-multiplication-table", "completion": "class Solution(object):\n    def findKthNumber(self, m, n, k):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def count(x):\n            return sum(min(x // i, n) for i in range(1, m + 1))\n        \n        lo, hi = 1, m * n\n        while lo < hi:\n            mi = lo + (hi - lo) // 2\n            if count(mi) >= k:\n                hi = mi\n            else:\n                lo = mi + 1\n        return lo"}, {"task_id": "kth-smallest-number-in-multiplication-table", "completion": "class Solution(object):\n    def findKthNumber(self, m, n, k):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def count(x):\n            return sum(min(x // i, n) for i in range(1, m + 1))\n        \n        lo, hi = 1, m * n\n        while lo < hi:\n            mi = lo + (hi - lo) // 2\n            if count(mi) >= k:\n                hi = mi\n            else:\n                lo = mi + 1\n        return lo"}, {"task_id": "kth-smallest-number-in-multiplication-table", "completion": "class Solution(object):\n    def findKthNumber(self, m, n, k):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def count(x):\n            return sum(min(x//i, n) for i in range(1, m+1))\n        \n        lo, hi = 1, m*n\n        while lo < hi:\n            mi = lo + (hi - lo) // 2\n            if count(mi) >= k:\n                hi = mi\n            else:\n                lo = mi + 1\n        return lo"}, {"task_id": "kth-smallest-number-in-multiplication-table", "completion": "class Solution(object):\n    def findKthNumber(self, m, n, k):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def count(x):\n            return sum(min(x // i, n) for i in range(1, m + 1))\n        \n        lo, hi = 1, m * n\n        while lo < hi:\n            mi = lo + (hi - lo) // 2\n            if count(mi) >= k:\n                hi = mi\n            else:\n                lo = mi + 1\n        return lo"}, {"task_id": "kth-smallest-number-in-multiplication-table", "completion": "class Solution(object):\n    def findKthNumber(self, m, n, k):\n        \"\"\"\n        :type m: int\n        :type n: int\n        :type k: int\n        :rtype: int\n        \"\"\"\n        \n        def count(x):\n            return sum(min(x // i, n) for i in range(1, m + 1))\n        \n        lo, hi = 1, m * n\n        while lo < hi:\n            mi = lo + (hi - lo) // 2\n            if count(mi) >= k:\n                hi = mi\n            else:\n                lo = mi + 1\n        return lo"}], "convert-sorted-list-to-binary-search-tree": [{"task_id": "convert-sorted-list-to-binary-search-tree", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        \n        def get_mid(head):\n            slow, fast = head, head\n            prev = None\n            while fast and fast.next:\n                prev = slow\n                slow = slow.next\n                fast = fast.next.next\n            if prev:\n                prev.next = None\n            return slow\n        \n        def helper(head):\n            if not head:\n                return None\n            mid = get_mid(head)\n            root = TreeNode(mid.val)\n            if head == mid:\n                return root\n            root.left = helper(head)\n            root.right = helper(mid.next)\n            return root\n        \n        return helper(head)"}, {"task_id": "convert-sorted-list-to-binary-search-tree", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        \n        def get_mid(head):\n            slow = head\n            fast = head\n            prev = None\n            while fast and fast.next:\n                prev = slow\n                slow = slow.next\n                fast = fast.next.next\n            return prev\n        \n        def helper(head):\n            if not head:\n                return None\n            if not head.next:\n                return TreeNode(head.val)\n            mid = get_mid(head)\n            root = TreeNode(mid.next.val)\n            mid.next = mid.next.next\n            root.left = helper(head)\n            root.right = helper(mid.next)\n            return root\n        \n        return helper(head)"}, {"task_id": "convert-sorted-list-to-binary-search-tree", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        \n        def get_mid(head):\n            slow = head\n            fast = head\n            prev = None\n            while fast and fast.next:\n                prev = slow\n                slow = slow.next\n                fast = fast.next.next\n            return prev, slow\n        \n        def helper(head):\n            if not head:\n                return None\n            if not head.next:\n                return TreeNode(head.val)\n            prev, mid = get_mid(head)\n            if prev:\n                prev.next = None\n            else:\n                head = None\n            root = TreeNode(mid.val)\n            root.left = helper(head)\n            root.right = helper(mid.next)\n            return root\n        \n        return helper(head)"}, {"task_id": "convert-sorted-list-to-binary-search-tree", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        \n        def get_mid(head):\n            slow = head\n            fast = head\n            prev = None\n            while fast and fast.next:\n                prev = slow\n                slow = slow.next\n                fast = fast.next.next\n            return prev\n        \n        def helper(head):\n            if not head:\n                return None\n            if not head.next:\n                return TreeNode(head.val)\n            mid = get_mid(head)\n            root = TreeNode(mid.next.val)\n            mid.next = mid.next.next\n            root.left = helper(head)\n            root.right = helper(mid.next)\n            return root\n        \n        return helper(head)"}, {"task_id": "convert-sorted-list-to-binary-search-tree", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def sortedListToBST(self, head):\n        \"\"\"\n        :type head: Optional[ListNode]\n        :rtype: Optional[TreeNode]\n        \"\"\"\n        \n        def get_mid(head):\n            slow, fast = head, head\n            prev = None\n            while fast and fast.next:\n                prev = slow\n                slow = slow.next\n                fast = fast.next.next\n            if prev:\n                prev.next = None\n            return slow\n        \n        def helper(head):\n            if not head:\n                return None\n            mid = get_mid(head)\n            root = TreeNode(mid.val)\n            if head == mid:\n                return root\n            root.left = helper(head)\n            root.right = helper(mid.next)\n            return root\n        \n        return helper(head)"}], "merge-two-sorted-lists": [{"task_id": "merge-two-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: Optional[ListNode]\n        :type list2: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        \n        # create a dummy node\n        dummy = ListNode()\n        \n        # create a pointer to the dummy node\n        tail = dummy\n        \n        # while both lists are not empty\n        while list1 and list2:\n            # if the value of the first list is less than the value of the second list\n            if list1.val < list2.val:\n                # set the next node of the tail to the first list\n                tail.next = list1\n                # move the first list to the next node\n                list1 = list1.next\n            else:\n                # set the next node of the tail to the second list\n                tail.next = list2\n                # move the second list to the next node\n                list2 = list2.next\n            # move the tail to the next node\n            tail = tail.next\n        \n        # if the first list is not empty\n        if list1:\n            # set the next node of the tail to the first list\n            tail.next = list1\n        # if the second list is not empty\n        elif list2:\n            # set the next node of the tail to the second list\n            tail.next = list2\n        \n        # return the next node of the dummy node\n        return dummy.next"}, {"task_id": "merge-two-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: Optional[ListNode]\n        :type list2: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        \n        # create a dummy node\n        dummy = ListNode()\n        \n        # create a pointer to the dummy node\n        tail = dummy\n        \n        # while both lists are not empty\n        while list1 and list2:\n            # if the value of the first node in list1 is less than or equal to the value of the first node in list2\n            if list1.val <= list2.val:\n                # set the next node of the tail to the first node in list1\n                tail.next = list1\n                # move the pointer to the next node in list1\n                list1 = list1.next\n            else:\n                # set the next node of the tail to the first node in list2\n                tail.next = list2\n                # move the pointer to the next node in list2\n                list2 = list2.next\n            # move the pointer to the next node in the tail\n            tail = tail.next\n        \n        # if list1 is not empty\n        if list1:\n            # set the next node of the tail to the first node in list1\n            tail.next = list1\n        # if list2 is not empty\n        elif list2:\n            # set the next node of the tail to the first node in list2\n            tail.next = list2\n        \n        # return the next node of the dummy node\n        return dummy.next"}, {"task_id": "merge-two-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: Optional[ListNode]\n        :type list2: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        \n        # create a dummy node\n        dummy = ListNode()\n        \n        # create a pointer to the dummy node\n        tail = dummy\n        \n        # while both lists are not empty\n        while list1 and list2:\n            # if the value of the first node in list1 is less than or equal to the value of the first node in list2\n            if list1.val <= list2.val:\n                # set the next node of the tail to the first node in list1\n                tail.next = list1\n                # move the pointer to the next node in list1\n                list1 = list1.next\n            else:\n                # set the next node of the tail to the first node in list2\n                tail.next = list2\n                # move the pointer to the next node in list2\n                list2 = list2.next\n            # move the pointer to the next node in the tail\n            tail = tail.next\n        \n        # if list1 is not empty\n        if list1:\n            # set the next node of the tail to the first node in list1\n            tail.next = list1\n        # if list2 is not empty\n        elif list2:\n            # set the next node of the tail to the first node in list2\n            tail.next = list2\n        \n        # return the next node of the dummy node\n        return dummy.next"}, {"task_id": "merge-two-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: Optional[ListNode]\n        :type list2: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        \n        # create a dummy node to store the head of the merged list\n        dummy = ListNode()\n        # create a pointer to the head of the merged list\n        tail = dummy\n        \n        # iterate through both lists\n        while list1 and list2:\n            # compare the values of the current nodes in both lists\n            if list1.val < list2.val:\n                # add the node from list1 to the merged list\n                tail.next = list1\n                # move the pointer to the next node in list1\n                list1 = list1.next\n            else:\n                # add the node from list2 to the merged list\n                tail.next = list2\n                # move the pointer to the next node in list2\n                list2 = list2.next\n            # move the pointer to the next node in the merged list\n            tail = tail.next\n        \n        # add any remaining nodes from list1 or list2 to the merged list\n        if list1:\n            tail.next = list1\n        elif list2:\n            tail.next = list2\n        \n        # return the head of the merged list\n        return dummy.next"}, {"task_id": "merge-two-sorted-lists", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def mergeTwoLists(self, list1, list2):\n        \"\"\"\n        :type list1: Optional[ListNode]\n        :type list2: Optional[ListNode]\n        :rtype: Optional[ListNode]\n        \"\"\"\n        \n        # create a dummy node to store the head of the merged list\n        dummy = ListNode()\n        # create a pointer to the head of the merged list\n        tail = dummy\n        \n        # iterate through both lists\n        while list1 and list2:\n            # compare the values of the current nodes in both lists\n            if list1.val < list2.val:\n                # add the node from list1 to the merged list\n                tail.next = list1\n                # move the pointer to the next node in list1\n                list1 = list1.next\n            else:\n                # add the node from list2 to the merged list\n                tail.next = list2\n                # move the pointer to the next node in list2\n                list2 = list2.next\n            # move the pointer to the next node in the merged list\n            tail = tail.next\n        \n        # add any remaining nodes from list1 or list2 to the merged list\n        if list1:\n            tail.next = list1\n        elif list2:\n            tail.next = list2\n        \n        # return the head of the merged list\n        return dummy.next"}], "maximal-rectangle": [{"task_id": "maximal-rectangle", "completion": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        heights = [0] * n\n        max_area = 0\n        \n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == '1':\n                    heights[j] += 1\n                else:\n                    heights[j] = 0\n            max_area = max(max_area, self.largestRectangleArea(heights))\n        \n        return max_area\n    \n    def largestRectangleArea(self, heights):\n        stack = []\n        max_area = 0\n        heights.append(0)\n        \n        for i in range(len(heights)):\n            while stack and heights[stack[-1]] > heights[i]:\n                h = heights[stack.pop()]\n                w = i if not stack else i - stack[-1] - 1\n                max_area = max(max_area, h * w)\n            stack.append(i)\n        \n        return max_area"}, {"task_id": "maximal-rectangle", "completion": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        heights = [0] * n\n        max_area = 0\n        \n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == '1':\n                    heights[j] += 1\n                else:\n                    heights[j] = 0\n            max_area = max(max_area, self.largestRectangleArea(heights))\n        \n        return max_area\n    \n    def largestRectangleArea(self, heights):\n        stack = []\n        max_area = 0\n        heights.append(0)\n        \n        for i in range(len(heights)):\n            while stack and heights[stack[-1]] > heights[i]:\n                h = heights[stack.pop()]\n                w = i if not stack else i - stack[-1] - 1\n                max_area = max(max_area, h * w)\n            stack.append(i)\n        \n        return max_area"}, {"task_id": "maximal-rectangle", "completion": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2D DP\n        # Time: O(m*n)\n        # Space: O(m*n)\n        # 2. 1D DP\n        # Time: O(m*n)\n        # Space: O(n)\n        # 3. Stack\n        # Time: O(m*n)\n        # Space: O(n)\n        \n        # 1. 2D DP\n        # Time: O(m*n)\n        # Space: O(m*n)\n        if not matrix:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        dp = [[0] * n for _ in range(m)]\n        res = 0\n        \n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == '1':\n                    if i == 0:\n                        dp[i][j] = 1\n                    else:\n                        dp[i][j] = dp[i-1][j] + 1\n        \n        for i in range(m):\n            stack = []\n            for j in range(n+1):\n                if j < n:\n                    cur = dp[i][j]\n                else:\n                    cur = 0\n                while stack and cur < dp[i][stack[-1]]:\n                    h = dp[i][stack.pop()]\n                    if stack:\n                        w = j - stack[-1] - 1\n                    else:\n                        w = j\n                    res = max(res, h * w)\n                stack.append(j)\n        \n        return res\n    \n        # 2. 1D DP\n        # Time: O(m*n)\n        # Space: O(n)\n        if not matrix:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        dp = [0] * n\n        res = 0\n        \n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == '1':\n                    dp[j] += 1\n                else:\n                    dp[j] = 0\n            stack = []\n            for j in range(n+1):\n                if j < n:\n                    cur = dp[j]\n                else:\n                    cur = 0\n                while stack and cur < dp[stack[-1]]:\n                    h = dp[stack.pop()]\n                    if stack:\n                        w = j - stack[-1] - 1\n                    else:\n                        w = j\n                    res = max(res, h * w)\n                stack.append(j)\n        \n        return res\n    \n        # 3. Stack\n        # Time: O(m*n)\n        # Space: O(n)\n        if not matrix:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        dp = [0] * n\n        res = 0\n        \n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == '1':\n                    dp[j] += 1\n                else:\n                    dp[j] = 0\n            stack = []\n            for j in range(n+1):\n                if j < n:\n                    cur = dp[j]\n                else:\n                    cur = 0\n                while stack and cur < dp[stack[-1]]:\n                    h = dp[stack.pop()]\n                    if stack:\n                        w = j - stack[-1] - 1\n                    else:\n                        w = j\n                    res = max(res, h * w)\n                stack.append(j)\n        \n        return res"}, {"task_id": "maximal-rectangle", "completion": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        \n        if not matrix:\n            return 0\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        heights = [0] * n\n        max_area = 0\n        \n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == '1':\n                    heights[j] += 1\n                else:\n                    heights[j] = 0\n            \n            max_area = max(max_area, self.largestRectangleArea(heights))\n        \n        return max_area\n    \n    def largestRectangleArea(self, heights):\n        stack = []\n        max_area = 0\n        \n        for i in range(len(heights) + 1):\n            h = heights[i] if i < len(heights) else 0\n            \n            while stack and heights[stack[-1]] > h:\n                height = heights[stack.pop()]\n                width = i if not stack else i - stack[-1] - 1\n                max_area = max(max_area, height * width)\n            \n            stack.append(i)\n        \n        return max_area"}, {"task_id": "maximal-rectangle", "completion": "class Solution(object):\n    def maximalRectangle(self, matrix):\n        \"\"\"\n        :type matrix: List[List[str]]\n        :rtype: int\n        \"\"\"\n        \n        # 1. 2D DP\n        # Time: O(m*n)\n        # Space: O(m*n)\n        # 2. 1D DP\n        # Time: O(m*n)\n        # Space: O(n)\n        # 3. Stack\n        # Time: O(m*n)\n        # Space: O(n)\n        \n        # 1. 2D DP\n        # Time: O(m*n)\n        # Space: O(m*n)\n        if not matrix:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        dp = [[0] * n for _ in range(m)]\n        max_area = 0\n        \n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == '0':\n                    continue\n                if i == 0:\n                    dp[i][j] = 1\n                else:\n                    dp[i][j] = dp[i-1][j] + 1\n        \n        for i in range(m):\n            stack = []\n            for j in range(n+1):\n                h = dp[i][j] if j < n else 0\n                while stack and h < dp[i][stack[-1]]:\n                    idx = stack.pop()\n                    k = stack[-1] if stack else -1\n                    max_area = max(max_area, dp[i][idx] * (j - k - 1))\n                stack.append(j)\n        \n        return max_area\n    \n        # 2. 1D DP\n        # Time: O(m*n)\n        # Space: O(n)\n        if not matrix:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        dp = [0] * n\n        max_area = 0\n        \n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == '0':\n                    dp[j] = 0\n                else:\n                    dp[j] += 1\n            stack = []\n            for j in range(n+1):\n                h = dp[j] if j < n else 0\n                while stack and h < dp[stack[-1]]:\n                    idx = stack.pop()\n                    k = stack[-1] if stack else -1\n                    max_area = max(max_area, dp[idx] * (j - k - 1))\n                stack.append(j)\n        \n        return max_area\n    \n        # 3. Stack\n        # Time: O(m*n)\n        # Space: O(n)\n        if not matrix:\n            return 0\n        \n        m, n = len(matrix), len(matrix[0])\n        dp = [0] * n\n        max_area = 0\n        \n        for i in range(m):\n            for j in range(n):\n                if matrix[i][j] == '0':\n                    dp[j] = 0\n                else:\n                    dp[j] += 1\n            stack = []\n            for j in range(n+1):\n                h = dp[j] if j < n else 0\n                while stack and h < dp[stack[-1]]:\n                    idx = stack.pop()\n                    k = stack[-1] if stack else -1\n                    max_area = max(max_area, dp[idx] * (j - k - 1))\n                stack.append(j)\n        \n        return max_area"}], "subsets": [{"task_id": "subsets", "completion": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(first = 0, curr = []):\n            # if the combination is done\n            if len(curr) == k:  \n                output.append(curr[:])\n                return\n            for i in range(first, n):\n                # add nums[i] into the current combination\n                curr.append(nums[i])\n                # use next integers to complete the combination\n                backtrack(i + 1, curr)\n                # backtrack\n                curr.pop()\n        \n        output = []\n        n = len(nums)\n        for k in range(n + 1):\n            backtrack()\n        return output"}, {"task_id": "subsets", "completion": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(first = 0, curr = []):\n            # if the combination is done\n            if len(curr) == k:  \n                output.append(curr[:])\n                return\n            for i in range(first, n):\n                # add nums[i] into the current combination\n                curr.append(nums[i])\n                # use next integers to complete the combination\n                backtrack(i + 1, curr)\n                # backtrack\n                curr.pop()\n        \n        output = []\n        n = len(nums)\n        for k in range(n + 1):\n            backtrack()\n        return output"}, {"task_id": "subsets", "completion": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(first = 0, curr = []):\n            # if the combination is done\n            if len(curr) == k:  \n                output.append(curr[:])\n                return\n            for i in range(first, n):\n                # add nums[i] into the current combination\n                curr.append(nums[i])\n                # use next integers to complete the combination\n                backtrack(i + 1, curr)\n                # backtrack\n                curr.pop()\n        \n        output = []\n        n = len(nums)\n        for k in range(n + 1):\n            backtrack()\n        return output"}, {"task_id": "subsets", "completion": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(first = 0, curr = []):\n            # if the combination is done\n            if len(curr) == k:  \n                output.append(curr[:])\n                return\n            for i in range(first, n):\n                # add nums[i] into the current combination\n                curr.append(nums[i])\n                # use next integers to complete the combination\n                backtrack(i + 1, curr)\n                # backtrack\n                curr.pop()\n        \n        output = []\n        n = len(nums)\n        for k in range(n + 1):\n            backtrack()\n        return output"}, {"task_id": "subsets", "completion": "class Solution(object):\n    def subsets(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(first = 0, curr = []):\n            # if the combination is done\n            if len(curr) == k:  \n                output.append(curr[:])\n                return\n            for i in range(first, n):\n                # add nums[i] into the current combination\n                curr.append(nums[i])\n                # use next integers to complete the combination\n                backtrack(i + 1, curr)\n                # backtrack\n                curr.pop()\n        \n        output = []\n        n = len(nums)\n        for k in range(n + 1):\n            backtrack()\n        return output"}], "find-minimum-in-rotated-sorted-array-ii": [{"task_id": "find-minimum-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u4e8c\u5206\u67e5\u627e\n        # 2. \u4e8c\u5206\u67e5\u627e\u7684\u6761\u4ef6\u662f\uff1a\n        # 3. \u5982\u679c\u4e2d\u95f4\u7684\u6570\u5c0f\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u53f3\u8fb9\n        # 4. \u5982\u679c\u4e2d\u95f4\u6570\u5927\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u5de6\u8fb9\n        # 5. \u5982\u679c\u4e2d\u95f4\u6570\u7b49\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u5728\u5de6\u8fb9\u6216\u53f3\u8fb9\n        # 6. \u65f6\u95f4\u590d\u6742\u5ea6O(logn)\n        # 7. \u7a7a\u95f4\u590d\u6742\u5ea6O(1)\n        # 8. \u4e8c\u5206\u67e5\u627e\u7684\u6761\u4ef6\u662f\uff1a\n        # 9. \u5982\u679c\u4e2d\u95f4\u7684\u6570\u5c0f\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u53f3\u8fb9\n        # 10. \u5982\u679c\u4e2d\u95f4\u6570\u5927\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u5de6\u8fb9\n        # 11. \u5982\u679c\u4e2d\u95f4\u6570\u7b49\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u5728\u5de6\u8fb9\u6216\u53f3\u8fb9\n        # 12. \u65f6\u95f4\u590d\u6742\u5ea6O(logn)\n        # 13. \u7a7a\u95f4\u590d\u6742\u5ea6O(1)\n        # 14. \u4e8c\u5206\u67e5\u627e\u7684\u6761\u4ef6\u662f\uff1a\n        # 15. \u5982\u679c\u4e2d\u95f4\u7684\u6570\u5c0f\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u53f3\u8fb9\n        # 16. \u5982\u679c\u4e2d\u95f4\u6570\u5927\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u5de6\u8fb9\n        # 17. \u5982\u679c\u4e2d\u95f4\u6570\u7b49\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u5728\u5de6\u8fb9\u6216\u53f3\u8fb9\n        # 18. \u65f6\u95f4\u590d\u6742\u5ea6O(logn)\n        # 19. \u7a7a\u95f4\u590d\u6742\u5ea6O(1)\n        # 20. \u4e8c\u5206\u67e5\u627e\u7684\u6761\u4ef6\u662f\uff1a\n        # 21. \u5982\u679c\u4e2d\u95f4\u7684\u6570\u5c0f\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u53f3\u8fb9\n        # 22. \u5982\u679c\u4e2d\u95f4\u6570\u5927\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u5de6\u8fb9\n        # 23. \u5982\u679c\u4e2d\u95f4\u6570\u7b49\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u5728\u5de6\u8fb9\u6216\u53f3\u8fb9\n        # 24. \u65f6\u95f4\u590d\u6742\u5ea6O(logn)\n        # 25. \u7a7a\u95f4\u590d\u6742\u5ea6O(1)\n        # 26. \u4e8c\u5206\u67e5\u627e\u7684\u6761\u4ef6\u662f\uff1a\n        # 27. \u5982\u679c\u4e2d\u95f4\u7684\u6570\u5c0f\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u53f3\u8fb9\n        # 28. \u5982\u679c\u4e2d\u95f4\u6570\u5927\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u5de6\u8fb9\n        # 29. \u5982\u679c\u4e2d\u95f4\u6570\u7b49\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u5728\u5de6\u8fb9\u6216\u53f3\u8fb9\n        # 30. \u65f6\u95f4\u590d\u6742\u5ea6O(logn)\n        # 31. \u7a7a\u95f4\u590d\u6742\u5ea6O(1)\n        # 32. \u4e8c\u5206\u67e5\u627e\u7684\u6761\u4ef6\u662f\uff1a\n        # 33. \u5982\u679c\u4e2d\u95f4\u7684\u6570\u5c0f\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u53f3\u8fb9\n        # 34. \u5982\u679c\u4e2d\u95f4\u6570\u5927\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u5de6\u8fb9\n        # 35. \u5982\u679c\u4e2d\u95f4\u6570\u7b49\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u5728\u5de6\u8fb9\u6216\u53f3\u8fb9\n        # 36. \u65f6\u95f4\u590d\u6742\u5ea6O(logn)\n        # 37. \u7a7a\u95f4\u590d\u6742\u5ea6O(1)\n        # 38. \u4e8c\u5206\u67e5\u627e\u7684\u6761\u4ef6\u662f\uff1a\n        # 39. \u5982\u679c\u4e2d\u95f4\u7684\u6570\u5c0f\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u53f3\u8fb9\n        # 40. \u5982\u679c\u4e2d\u95f4\u6570\u5927\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u5de6\u8fb9\n        # 41. \u5982\u679c\u4e2d\u95f4\u6570\u7b49\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u5728\u5de6\u8fb9\u6216\u53f3\u8fb9\n        # 42. \u65f6\u95f4\u590d\u6742\u5ea6O(logn)\n        # 43. \u7a7a\u95f4\u590d\u6742\u5ea6O(1)\n        # 44. \u4e8c\u5206\u67e5\u627e\u7684\u6761\u4ef6\u662f\uff1a\n        # 45. \u5982\u679c\u4e2d\u95f4\u7684\u6570\u5c0f\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u53f3\u8fb9\n        # 46. \u5982\u679c\u4e2d\u95f4\u6570\u5927\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u5de6\u8fb9\n        # 47. \u5982\u679c\u4e2d\u95f4\u6570\u7b49\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u5728\u5de6\u8fb9\u6216\u53f3\u8fb9\n        # 48. \u65f6\u95f4\u590d\u6742\u5ea6O(logn)\n        # 49. \u7a7a\u95f4\u590d\u6742\u5ea6O(1)\n        # 50. \u4e8c\u5206\u67e5\u627e\u7684\u6761\u4ef6\u662f\uff1a\n        # 5"}, {"task_id": "find-minimum-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u4e8c\u5206\u67e5\u627e\n        # 2. \u4e8c\u5206\u67e5\u627e\u7684\u601d\u8def\u662f\uff0c\u5982\u679c\u4e2d\u95f4\u7684\u6570\u5c0f\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u6570\u4e00\u5b9a\u5728\u5de6\u534a\u90e8\u5206\u6570\u7ec4\u4e2d\uff0c\u5982\u679c\u4e2d\u95f4\u7684\u6570\u5927\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u6570\u4e00\u5b9a\u5728\u53f3\u534a\u90e8\u5206\u6570\u7ec4\u4e2d\uff0c\u5982\u679c\u4e2d\u95f4\u7684\u6570\u7b49\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u6570\u5728\u5de6\u534a\u90e8\u5206\u6570\u7ec4\u4e2d\u6216\u8005\u53f3\u534a\u90e8\u5206\u6570\u7ec4\u4e2d\u3002\n        # 3. \u4e8c\u5206\u67e5\u627e\u7684\u601d\u8def\u662f\uff0c\u5982\u679c\u4e2d\u95f4\u7684\u6570\u5c0f\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u6570\u4e00\u5b9a\u5728\u5de6\u534a\u90e8\u5206\u6570\u7ec4\u4e2d\uff0c\u5982\u679c\u4e2d\u95f4\u7684\u6570\u5927\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u6570\u4e00\u5b9a\u5728\u53f3\u534a\u90e8\u5206\u6570\u7ec4\u4e2d\uff0c\u5982\u679c\u4e2d\u95f4\u7684\u6570\u7b49\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u6570\u5728\u5de6\u534a\u90e8\u5206\u6570\u7ec4\u4e2d\u6216\u8005\u53f3\u534a\u90e8\u5206\u6570\u7ec4\u4e2d\u3002\n        # 4. \u4e8c\u5206\u67e5\u627e\u7684\u601d\u8def\u662f\uff0c\u5982\u679c\u4e2d\u95f4\u7684\u6570\u5c0f\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u6570\u4e00\u5b9a\u5728\u5de6\u534a\u90e8\u5206\u6570\u7ec4\u4e2d\uff0c\u5982\u679c\u4e2d\u95f4\u7684\u6570\u5927\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u6570\u4e00\u5b9a\u5728\u53f3\u534a\u90e8\u5206\u6570\u7ec4\u4e2d\uff0c\u5982\u679c\u4e2d\u95f4\u7684\u6570\u7b49\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u6570\u5728\u5de6\u534a\u90e8\u5206\u6570\u7ec4\u4e2d\u6216\u8005\u53f3\u534a\u90e8\u5206\u6570\u7ec4\u4e2d\u3002\n        # 5. \u4e8c\u5206\u67e5\u627e\u7684\u601d\u8def\u662f\uff0c\u5982\u679c\u4e2d\u95f4\u7684\u6570\u5c0f\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u6570\u4e00\u5b9a\u5728\u5de6\u534a\u90e8\u5206\u6570\u7ec4\u4e2d\uff0c\u5982\u679c\u4e2d\u95f4\u7684\u6570\u5927\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u6570\u4e00\u5b9a\u5728\u53f3\u534a\u90e8\u5206\u6570\u7ec4\u4e2d\uff0c\u5982\u679c\u4e2d\u95f4\u7684\u6570\u7b49\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u6570\u5728\u5de6\u534a\u90e8\u5206\u6570\u7ec4\u4e2d\u6216\u8005\u53f3\u534a\u90e8\u5206\u6570\u7ec4\u4e2d\u3002\n        # 6. \u4e8c\u5206\u67e5\u627e\u7684\u601d\u8def\u662f\uff0c\u5982\u679c\u4e2d\u95f4\u7684\u6570\u5c0f\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u6570\u4e00\u5b9a\u5728\u5de6\u534a\u90e8\u5206\u6570\u7ec4\u4e2d\uff0c\u5982\u679c\u4e2d\u95f4\u7684\u6570\u5927\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u6570\u4e00\u5b9a\u5728\u53f3\u534a\u90e8\u5206\u6570\u7ec4\u4e2d\uff0c\u5982\u679c\u4e2d\u95f4\u7684\u6570\u7b49\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u6570\u5728\u5de6\u534a\u90e8\u5206\u6570\u7ec4\u4e2d\u6216\u8005\u53f3\u534a\u90e8\u5206\u6570\u7ec4\u4e2d\u3002\n        # 7. \u4e8c\u5206\u67e5\u627e\u7684\u601d\u8def\u662f\uff0c\u5982\u679c\u4e2d\u95f4\u7684\u6570\u5c0f\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u6570\u4e00\u5b9a\u5728\u5de6\u534a\u90e8\u5206\u6570\u7ec4\u4e2d\uff0c\u5982\u679c\u4e2d\u95f4\u7684\u6570\u5927\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u6570\u4e00\u5b9a\u5728\u53f3\u534a\u90e8\u5206\u6570\u7ec4\u4e2d\uff0c\u5982\u679c\u4e2d\u95f4\u7684\u6570\u7b49\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u6570\u5728\u5de6\u534a\u90e8\u5206\u6570\u7ec4\u4e2d\u6216\u8005\u53f3\u534a\u90e8\u5206\u6570\u7ec4\u4e2d\u3002\n        # 8. \u4e8c\u5206\u67e5\u627e\u7684\u601d\u8def\u662f\uff0c\u5982\u679c\u4e2d\u95f4\u7684\u6570\u5c0f\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u6570\u4e00\u5b9a\u5728\u5de6\u534a\u90e8\u5206\u6570\u7ec4\u4e2d\uff0c\u5982\u679c\u4e2d\u95f4\u7684\u6570\u5927\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u6570\u4e00\u5b9a\u5728\u53f3\u534a\u90e8\u5206\u6570\u7ec4\u4e2d\uff0c\u5982\u679c\u4e2d\u95f4\u7684\u6570\u7b49\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u6570\u5728\u5de6\u534a\u90e8\u5206\u6570\u7ec4\u4e2d\u6216\u8005\u53f3\u534a\u90e8\u5206\u6570\u7ec4\u4e2d\u3002\n        # 9. \u4e8c\u5206\u67e5\u627e\u7684\u601d\u8def\u662f\uff0c\u5982\u679c\u4e2d\u95f4\u7684\u6570\u5c0f\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u6570\u4e00\u5b9a\u5728\u5de6\u534a\u90e8\u5206\u6570\u7ec4\u4e2d\uff0c\u5982\u679c\u4e2d\u95f4\u7684\u6570\u5927\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u6570\u4e00\u5b9a\u5728\u53f3\u534a\u90e8\u5206\u6570\u7ec4\u4e2d\uff0c\u5982\u679c\u4e2d\u95f4\u7684\u6570\u7b49\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u6570\u5728\u5de6\u534a\u90e8\u5206\u6570\u7ec4\u4e2d\u6216\u8005\u53f3\u534a\u90e8\u5206\u6570\u7ec4\u4e2d\u3002\n        # 10. \u4e8c\u5206\u67e5\u627e\u7684\u601d\u8def\u662f\uff0c\u5982\u679c\u4e2d\u95f4\u7684\u6570\u5c0f\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u6570\u4e00\u5b9a\u5728\u5de6\u534a\u90e8\u5206\u6570\u7ec4\u4e2d\uff0c\u5982\u679c\u4e2d\u95f4\u7684\u6570\u5927\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u6570\u4e00\u5b9a\u5728\u53f3\u534a\u90e8\u5206\u6570\u7ec4\u4e2d\uff0c\u5982\u679c\u4e2d\u95f4\u7684\u6570\u7b49\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u6570\u5728\u5de6\u534a\u90e8\u5206\u6570\u7ec4\u4e2d\u6216\u8005\u53f3\u534a\u90e8\u5206\u6570\u7ec4\u4e2d\u3002\n        # 11. \u4e8c\u5206\u67e5\u627e\u7684\u601d\u8def\u662f\uff0c\u5982\u679c\u4e2d\u95f4\u7684\u6570\u5c0f\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u6570\u4e00\u5b9a\u5728\u5de6\u534a\u90e8\u5206\u6570\u7ec4\u4e2d\uff0c\u5982\u679c\u4e2d\u95f4\u7684\u6570\u5927\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u6570\u4e00\u5b9a\u5728\u53f3\u534a\u90e8\u5206\u6570\u7ec4\u4e2d\uff0c\u5982\u679c\u4e2d\u95f4\u7684\u6570\u7b49\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u6570\u5728\u5de6\u534a\u90e8\u5206\u6570\u7ec4\u4e2d\u6216\u8005\u53f3\u534a\u90e8\u5206\u6570\u7ec4\u4e2d\u3002\n        # 12. \u4e8c\u5206\u67e5\u627e\u7684\u601d\u8def\u662f\uff0c\u5982\u679c\u4e2d\u95f4\u7684\u6570\u5c0f\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u6570\u4e00\u5b9a\u5728\u5de6\u534a\u90e8\u5206\u6570\u7ec4\u4e2d\uff0c\u5982\u679c\u4e2d\u95f4\u7684\u6570\u5927\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u6570\u4e00\u5b9a\u5728\u53f3\u534a\u90e8\u5206\u6570\u7ec4\u4e2d\uff0c\u5982\u679c\u4e2d\u95f4\u7684\u6570\u7b49\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u6570\u5728\u5de6\u534a"}, {"task_id": "find-minimum-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u4e8c\u5206\u67e5\u627e\n        # 2. \u4e8c\u5206\u67e5\u627e\u7684\u601d\u8def\u662f\uff1a\n        # 3. \u5982\u679c\u4e2d\u95f4\u7684\u6570\u5927\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u53f3\u8fb9\n        # 4. \u5982\u679c\u4e2d\u95f4\u6570\u5c0f\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u5de6\u8fb9\n        # 5. \u5982\u679c\u4e2d\u95f4\u6570\u7b49\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u5728\u5de6\u8fb9\u6216\u8005\u53f3\u8fb9\n        # 6. \u65f6\u95f4\u590d\u6742\u5ea6O(logn)\n        # 7. \u7a7a\u95f4\u590d\u6742\u5ea6O(1)\n        # 8. \u4e8c\u5206\u67e5\u627e\u7684\u601d\u8def\u662f\uff1a\n        # 9. \u5982\u679c\u4e2d\u95f4\u7684\u6570\u5927\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u53f3\u8fb9\n        # 10. \u5982\u679c\u4e2d\u95f4\u6570\u5c0f\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u5de6\u8fb9\n        # 11. \u5982\u679c\u4e2d\u95f4\u6570\u7b49\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u5728\u5de6\u8fb9\u6216\u8005\u53f3\u8fb9\n        # 12. \u65f6\u95f4\u590d\u6742\u5ea6O(logn)\n        # 13. \u7a7a\u95f4\u590d\u6742\u5ea6O(1)\n        # 14. \u4e8c\u5206\u67e5\u627e\u7684\u601d\u8def\u662f\uff1a\n        # 15. \u5982\u679c\u4e2d\u95f4\u7684\u6570\u5927\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u53f3\u8fb9\n        # 16. \u5982\u679c\u4e2d\u95f4\u6570\u5c0f\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u5de6\u8fb9\n        # 17. \u5982\u679c\u4e2d\u95f4\u6570\u7b49\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u5728\u5de6\u8fb9\u6216\u8005\u53f3\u8fb9\n        # 18. \u65f6\u95f4\u590d\u6742\u5ea6O(logn)\n        # 19. \u7a7a\u95f4\u590d\u6742\u5ea6O(1)\n        # 20. \u4e8c\u5206\u67e5\u627e\u7684\u601d\u8def\u662f\uff1a\n        # 21. \u5982\u679c\u4e2d\u95f4\u7684\u6570\u5927\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u53f3\u8fb9\n        # 22. \u5982\u679c\u4e2d\u95f4\u6570\u5c0f\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u5de6\u8fb9\n        # 23. \u5982\u679c\u4e2d\u95f4\u6570\u7b49\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u5728\u5de6\u8fb9\u6216\u8005\u53f3\u8fb9\n        # 24. \u65f6\u95f4\u590d\u6742\u5ea6O(logn)\n        # 25. \u7a7a\u95f4\u590d\u6742\u5ea6O(1)\n        # 26. \u4e8c\u5206\u67e5\u627e\u7684\u601d\u8def\u662f\uff1a\n        # 27. \u5982\u679c\u4e2d\u95f4\u7684\u6570\u5927\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u53f3\u8fb9\n        # 28. \u5982\u679c\u4e2d\u95f4\u6570\u5c0f\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u5de6\u8fb9\n        # 29. \u5982\u679c\u4e2d\u95f4\u6570\u7b49\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u5728\u5de6\u8fb9\u6216\u8005\u53f3\u8fb9\n        # 30. \u65f6\u95f4\u590d\u6742\u5ea6O(logn)\n        # 31. \u7a7a\u95f4\u590d\u6742\u5ea6O(1)\n        # 32. \u4e8c\u5206\u67e5\u627e\u7684\u601d\u8def\u662f\uff1a\n        # 33. \u5982\u679c\u4e2d\u95f4\u7684\u6570\u5927\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u53f3\u8fb9\n        # 34. \u5982\u679c\u4e2d\u95f4\u6570\u5c0f\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u5de6\u8fb9\n        # 35. \u5982\u679c\u4e2d\u95f4\u6570\u7b49\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u5728\u5de6\u8fb9\u6216\u8005\u53f3\u8fb9\n        # 36. \u65f6\u95f4\u590d\u6742\u5ea6O(logn)\n        # 37. \u7a7a\u95f4\u590d\u6742\u5ea6O(1)\n        # 38. \u4e8c\u5206\u67e5\u627e\u7684\u601d\u8def\u662f\uff1a\n        # 39. \u5982\u679c\u4e2d\u95f4\u7684\u6570\u5927\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u53f3\u8fb9\n        # 40. \u5982\u679c\u4e2d\u95f4\u6570\u5c0f\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u5de6\u8fb9\n        # 41. \u5982\u679c\u4e2d\u95f4\u6570\u7b49\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u5728\u5de6\u8fb9\u6216\u8005\u53f3\u8fb9\n        # 42. \u65f6\u95f4\u590d\u6742\u5ea6O(logn)\n        # 43. \u7a7a\u95f4\u590d\u6742\u5ea6O(1)\n        # 44. \u4e8c\u5206\u67e5\u627e\u7684\u601d\u8def\u662f\uff1a\n        # 45. \u5982\u679c\u4e2d\u95f4\u7684\u6570\u5927\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u53f3\u8fb9\n        # 46. \u5982\u679c\u4e2d\u95f4\u6570\u5c0f\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u5de6\u8fb9\n        # 47. \u5982\u679c\u4e2d\u95f4\u6570\u7b49\u4e8e\u6700\u53f3\u8fb9\u7684\u6570\uff0c\u5219\u6700\u5c0f\u503c\u5728\u5de6\u8fb9\u6216\u8005\u53f3\u8fb9\n        # 48. \u65f6\u95f4\u590d\u6742\u5ea6O(logn)\n        # 49. \u7a7a\u95f4\u590d\u6742\u5ea6O(1)\n        # 50. \u4e8c\u5206\u67e5\u627e\u7684\u601d\u8def\u662f\uff1a\n        # 5"}, {"task_id": "find-minimum-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u4e8c\u5206\u67e5\u627e\n        # 2. \u4e8c\u5206\u67e5\u627e\u7684\u6761\u4ef6\u662f\uff1a\n        # 3. \u5982\u679c\u4e2d\u95f4\u5143\u7d20\u5927\u4e8e\u6700\u53f3\u5143\u7d20\uff0c\u5219\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u5426\u5219\u5728\u5de6\u8fb9\n        # 4. \u5982\u679c\u4e2d\u95f4\u5143\u7d20\u7b49\u4e8e\u6700\u53f3\u5143\u7d20\uff0c\u5219\u6700\u5c0f\u503c\u5728\u5de6\u8fb9\u6216\u8005\u53f3\u8fb9\uff0c\u6b64\u65f6\uff0c\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a\u5728\u53f3\u8fb9\uff0c\u6240\u4ee5\u6700\u5c0f\u503c\u4e00\u5b9a"}, {"task_id": "find-minimum-in-rotated-sorted-array-ii", "completion": "class Solution(object):\n    def findMin(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \u4e8c\u5206\u67e5\u627e\n        # 2. \u4e8c\u5206\u67e5\u627e\u7684\u7ec8\u6b62\u6761\u4ef6\u662f left == right\n        # 3. \u5f53 nums[mid] == nums[right] \u65f6\uff0c\u65e0\u6cd5\u5224\u65ad\u6700\u5c0f\u503c\u5728 mid \u7684\u5de6\u4fa7\u8fd8\u662f\u53f3\u4fa7\uff0c\n        #    \u4f46\u53ef\u4ee5\u77e5\u9053\u7684\u662f\uff0cmid \u4e00\u5b9a\u4e0d\u662f\u6700\u5c0f\u503c\uff0c\u56e0\u6b64\u53ef\u4ee5\u5c06 right \u5de6\u79fb\u4e00\u4f4d\n        # 4. \u5f53 nums[mid] > nums[right] \u65f6\uff0c\u6700\u5c0f\u503c\u4e00\u5b9a\u5728 mid \u7684\u53f3\u4fa7\uff0c\u56e0\u6b64\u53ef\u4ee5\u5c06 left \u53f3\u79fb\u4e00\u4f4d\n        # 5. \u5f53 nums[mid] < nums[right] \u65f6\uff0c\u6700\u5c0f\u503c\u4e00\u5b9a\u5728 mid \u7684\u5de6\u4fa7\uff0c\u56e0\u6b64\u53ef\u4ee5\u5c06 right \u5de6\u79fb\u4e00\u4f4d\n        # 6. \u5f53 nums[mid] == nums[right] \u65f6\uff0c\u65e0\u6cd5\u5224\u65ad\u6700\u5c0f\u503c\u5728 mid \u7684\u5de6\u4fa7\u8fd8\u662f\u53f3\u4fa7\uff0c\n        #    \u4f46\u53ef\u4ee5\u77e5\u9053\u7684\u662f\uff0cmid \u4e00\u5b9a\u4e0d\u662f\u6700\u5c0f\u503c\uff0c\u56e0\u6b64\u53ef\u4ee5\u5c06 right \u5de6\u79fb\u4e00\u4f4d\n        # 7. \u5f53 nums[mid] > nums[right] \u65f6\uff0c\u6700\u5c0f\u503c\u4e00\u5b9a\u5728 mid \u7684\u53f3\u4fa7\uff0c\u56e0\u6b64\u53ef\u4ee5\u5c06 left \u53f3\u79fb\u4e00\u4f4d\n        # 8. \u5f53 nums[mid] < nums[right] \u65f6\uff0c\u6700\u5c0f\u503c\u4e00\u5b9a\u5728 mid \u7684\u5de6\u4fa7\uff0c\u56e0\u6b64\u53ef\u4ee5\u5c06 right \u5de6\u79fb\u4e00\u4f4d\n        # 9. \u5f53 nums[mid] == nums[right] \u65f6\uff0c\u65e0\u6cd5\u5224\u65ad\u6700\u5c0f\u503c\u5728 mid \u7684\u5de6\u4fa7\u8fd8\u662f\u53f3\u4fa7\uff0c\n        #    \u4f46\u53ef\u4ee5\u77e5\u9053\u7684\u662f\uff0cmid \u4e00\u5b9a\u4e0d\u662f\u6700\u5c0f\u503c\uff0c\u56e0\u6b64\u53ef\u4ee5\u5c06 right \u5de6\u79fb\u4e00\u4f4d\n        # 10. \u5f53 nums[mid] > nums[right] \u65f6\uff0c\u6700\u5c0f\u503c\u4e00\u5b9a\u5728 mid \u7684\u53f3\u4fa7\uff0c\u56e0\u6b64\u53ef\u4ee5\u5c06 left \u53f3\u79fb\u4e00\u4f4d\n        # 11. \u5f53 nums[mid] < nums[right] \u65f6\uff0c\u6700\u5c0f\u503c\u4e00\u5b9a\u5728 mid \u7684\u5de6\u4fa7\uff0c\u56e0\u6b64\u53ef\u4ee5\u5c06 right \u5de6\u79fb\u4e00\u4f4d\n        # 12. \u5f53 nums[mid] == nums[right] \u65f6\uff0c\u65e0\u6cd5\u5224\u65ad\u6700\u5c0f\u503c\u5728 mid \u7684\u5de6\u4fa7\u8fd8\u662f\u53f3\u4fa7\uff0c\n        #    \u4f46\u53ef\u4ee5\u77e5\u9053\u7684\u662f\uff0cmid \u4e00\u5b9a\u4e0d\u662f\u6700\u5c0f\u503c\uff0c\u56e0\u6b64\u53ef\u4ee5\u5c06 right \u5de6\u79fb\u4e00\u4f4d\n        # 13. \u5f53 nums[mid] > nums[right] \u65f6\uff0c\u6700\u5c0f\u503c\u4e00\u5b9a\u5728 mid \u7684\u53f3\u4fa7\uff0c\u56e0\u6b64\u53ef\u4ee5\u5c06 left \u53f3\u79fb\u4e00\u4f4d\n        # 14. \u5f53 nums[mid] < nums[right] \u65f6\uff0c\u6700\u5c0f\u503c\u4e00\u5b9a\u5728 mid \u7684\u5de6\u4fa7\uff0c\u56e0\u6b64\u53ef\u4ee5\u5c06 right \u5de6\u79fb\u4e00\u4f4d\n        # 15. \u5f53 nums[mid] == nums[right] \u65f6\uff0c\u65e0\u6cd5\u5224\u65ad\u6700\u5c0f\u503c\u5728 mid \u7684\u5de6\u4fa7\u8fd8\u662f\u53f3\u4fa7\uff0c\n        #    \u4f46\u53ef\u4ee5\u77e5\u9053\u7684\u662f\uff0cmid \u4e00\u5b9a\u4e0d\u662f\u6700\u5c0f\u503c\uff0c\u56e0\u6b64\u53ef\u4ee5\u5c06 right \u5de6\u79fb\u4e00\u4f4d\n        # 16. \u5f53 nums[mid] > nums[right] \u65f6\uff0c\u6700\u5c0f\u503c\u4e00\u5b9a\u5728 mid \u7684\u53f3\u4fa7\uff0c\u56e0\u6b64\u53ef\u4ee5\u5c06 left \u53f3\u79fb\u4e00\u4f4d\n        # 17. \u5f53 nums[mid] < nums[right] \u65f6\uff0c\u6700\u5c0f\u503c\u4e00\u5b9a\u5728 mid \u7684\u5de6\u4fa7\uff0c\u56e0\u6b64\u53ef\u4ee5\u5c06 right \u5de6\u79fb\u4e00\u4f4d\n        # 18. \u5f53 nums[mid] == nums[right] \u65f6\uff0c\u65e0\u6cd5\u5224\u65ad\u6700\u5c0f\u503c\u5728 mid \u7684\u5de6\u4fa7\u8fd8\u662f\u53f3\u4fa7\uff0c\n        #    \u4f46\u53ef\u4ee5\u77e5\u9053\u7684\u662f\uff0cmid \u4e00\u5b9a\u4e0d\u662f\u6700\u5c0f\u503c\uff0c\u56e0\u6b64\u53ef\u4ee5\u5c06 right \u5de6\u79fb\u4e00\u4f4d\n        # 19. \u5f53 nums[mid] > nums[right] \u65f6\uff0c\u6700\u5c0f\u503c\u4e00\u5b9a\u5728 mid \u7684\u53f3\u4fa7\uff0c\u56e0\u6b64\u53ef\u4ee5\u5c06 left \u53f3\u79fb\u4e00\u4f4d\n        # 20. \u5f53 nums[mid] < nums[right] \u65f6\uff0c\u6700\u5c0f\u503c\u4e00\u5b9a\u5728 mid \u7684\u5de6\u4fa7\uff0c\u56e0\u6b64\u53ef\u4ee5\u5c06 right \u5de6\u79fb\u4e00\u4f4d\n        # 21. \u5f53 nums[mid] == nums[right] \u65f6\uff0c\u65e0\u6cd5\u5224\u65ad\u6700\u5c0f\u503c\u5728 mid \u7684\u5de6\u4fa7\u8fd8\u662f\u53f3\u4fa7\uff0c\n        #    \u4f46\u53ef\u4ee5\u77e5\u9053\u7684\u662f\uff0cmid \u4e00\u5b9a\u4e0d\u662f\u6700\u5c0f\u503c\uff0c\u56e0\u6b64\u53ef\u4ee5\u5c06 right \u5de6\u79fb\u4e00\u4f4d\n        # 22. \u5f53 nums[mid] > nums[right] \u65f6\uff0c\u6700\u5c0f\u503c\u4e00\u5b9a\u5728 mid \u7684\u53f3\u4fa7\uff0c\u56e0\u6b64\u53ef\u4ee5\u5c06 left \u53f3\u79fb\u4e00\u4f4d\n        # 23."}], "valid-number": [{"task_id": "valid-number", "completion": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \u53bb\u9664\u9996\u5c3e\u7a7a\u683c\n        s = s.strip()\n        \n        # 2. \u5982\u679c\u4e3a\u7a7a\uff0c\u8fd4\u56deFalse\n        if not s:\n            return False\n        \n        # 3. \u5982\u679c\u53ea\u6709\u4e00\u4e2a\u5b57\u7b26\uff0c\u5224\u65ad\u662f\u5426\u4e3a\u6570\u5b57\n        if len(s) == 1:\n            return s.isdigit()\n        \n        # 4. \u5982\u679c\u6709e\uff0c\u5224\u65ade\u524d\u540e\u662f\u5426\u4e3a\u6570\u5b57\n        if 'e' in s:\n            # 4.1 \u5982\u679ce\u540e\u9762\u6ca1\u6709\u6570\u5b57\uff0c\u8fd4\u56deFalse\n            if not s[s.index('e')+1:]:\n                return False\n            # 4.2 \u5982\u679ce\u524d\u9762\u6ca1\u6709\u6570\u5b57\uff0c\u8fd4\u56deFalse\n            if not s[:s.index('e')]:\n                return False\n            # 4.3 \u5982\u679ce\u524d\u9762\u4e0d\u662f\u6570\u5b57\uff0c\u8fd4\u56deFalse\n            if not s[:s.index('e')].isdigit():\n                return False\n            # 4.4 \u5982\u679ce\u540e\u9762\u4e0d\u662f\u6570\u5b57\uff0c\u8fd4\u56deFalse\n            if not s[s.index('e')+1:].isdigit():\n                return False\n            # 4.5 \u5982\u679ce\u524d\u9762\u6709\u591a\u4e2a\u70b9\uff0c\u8fd4\u56deFalse\n            if s[s.index('e')-1] == '.':\n                return False\n            # 4.6 \u5982\u679ce\u540e\u9762\u6709\u591a\u4e2a\u70b9\uff0c\u8fd4\u56deFalse\n            if s[s.index('e')+1] == '.':\n                return False\n            # 4.7 \u5982\u679ce\u524d\u9762\u6709\u591a\u4e2ae\uff0c\u8fd4\u56deFalse\n            if s[s.index('e')-1] == 'e':\n                return False\n            # 4.8 \u5982\u679ce\u540e\u9762\u6709\u591a\u4e2ae\uff0c\u8fd4\u56deFalse\n            if s[s.index('e')+1] == 'e':\n                return False\n            # 4.9 \u5982\u679ce\u524d\u9762\u6709\u591a\u4e2a\u7b26\u53f7\uff0c\u8fd4\u56deFalse\n            if s[s.index('e')-1] == '+' or s[s.index('e')-1] == '-':\n                return False\n            # 4.10 \u5982\u679ce\u540e\u9762\u6709\u591a\u4e2a\u7b26\u53f7\uff0c\u8fd4\u56deFalse\n            if s[s.index('e')+1] == '+' or s[s.index('e')+1] == '-':\n                return False\n            # 4.11 \u5982\u679ce\u524d\u9762\u6709\u591a\u4e2a\u7b26\u53f7\uff0c\u8fd4\u56deFalse\n            if s[s.index('e')-1] == '+' or s[s.index('e')-1] == '-':\n                return False\n            # 4.12 \u5982\u679ce\u540e\u9762\u6709\u591a\u4e2a\u7b26\u53f7\uff0c\u8fd4\u56deFalse\n            if s[s.index('e')+1] == '+' or s[s.index('e')+1] == '-':\n                return False\n            # 4.13 \u5982\u679ce\u524d\u9762\u6709\u591a\u4e2a\u7b26\u53f7\uff0c\u8fd4\u56deFalse\n            if s[s.index('e')-1] == '+' or s[s.index('e')-1] == '-':\n                return False\n            # 4.14 \u5982\u679ce\u540e\u9762\u6709\u591a\u4e2a\u7b26\u53f7\uff0c\u8fd4\u56deFalse\n            if s[s.index('e')+1] == '+' or s[s.index('e')+1] == '-':\n                return False\n            # 4.15 \u5982\u679ce\u524d\u9762\u6709\u591a\u4e2a\u7b26\u53f7\uff0c\u8fd4\u56deFalse\n            if s[s.index('e')-1] == '+' or s[s.index('e')-1] == '-':\n                return False\n            # 4.16 \u5982\u679ce\u540e\u9762\u6709\u591a\u4e2a\u7b26\u53f7\uff0c\u8fd4\u56deFalse\n            if s[s.index('e')+1] == '+' or s[s.index('e')+1] == '-':\n                return False\n            # 4.17 \u5982\u679ce\u524d\u9762\u6709\u591a\u4e2a\u7b26\u53f7\uff0c\u8fd4\u56deFalse\n            if s[s.index('e')-1] == '+' or s[s.index('e')-1] == '-':\n                return False\n            # 4.18 \u5982\u679ce\u540e\u9762\u6709\u591a\u4e2a\u7b26\u53f7\uff0c\u8fd4\u56deFalse\n            if s[s.index('e')+1] == '+' or s[s.index('e')+1] == '-':\n                return False\n            # 4.19 \u5982\u679ce\u524d\u9762\u6709\u591a\u4e2a\u7b26\u53f7\uff0c\u8fd4\u56deFalse\n            if s[s.index('e')-1] == '+' or s[s.index('e')-"}, {"task_id": "valid-number", "completion": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \u53bb\u6389\u9996\u5c3e\u7a7a\u683c\n        s = s.strip()\n        \n        # 2. \u5982\u679c\u4e3a\u7a7a\uff0c\u8fd4\u56deFalse\n        if not s:\n            return False\n        \n        # 3. \u5982\u679c\u53ea\u6709\u4e00\u4e2a\u5b57\u7b26\uff0c\u5224\u65ad\u662f\u5426\u4e3a\u6570\u5b57\n        if len(s) == 1:\n            return s.isdigit()\n        \n        # 4. \u5982\u679c\u6709e\uff0c\u5224\u65ade\u524d\u540e\u662f\u5426\u4e3a\u6570\u5b57\n        if 'e' in s:\n            # 4.1 \u5982\u679ce\u540e\u9762\u6ca1\u6709\u6570\u5b57\uff0c\u8fd4\u56deFalse\n            if not s[s.index('e')+1:]:\n                return False\n            # 4.2 \u5982\u679ce\u524d\u9762\u6ca1\u6709\u6570\u5b57\uff0c\u8fd4\u56deFalse\n            if not s[:s.index('e')]:\n                return False\n            # 4.3 \u5982\u679ce\u524d\u9762\u4e0d\u662f\u6570\u5b57\uff0c\u8fd4\u56deFalse\n            if not s[:s.index('e')].isdigit():\n                return False\n            # 4.4 \u5982\u679ce\u540e\u9762\u4e0d\u662f\u6570\u5b57\uff0c\u8fd4\u56deFalse\n            if not s[s.index('e')+1:].isdigit():\n                return False\n            # 4.5 \u5982\u679ce\u524d\u9762\u6709\u591a\u4e2a\u70b9\uff0c\u8fd4\u56deFalse\n            if s[s.index('e')-1] == '.':\n                return False\n            # 4.6 \u5982\u679ce\u540e\u9762\u6709\u591a\u4e2a\u70b9\uff0c\u8fd4\u56deFalse\n            if s[s.index('e')+1] == '.':\n                return False\n            # 4.7 \u5982\u679ce\u540e\u9762\u6709\u591a\u4e2ae\uff0c\u8fd4\u56deFalse\n            if s[s.index('e')+1:].count('e') > 0:\n                return False\n            # 4.8 \u5982\u679ce\u540e\u9762\u6709\u591a\u4e2a+\uff0c\u8fd4\u56deFalse\n            if s[s.index('e')+1:].count('+') > 0:\n                return False\n            # 4.9 \u5982\u679ce\u540e\u9762\u6709\u591a\u4e2a-\uff0c\u8fd4\u56deFalse\n            if s[s.index('e')+1:].count('-') > 0:\n                return False\n            # 4.10 \u5982\u679ce\u540e\u9762\u6709\u591a\u4e2a.\uff0c\u8fd4\u56deFalse\n            if s[s.index('e')+1:].count('.') > 0:\n                return False\n            # 4.11 \u5982\u679ce\u540e\u9762\u6709\u591a\u4e2a\u5b57\u6bcd\uff0c\u8fd4\u56deFalse\n            if s[s.index('e')+1:].isalpha():\n                return False\n            # 4.12 \u5982\u679ce\u540e\u9762\u6709\u591a\u4e2a\u7a7a\u683c\uff0c\u8fd4\u56deFalse\n            if s[s.index('e')+1:].isspace():\n                return False\n            # 4.13 \u5982\u679ce\u540e\u9762\u6709\u591a\u4e2a\u5176\u4ed6\u5b57\u7b26\uff0c\u8fd4\u56deFalse\n            if s[s.index('e')+1:].isalnum():\n                return False\n            # 4.14 \u5982\u679ce\u540e\u9762\u6709\u591a\u4e2a\u5176\u4ed6\u5b57\u7b26\uff0c\u8fd4\u56deFalse\n            if s[s.index('e')+1:].isalnum():\n                return False\n            # 4.15 \u5982\u679ce\u540e\u9762\u6709\u591a\u4e2a\u5176\u4ed6\u5b57\u7b26\uff0c\u8fd4\u56deFalse\n            if s[s.index('e')+1:].isalnum():\n                return False\n            # 4.16 \u5982\u679ce\u540e\u9762\u6709\u591a\u4e2a\u5176\u4ed6\u5b57\u7b26\uff0c\u8fd4\u56deFalse\n            if s[s.index('e')+1:].isalnum():\n                return False\n            # 4.17 \u5982\u679ce\u540e\u9762\u6709\u591a\u4e2a\u5176\u4ed6\u5b57\u7b26\uff0c\u8fd4\u56deFalse\n            if s[s.index('e')+1:].isalnum():\n                return False\n            # 4.18 \u5982\u679ce\u540e\u9762\u6709\u591a\u4e2a\u5176\u4ed6\u5b57\u7b26\uff0c\u8fd4\u56deFalse\n            if s[s.index('e')+1:].isalnum():\n                return False\n            # 4.19 \u5982\u679ce\u540e\u9762\u6709\u591a\u4e2a\u5176\u4ed6\u5b57\u7b26\uff0c\u8fd4\u56deFalse\n            if s[s.index('e')+1:].isalnum():\n                return False\n            # 4.20 \u5982\u679ce\u540e\u9762\u6709\u591a\u4e2a\u5176\u4ed6\u5b57\u7b26\uff0c\u8fd4\u56deFalse\n            if s[s.index('e')+1:].isalnum():\n                return False\n            # 4.21 \u5982\u679ce\u540e\u9762\u6709\u591a\u4e2a\u5176\u4ed6\u5b57\u7b26\uff0c\u8fd4\u56deFalse\n            if s[s.index('e')+1:].isalnum():\n                return False\n            # 4.22 \u5982\u679ce\u540e\u9762\u6709\u591a\u4e2a\u5176\u4ed6\u5b57\u7b26\uff0c\u8fd4\u56deFalse\n            if s[s."}, {"task_id": "valid-number", "completion": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \u53bb\u6389\u9996\u5c3e\u7a7a\u683c\n        s = s.strip()\n        \n        # 2. \u5982\u679c\u4e3a\u7a7a\uff0c\u8fd4\u56deFalse\n        if not s:\n            return False\n        \n        # 3. \u5982\u679c\u53ea\u6709\u4e00\u4e2a\u5b57\u7b26\uff0c\u5224\u65ad\u662f\u5426\u4e3a\u6570\u5b57\n        if len(s) == 1:\n            return s.isdigit()\n        \n        # 4. \u5982\u679c\u6709e\uff0c\u5224\u65ade\u524d\u540e\u662f\u5426\u4e3a\u6570\u5b57\n        if 'e' in s:\n            s1, s2 = s.split('e')\n            return self.isNumber(s1) and self.isNumber(s2)\n        \n        # 5. \u5982\u679c\u6709.\uff0c\u5224\u65ad.\u524d\u540e\u662f\u5426\u4e3a\u6570\u5b57\n        if '.' in s:\n            s1, s2 = s.split('.')\n            return self.isNumber(s1) and self.isNumber(s2)\n        \n        # 6. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad+\u6216-\u540e\u662f\u5426\u4e3a\u6570\u5b57\n        if s[0] in ['+', '-']:\n            return self.isNumber(s[1:])\n        \n        # 7. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad+\u6216-\u540e\u662f\u5426\u4e3a\u6570\u5b57\n        if s[-1] in ['+', '-']:\n            return self.isNumber(s[:-1])\n        \n        # 8. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad+\u6216-\u524d\u540e\u662f\u5426\u4e3a\u6570\u5b57\n        if s[0] in ['+', '-'] and s[-1] in ['+', '-']:\n            return self.isNumber(s[1:-1])\n        \n        # 9. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad+\u6216-\u524d\u540e\u662f\u5426\u4e3a\u6570\u5b57\n        if s[0] in ['+', '-'] and s[-1] in ['+', '-']:\n            return self.isNumber(s[1:-1])\n        \n        # 10. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad+\u6216-\u524d\u540e\u662f\u5426\u4e3a\u6570\u5b57\n        if s[0] in ['+', '-'] and s[-1] in ['+', '-']:\n            return self.isNumber(s[1:-1])\n        \n        # 11. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad+\u6216-\u524d\u540e\u662f\u5426\u4e3a\u6570\u5b57\n        if s[0] in ['+', '-'] and s[-1] in ['+', '-']:\n            return self.isNumber(s[1:-1])\n        \n        # 12. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad+\u6216-\u524d\u540e\u662f\u5426\u4e3a\u6570\u5b57\n        if s[0] in ['+', '-'] and s[-1] in ['+', '-']:\n            return self.isNumber(s[1:-1])\n        \n        # 13. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad+\u6216-\u524d\u540e\u662f\u5426\u4e3a\u6570\u5b57\n        if s[0] in ['+', '-'] and s[-1] in ['+', '-']:\n            return self.isNumber(s[1:-1])\n        \n        # 14. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad+\u6216-\u524d\u540e\u662f\u5426\u4e3a\u6570\u5b57\n        if s[0] in ['+', '-'] and s[-1] in ['+', '-']:\n            return self.isNumber(s[1:-1])\n        \n        # 15. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad+\u6216-\u524d\u540e\u662f\u5426\u4e3a\u6570\u5b57\n        if s[0] in ['+', '-'] and s[-1] in ['+', '-']:\n            return self.isNumber(s[1:-1])\n        \n        # 16. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad+\u6216-\u524d\u540e\u662f\u5426\u4e3a\u6570\u5b57\n        if s[0] in ['+', '-'] and s[-1] in ['+', '-']:\n            return self.isNumber(s[1:-1])\n        \n        # 17. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad+\u6216-\u524d\u540e\u662f\u5426\u4e3a\u6570\u5b57\n        if s[0] in ['+', '-'] and s[-1] in ['+', '-']:\n            return self.isNumber(s[1:-1])\n        \n        # 18. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad+\u6216-\u524d\u540e\u662f\u5426\u4e3a\u6570\u5b57\n        if s[0] in ['+', '-'] and s[-1] in ['+', '-']:\n            return self.isNumber(s[1:-1])\n        \n        # 19. \u5982\u679c\u6709+"}, {"task_id": "valid-number", "completion": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \u53bb\u6389\u9996\u5c3e\u7a7a\u683c\n        s = s.strip()\n        \n        # 2. \u5982\u679c\u4e3a\u7a7a\uff0c\u8fd4\u56deFalse\n        if not s:\n            return False\n        \n        # 3. \u5982\u679c\u53ea\u6709\u4e00\u4e2a\u5b57\u7b26\uff0c\u5224\u65ad\u662f\u5426\u4e3a\u6570\u5b57\n        if len(s) == 1:\n            return s.isdigit()\n        \n        # 4. \u5982\u679c\u6709e\uff0c\u5224\u65ade\u524d\u540e\u662f\u5426\u4e3a\u6570\u5b57\n        if 'e' in s:\n            s1, s2 = s.split('e')\n            return self.isNumber(s1) and self.isNumber(s2)\n        \n        # 5. \u5982\u679c\u6709.\uff0c\u5224\u65ad.\u524d\u540e\u662f\u5426\u4e3a\u6570\u5b57\n        if '.' in s:\n            s1, s2 = s.split('.')\n            return selfisNumber(s1) and selfisNumber(s2)\n        \n        # 6. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad+\u6216-\u540e\u662f\u5426\u4e3a\u6570\u5b57\n        if s[0] in ['+', '-']:\n            return self.isNumber(s[1:])\n        \n        # 7. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad+\u6216-\u524d\u662f\u5426\u4e3a\u6570\u5b57\n        if s[-1] in ['+', '-']:\n            return self.isNumber(s[:-1])\n        \n        # 8. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad+\u6216-\u524d\u540e\u662f\u5426\u4e3a\u6570\u5b57\n        if s[0] in ['+', '-'] and s[-1] in ['+', '-']:\n            return self.isNumber(s[1:-1])\n        \n        # 9. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad+\u6216-\u524d\u540e\u662f\u5426\u4e3a\u6570\u5b57\n        if s[0] in ['+', '-'] and s[-1] in ['+', '-']:\n            return self.isNumber(s[1:-1])\n        \n        # 10. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad+\u6216-\u524d\u540e\u662f\u5426\u4e3a\u6570\u5b57\n        if s[0] in ['+', '-'] and s[-1] in ['+', '-']:\n            return self.isNumber(s[1:-1])\n        \n        # 11. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad+\u6216-\u524d\u540e\u662f\u5426\u4e3a\u6570\u5b57\n        if s[0] in ['+', '-'] and s[-1] in ['+', '-']:\n            return self.isNumber(s[1:-1])\n        \n        # 12. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad+\u6216-\u524d\u540e\u662f\u5426\u4e3a\u6570\u5b57\n        if s[0] in ['+', '-'] and s[-1] in ['+', '-']:\n            return self.isNumber(s[1:-1])\n        \n        # 13. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad+\u6216-\u524d\u540e\u662f\u5426\u4e3a\u6570\u5b57\n        if s[0] in ['+', '-'] and s[-1] in ['+', '-']:\n            return self.isNumber(s[1:-1])\n        \n        # 14. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad+\u6216-\u524d\u540e\u662f\u5426\u4e3a\u6570\u5b57\n        if s[0] in ['+', '-'] and s[-1] in ['+', '-']:\n            return self.isNumber(s[1:-1])\n        \n        # 15. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad+\u6216-\u524d\u540e\u662f\u5426\u4e3a\u6570\u5b57\n        if s[0] in ['+', '-'] and s[-1] in ['+', '-']:\n            return self.isNumber(s[1:-1])\n        \n        # 16. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad+\u6216-\u524d\u540e\u662f\u5426\u4e3a\u6570\u5b57\n        if s[0] in ['+', '-'] and s[-1] in ['+', '-']:\n            return self.isNumber(s[1:-1])\n        \n        # 17. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad+\u6216-\u524d\u540e\u662f\u5426\u4e3a\u6570\u5b57\n        if s[0] in ['+', '-'] and s[-1] in ['+', '-']:\n            return self.isNumber(s[1:-1])\n        \n        # 18. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad+\u6216-\u524d\u540e\u662f\u5426\u4e3a\u6570\u5b57\n        if s[0] in ['+', '-'] and s[-1] in ['+', '-']:\n            return self.isNumber(s[1:-1])\n        \n        # 19. \u5982\u679c\u6709+\u6216"}, {"task_id": "valid-number", "completion": "class Solution(object):\n    def isNumber(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \u53bb\u6389\u9996\u5c3e\u7a7a\u683c\n        s = s.strip()\n        \n        # 2. \u5982\u679c\u4e3a\u7a7a\uff0c\u8fd4\u56deFalse\n        if len(s) == 0:\n            return False\n        \n        # 3. \u5982\u679c\u53ea\u6709\u4e00\u4e2a\u5b57\u7b26\uff0c\u5224\u65ad\u662f\u5426\u4e3a\u6570\u5b57\n        if len(s) == 1:\n            return s.isdigit()\n        \n        # 4. \u5982\u679c\u6709e\uff0c\u5224\u65ade\u524d\u540e\u662f\u5426\u4e3a\u6570\u5b57\n        if 'e' in s:\n            s1, s2 = s.split('e')\n            return self.isNumber(s1) and self.isNumber(s2)\n        \n        # 5. \u5982\u679c\u6709.\uff0c\u5224\u65ad.\u524d\u540e\u662f\u5426\u4e3a\u6570\u5b57\n        if '.' in s:\n            s1, s2 = s.split('.')\n            return self.isNumber(s1) and self.isNumber(s2)\n        \n        # 6. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad+\u6216-\u540e\u662f\u5426\u4e3a\u6570\u5b57\n        if '+' in s or '-' in s:\n            s1, s2 = s.split('+')\n            return self.isNumber(s1) and self.isNumber(s2)\n        \n        # 7. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad+\u6216-\u540e\u662f\u5426\u4e3a\u6570\u5b57\n        if '+' in s or '-' in s:\n            s1, s2 = s.split('-')\n            return self.isNumber(s1) and self.isNumber(s2)\n        \n        # 8. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad+\u6216-\u540e\u662f\u5426\u4e3a\u6570\u5b57\n        if '+' in s or '-' in s:\n            s1, s2 = s.split('+')\n            return self.isNumber(s1) and self.isNumber(s2)\n        \n        # 9. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad+\u6216-\u540e\u662f\u5426\u4e3a\u6570\u5b57\n        if '+' in s or '-' in s:\n            s1, s2 = s.split('-')\n            return self.isNumber(s1) and self.isNumber(s2)\n        \n        # 10. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad+\u6216-\u540e\u662f\u5426\u4e3a\u6570\u5b57\n        if '+' in s or '-' in s:\n            s1, s2 = s.split('+')\n            return self.isNumber(s1) and self.isNumber(s2)\n        \n        # 11. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad+\u6216-\u540e\u662f\u5426\u4e3a\u6570\u5b57\n        if '+' in s or '-' in s:\n            s1, s2 = s.split('-')\n            return self.isNumber(s1) and self.isNumber(s2)\n        \n        # 12. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad+\u6216-\u540e\u662f\u5426\u4e3a\u6570\u5b57\n        if '+' in s or '-' in s:\n            s1, s2 = s.split('+')\n            return self.isNumber(s1) and self.isNumber(s2)\n        \n        # 13. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad+\u6216-\u540e\u662f\u5426\u4e3a\u6570\u5b57\n        if '+' in s or '-' in s:\n            s1, s2 = s.split('-')\n            return self.isNumber(s1) and self.isNumber(s2)\n        \n        # 14. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad+\u6216-\u540e\u662f\u5426\u4e3a\u6570\u5b57\n        if '+' in s or '-' in s:\n            s1, s2 = s.split('+')\n            return self.isNumber(s1) and self.isNumber(s2)\n        \n        # 15. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad+\u6216-\u540e\u662f\u5426\u4e3a\u6570\u5b57\n        if '+' in s or '-' in s:\n            s1, s2 = s.split('-')\n            return self.isNumber(s1) and self.isNumber(s2)\n        \n        # 16. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad+\u6216-\u540e\u662f\u5426\u4e3a\u6570\u5b57\n        if '+' in s or '-' in s:\n            s1, s2 = s.split('+')\n            return self.isNumber(s1) and self.isNumber(s2)\n        \n        # 17. \u5982\u679c\u6709+\u6216-\uff0c\u5224\u65ad+\u6216-\u540e\u662f\u5426\u4e3a"}], "integer-to-roman": [{"task_id": "integer-to-roman", "completion": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        \n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        \n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        \n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        \n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        \n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        \n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        \n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        \n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        \n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        \n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        \n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1"}, {"task_id": "integer-to-roman", "completion": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X,"}, {"task_id": "integer-to-roman", "completion": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        \n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        \n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        \n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        \n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        \n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        \n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        \n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        \n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        \n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        \n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        \n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1"}, {"task_id": "integer-to-roman", "completion": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X, IX, V, IV, I\n        # 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # M, CM, D, CD, C, XC, L, XL, X,"}, {"task_id": "integer-to-roman", "completion": "class Solution(object):\n    def intToRoman(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        # 1. 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1\n        # 2. 1000 -> M, 900 -> CM, 500 -> D, 400 -> CD, 100 -> C, 90 -> XC, 50 -> L, 40 -> XL, 10 -> X, 9 -> IX, 5 -> V, 4 -> IV, 1 -> I\n        # 3. 1000 -> M, 900 -> CM, 500 -> D, 400 -> CD, 100 -> C, 90 -> XC, 50 -> L, 40 -> XL, 10 -> X, 9 -> IX, 5 -> V, 4 -> IV, 1 -> I\n        # 4. 1000 -> M, 900 -> CM, 500 -> D, 400 -> CD, 100 -> C, 90 -> XC, 50 -> L, 40 -> XL, 10 -> X, 9 -> IX, 5 -> V, 4 -> IV, 1 -> I\n        # 5. 1000 -> M, 900 -> CM, 500 -> D, 400 -> CD, 100 -> C, 90 -> XC, 50 -> L, 40 -> XL, 10 -> X, 9 -> IX, 5 -> V, 4 -> IV, 1 -> I\n        # 6. 1000 -> M, 900 -> CM, 500 -> D, 400 -> CD, 100 -> C, 90 -> XC, 50 -> L, 40 -> XL, 10 -> X, 9 -> IX, 5 -> V, 4 -> IV, 1 -> I\n        # 7. 1000 -> M, 900 -> CM, 500 -> D, 400 -> CD, 100 -> C, 90 -> XC, 50 -> L, 40 -> XL, 10 -> X, 9 -> IX, 5 -> V, 4 -> IV, 1 -> I\n        # 8. 1000 -> M, 900 -> CM, 500 -> D, 400 -> CD, 100 -> C, 90 -> XC, 50 -> L, 40 -> XL, 10 -> X, 9 -> IX, 5 -> V, 4 -> IV, 1 -> I\n        # 9. 1000 -> M, 900 -> CM, 500 -> D, 400 -> CD, 100 -> C, 90 -> XC, 50 -> L, 40 -> XL, 10 -> X, 9 -> IX, 5 -> V, 4 -> IV, 1 -> I\n        # 10. 1000 -> M, 900 -> CM, 500 -> D, 400 -> CD, 100 -> C, 90 -> XC, 50 -> L, 40 -> XL, 10 -> X, 9 -> IX, 5 -> V, 4 -> IV, 1 -> I\n        # 11. 1000 -> M, 900 -> CM, 500 -> D, 400 -> CD, 100 -> C, 90 -> XC, 50 -> L, 4"}], "find-the-difference": [{"task_id": "find-the-difference", "completion": "class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        ## 1. sort both strings and compare\n        ## 2. use hashmap to store the count of each character in s and t\n        ## 3. use XOR\n        \n        ## 1. sort both strings and compare\n        # s = sorted(s)\n        # t = sorted(t)\n        # for i in range(len(s)):\n        #     if s[i] != t[i]:\n        #         return t[i]\n        # return t[-1]\n        \n        ## 2. use hashmap to store the count of each character in s and t\n        # s_dict = {}\n        # t_dict = {}\n        # for i in s:\n        #     if i in s_dict:\n        #         s_dict[i] += 1\n        #     else:\n        #         s_dict[i] = 1\n        # for i in t:\n        #     if i in t_dict:\n        #         t_dict[i] += 1\n        #     else:\n        #         t_dict[i] = 1\n        # for i in t_dict:\n        #     if i not in s_dict or s_dict[i] != t_dict[i]:\n        #         return i\n        \n        ## 3. use XOR\n        ## XOR of two same numbers is 0\n        ## XOR of two different numbers is 1\n        ## XOR of two numbers is commutative\n        ## XOR of two numbers is associative\n        ## XOR of two numbers is distributive\n        ## XOR of two numbers is commutative\n        ## XOR of two numbers is associative\n        ## XOR of two numbers is distributive\n        ## XOR of two numbers is commutative\n        ## XOR of two numbers is associative\n        ## XOR of two numbers is distributive\n        ## XOR of two numbers is commutative\n        ## XOR of two numbers is associative\n        ## XOR of two numbers is distributive\n        ## XOR of two numbers is commutative\n        ## XOR of two numbers is associative\n        ## XOR of two numbers is distributive\n        ## XOR of two numbers is commutative\n        ## XOR of two numbers is associative\n        ## XOR of two numbers is distributive\n        ## XOR of two numbers is commutative\n        ## XOR of two numbers is associative\n        ## XOR of two numbers is distributive\n        ## XOR of two numbers is commutative\n        ## XOR of two numbers is associative\n        ## XOR of two numbers is distributive\n        ## XOR of two numbers is commutative\n        ## XOR of two numbers is associative\n        ## XOR of two numbers is distributive\n        ## XOR of two numbers is commutative\n        ## XOR of two numbers is associative\n        ## XOR of two numbers is distributive\n        ## XOR of two numbers is commutative\n        ## XOR of two numbers is associative\n        ## XOR of two numbers is distributive\n        ## XOR of two numbers is commutative\n        ## XOR of two numbers is associative\n        ## XOR of two numbers is distributive\n        ## XOR of two numbers is commutative\n        ## XOR of two numbers is associative\n        ## XOR of two numbers is distributive\n        ## XOR of two numbers is commutative\n        ## XOR of two numbers is associative\n        ## XOR of two numbers is distributive\n        ## XOR of two numbers is commutative\n        ## XOR of two numbers is associative\n        ## XOR of two numbers is distributive\n        ## XOR of two numbers is commutative\n        ## XOR of two numbers is associative\n        ## XOR of two numbers is distributive\n        ## XOR of two numbers is commutative\n        ## XOR of two numbers is associative\n        ## XOR of two numbers is distributive\n        ## XOR of two numbers is commutative\n        ## XOR of two numbers is associative\n        ## XOR of two numbers is distributive\n        ## XOR of two numbers is commutative\n        ## XOR of two numbers is associative\n        ## XOR of two numbers is distributive\n        ##"}, {"task_id": "find-the-difference", "completion": "class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. sort both strings\n        # 2. iterate through both strings and compare each character\n        # 3. if the characters are not equal, return the character from t\n        # 4. if the characters are equal, continue\n        # 5. if the characters are equal, return the last character from t\n        \n        s = sorted(s)\n        t = sorted(t)\n        \n        for i in range(len(s)):\n            if s[i] != t[i]:\n                return t[i]\n        return t[-1]"}, {"task_id": "find-the-difference", "completion": "class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        s_dict = {}\n        t_dict = {}\n        \n        for i in s:\n            if i in s_dict:\n                s_dict[i] += 1\n            else:\n                s_dict[i] = 1\n        \n        for i in t:\n            if i in t_dict:\n                t_dict[i] += 1\n            else:\n                t_dict[i] = 1\n        \n        for i in t_dict:\n            if i not in s_dict:\n                return i\n            elif t_dict[i] > s_dict[i]:\n                return i"}, {"task_id": "find-the-difference", "completion": "class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        s_dict = {}\n        t_dict = {}\n        \n        for i in s:\n            if i in s_dict:\n                s_dict[i] += 1\n            else:\n                s_dict[i] = 1\n        \n        for i in t:\n            if i in t_dict:\n                t_dict[i] += 1\n            else:\n                t_dict[i] = 1\n        \n        for i in t_dict:\n            if i not in s_dict:\n                return i\n            elif s_dict[i] != t_dict[i]:\n                return i"}, {"task_id": "find-the-difference", "completion": "class Solution(object):\n    def findTheDifference(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: str\n        \"\"\"\n        \n        ## 1.\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 20 ms, faster than 99.87% of Python online submissions for Find the Difference.\n        ## Memory Usage: 13.5 MB, less than 99.99% of Python online submissions for Find the Difference.\n        ## 2.\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 20 ms, faster than 99.87% of Python online submissions for Find the Difference.\n        ## Memory Usage: 13.5 MB, less than 99.99% of Python online submissions for Find the Difference.\n        ## 3.\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 20 ms, faster than 99.87% of Python online submissions for Find the Difference.\n        ## Memory Usage: 13.5 MB, less than 99.99% of Python online submissions for Find the Difference.\n        ## 4.\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 20 ms, faster than 99.87% of Python online submissions for Find the Difference.\n        ## Memory Usage: 13.5 MB, less than 99.99% of Python online submissions for Find the Difference.\n        ## 5.\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 20 ms, faster than 99.87% of Python online submissions for Find the Difference.\n        ## Memory Usage: 13.5 MB, less than 99.99% of Python online submissions for Find the Difference.\n        ## 6.\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 20 ms, faster than 99.87% of Python online submissions for Find the Difference.\n        ## Memory Usage: 13.5 MB, less than 99.99% of Python online submissions for Find the Difference.\n        ## 7.\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 20 ms, faster than 99.87% of Python online submissions for Find the Difference.\n        ## Memory Usage: 13.5 MB, less than 99.99% of Python online submissions for Find the Difference.\n        ## 8.\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 20 ms, faster than 99.87% of Python online submissions for Find the Difference.\n        ## Memory Usage: 13.5 MB, less than 99.99% of Python online submissions for Find the Difference.\n        ## 9.\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 20 ms, faster than 99.87% of Python online submissions for Find the Difference.\n        ## Memory Usage: 13.5 MB, less than 99.99% of Python online submissions for Find the Difference.\n        ## 10.\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)\n        ## Runtime: 20 ms, faster than 99.87% of Python online submissions for Find the Difference.\n        ## Memory Usage: 13.5 MB, less than 99.99% of Python online submissions for Find the Difference.\n        ## 11.\n        ## Time Complexity: O(n)\n        ## Space Complexity: O(1)"}], "sudoku-solver": [{"task_id": "sudoku-solver", "completion": "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def isValid(board, row, col, num):\n            for i in range(9):\n                if board[row][i] == num:\n                    return False\n                if board[i][col] == num:\n                    return False\n                if board[3 * (row // 3) + i // 3][3 * (col // 3) + i % 3] == num:\n                    return False\n            return True\n        \n        def solve(board):\n            for i in range(9):\n                for j in range(9):\n                    if board[i][j] == '.':\n                        for num in range(1, 10):\n                            if isValid(board, i, j, str(num)):\n                                board[i][j] = str(num)\n                                if solve(board):\n                                    return True\n                                else:\n                                    board[i][j] = '.'\n                        return False\n            return True\n        \n        solve(board)"}, {"task_id": "sudoku-solver", "completion": "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def isValid(board, row, col, num):\n            for i in range(9):\n                if board[row][i] == num:\n                    return False\n                if board[i][col] == num:\n                    return False\n                if board[3 * (row // 3) + i // 3][3 * (col // 3) + i % 3] == num:\n                    return False\n            return True\n        \n        def solve(board):\n            for i in range(9):\n                for j in range(9):\n                    if board[i][j] == '.':\n                        for num in range(1, 10):\n                            if isValid(board, i, j, str(num)):\n                                board[i][j] = str(num)\n                                if solve(board):\n                                    return True\n                                else:\n                                    board[i][j] = '.'\n                        return False\n            return True\n        \n        solve(board)"}, {"task_id": "sudoku-solver", "completion": "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def isValid(board, row, col, num):\n            for i in range(9):\n                if board[row][i] == num:\n                    return False\n                if board[i][col] == num:\n                    return False\n                if board[3 * (row // 3) + i // 3][3 * (col // 3) + i % 3] == num:\n                    return False\n            return True\n        \n        def solve(board):\n            for i in range(9):\n                for j in range(9):\n                    if board[i][j] == '.':\n                        for num in range(1, 10):\n                            if isValid(board, i, j, str(num)):\n                                board[i][j] = str(num)\n                                if solve(board):\n                                    return True\n                                else:\n                                    board[i][j] = '.'\n                        return False\n            return True\n        \n        solve(board)"}, {"task_id": "sudoku-solver", "completion": "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def isValid(board, row, col, num):\n            for i in range(9):\n                if board[row][i] == num:\n                    return False\n                if board[i][col] == num:\n                    return False\n                if board[3 * (row // 3) + i // 3][3 * (col // 3) + i % 3] == num:\n                    return False\n            return True\n        \n        def solve(board):\n            for i in range(9):\n                for j in range(9):\n                    if board[i][j] == '.':\n                        for num in range(1, 10):\n                            if isValid(board, i, j, str(num)):\n                                board[i][j] = str(num)\n                                if solve(board):\n                                    return True\n                                else:\n                                    board[i][j] = '.'\n                        return False\n            return True\n        \n        solve(board)"}, {"task_id": "sudoku-solver", "completion": "class Solution(object):\n    def solveSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: None Do not return anything, modify board in-place instead.\n        \"\"\"\n        \n        def isValid(board, row, col, num):\n            for i in range(9):\n                if board[row][i] == num:\n                    return False\n                if board[i][col] == num:\n                    return False\n                if board[3 * (row // 3) + i // 3][3 * (col // 3) + i % 3] == num:\n                    return False\n            return True\n        \n        def solve(board):\n            for i in range(9):\n                for j in range(9):\n                    if board[i][j] == '.':\n                        for num in range(1, 10):\n                            if isValid(board, i, j, str(num)):\n                                board[i][j] = str(num)\n                                if solve(board):\n                                    return True\n                                else:\n                                    board[i][j] = '.'\n                        return False\n            return True\n        \n        solve(board)"}], "recover-binary-search-tree": [{"task_id": "recover-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # 1. Inorder traversal of the tree and store the result in a list\n        # 2. Find the two elements that are out of order\n        # 3. Swap the values of the two elements\n        \n        # 1. Inorder traversal of the tree and store the result in a list\n        def inorder(root):\n            if root is None:\n                return\n            inorder(root.left)\n            self.nodes.append(root)\n            inorder(root.right)\n        \n        self.nodes = []\n        inorder(root)\n        \n        # 2. Find the two elements that are out of order\n        first = None\n        second = None\n        for i in range(len(self.nodes)-1):\n            if self.nodes[i].val > self.nodes[i+1].val:\n                first = self.nodes[i]\n                break\n        for i in range(len(self.nodes)-1, 0, -1):\n            if self.nodes[i].val < self.nodes[i-1].val:\n                second = self.nodes[i]\n                break\n        \n        # 3. Swap the values of the two elements\n        first.val, second.val = second.val, first.val"}, {"task_id": "recover-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # 1. Inorder traversal of the tree and store the result in a list.\n        # 2. Find the two elements in the list that are out of order.\n        # 3. Swap the values of the two elements.\n        \n        # 1. Inorder traversal of the tree and store the result in a list.\n        def inorder(root):\n            if root is None:\n                return\n            inorder(root.left)\n            self.inorder.append(root.val)\n            inorder(root.right)\n        \n        self.inorder = []\n        inorder(root)\n        \n        # 2. Find the two elements in the list that are out of order.\n        first = None\n        second = None\n        for i in range(len(self.inorder)-1):\n            if self.inorder[i] > self.inorder[i+1]:\n                first = self.inorder[i]\n                break\n        for i in range(len(self.inorder)-1, 0, -1):\n            if self.inorder[i] < self.inorder[i-1]:\n                second = self.inorder[i]\n                break\n        \n        # 3. Swap the values of the two elements.\n        def swap(root, first, second):\n            if root is None:\n                return\n            if root.val == first:\n                root.val = second\n            elif root.val == second:\n                root.val = first\n            swap(root.left, first, second)\n            swap(root.right, first, second)\n        \n        swap(root, first, second)\n        \n        return root"}, {"task_id": "recover-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # 1. Inorder traversal of the tree and store the result in a list.\n        # 2. Find the two elements in the list that are out of order.\n        # 3. Swap the values of the two elements.\n        \n        # 1. Inorder traversal of the tree and store the result in a list.\n        def inorder(root):\n            if root is None:\n                return\n            inorder(root.left)\n            self.inorder.append(root.val)\n            inorder(root.right)\n        \n        self.inorder = []\n        inorder(root)\n        \n        # 2. Find the two elements in the list that are out of order.\n        first = None\n        second = None\n        for i in range(len(self.inorder)-1):\n            if self.inorder[i] > self.inorder[i+1]:\n                first = self.inorder[i]\n                break\n        for i in range(len(self.inorder)-1, 0, -1):\n            if self.inorder[i] < self.inorder[i-1]:\n                second = self.inorder[i]\n                break\n        \n        # 3. Swap the values of the two elements.\n        def swap(root, first, second):\n            if root is None:\n                return\n            if root.val == first:\n                root.val = second\n            elif root.val == second:\n                root.val = first\n            swap(root.left, first, second)\n            swap(root.right, first, second)\n        \n        swap(root, first, second)"}, {"task_id": "recover-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # 1. Inorder traversal of the tree and store the result in a list\n        # 2. Find the two elements that are out of order\n        # 3. Swap the values of the two elements\n        \n        # 1. Inorder traversal of the tree and store the result in a list\n        def inorder(root):\n            if root is None:\n                return\n            inorder(root.left)\n            self.nodes.append(root)\n            inorder(root.right)\n        \n        self.nodes = []\n        inorder(root)\n        \n        # 2. Find the two elements that are out of order\n        first = None\n        second = None\n        for i in range(len(self.nodes)-1):\n            if self.nodes[i].val > self.nodes[i+1].val:\n                first = self.nodes[i]\n                break\n        for i in range(len(self.nodes)-1, 0, -1):\n            if self.nodes[i].val < self.nodes[i-1].val:\n                second = self.nodes[i]\n                break\n        \n        # 3. Swap the values of the two elements\n        first.val, second.val = second.val, first.val"}, {"task_id": "recover-binary-search-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def recoverTree(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: None Do not return anything, modify root in-place instead.\n        \"\"\"\n        \n        # 1. Inorder traversal of the tree and store the result in a list.\n        # 2. Find the two elements in the list that are out of order.\n        # 3. Swap the values of the two elements.\n        \n        # 1. Inorder traversal of the tree and store the result in a list.\n        def inorder(root):\n            if root is None:\n                return\n            inorder(root.left)\n            self.inorder.append(root.val)\n            inorder(root.right)\n        \n        self.inorder = []\n        inorder(root)\n        \n        # 2. Find the two elements in the list that are out of order.\n        first = None\n        second = None\n        for i in range(len(self.inorder)-1):\n            if self.inorder[i] > self.inorder[i+1]:\n                first = self.inorder[i]\n                break\n        for i in range(len(self.inorder)-1, 0, -1):\n            if self.inorder[i] < self.inorder[i-1]:\n                second = self.inorder[i]\n                break\n        \n        # 3. Swap the values of the two elements.\n        def swap(root, first, second):\n            if root is None:\n                return\n            if root.val == first:\n                root.val = second\n            elif root.val == second:\n                root.val = first\n            swap(root.left, first, second)\n            swap(root.right, first, second)\n        \n        swap(root, first, second)\n        \n        return root"}], "palindrome-linked-list": [{"task_id": "palindrome-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        \n        # 1. find the middle of the linked list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # 2. reverse the second half of the linked list\n        prev = None\n        while slow:\n            temp = slow.next\n            slow.next = prev\n            prev = slow\n            slow = temp\n        \n        # 3. compare the first half and the reversed second half\n        while prev:\n            if prev.val != head.val:\n                return False\n            prev = prev.next\n            head = head.next\n        return True"}, {"task_id": "palindrome-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        \n        # 1. find the middle of the linked list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # 2. reverse the second half of the linked list\n        prev = None\n        while slow:\n            temp = slow.next\n            slow.next = prev\n            prev = slow\n            slow = temp\n        \n        # 3. compare the first half and the reversed second half\n        while prev:\n            if prev.val != head.val:\n                return False\n            prev = prev.next\n            head = head.next\n        return True"}, {"task_id": "palindrome-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        \n        # 1. find the middle of the linked list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # 2. reverse the second half of the linked list\n        prev = None\n        while slow:\n            temp = slow.next\n            slow.next = prev\n            prev = slow\n            slow = temp\n        \n        # 3. compare the first half and the reversed second half\n        while prev:\n            if prev.val != head.val:\n                return False\n            prev = prev.next\n            head = head.next\n        return True"}, {"task_id": "palindrome-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        \n        # 1. find the middle of the linked list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # 2. reverse the second half of the linked list\n        prev = None\n        while slow:\n            temp = slow.next\n            slow.next = prev\n            prev = slow\n            slow = temp\n        \n        # 3. compare the first half and the reversed second half\n        while prev:\n            if prev.val != head.val:\n                return False\n            prev = prev.next\n            head = head.next\n        return True"}, {"task_id": "palindrome-linked-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def isPalindrome(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        \n        # 1. find the middle of the linked list\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # 2. reverse the second half of the linked list\n        prev = None\n        while slow:\n            temp = slow.next\n            slow.next = prev\n            prev = slow\n            slow = temp\n        \n        # 3. compare the first half and the reversed second half\n        while prev:\n            if prev.val != head.val:\n                return False\n            prev = prev.next\n            head = head.next\n        return True"}], "valid-perfect-square": [{"task_id": "valid-perfect-square", "completion": "class Solution(object):\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10."}, {"task_id": "valid-perfect-square", "completion": "class Solution(object):\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10."}, {"task_id": "valid-perfect-square", "completion": "class Solution(object):\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10."}, {"task_id": "valid-perfect-square", "completion": "class Solution(object):\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        # 11. \n        # 12. \n        # 13. \n        # 14. \n        # 15. \n        # 16. \n        # 17. \n        # 18. \n        # 19. \n        # 20. \n        # 21. \n        # 22. \n        # 23. \n        # 24. \n        # 25. \n        # 26. \n        # 27. \n        # 28. \n        # 29. \n        # 30. \n        # 31. \n        # 32. \n        # 33. \n        # 34. \n        # 35. \n        # 36. \n        # 37. \n        # 38. \n        # 39. \n        # 40. \n        # 41. \n        # 42. \n        # 43. \n        # 44. \n        # 45. \n        # 46. \n        # 47. \n        # 48. \n        # 49. \n        # 50. \n        # 51. \n        # 52. \n        # 53. \n        # 54. \n        # 55. \n        # 56. \n        # 57. \n        # 58. \n        # 59. \n        # 60. \n        # 61. \n        # 62. \n        # 63. \n        # 64. \n        # 65. \n        # 66. \n        # 67. \n        # 68. \n        # 69. \n        # 70. \n        # 71. \n        # 72. \n        # 73. \n        # 74. \n        # 75. \n        # 76. \n        # 77. \n        # 78. \n        # 79. \n        # 80. \n        # 81. \n        # 82. \n        # 83. \n        # 84. \n        # 85. \n        # 86. \n        # 87. \n        # 88. \n        # 89. \n        # 90. \n        # 91. \n        # 92. \n        # 93. \n        # 94. \n        # 95. \n        # 96. \n        # 97. \n        # 98. \n        # 99. \n        # 100. \n        # 101. \n        # 102. \n        # 103. \n        # 104. \n        # 105. \n        # 106. \n        # 107. \n        # 108. \n        # 109. \n        # 110. \n        # 111. \n        # 112. \n        # 113. \n        # 114. \n        # 115. \n        # 116. \n        # 117. \n        # 118. \n        # 119. \n        # 120. \n        # 121. \n        # 122. \n        # 123. \n        # 124. \n        # 125. \n        # 126."}, {"task_id": "valid-perfect-square", "completion": "class Solution(object):\n    def isPerfectSquare(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: bool\n        \"\"\"\n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10. \n        \n        # 1. \n        # 2. \n        # 3. \n        # 4. \n        # 5. \n        # 6. \n        # 7. \n        # 8. \n        # 9. \n        # 10."}], "counting-bits": [{"task_id": "counting-bits", "completion": "class Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. 0 -> 0\n        # 2. 1 -> 1\n        # 3. 2 -> 10\n        # 4. 3 -> 11\n        # 5. 4 -> 100\n        # 6. 5 -> 101\n        # 7. 6 -> 110\n        # 8. 7 -> 111\n        # 9. 8 -> 1000\n        # 10. 9 -> 1001\n        # 11. 10 -> 1010\n        # 12. 11 -> 1011\n        # 13. 12 -> 1100\n        # 14. 13 -> 1101\n        # 15. 14 -> 1110\n        # 16. 15 -> 1111\n        # 17. 16 -> 10000\n        # 18. 17 -> 10001\n        # 19. 18 -> 10010\n        # 20. 19 -> 10011\n        # 21. 20 -> 10100\n        # 22. 21 -> 10101\n        # 23. 22 -> 10110\n        # 24. 23 -> 10111\n        # 25. 24 -> 11000\n        # 26. 25 -> 11001\n        # 27. 26 -> 11010\n        # 28. 27 -> 11011\n        # 29. 28 -> 11100\n        # 30. 29 -> 11101\n        # 31. 30 -> 11110\n        # 32. 31 -> 11111\n        # 33. 32 -> 100000\n        # 34. 33 -> 100001\n        # 35. 34 -> 100010\n        # 36. 35 -> 100011\n        # 37. 36 -> 100100\n        # 38. 37 -> 100101\n        # 39. 38 -> 100110\n        # 40. 39 -> 100111\n        # 41. 40 -> 101000\n        # 42. 41 -> 101001\n        # 43. 42 -> 101010\n        # 44. 43 -> 101011\n        # 45. 44 -> 101100\n        # 46. 45 -> 101101\n        # 47. 46 -> 101110\n        # 48. 47 -> 101111\n        # 49. 48 -> 110000\n        # 50. 49 -> 110001\n        # 51. 50 -> 110010\n        # 52. 51 -> 110011\n        # 53. 52 -> 110100\n        # 54. 53 -> 110101\n        # 55. 54 -> 110110\n        # 56. 55 -> 110111\n        # 57. 56 -> 111000\n        # 58. 57 -> 111001\n        # 59. 58 -> 111010\n        # 60. 59 -> 111011\n        # 61. 60 -> 111100\n        # 62."}, {"task_id": "counting-bits", "completion": "class Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. 0 -> 0\n        # 2. 1 -> 1\n        # 3. 2 -> 10\n        # 4. 3 -> 11\n        # 5. 4 -> 100\n        # 6. 5 -> 101\n        # 7. 6 -> 110\n        # 8. 7 -> 111\n        # 9. 8 -> 1000\n        # 10. 9 -> 1001\n        # 11. 10 -> 1010\n        # 12. 11 -> 1011\n        # 13. 12 -> 1100\n        # 14. 13 -> 1101\n        # 15. 14 -> 1110\n        # 16. 15 -> 1111\n        # 17. 16 -> 10000\n        # 18. 17 -> 10001\n        # 19. 18 -> 10010\n        # 20. 19 -> 10011\n        # 21. 20 -> 10100\n        # 22. 21 -> 10101\n        # 23. 22 -> 10110\n        # 24. 23 -> 10111\n        # 25. 24 -> 11000\n        # 26. 25 -> 11001\n        # 27. 26 -> 11010\n        # 28. 27 -> 11011\n        # 29. 28 -> 11100\n        # 30. 29 -> 11101\n        # 31. 30 -> 11110\n        # 32. 31 -> 11111\n        # 33. 32 -> 100000\n        # 34. 33 -> 100001\n        # 35. 34 -> 100010\n        # 36. 35 -> 100011\n        # 37. 36 -> 100100\n        # 38. 37 -> 100101\n        # 39. 38 -> 100110\n        # 40. 39 -> 100111\n        # 41. 40 -> 101000\n        # 42. 41 -> 101001\n        # 43. 42 -> 101010\n        # 44. 43 -> 101011\n        # 45. 44 -> 101100\n        # 46. 45 -> 101101\n        # 47. 46 -> 101110\n        # 48. 47 -> 101111\n        # 49. 48 -> 110000\n        # 50. 49 -> 110001\n        # 51. 50 -> 110010\n        # 52. 51 -> 110011\n        # 53. 52 -> 110100\n        # 54. 53 -> 110101\n        # 55. 54 -> 110110\n        # 56. 55 -> 110111\n        # 57. 56 -> 111000\n        # 58. 57 -> 111001\n        # 59. 58 -> 111010\n        # 60. 59 -> 111011\n        # 61. 60 -> 111100\n        # 62."}, {"task_id": "counting-bits", "completion": "class Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. 0 -> 0\n        # 2. 1 -> 1\n        # 3. 2 -> 10\n        # 4. 3 -> 11\n        # 5. 4 -> 100\n        # 6. 5 -> 101\n        # 7. 6 -> 110\n        # 8. 7 -> 111\n        # 9. 8 -> 1000\n        # 10. 9 -> 1001\n        # 11. 10 -> 1010\n        # 12. 11 -> 1011\n        # 13. 12 -> 1100\n        # 14. 13 -> 1101\n        # 15. 14 -> 1110\n        # 16. 15 -> 1111\n        # 17. 16 -> 10000\n        # 18. 17 -> 10001\n        # 19. 18 -> 10010\n        # 20. 19 -> 10011\n        # 21. 20 -> 10100\n        # 22. 21 -> 10101\n        # 23. 22 -> 10110\n        # 24. 23 -> 10111\n        # 25. 24 -> 11000\n        # 26. 25 -> 11001\n        # 27. 26 -> 11010\n        # 28. 27 -> 11011\n        # 29. 28 -> 11100\n        # 30. 29 -> 11101\n        # 31. 30 -> 11110\n        # 32. 31 -> 11111\n        # 33. 32 -> 100000\n        # 34. 33 -> 100001\n        # 35. 34 -> 100010\n        # 36. 35 -> 100011\n        # 37. 36 -> 100100\n        # 38. 37 -> 100101\n        # 39. 38 -> 100110\n        # 40. 39 -> 100111\n        # 41. 40 -> 101000\n        # 42. 41 -> 101001\n        # 43. 42 -> 101010\n        # 44. 43 -> 101011\n        # 45. 44 -> 101100\n        # 46. 45 -> 101101\n        # 47. 46 -> 101110\n        # 48. 47 -> 101111\n        # 49. 48 -> 110000\n        # 50. 49 -> 110001\n        # 51. 50 -> 110010\n        # 52. 51 -> 110011\n        # 53. 52 -> 110100\n        # 54. 53 -> 110101\n        # 55. 54 -> 110110\n        # 56. 55 -> 110111\n        # 57. 56 -> 111000\n        # 58. 57 -> 111001\n        # 59. 58 -> 111010\n        # 60. 59 -> 111011\n        # 61. 60 -> 111100\n        # 62."}, {"task_id": "counting-bits", "completion": "class Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. 0 -> 0\n        # 2. 1 -> 1\n        # 3. 2 -> 10\n        # 4. 3 -> 11\n        # 5. 4 -> 100\n        # 6. 5 -> 101\n        # 7. 6 -> 110\n        # 8. 7 -> 111\n        # 9. 8 -> 1000\n        # 10. 9 -> 1001\n        # 11. 10 -> 1010\n        # 12. 11 -> 1011\n        # 13. 12 -> 1100\n        # 14. 13 -> 1101\n        # 15. 14 -> 1110\n        # 16. 15 -> 1111\n        # 17. 16 -> 10000\n        # 18. 17 -> 10001\n        # 19. 18 -> 10010\n        # 20. 19 -> 10011\n        # 21. 20 -> 10100\n        # 22. 21 -> 10101\n        # 23. 22 -> 10110\n        # 24. 23 -> 10111\n        # 25. 24 -> 11000\n        # 26. 25 -> 11001\n        # 27. 26 -> 11010\n        # 28. 27 -> 11011\n        # 29. 28 -> 11100\n        # 30. 29 -> 11101\n        # 31. 30 -> 11110\n        # 32. 31 -> 11111\n        # 33. 32 -> 100000\n        # 34. 33 -> 100001\n        # 35. 34 -> 100010\n        # 36. 35 -> 100011\n        # 37. 36 -> 100100\n        # 38. 37 -> 100101\n        # 39. 38 -> 100110\n        # 40. 39 -> 100111\n        # 41. 40 -> 101000\n        # 42. 41 -> 101001\n        # 43. 42 -> 101010\n        # 44. 43 -> 101011\n        # 45. 44 -> 101100\n        # 46. 45 -> 101101\n        # 47. 46 -> 101110\n        # 48. 47 -> 101111\n        # 49. 48 -> 110000\n        # 50. 49 -> 110001\n        # 51. 50 -> 110010\n        # 52. 51 -> 110011\n        # 53. 52 -> 110100\n        # 54. 53 -> 110101\n        # 55. 54 -> 110110\n        # 56. 55 -> 110111\n        # 57. 56 -> 111000\n        # 58. 57 -> 111001\n        # 59. 58 -> 111010\n        # 60. 59 -> 111011\n        # 61. 60 -> 111100\n        # 62."}, {"task_id": "counting-bits", "completion": "class Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        \n        # 1. 0 -> 0\n        # 2. 1 -> 1\n        # 3. 2 -> 10\n        # 4. 3 -> 11\n        # 5. 4 -> 100\n        # 6. 5 -> 101\n        # 7. 6 -> 110\n        # 8. 7 -> 111\n        # 9. 8 -> 1000\n        # 10. 9 -> 1001\n        # 11. 10 -> 1010\n        # 12. 11 -> 1011\n        # 13. 12 -> 1100\n        # 14. 13 -> 1101\n        # 15. 14 -> 1110\n        # 16. 15 -> 1111\n        # 17. 16 -> 10000\n        # 18. 17 -> 10001\n        # 19. 18 -> 10010\n        # 20. 19 -> 10011\n        # 21. 20 -> 10100\n        # 22. 21 -> 10101\n        # 23. 22 -> 10110\n        # 24. 23 -> 10111\n        # 25. 24 -> 11000\n        # 26. 25 -> 11001\n        # 27. 26 -> 11010\n        # 28. 27 -> 11011\n        # 29. 28 -> 11100\n        # 30. 29 -> 11101\n        # 31. 30 -> 11110\n        # 32. 31 -> 11111\n        # 33. 32 -> 100000\n        # 34. 33 -> 100001\n        # 35. 34 -> 100010\n        # 36. 35 -> 100011\n        # 37. 36 -> 100100\n        # 38. 37 -> 100101\n        # 39. 38 -> 100110\n        # 40. 39 -> 100111\n        # 41. 40 -> 101000\n        # 42. 41 -> 101001\n        # 43. 42 -> 101010\n        # 44. 43 -> 101011\n        # 45. 44 -> 101100\n        # 46. 45 -> 101101\n        # 47. 46 -> 101110\n        # 48. 47 -> 101111\n        # 49. 48 -> 110000\n        # 50. 49 -> 110001\n        # 51. 50 -> 110010\n        # 52. 51 -> 110011\n        # 53. 52 -> 110100\n        # 54. 53 -> 110101\n        # 55. 54 -> 110110\n        # 56. 55 -> 110111\n        # 57. 56 -> 111000\n        # 58. 57 -> 111001\n        # 59. 58 -> 111010\n        # 60. 59 -> 111011\n        # 61. 60 -> 111100\n        # 62."}], "remove-linked-list-elements": [{"task_id": "remove-linked-list-elements", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # 1. create a dummy node\n        dummy = ListNode(0)\n        dummy.next = head\n        \n        # 2. create a pointer to the dummy node\n        curr = dummy\n        \n        # 3. iterate through the linked list\n        while curr.next:\n            # 4. if the current node's value is equal to the target value\n            if curr.next.val == val:\n                # 5. skip the current node\n                curr.next = curr.next.next\n            else:\n                # 6. move to the next node\n                curr = curr.next\n        \n        # 7. return the next node of the dummy node\n        return dummy.next"}, {"task_id": "remove-linked-list-elements", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # 1. create a dummy node\n        dummy = ListNode(0)\n        dummy.next = head\n        \n        # 2. create a pointer to the dummy node\n        curr = dummy\n        \n        # 3. iterate through the linked list\n        while curr.next:\n            # 4. if the value of the current node is equal to the value we want to remove\n            if curr.next.val == val:\n                # 5. remove the node\n                curr.next = curr.next.next\n            else:\n                # 6. move to the next node\n                curr = curr.next\n        \n        # 7. return the next node of the dummy node\n        return dummy.next"}, {"task_id": "remove-linked-list-elements", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # 1. create a dummy node\n        dummy = ListNode(0)\n        dummy.next = head\n        \n        # 2. create a pointer to the dummy node\n        curr = dummy\n        \n        # 3. iterate through the linked list\n        while curr.next:\n            # 4. if the value of the current node is equal to the value we want to remove\n            if curr.next.val == val:\n                # 5. remove the node\n                curr.next = curr.next.next\n            else:\n                # 6. move to the next node\n                curr = curr.next\n        \n        # 7. return the next node of the dummy node\n        return dummy.next"}, {"task_id": "remove-linked-list-elements", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # 1. create a dummy node\n        dummy = ListNode(0)\n        dummy.next = head\n        \n        # 2. create a pointer to the dummy node\n        curr = dummy\n        \n        # 3. iterate through the linked list\n        while curr.next:\n            # 4. if the value of the current node is equal to the value we want to remove\n            if curr.next.val == val:\n                # 5. remove the node\n                curr.next = curr.next.next\n            else:\n                # 6. move to the next node\n                curr = curr.next\n        \n        # 7. return the next node of the dummy node\n        return dummy.next"}, {"task_id": "remove-linked-list-elements", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def removeElements(self, head, val):\n        \"\"\"\n        :type head: ListNode\n        :type val: int\n        :rtype: ListNode\n        \"\"\"\n        \n        # 1. create a dummy node\n        dummy = ListNode(0)\n        dummy.next = head\n        \n        # 2. create a pointer to the dummy node\n        curr = dummy\n        \n        # 3. iterate through the linked list\n        while curr.next:\n            # 4. if the value of the current node is equal to the value we want to remove\n            if curr.next.val == val:\n                # 5. remove the node\n                curr.next = curr.next.next\n            else:\n                # 6. move to the next node\n                curr = curr.next\n        \n        # 7. return the next node of the dummy node\n        return dummy.next"}], "scramble-string": [{"task_id": "scramble-string", "completion": "class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) != len(s2):\n            return False\n        \n        if s1 == s2:\n            return True\n        \n        if sorted(s1) != sorted(s2):\n            return False\n        \n        for i in range(1, len(s1)):\n            if (self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:])) or (self.isScramble(s1[:i], s2[-i:]) and selfcramble(s1[i:], s2[:-i])):\n                return True\n        \n        return False"}, {"task_id": "scramble-string", "completion": "class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) != len(s2):\n            return False\n        \n        if s1 == s2:\n            return True\n        \n        if sorted(s1) != sorted(s2):\n            return False\n        \n        for i in range(1, len(s1)):\n            if (self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:])) or (self.isScramble(s1[:i], s2[-i:]) and selfcramble(s1[i:], s2[:-i])):\n                return True\n        \n        return False"}, {"task_id": "scramble-string", "completion": "class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) != len(s2):\n            return False\n        \n        if s1 == s2:\n            return True\n        \n        if sorted(s1) != sorted(s2):\n            return False\n        \n        for i in range(1, len(s1)):\n            if (self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:])) or (self.isScramble(s1[:i], s2[-i:]) and selfisScramble(s1[i:], s2[:-i])):\n                return True\n        \n        return False"}, {"task_id": "scramble-string", "completion": "class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) != len(s2):\n            return False\n        \n        if s1 == s2:\n            return True\n        \n        if sorted(s1) != sorted(s2):\n            return False\n        \n        for i in range(1, len(s1)):\n            if (self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:])) or (self.isScramble(s1[:i], s2[-i:]) and selfcramble(s1[i:], s2[:-i])):\n                return True\n        \n        return False"}, {"task_id": "scramble-string", "completion": "class Solution(object):\n    def isScramble(self, s1, s2):\n        \"\"\"\n        :type s1: str\n        :type s2: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s1) != len(s2):\n            return False\n        \n        if s1 == s2:\n            return True\n        \n        if sorted(s1) != sorted(s2):\n            return False\n        \n        for i in range(1, len(s1)):\n            if (self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:])) or (self.isScramble(s1[:i], s2[-i:]) and selfcramble(s1[i:], s2[:-i])):\n                return True\n        \n        return False"}], "simplify-path": [{"task_id": "simplify-path", "completion": "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. split the path into a list of directories\n        # 2. iterate through the list of directories\n        # 3. if the directory is '..', pop the last directory from the stack\n        # 4. if the directory is '.' or '', do nothing\n        # 5. otherwise, push the directory onto the stack\n        # 6. join the stack into a string\n        # 7. return the string\n        \n        # split the path into a list of directories\n        directories = path.split('/')\n        \n        # stack to store the directories\n        stack = []\n        \n        # iterate through the list of directories\n        for directory in directories:\n            # if the directory is '..', pop the last directory from the stack\n            if directory == '..':\n                if stack:\n                    stack.pop()\n            # if the directory is '.' or '', do nothing\n            elif directory != '.' and directory:\n                # push the directory onto the stack\n                stack.append(directory)\n        \n        # join the stack into a string\n        return '/' + '/'.join(stack)"}, {"task_id": "simplify-path", "completion": "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        \n        stack = []\n        for p in path.split('/'):\n            if p == '..':\n                if stack:\n                    stack.pop()\n            elif p and p != '.':\n                stack.append(p)\n        return '/' + '/'.join(stack)"}, {"task_id": "simplify-path", "completion": "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. split the path by '/'\n        # 2. iterate through the list\n        # 3. if the element is '.' or '' or '..', then ignore\n        # 4. else, append the element to the stack\n        # 5. if the stack is empty, return '/'\n        # 6. else, return '/' + '/'.join(stack)\n        \n        stack = []\n        for element in path.split('/'):\n            if element == '..':\n                if stack:\n                    stack.pop()\n            elif element and element != '.':\n                stack.append(element)\n        return '/' if not stack else '/' + '/'.join(stack)"}, {"task_id": "simplify-path", "completion": "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        \n        stack = []\n        for p in path.split('/'):\n            if p == '..':\n                if stack:\n                    stack.pop()\n            elif p and p != '.':\n                stack.append(p)\n        return '/' + '/'.join(stack)"}, {"task_id": "simplify-path", "completion": "class Solution(object):\n    def simplifyPath(self, path):\n        \"\"\"\n        :type path: str\n        :rtype: str\n        \"\"\"\n        \n        stack = []\n        for p in path.split('/'):\n            if p == '..':\n                if stack:\n                    stack.pop()\n            elif p and p != '.':\n                stack.append(p)\n        return '/' + '/'.join(stack)"}], "word-search-ii": [{"task_id": "word-search-ii", "completion": "class Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # build trie\n        trie = {}\n        for word in words:\n            node = trie\n            for char in word:\n                node = node.setdefault(char, {})\n            node['#'] = '#'\n        \n        # dfs\n        def dfs(i, j, node, pre, visited):\n            if '#' in node:\n                res.add(pre)\n            if not (0 <= i < len(board) and 0 <= j < len(board[0])) or (i, j) in visited or board[i][j] not in node:\n                return\n            visited.add((i, j))\n            for x, y in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                dfs(x, y, node[board[i][j]], pre + board[i][j], visited)\n            visited.remove((i, j))\n        \n        res = set()\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                dfs(i, j, trie, '', set())\n        return list(res)"}, {"task_id": "word-search-ii", "completion": "class Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # build trie\n        trie = {}\n        for word in words:\n            node = trie\n            for char in word:\n                node = node.setdefault(char, {})\n            node['#'] = '#'\n        \n        # dfs\n        def dfs(i, j, node, pre, visited):\n            if '#' in node:\n                res.add(pre)\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]):\n                return\n            if board[i][j] not in node or (i, j) in visited:\n                return\n            visited.add((i, j))\n            dfs(i + 1, j, node[board[i][j]], pre + board[i][j], visited)\n            dfs(i - 1, j, node[board[i][j]], pre + board[i][j], visited)\n            dfs(i, j + 1, node[board[i][j]], pre + board[i][j], visited)\n            dfs(i, j - 1, node[board[i][j]], pre + board[i][j], visited)\n            visited.remove((i, j))\n        \n        res = set()\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                dfs(i, j, trie, '', set())\n        return list(res)"}, {"task_id": "word-search-ii", "completion": "class Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # 1. build trie\n        trie = {}\n        for word in words:\n            node = trie\n            for char in word:\n                node = node.setdefault(char, {})\n            node['#'] = '#'\n        \n        # 2. dfs\n        m, n = len(board), len(board[0])\n        res = []\n        def dfs(i, j, node, word):\n            if '#' in node:\n                res.append(word)\n                del node['#']\n            if i < 0 or i >= m or j < 0 or j >= n or board[i][j] not in node:\n                return\n            char = board[i][j]\n            board[i][j] = '.'\n            for x, y in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:\n                dfs(x, y, node[char], word+char)\n            board[i][j] = char\n        \n        for i in range(m):\n            for j in range(n):\n                if board[i][j] in trie:\n                    dfs(i, j, trie, '')\n        return res"}, {"task_id": "word-search-ii", "completion": "class Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # 1. build trie\n        trie = {}\n        for word in words:\n            node = trie\n            for char in word:\n                node = node.setdefault(char, {})\n            node['#'] = '#'\n        \n        # 2. dfs\n        m, n = len(board), len(board[0])\n        res = []\n        def dfs(i, j, node, word):\n            if '#' in node:\n                res.append(word)\n                del node['#']\n            if i < 0 or i >= m or j < 0 or j >= n or board[i][j] not in node:\n                return\n            char = board[i][j]\n            board[i][j] = '.'\n            for x, y in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]:\n                dfs(x, y, node[char], word + char)\n            board[i][j] = char\n        \n        for i in range(m):\n            for j in range(n):\n                dfs(i, j, trie, '')\n        \n        return res"}, {"task_id": "word-search-ii", "completion": "class Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        # build trie\n        trie = {}\n        for word in words:\n            node = trie\n            for char in word:\n                node = node.setdefault(char, {})\n            node['#'] = '#'\n        \n        # dfs\n        def dfs(i, j, node, pre, visited):\n            if '#' in node:\n                res.add(pre)\n            if not (0 <= i < len(board) and 0 <= j < len(board[0])) or (i, j) in visited or board[i][j] not in node:\n                return\n            visited.add((i, j))\n            for x, y in [(i - 1, j), (i + 1, j), (i, j - 1), (i, j + 1)]:\n                dfs(x, y, node[board[i][j]], pre + board[i][j], visited)\n            visited.remove((i, j))\n        \n        res = set()\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                dfs(i, j, trie, '', set())\n        return list(res)"}], "valid-anagram": [{"task_id": "valid-anagram", "completion": "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_dict = {}\n        t_dict = {}\n        \n        for i in range(len(s)):\n            if s[i] in s_dict:\n                s_dict[s[i]] += 1\n            else:\n                s_dict[s[i]] = 1\n                \n            if t[i] in t_dict:\n                t_dict[t[i]] += 1\n            else:\n                t_dict[t[i]] = 1\n                \n        for key in s_dict:\n            if key not in t_dict:\n                return False\n            if s_dict[key] != t_dict[key]:\n                return False\n            \n        return True"}, {"task_id": "valid-anagram", "completion": "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_dict = {}\n        t_dict = {}\n        \n        for i in range(len(s)):\n            if s[i] in s_dict:\n                s_dict[s[i]] += 1\n            else:\n                s_dict[s[i]] = 1\n                \n            if t[i] in t_dict:\n                t_dict[t[i]] += 1\n            else:\n                t_dict[t[i]] = 1\n                \n        for key in s_dict:\n            if key not in t_dict:\n                return False\n            if s_dict[key] != t_dict[key]:\n                return False\n            \n        return True"}, {"task_id": "valid-anagram", "completion": "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_dict = {}\n        t_dict = {}\n        \n        for i in range(len(s)):\n            if s[i] in s_dict:\n                s_dict[s[i]] += 1\n            else:\n                s_dict[s[i]] = 1\n                \n            if t[i] in t_dict:\n                t_dict[t[i]] += 1\n            else:\n                t_dict[t[i]] = 1\n                \n        for key in s_dict:\n            if key not in t_dict or s_dict[key] != t_dict[key]:\n                return False\n            \n        return True"}, {"task_id": "valid-anagram", "completion": "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        if len(s) != len(t):\n            return False\n        \n        s_dict = {}\n        t_dict = {}\n        \n        for i in range(len(s)):\n            if s[i] in s_dict:\n                s_dict[s[i]] += 1\n            else:\n                s_dict[s[i]] = 1\n                \n            if t[i] in t_dict:\n                t_dict[t[i]] += 1\n            else:\n                t_dict[t[i]] = 1\n                \n        for key in s_dict:\n            if key not in t_dict or s_dict[key] != t_dict[key]:\n                return False\n            \n        return True"}, {"task_id": "valid-anagram", "completion": "class Solution(object):\n    def isAnagram(self, s, t):\n        \"\"\"\n        :type s: str\n        :type t: str\n        :rtype: bool\n        \"\"\"\n        \n        # if the length of the two strings are not equal, then they cannot be anagrams\n        if len(s) != len(t):\n            return False\n        \n        # create a dictionary to store the count of each character in the first string\n        char_count = {}\n        for char in s:\n            if char in char_count:\n                char_count[char] += 1\n            else:\n                char_count[char] = 1\n        \n        # iterate through the second string and decrement the count of each character in the dictionary\n        for char in t:\n            if char in char_count:\n                char_count[char] -= 1\n            else:\n                return False\n        \n        # if the count of any character is not zero, then the two strings are not anagrams\n        for count in char_count.values():\n            if count != 0:\n                return False\n        \n        return True"}], "valid-sudoku": [{"task_id": "valid-sudoku", "completion": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        # check rows\n        for row in board:\n            if not self.isValid(row):\n                return False\n        \n        # check columns\n        for col in zip(*board):\n            if not self.isValid(col):\n                return False\n        \n        # check 3x3 sub-boxes\n        for i in (0, 3, 6):\n            for j in (0, 3, 6):\n                square = [board[x][y] for x in range(i, i + 3) for y in range(j, j + 3)]\n                if not self.isValid(square):\n                    return False\n        \n        return True\n    \n    def isValid(self, arr):\n        nums = [i for i in arr if i != '.']\n        return len(nums) == len(set(nums))"}, {"task_id": "valid-sudoku", "completion": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        # check rows\n        for row in board:\n            if not self.isValid(row):\n                return False\n        \n        # check columns\n        for col in zip(*board):\n            if not self.isValid(col):\n                return False\n        \n        # check 3x3 sub-boxes\n        for i in (0, 3, 6):\n            for j in (0, 3, 6):\n                square = [board[x][y] for x in range(i, i + 3) for y in range(j, j + 3)]\n                if not self.isValid(square):\n                    return False\n        \n        return True\n    \n    def isValid(self, arr):\n        nums = [i for i in arr if i != '.']\n        return len(nums) == len(set(nums))"}, {"task_id": "valid-sudoku", "completion": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        # check rows\n        for row in board:\n            if not self.isValid(row):\n                return False\n        \n        # check columns\n        for col in zip(*board):\n            if not self.isValid(col):\n                return False\n        \n        # check 3x3 sub-boxes\n        for i in (0, 3, 6):\n            for j in (0, 3, 6):\n                square = [board[x][y] for x in range(i, i + 3) for y in range(j, j + 3)]\n                if not self.isValid(square):\n                    return False\n        \n        return True\n    \n    def isValid(self, nums):\n        nums = [i for i in nums if i != '.']\n        return len(set(nums)) == len(nums)"}, {"task_id": "valid-sudoku", "completion": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        # check rows\n        for row in board:\n            if not self.isValid(row):\n                return False\n        \n        # check columns\n        for col in zip(*board):\n            if not self.isValid(col):\n                return False\n        \n        # check 3x3 sub-boxes\n        for i in (0, 3, 6):\n            for j in (0, 3, 6):\n                square = [board[x][y] for x in range(i, i + 3) for y in range(j, j + 3)]\n                if not self.isValid(square):\n                    return False\n        \n        return True\n    \n    def isValid(self, arr):\n        nums = [i for i in arr if i != '.']\n        return len(nums) == len(set(nums))"}, {"task_id": "valid-sudoku", "completion": "class Solution(object):\n    def isValidSudoku(self, board):\n        \"\"\"\n        :type board: List[List[str]]\n        :rtype: bool\n        \"\"\"\n        \n        # check rows\n        for row in board:\n            if not self.isValid(row):\n                return False\n        \n        # check columns\n        for col in zip(*board):\n            if not self.isValid(col):\n                return False\n        \n        # check 3x3 sub-boxes\n        for i in (0, 3, 6):\n            for j in (0, 3, 6):\n                square = [board[x][y] for x in range(i, i + 3) for y in range(j, j + 3)]\n                if not self.isValid(square):\n                    return False\n        \n        return True\n    \n    def isValid(self, nums):\n        nums = [i for i in nums if i != '.']\n        return len(set(nums)) == len(nums)"}], "fizz-buzz": [{"task_id": "fizz-buzz", "completion": "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        # create a list of strings\n        # iterate through the list\n        # if the index is divisible by 3 and 5, add \"FizzBuzz\" to the list\n        # if the index is divisible by 3, add \"Fizz\" to the list\n        # if the index is divisible by 5, add \"Buzz\" to the list\n        # if the index is not divisible by 3 or 5, add the index to the list\n        # return the list\n        \n        # create a list of strings\n        result = []\n        \n        # iterate through the list\n        for i in range(1, n+1):\n            # if the index is divisible by 3 and 5, add \"FizzBuzz\" to the list\n            if i % 3 == 0 and i % 5 == 0:\n                result.append(\"FizzBuzz\")\n            # if the index is divisible by 3, add \"Fizz\" to the list\n            elif i % 3 == 0:\n                result.append(\"Fizz\")\n            # if the index is divisible by 5, add \"Buzz\" to the list\n            elif i % 5 == 0:\n                result.append(\"Buzz\")\n            # if the index is not divisible by 3 or 5, add the index to the list\n            else:\n                result.append(str(i))\n        \n        # return the list\n        return result"}, {"task_id": "fizz-buzz", "completion": "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        # 1. create a list of strings\n        # 2. iterate through the list\n        # 3. if the index is divisible by 3 and 5, append \"FizzBuzz\"\n        # 4. if the index is divisible by 3, append \"Fizz\"\n        # 5. if the index is divisible by 5, append \"Buzz\"\n        # 6. if the index is not divisible by 3 or 5, append the index\n        # 7. return the list\n        \n        # 1. create a list of strings\n        result = []\n        \n        # 2. iterate through the list\n        for i in range(1, n+1):\n            # 3. if the index is divisible by 3 and 5, append \"FizzBuzz\"\n            if i % 3 == 0 and i % 5 == 0:\n                result.append(\"FizzBuzz\")\n            # 4. if the index is divisible by 3, append \"Fizz\"\n            elif i % 3 == 0:\n                result.append(\"Fizz\")\n            # 5. if the index is divisible by 5, append \"Buzz\"\n            elif i % 5 == 0:\n                result.append(\"Buzz\")\n            # 6. if the index is not divisible by 3 or 5, append the index\n            else:\n                result.append(str(i))\n        \n        # 7. return the list\n        return result"}, {"task_id": "fizz-buzz", "completion": "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        # create a list of strings\n        # iterate through the list\n        # if the index is divisible by 3 and 5, append \"FizzBuzz\"\n        # if the index is divisible by 3, append \"Fizz\"\n        # if the index is divisible by 5, append \"Buzz\"\n        # if the index is not divisible by 3 or 5, append the index\n        # return the list\n        \n        # create a list of strings\n        result = []\n        \n        # iterate through the list\n        for i in range(1, n+1):\n            # if the index is divisible by 3 and 5, append \"FizzBuzz\"\n            if i % 3 == 0 and i % 5 == 0:\n                result.append(\"FizzBuzz\")\n            # if the index is divisible by 3, append \"Fizz\"\n            elif i % 3 == 0:\n                result.append(\"Fizz\")\n            # if the index is divisible by 5, append \"Buzz\"\n            elif i % 5 == 0:\n                result.append(\"Buzz\")\n            # if the index is not divisible by 3 or 5, append the index\n            else:\n                result.append(str(i))\n        \n        # return the list\n        return result"}, {"task_id": "fizz-buzz", "completion": "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        # 1. create a list of strings\n        # 2. iterate through the list\n        # 3. if the index is divisible by 3 and 5, append \"FizzBuzz\"\n        # 4. if the index is divisible by 3, append \"Fizz\"\n        # 5. if the index is divisible by 5, append \"Buzz\"\n        # 6. if the index is not divisible by 3 or 5, append the index as a string\n        # 7. return the list\n        \n        # 1. create a list of strings\n        result = []\n        \n        # 2. iterate through the list\n        for i in range(1, n+1):\n            # 3. if the index is divisible by 3 and 5, append \"FizzBuzz\"\n            if i % 3 == 0 and i % 5 == 0:\n                result.append(\"FizzBuzz\")\n            # 4. if the index is divisible by 3, append \"Fizz\"\n            elif i % 3 == 0:\n                result.append(\"Fizz\")\n            # 5. if the index is divisible by 5, append \"Buzz\"\n            elif i % 5 == 0:\n                result.append(\"Buzz\")\n            # 6. if the index is not divisible by 3 or 5, append the index as a string\n            else:\n                result.append(str(i))\n        \n        # 7. return the list\n        return result"}, {"task_id": "fizz-buzz", "completion": "class Solution(object):\n    def fizzBuzz(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[str]\n        \"\"\"\n        \n        # 1. create a list of strings\n        # 2. iterate through the list\n        # 3. if the index is divisible by 3 and 5, append \"FizzBuzz\"\n        # 4. if the index is divisible by 3, append \"Fizz\"\n        # 5. if the index is divisible by 5, append \"Buzz\"\n        # 6. if the index is not divisible by 3 or 5, append the index as a string\n        # 7. return the list\n        \n        # 1. create a list of strings\n        result = []\n        \n        # 2. iterate through the list\n        for i in range(1, n+1):\n            # 3. if the index is divisible by 3 and 5, append \"FizzBuzz\"\n            if i % 3 == 0 and i % 5 == 0:\n                result.append(\"FizzBuzz\")\n            # 4. if the index is divisible by 3, append \"Fizz\"\n            elif i % 3 == 0:\n                result.append(\"Fizz\")\n            # 5. if the index is divisible by 5, append \"Buzz\"\n            elif i % 5 == 0:\n                result.append(\"Buzz\")\n            # 6. if the index is not divisible by 3 or 5, append the index as a string\n            else:\n                result.append(str(i))\n        \n        # 7. return the list\n        return result"}], "reverse-words-in-a-string": [{"task_id": "reverse-words-in-a-string", "completion": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # split the string into a list of words\n        words = s.split()\n        \n        # reverse the list of words\n        words.reverse()\n        \n        # join the list of words into a string\n        return ' '.join(words)"}, {"task_id": "reverse-words-in-a-string", "completion": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. split the string into a list of words\n        # 2. reverse the list\n        # 3. join the list\n        # 4. return the string\n        \n        # 1. split the string into a list of words\n        words = s.split()\n        \n        # 2. reverse the list\n        words.reverse()\n        \n        # 3. join the list\n        s = ' '.join(words)\n        \n        # 4. return the string\n        return s"}, {"task_id": "reverse-words-in-a-string", "completion": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. split the string into a list of words\n        # 2. reverse the list\n        # 3. join the list\n        # 4. return the string\n        \n        # 1. split the string into a list of words\n        words = s.split()\n        \n        # 2. reverse the list\n        words.reverse()\n        \n        # 3. join the list\n        s = \" \".join(words)\n        \n        # 4. return the string\n        return s"}, {"task_id": "reverse-words-in-a-string", "completion": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # 1. split the string into a list of words\n        # 2. reverse the list\n        # 3. join the list\n        # 4. return the string\n        \n        # 1. split the string into a list of words\n        words = s.split()\n        \n        # 2. reverse the list\n        words.reverse()\n        \n        # 3. join the list\n        s = \" \".join(words)\n        \n        # 4. return the string\n        return s"}, {"task_id": "reverse-words-in-a-string", "completion": "class Solution(object):\n    def reverseWords(self, s):\n        \"\"\"\n        :type s: str\n        :rtype: str\n        \"\"\"\n        \n        # split the string into a list of words\n        words = s.split()\n        \n        # reverse the list of words\n        words.reverse()\n        \n        # join the list of words into a string\n        return ' '.join(words)"}], "excel-sheet-column-number": [{"task_id": "excel-sheet-column-number", "completion": "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        \"\"\"\n        :type columnTitle: str\n        :rtype: int\n        \"\"\"\n        \n        # 26\u8fdb\u5236\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4ece1\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bb1\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 2"}, {"task_id": "excel-sheet-column-number", "completion": "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        \"\"\"\n        :type columnTitle: str\n        :rtype: int\n        \"\"\"\n        \n        # 26\u8fdb\u5236\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4ece1\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bb1\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684"}, {"task_id": "excel-sheet-column-number", "completion": "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        \"\"\"\n        :type columnTitle: str\n        :rtype: int\n        \"\"\"\n        \n        # 26\u8fdb\u5236\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4ece1\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bb1\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684"}, {"task_id": "excel-sheet-column-number", "completion": "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        \"\"\"\n        :type columnTitle: str\n        :rtype: int\n        \"\"\"\n        \n        # 26\u8fdb\u5236\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4ece1\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bb1\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684ASCII\u7801\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\u7684"}, {"task_id": "excel-sheet-column-number", "completion": "class Solution(object):\n    def titleToNumber(self, columnTitle):\n        \"\"\"\n        :type columnTitle: str\n        :rtype: int\n        \"\"\"\n        \n        # 26\u8fdb\u5236\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4ece1\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bb1\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4ece1\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bb1\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4ece1\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bb1\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4ece1\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bb1\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4ece1\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bb1\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4ece1\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bb1\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4ece1\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bb1\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4ece1\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bb1\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4ece1\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bb1\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4ece1\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bb1\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4ece1\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bb1\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4ece1\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bb1\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4ece1\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bb1\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4ece1\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bb1\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4ece1\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bb1\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4ece1\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bb1\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4ece1\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bb1\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4ece1\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bb1\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4ece1\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bb1\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4ece1\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bb1\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4ece1\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bb1\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4ece1\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bb1\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4ece1\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bb1\n        # 26\u8fdb\u5236\u7684\u6bcf\u4e00\u4f4d\u90fd\u662f\u4eceA\u5f00\u59cb\u7684\uff0c\u6240\u4ee5\u9700\u8981\u51cf\u53bbA\n        # 2"}], "candy": [{"task_id": "candy", "completion": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(ratings)\n        left = [1] * n\n        right = [1] * n\n        \n        for i in range(1, n):\n            if ratings[i] > ratings[i-1]:\n                left[i] = left[i-1] + 1\n        \n        for i in range(n-2, -1, -1):\n            if ratings[i] > ratings[i+1]:\n                right[i] = right[i+1] + 1\n        \n        return sum(max(left[i], right[i]) for i in range(n))"}, {"task_id": "candy", "completion": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(ratings)\n        left = [1] * n\n        right = [1] * n\n        \n        for i in range(1, n):\n            if ratings[i] > ratings[i-1]:\n                left[i] = left[i-1] + 1\n        \n        for i in range(n-2, -1, -1):\n            if ratings[i] > ratings[i+1]:\n                right[i] = right[i+1] + 1\n        \n        return sum(max(left[i], right[i]) for i in range(n))"}, {"task_id": "candy", "completion": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(ratings)\n        left = [1] * n\n        right = [1] * n\n        \n        for i in range(1, n):\n            if ratings[i] > ratings[i-1]:\n                left[i] = left[i-1] + 1\n        \n        for i in range(n-2, -1, -1):\n            if ratings[i] > ratings[i+1]:\n                right[i] = right[i+1] + 1\n        \n        return sum(max(left[i], right[i]) for i in range(n))"}, {"task_id": "candy", "completion": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(ratings)\n        candies = [1] * n\n        \n        for i in range(1, n):\n            if ratings[i] > ratings[i-1]:\n                candies[i] = candies[i-1] + 1\n        \n        for i in range(n-2, -1, -1):\n            if ratings[i] > ratings[i+1]:\n                candies[i] = max(candies[i], candies[i+1] + 1)\n        \n        return sum(candies)"}, {"task_id": "candy", "completion": "class Solution(object):\n    def candy(self, ratings):\n        \"\"\"\n        :type ratings: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(ratings)\n        if n == 1:\n            return 1\n        \n        candies = [1] * n\n        \n        for i in range(1, n):\n            if ratings[i] > ratings[i-1]:\n                candies[i] = candies[i-1] + 1\n        \n        for i in range(n-2, -1, -1):\n            if ratings[i] > ratings[i+1]:\n                candies[i] = max(candies[i], candies[i+1] + 1)\n        \n        return sum(candies)"}], "same-tree": [{"task_id": "same-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if p == None and q == None:\n            return True\n        if p == None or q == None:\n            return False\n        if p.val != q.val:\n            return False\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)"}, {"task_id": "same-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if p == None and q == None:\n            return True\n        elif p == None or q == None:\n            return False\n        elif p.val != q.val:\n            return False\n        else:\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)"}, {"task_id": "same-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if p == None and q == None:\n            return True\n        if p == None or q == None:\n            return False\n        if p.val != q.val:\n            return False\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)"}, {"task_id": "same-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if p == None and q == None:\n            return True\n        if p == None or q == None:\n            return False\n        if p.val != q.val:\n            return False\n        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)"}, {"task_id": "same-tree", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def isSameTree(self, p, q):\n        \"\"\"\n        :type p: TreeNode\n        :type q: TreeNode\n        :rtype: bool\n        \"\"\"\n        \n        if p == None and q == None:\n            return True\n        elif p == None or q == None:\n            return False\n        elif p.val != q.val:\n            return False\n        else:\n            return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)"}], "reorder-list": [{"task_id": "reorder-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reorderList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: None Do not return anything, modify head in-place instead.\n        \"\"\"\n        \n        # find the middle of the linked list\n        slow, fast = head, head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the linked list\n        prev, curr = None, slow\n        while curr:\n            curr.next, prev, curr = prev, curr, curr.next\n        \n        # merge the two halves of the linked list\n        first, second = head, prev\n        while second.next:\n            first.next, first = second, first.next\n            second.next, second = first, second.next\n        \n        return head"}, {"task_id": "reorder-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reorderList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: None Do not return anything, modify head in-place instead.\n        \"\"\"\n        \n        # find the middle of the linked list\n        slow, fast = head, head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the linked list\n        prev, curr = None, slow\n        while curr:\n            curr.next, prev, curr = prev, curr, curr.next\n        \n        # merge the two halves of the linked list\n        first, second = head, prev\n        while second.next:\n            first.next, first = second, first.next\n            second.next, second = first, second.next\n        \n        return head"}, {"task_id": "reorder-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reorderList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: None Do not return anything, modify head in-place instead.\n        \"\"\"\n        \n        # find the middle of the linked list\n        slow, fast = head, head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the linked list\n        prev, curr = None, slow\n        while curr:\n            curr.next, prev, curr = prev, curr, curr.next\n        \n        # merge the two halves of the linked list\n        first, second = head, prev\n        while second.next:\n            first.next, first = second, first.next\n            second.next, second = first, second.next\n        \n        return head"}, {"task_id": "reorder-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reorderList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: None Do not return anything, modify head in-place instead.\n        \"\"\"\n        \n        # find the middle of the linked list\n        slow, fast = head, head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the linked list\n        prev, curr = None, slow\n        while curr:\n            curr.next, prev, curr = prev, curr, curr.next\n        \n        # merge the two halves of the linked list\n        first, second = head, prev\n        while second.next:\n            first.next, first = second, first.next\n            second.next, second = first, second.next\n        \n        return head"}, {"task_id": "reorder-list", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def reorderList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: None Do not return anything, modify head in-place instead.\n        \"\"\"\n        \n        # find the middle of the linked list\n        slow, fast = head, head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n        \n        # reverse the second half of the linked list\n        prev, curr = None, slow\n        while curr:\n            curr.next, prev, curr = prev, curr, curr.next\n        \n        # merge the two halves of the linked list\n        first, second = head, prev\n        while second.next:\n            first.next, first = second, first.next\n            second.next, second = first, second.next\n        \n        return head"}], "word-pattern": [{"task_id": "word-pattern", "completion": "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # if the length of the pattern and the number of words in the string are not equal, return False\n        if len(pattern) != len(words):\n            return False\n        \n        # create a dictionary to store the mapping between characters in the pattern and words in the string\n        char_word_map = {}\n        \n        # create a set to store the words that have already been mapped\n        used_words = set()\n        \n        # iterate through the pattern and words\n        for i in range(len(pattern)):\n            # if the character is not in the dictionary, add it to the dictionary with the corresponding word\n            if pattern[i] not in char_word_map:\n                # if the word has already been used, return False\n                if words[i] in used_words:\n                    return False\n                # add the mapping to the dictionary and add the word to the set of used words\n                char_word_map[pattern[i]] = words[i]\n                used_words.add(words[i])\n            # if the character is in the dictionary, check if the corresponding word is the same as the one in the dictionary\n            else:\n                if char_word_map[pattern[i]] != words[i]:\n                    return False\n        \n        # if all the checks pass, return True\n        return True"}, {"task_id": "word-pattern", "completion": "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # if the length of the pattern is not equal to the length of the words, return False\n        if len(pattern) != len(words):\n            return False\n        \n        # create a dictionary to store the mapping between the pattern and the words\n        mapping = {}\n        \n        # create a set to store the words that have already been mapped\n        used = set()\n        \n        # iterate through the pattern and words\n        for i in range(len(pattern)):\n            # if the pattern character is not in the mapping, add it to the mapping\n            if pattern[i] not in mapping:\n                # if the word has already been used, return False\n                if words[i] in used:\n                    return False\n                # add the pattern character and word to the mapping and add the word to the used set\n                mapping[pattern[i]] = words[i]\n                used.add(words[i])\n            # if the pattern character is in the mapping, check if the word matches the mapping\n            else:\n                # if the word does not match the mapping, return False\n                if words[i] != mapping[pattern[i]]:\n                    return False\n        \n        # if all the checks pass, return True\n        return True"}, {"task_id": "word-pattern", "completion": "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # check if the number of words and characters in the pattern are the same\n        if len(words) != len(pattern):\n            return False\n        \n        # create a dictionary to store the mapping between characters and words\n        char_word = {}\n        \n        # create a set to store the words that have already been mapped\n        used_words = set()\n        \n        # iterate through the characters in the pattern\n        for i in range(len(pattern)):\n            # get the current character and word\n            char = pattern[i]\n            word = words[i]\n            \n            # if the character is not in the dictionary, add it with the current word\n            if char not in char_word:\n                # check if the word has already been used\n                if word in used_words:\n                    return False\n                char_word[char] = word\n                used_words.add(word)\n            # if the character is in the dictionary, check if the word matches the one stored\n            else:\n                if char_word[char] != word:\n                    return False\n        \n        # if we have iterated through all the characters in the pattern, return True\n        return True"}, {"task_id": "word-pattern", "completion": "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # if the length of the pattern and the number of words in the string are not equal, return False\n        if len(pattern) != len(words):\n            return False\n        \n        # create a dictionary to store the mapping between characters in the pattern and words in the string\n        char_word_map = {}\n        \n        # create a set to store the words that have already been mapped\n        used_words = set()\n        \n        # iterate through the pattern and words\n        for i in range(len(pattern)):\n            # if the character is not in the dictionary, add it to the dictionary with the corresponding word\n            if pattern[i] not in char_word_map:\n                # if the word has already been used, return False\n                if words[i] in used_words:\n                    return False\n                # add the mapping to the dictionary and add the word to the set of used words\n                char_word_map[pattern[i]] = words[i]\n                used_words.add(words[i])\n            # if the character is in the dictionary, check if the corresponding word is the same as the one in the dictionary\n            else:\n                if char_word_map[pattern[i]] != words[i]:\n                    return False\n        \n        # if all the checks pass, return True\n        return True"}, {"task_id": "word-pattern", "completion": "class Solution(object):\n    def wordPattern(self, pattern, s):\n        \"\"\"\n        :type pattern: str\n        :type s: str\n        :rtype: bool\n        \"\"\"\n        \n        # split the string into words\n        words = s.split()\n        \n        # if the length of the pattern is not equal to the length of the words, return False\n        if len(pattern) != len(words):\n            return False\n        \n        # create a dictionary to store the pattern and the words\n        pattern_dict = {}\n        \n        # create a set to store the words\n        word_set = set()\n        \n        # iterate through the pattern and words\n        for i in range(len(pattern)):\n            # if the pattern is not in the dictionary\n            if pattern[i] not in pattern_dict:\n                # if the word is in the set, return False\n                if words[i] in word_set:\n                    return False\n                # add the pattern and word to the dictionary and set\n                pattern_dict[pattern[i]] = words[i]\n                word_set.add(words[i])\n            # if the pattern is in the dictionary\n            else:\n                # if the word is not equal to the word in the dictionary, return False\n                if words[i] != pattern_dict[pattern[i]]:\n                    return False\n        # return True\n        return True"}], "permutations": [{"task_id": "permutations", "completion": "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(first = 0):\n            # if all integers are used up\n            if first == n:  \n                output.append(nums[:])\n            for i in range(first, n):\n                # place i-th integer first \n                # in the current permutation\n                nums[first], nums[i] = nums[i], nums[first]\n                # use next integers to complete the permutations\n                backtrack(first + 1)\n                # backtrack\n                nums[first], nums[i] = numsnums[i], nums[first]\n        \n        n = len(nums)\n        output = []\n        backtrack()\n        return output"}, {"task_id": "permutations", "completion": "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(first = 0):\n            # if all integers are used up\n            if first == n:  \n                output.append(nums[:])\n            for i in range(first, n):\n                # place i-th integer first \n                # in the current permutation\n                nums[first], nums[i] = nums[i], nums[first]\n                # use next integers to complete the permutations\n                backtrack(first + 1)\n                # backtrack\n                nums[first], nums[i] = numsnums[i], nums[first]\n        \n        n = len(nums)\n        output = []\n        backtrack()\n        return output"}, {"task_id": "permutations", "completion": "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(first = 0):\n            # if all integers are used up\n            if first == n:  \n                output.append(nums[:])\n            for i in range(first, n):\n                # place i-th integer first \n                # in the current permutation\n                nums[first], nums[i] = nums[i], nums[first]\n                # use next integers to complete the permutations\n                backtrack(first + 1)\n                # backtrack\n                nums[first], nums[i] = numsnums[i], nums[first]\n        \n        n = len(nums)\n        output = []\n        backtrack()\n        return output"}, {"task_id": "permutations", "completion": "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(first = 0):\n            # if all integers are used up\n            if first == n:  \n                output.append(nums[:])\n            for i in range(first, n):\n                # place i-th integer first \n                # in the current permutation\n                nums[first], nums[i] = nums[i], nums[first]\n                # use next integers to complete the permutations\n                backtrack(first + 1)\n                # backtrack\n                nums[first], nums[i] = numsnums[i], nums[first]\n        \n        n = len(nums)\n        output = []\n        backtrack()\n        return output"}, {"task_id": "permutations", "completion": "class Solution(object):\n    def permute(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: List[List[int]]\n        \"\"\"\n        \n        def backtrack(first = 0):\n            # if all integers are used up\n            if first == n:  \n                output.append(nums[:])\n            for i in range(first, n):\n                # place i-th integer first \n                # in the current permutation\n                nums[first], nums[i] = nums[i], nums[first]\n                # use next integers to complete the permutations\n                backtrack(first + 1)\n                # backtrack\n                nums[first], nums[i] = numsnums[i], nums[first]\n        \n        n = len(nums)\n        output = []\n        backtrack()\n        return output"}], "search-a-2d-matrix": [{"task_id": "search-a-2d-matrix", "completion": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        left = 0\n        right = m*n - 1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            row = mid // n\n            col = mid % n\n            \n            if matrix[row][col] == target:\n                return True\n            elif matrix[row][col] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return False"}, {"task_id": "search-a-2d-matrix", "completion": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        left = 0\n        right = m*n - 1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            row = mid // n\n            col = mid % n\n            if matrix[row][col] == target:\n                return True\n            elif matrix[row][col] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return False"}, {"task_id": "search-a-2d-matrix", "completion": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        left = 0\n        right = m*n - 1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            mid_element = matrix[mid // n][mid % n]\n            \n            if target == mid_element:\n                return True\n            elif target < mid_element:\n                right = mid - 1\n            else:\n                left = mid + 1\n                \n        return False"}, {"task_id": "search-a-2d-matrix", "completion": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        left = 0\n        right = m*n - 1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            row = mid // n\n            col = mid % n\n            \n            if matrix[row][col] == target:\n                return True\n            elif matrix[row][col] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return False"}, {"task_id": "search-a-2d-matrix", "completion": "class Solution(object):\n    def searchMatrix(self, matrix, target):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :type target: int\n        :rtype: bool\n        \"\"\"\n        \n        m = len(matrix)\n        n = len(matrix[0])\n        \n        left = 0\n        right = m*n - 1\n        \n        while left <= right:\n            mid = (left + right) // 2\n            row = mid // n\n            col = mid % n\n            \n            if matrix[row][col] == target:\n                return True\n            elif matrix[row][col] < target:\n                left = mid + 1\n            else:\n                right = mid - 1\n        \n        return False"}], "add-two-numbers": [{"task_id": "add-two-numbers", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # create a dummy node to store the result\n        dummy = ListNode(0)\n        curr = dummy\n        carry = 0\n        \n        # loop through both linked lists\n        while l1 or l2 or carry:\n            # get the value of the current node in each linked list\n            val1 = l1.val if l1 else 0\n            val2 = l2.val if l2 else 0\n            \n            # calculate the sum of the values and the carry\n            sum = val1 + val2 + carry\n            \n            # update the carry\n            carry = sum // 10\n            \n            # create a new node with the last digit of the sum\n            curr.next = ListNode(sum % 10)\n            \n            # move to the next node in each linked list\n            curr = curr.next\n            l1 = l1.next if l1 else None\n            l2 = l2.next if l2 else None\n        \n        # return the result linked list (excluding the dummy node)\n        return dummy.next"}, {"task_id": "add-two-numbers", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # create a dummy node to store the result\n        dummy = ListNode(0)\n        curr = dummy\n        carry = 0\n        \n        # loop through both linked lists\n        while l1 or l2 or carry:\n            # get the value of the current node in each linked list\n            val1 = l1.val if l1 else 0\n            val2 = l2.val if l2 else 0\n            \n            # calculate the sum of the values and the carry\n            sum = val1 + val2 + carry\n            carry = sum // 10\n            sum = sum % 10\n            \n            # create a new node with the sum value\n            curr.next = ListNode(sum)\n            curr = curr.next\n            \n            # move to the next node in each linked list\n            l1 = l1.next if l1 else None\n            l2 = l2.next if l2 else None\n        \n        # return the result linked list (excluding the dummy node)\n        return dummy.next"}, {"task_id": "add-two-numbers", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # create a dummy node to store the result\n        dummy = ListNode(0)\n        # create a pointer to the dummy node\n        curr = dummy\n        # create a carry variable to store the carry\n        carry = 0\n        \n        # loop until both lists are empty\n        while l1 or l2 or carry:\n            # if l1 is not empty, add the value to the carry\n            if l1:\n                carry += l1.val\n                l1 = l1.next\n            # if l2 is not empty, add the value to the carry\n            if l2:\n                carry += l2.val\n                l2 = l2.next\n            # create a new node with the carry % 10\n            curr.next = ListNode(carry % 10)\n            # update the carry\n            carry //= 10\n            # update the curr pointer\n            curr = curr.next\n        \n        # return the next node of the dummy node\n        return dummy.next"}, {"task_id": "add-two-numbers", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # create a dummy node to store the result\n        dummy = ListNode(0)\n        curr = dummy\n        carry = 0\n        \n        # loop through both linked lists\n        while l1 or l2 or carry:\n            # get the value of the current node in each linked list\n            val1 = l1.val if l1 else 0\n            val2 = l2.val if l2 else 0\n            \n            # calculate the sum of the values and the carry\n            sum = val1 + val2 + carry\n            carry = sum // 10\n            sum = sum % 10\n            \n            # create a new node with the sum as the value\n            curr.next = ListNode(sum)\n            curr = curr.next\n            \n            # move to the next node in each linked list\n            l1 = l1.next if l1 else None\n            l2 = l2.next if l2 else None\n        \n        # return the result linked list (excluding the dummy node)\n        return dummy.next"}, {"task_id": "add-two-numbers", "completion": "# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\nclass Solution(object):\n    def addTwoNumbers(self, l1, l2):\n        \"\"\"\n        :type l1: ListNode\n        :type l2: ListNode\n        :rtype: ListNode\n        \"\"\"\n        \n        # create a dummy node to store the result\n        dummy = ListNode(0)\n        curr = dummy\n        carry = 0\n        \n        # loop through both linked lists\n        while l1 or l2 or carry:\n            # get the value of the current node in each linked list\n            val1 = l1.val if l1 else 0\n            val2 = l2.val if l2 else 0\n            \n            # calculate the sum of the values and the carry\n            sum = val1 + val2 + carry\n            carry = sum // 10\n            sum = sum % 10\n            \n            # create a new node with the sum value\n            curr.next = ListNode(sum)\n            curr = curr.next\n            \n            # move to the next node in each linked list\n            l1 = l1.next if l1 else None\n            l2 = l2.next if l2 else None\n        \n        # return the result linked list (excluding the dummy node)\n        return dummy.next"}], "number-complement": [{"task_id": "number-complement", "completion": "class Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        # convert to binary\n        binary = bin(num)[2:]\n        \n        # flip 0s to 1s and 1s to 0s\n        flipped = ''\n        for i in binary:\n            if i == '0':\n                flipped += '1'\n            else:\n                flipped += '0'\n        \n        # convert back to decimal\n        return int(flipped, 2)"}, {"task_id": "number-complement", "completion": "class Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        # convert to binary\n        binary = bin(num)[2:]\n        \n        # flip 0s to 1s and 1s to 0s\n        flipped = \"\"\n        for i in binary:\n            if i == \"0\":\n                flipped += \"1\"\n            else:\n                flipped += \"0\"\n        \n        # convert to decimal\n        return int(flipped, 2)"}, {"task_id": "number-complement", "completion": "class Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        # convert to binary\n        binary = bin(num)[2:]\n        \n        # flip 0s to 1s and 1s to 0s\n        flipped = \"\"\n        for i in binary:\n            if i == \"0\":\n                flipped += \"1\"\n            else:\n                flipped += \"0\"\n        \n        # convert back to decimal\n        return int(flipped, 2)"}, {"task_id": "number-complement", "completion": "class Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        # convert to binary\n        binary = bin(num)[2:]\n        \n        # flip 0s to 1s and 1s to 0s\n        flipped = \"\"\n        for i in binary:\n            if i == \"0\":\n                flipped += \"1\"\n            else:\n                flipped += \"0\"\n        \n        # convert to decimal\n        return int(flipped, 2)"}, {"task_id": "number-complement", "completion": "class Solution(object):\n    def findComplement(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: int\n        \"\"\"\n        \n        # convert to binary\n        binary = bin(num)[2:]\n        \n        # flip 0s to 1s and 1s to 0s\n        flipped = ''\n        for i in binary:\n            if i == '0':\n                flipped += '1'\n            else:\n                flipped += '0'\n        \n        # convert back to decimal\n        return int(flipped, 2)"}], "arithmetic-slices-ii-subsequence": [{"task_id": "arithmetic-slices-ii-subsequence", "completion": "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(nums)\n        if n < 3:\n            return 0\n        \n        dp = [0] * n\n        for i in range(2, n):\n            if nums[i] - nums[i-1] == nums[i-1] - nums[i-2]:\n                dp[i] = dp[i-1] + 1\n        \n        return sum(dp)"}, {"task_id": "arithmetic-slices-ii-subsequence", "completion": "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(nums)\n        if n < 3:\n            return 0\n        \n        dp = [0] * n\n        for i in range(2, n):\n            if nums[i] - nums[i-1] == nums[i-1] - nums[i-2]:\n                dp[i] = dp[i-1] + 1\n        \n        return sum(dp)"}, {"task_id": "arithmetic-slices-ii-subsequence", "completion": "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(nums)\n        if n < 3:\n            return 0\n        \n        dp = [0] * n\n        for i in range(2, n):\n            if nums[i] - nums[i-1] == nums[i-1] - nums[i-2]:\n                dp[i] = dp[i-1] + 1\n        \n        return sum(dp)"}, {"task_id": "arithmetic-slices-ii-subsequence", "completion": "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(nums)\n        if n < 3:\n            return 0\n        \n        dp = [0] * n\n        for i in range(2, n):\n            if nums[i] - nums[i-1] == nums[i-1] - nums[i-2]:\n                dp[i] = dp[i-1] + 1\n        \n        return sum(dp)"}, {"task_id": "arithmetic-slices-ii-subsequence", "completion": "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        n = len(nums)\n        if n < 3:\n            return 0\n        \n        dp = [0] * n\n        for i in range(2, n):\n            if nums[i] - nums[i-1] == nums[i-1] - nums[i-2]:\n                dp[i] = dp[i-1] + 1\n        \n        return sum(dp)"}], "text-justification": [{"task_id": "text-justification", "completion": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def justify(words, maxWidth):\n            if len(words) == 1:\n                return words[0] + ' ' * (maxWidth - len(words[0]))\n            else:\n                spaces = maxWidth - sum(len(word) for word in words)\n                gaps = len(words) - 1\n                space_widths = [spaces // gaps] * gaps\n                for i in range(spaces % gaps):\n                    space_widths[i] += 1\n                return (' ' * space_widths[0]).join(words) + ' ' * space"}, {"task_id": "text-justification", "completion": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def justify(words, maxWidth, is_last=False):\n            if len(words) == 1:\n                return words[0] + ' ' * (maxWidth - len(words[0]))\n            \n            total_len = sum(len(word) for word in words)\n            space_len = maxWidth - total_len\n            space_between = space_len // (len(words) - 1)\n            space_extra = space_len % (len(words) - 1)\n            \n            if is_last:\n                return (' ' * space_between).join(words) + ' ' * space_extra\n            \n            res = ''\n            for i in range(len(words) - 1):\n                res += words[i] + ' ' * space_between\n                if i < space_extra:\n                    res += ' '\n            res += words[-1]\n            return res\n        \n        res = []\n        cur = []\n        cur_len = 0\n        for word in words:\n            if cur_len + len(word) + len(cur) > maxWidth:\n                res.append(justify(cur, maxWidth))\n                cur = []\n                cur_len = 0\n            cur.append(word)\n            cur_len += len(word)\n        res.append(justify(cur, maxWidth, True))\n        return res"}, {"task_id": "text-justification", "completion": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        \n        # 1. \u5148\u628awords\u5206\u6210\u82e5\u5e72\u4e2a\u5b50\u6570\u7ec4\uff0c\u6bcf\u4e2a\u5b50\u6570\u7ec4\u7684\u957f\u5ea6\u4e0d\u8d85\u8fc7maxWidth\n        # 2. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u5b50\u6570\u7ec4\u7684\u957f\u5ea6\u5c0f\u4e8emaxWidth\uff0c\u5219\u5728\u5b50\u6570\u7ec4\u7684\u672b\u5c3e\u8865\u7a7a\u683c\uff0c\u76f4\u5230\u5b50\u6570\u7ec4\u7684\u957f\u5ea6\u7b49\u4e8emaxWidth\n        # 3. \u5bf9\u4e8e\u5b50\u6570\u7ec4\u7684\u6700\u540e\u4e00\u884c\uff0c\u5728\u5b50\u6570\u7ec4\u7684\u672b\u5c3e\u8865\u7a7a\u683c\uff0c\u76f4\u5230\u5b50\u6570\u7ec4\u7684\u957f\u5ea6\u7b49\u4e8emaxWidth\n        # 4. \u5bf9\u4e8e\u5b50\u6570\u7ec4\u7684\u5176\u4ed6\u884c\uff0c\u5728\u5b50\u6570\u7ec4\u7684\u672b\u5c3e\u8865\u7a7a\u683c\uff0c\u76f4\u5230\u5b50\u6570\u7ec4\u7684\u957f\u5ea6\u7b49\u4e8emaxWidth\n        # 5. \u5bf9\u4e8e\u5b50\u6570\u7ec4\u7684\u6700\u540e\u4e00\u884c\uff0c\u5728\u5b50\u6570\u7ec4\u7684\u672b\u5c3e\u8865\u7a7a\u683c\uff0c\u76f4\u5230\u5b50\u6570\u7ec4\u7684\u957f\u5ea6\u7b49\u4e8emaxWidth\n        # 6. \u5bf9\u4e8e\u5b50\u6570\u7ec4\u7684\u5176\u4ed6\u884c\uff0c\u5728\u5b50\u6570\u7ec4\u7684\u672b\u5c3e\u8865\u7a7a\u683c\uff0c\u76f4\u5230\u5b50\u6570\u7ec4\u7684\u957f\u5ea6\u7b49\u4e8emaxWidth\n        # 7. \u5bf9\u4e8e\u5b50\u6570\u7ec4\u7684\u6700\u540e\u4e00\u884c\uff0c\u5728\u5b50\u6570\u7ec4\u7684\u672b\u5c3e\u8865\u7a7a\u683c\uff0c\u76f4\u5230\u5b50\u6570\u7ec4\u7684\u957f\u5ea6\u7b49\u4e8emaxWidth\n        # 8. \u5bf9\u4e8e\u5b50\u6570\u7ec4\u7684\u5176\u4ed6\u884c\uff0c\u5728\u5b50\u6570\u7ec4\u7684\u672b\u5c3e\u8865\u7a7a\u683c\uff0c\u76f4\u5230\u5b50\u6570\u7ec4\u7684\u957f\u5ea6\u7b49\u4e8emaxWidth\n        # 9. \u5bf9\u4e8e\u5b50\u6570\u7ec4\u7684\u6700\u540e\u4e00\u884c\uff0c\u5728\u5b50\u6570\u7ec4\u7684\u672b\u5c3e\u8865\u7a7a\u683c\uff0c\u76f4\u5230\u5b50\u6570\u7ec4\u7684\u957f\u5ea6\u7b49\u4e8emaxWidth\n        # 10. \u5bf9\u4e8e\u5b50\u6570\u7ec4\u7684\u5176\u4ed6\u884c\uff0c\u5728\u5b50\u6570\u7ec4\u7684\u672b\u5c3e\u8865\u7a7a\u683c\uff0c\u76f4\u5230\u5b50\u6570\u7ec4\u7684\u957f\u5ea6\u7b49\u4e8emaxWidth\n        # 11. \u5bf9\u4e8e\u5b50\u6570\u7ec4\u7684\u6700\u540e\u4e00\u884c\uff0c\u5728\u5b50\u6570\u7ec4\u7684\u672b\u5c3e\u8865\u7a7a\u683c\uff0c\u76f4\u5230\u5b50\u6570\u7ec4\u7684\u957f\u5ea6\u7b49\u4e8emaxWidth\n        # 12. \u5bf9\u4e8e\u5b50\u6570\u7ec4\u7684\u5176\u4ed6\u884c\uff0c\u5728\u5b50\u6570\u7ec4\u7684\u672b\u5c3e\u8865\u7a7a\u683c\uff0c\u76f4\u5230\u5b50\u6570\u7ec4\u7684\u957f\u5ea6\u7b49\u4e8emaxWidth\n        # 13. \u5bf9\u4e8e\u5b50\u6570\u7ec4\u7684\u6700\u540e\u4e00\u884c\uff0c\u5728\u5b50\u6570\u7ec4\u7684\u672b\u5c3e\u8865\u7a7a\u683c\uff0c\u76f4\u5230\u5b50\u6570\u7ec4\u7684\u957f\u5ea6\u7b49\u4e8emaxWidth\n        # 14. \u5bf9\u4e8e\u5b50\u6570\u7ec4\u7684\u5176\u4ed6\u884c\uff0c\u5728\u5b50\u6570\u7ec4\u7684\u672b\u5c3e\u8865\u7a7a\u683c\uff0c\u76f4\u5230\u5b50\u6570\u7ec4\u7684\u957f\u5ea6\u7b49\u4e8emaxWidth\n        # 15. \u5bf9\u4e8e\u5b50\u6570\u7ec4\u7684\u6700\u540e\u4e00\u884c\uff0c\u5728\u5b50\u6570\u7ec4\u7684\u672b\u5c3e\u8865\u7a7a\u683c\uff0c\u76f4\u5230\u5b50\u6570\u7ec4\u7684\u957f\u5ea6\u7b49\u4e8emaxWidth\n        # 16. \u5bf9\u4e8e\u5b50\u6570\u7ec4\u7684\u5176\u4ed6\u884c\uff0c\u5728\u5b50\u6570\u7ec4\u7684\u672b\u5c3e\u8865\u7a7a\u683c\uff0c\u76f4\u5230\u5b50\u6570\u7ec4\u7684\u957f\u5ea6\u7b49\u4e8emaxWidth\n        # 17. \u5bf9\u4e8e\u5b50\u6570\u7ec4\u7684\u6700\u540e\u4e00\u884c\uff0c\u5728\u5b50\u6570\u7ec4\u7684\u672b\u5c3e\u8865\u7a7a\u683c\uff0c\u76f4\u5230\u5b50\u6570\u7ec4\u7684\u957f\u5ea6\u7b49\u4e8emaxWidth\n        # 18. \u5bf9\u4e8e\u5b50\u6570\u7ec4\u7684\u5176\u4ed6\u884c\uff0c\u5728\u5b50\u6570\u7ec4\u7684\u672b\u5c3e\u8865\u7a7a\u683c\uff0c\u76f4\u5230\u5b50\u6570\u7ec4\u7684\u957f\u5ea6\u7b49\u4e8emaxWidth\n        # 19. \u5bf9\u4e8e\u5b50\u6570\u7ec4\u7684\u6700\u540e\u4e00\u884c\uff0c\u5728\u5b50\u6570\u7ec4\u7684\u672b\u5c3e\u8865\u7a7a\u683c\uff0c\u76f4\u5230\u5b50\u6570\u7ec4\u7684\u957f\u5ea6\u7b49\u4e8emaxWidth\n        # 20. \u5bf9\u4e8e\u5b50\u6570\u7ec4\u7684\u5176\u4ed6\u884c\uff0c\u5728\u5b50\u6570\u7ec4\u7684\u672b\u5c3e\u8865\u7a7a\u683c\uff0c\u76f4\u5230\u5b50\u6570\u7ec4\u7684\u957f\u5ea6\u7b49\u4e8emaxWidth\n        # 21. \u5bf9\u4e8e\u5b50\u6570\u7ec4\u7684\u6700\u540e\u4e00\u884c\uff0c\u5728\u5b50\u6570\u7ec4\u7684\u672b\u5c3e\u8865\u7a7a\u683c\uff0c\u76f4\u5230\u5b50\u6570\u7ec4\u7684\u957f\u5ea6\u7b49\u4e8emaxWidth\n        # 22. \u5bf9\u4e8e\u5b50\u6570\u7ec4\u7684\u5176\u4ed6\u884c\uff0c\u5728\u5b50\u6570\u7ec4\u7684\u672b\u5c3e\u8865\u7a7a\u683c\uff0c\u76f4\u5230\u5b50\u6570\u7ec4\u7684\u957f\u5ea6\u7b49\u4e8emaxWidth\n        # 23. \u5bf9\u4e8e\u5b50\u6570\u7ec4\u7684\u6700\u540e\u4e00\u884c\uff0c\u5728\u5b50\u6570\u7ec4\u7684\u672b\u5c3e\u8865\u7a7a\u683c\uff0c\u76f4\u5230\u5b50\u6570\u7ec4\u7684\u957f\u5ea6\u7b49\u4e8emaxWidth\n        # 24. \u5bf9\u4e8e\u5b50\u6570\u7ec4\u7684\u5176\u4ed6\u884c\uff0c\u5728\u5b50\u6570\u7ec4\u7684\u672b\u5c3e\u8865\u7a7a\u683c\uff0c\u76f4\u5230\u5b50\u6570\u7ec4\u7684\u957f\u5ea6\u7b49\u4e8emaxWidth\n        # 25. \u5bf9\u4e8e\u5b50\u6570\u7ec4\u7684\u6700\u540e\u4e00\u884c\uff0c\u5728\u5b50\u6570\u7ec4\u7684\u672b\u5c3e\u8865\u7a7a\u683c\uff0c\u76f4\u5230\u5b50\u6570\u7ec4\u7684\u957f\u5ea6\u7b49\u4e8emaxWidth\n        # 26. \u5bf9\u4e8e\u5b50\u6570\u7ec4\u7684\u5176\u4ed6\u884c\uff0c\u5728\u5b50\u6570\u7ec4\u7684\u672b\u5c3e\u8865\u7a7a\u683c\uff0c\u76f4\u5230\u5b50\u6570\u7ec4\u7684\u957f\u5ea6\u7b49\u4e8emaxWidth\n        # 27. \u5bf9\u4e8e\u5b50\u6570\u7ec4\u7684\u6700\u540e\u4e00\u884c\uff0c\u5728\u5b50\u6570\u7ec4\u7684\u672b\u5c3e\u8865\u7a7a\u683c\uff0c\u76f4\u5230\u5b50"}, {"task_id": "text-justification", "completion": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        \n        def justify(words, maxWidth):\n            if len(words) == 1:\n                return words[0] + ' ' * (maxWidth - len(words[0]))\n            else:\n                spaces = maxWidth - sum(len(word) for word in words)\n                gaps = len(words) - 1\n                space_widths = [spaces // gaps] * gaps\n                for i in range(spaces % gaps):\n                    space_widths[i] += 1\n                return (' ' * space_widths[0]).join(words) + ' ' * space"}, {"task_id": "text-justification", "completion": "class Solution(object):\n    def fullJustify(self, words, maxWidth):\n        \"\"\"\n        :type words: List[str]\n        :type maxWidth: int\n        :rtype: List[str]\n        \"\"\"\n        \n        # 1. \u5148\u628awords\u5206\u6210\u82e5\u5e72\u4e2a\u5b50\u6570\u7ec4\uff0c\u6bcf\u4e2a\u5b50\u6570\u7ec4\u7684\u957f\u5ea6\u4e0d\u8d85\u8fc7maxWidth\n        # 2. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5982\u679c\u6709\u591a\u4e2a\u5355\u8bcd\uff0c\u5219\u4e24\u7aef\u5bf9\u9f50\n        # 3. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5982\u679c\u6709\u591a\u4e2a\u5355\u8bcd\uff0c\u5219\u4e24\u7aef\u5bf9\u9f50\n        # 4. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5982\u679c\u6709\u591a\u4e2a\u5355\u8bcd\uff0c\u5219\u4e24\u7aef\u5bf9\u9f50\n        # 5. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5982\u679c\u6709\u591a\u4e2a\u5355\u8bcd\uff0c\u5219\u4e24\u7aef\u5bf9\u9f50\n        # 6. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5982\u679c\u6709\u591a\u4e2a\u5355\u8bcd\uff0c\u5219\u4e24\u7aef\u5bf9\u9f50\n        # 7. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5982\u679c\u6709\u591a\u4e2a\u5355\u8bcd\uff0c\u5219\u4e24\u7aef\u5bf9\u9f50\n        # 8. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5982\u679c\u6709\u591a\u4e2a\u5355\u8bcd\uff0c\u5219\u4e24\u7aef\u5bf9\u9f50\n        # 9. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5982\u679c\u6709\u591a\u4e2a\u5355\u8bcd\uff0c\u5219\u4e24\u7aef\u5bf9\u9f50\n        # 10. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5982\u679c\u6709\u591a\u4e2a\u5355\u8bcd\uff0c\u5219\u4e24\u7aef\u5bf9\u9f50\n        # 11. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5982\u679c\u6709\u591a\u4e2a\u5355\u8bcd\uff0c\u5219\u4e24\u7aef\u5bf9\u9f50\n        # 12. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5982\u679c\u6709\u591a\u4e2a\u5355\u8bcd\uff0c\u5219\u4e24\u7aef\u5bf9\u9f50\n        # 13. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5982\u679c\u6709\u591a\u4e2a\u5355\u8bcd\uff0c\u5219\u4e24\u7aef\u5bf9\u9f50\n        # 14. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5982\u679c\u6709\u591a\u4e2a\u5355\u8bcd\uff0c\u5219\u4e24\u7aef\u5bf9\u9f50\n        # 15. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5982\u679c\u6709\u591a\u4e2a\u5355\u8bcd\uff0c\u5219\u4e24\u7aef\u5bf9\u9f50\n        # 16. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5982\u679c\u6709\u591a\u4e2a\u5355\u8bcd\uff0c\u5219\u4e24\u7aef\u5bf9\u9f50\n        # 17. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5982\u679c\u6709\u591a\u4e2a\u5355\u8bcd\uff0c\u5219\u4e24\u7aef\u5bf9\u9f50\n        # 18. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5982\u679c\u6709\u591a\u4e2a\u5355\u8bcd\uff0c\u5219\u4e24\u7aef\u5bf9\u9f50\n        # 19. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5982\u679c\u6709\u591a\u4e2a\u5355\u8bcd\uff0c\u5219\u4e24\u7aef\u5bf9\u9f50\n        # 20. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5982\u679c\u6709\u591a\u4e2a\u5355\u8bcd\uff0c\u5219\u4e24\u7aef\u5bf9\u9f50\n        # 21. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5982\u679c\u6709\u591a\u4e2a\u5355\u8bcd\uff0c\u5219\u4e24\u7aef\u5bf9\u9f50\n        # 22. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5982\u679c\u6709\u591a\u4e2a\u5355\u8bcd\uff0c\u5219\u4e24\u7aef\u5bf9\u9f50\n        # 23. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5982\u679c\u6709\u591a\u4e2a\u5355\u8bcd\uff0c\u5219\u4e24\u7aef\u5bf9\u9f50\n        # 24. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5982\u679c\u6709\u591a\u4e2a\u5355\u8bcd\uff0c\u5219\u4e24\u7aef\u5bf9\u9f50\n        # 25. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5982\u679c\u6709\u591a\u4e2a\u5355\u8bcd\uff0c\u5219\u4e24\u7aef\u5bf9\u9f50\n        # 26. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5982\u679c\u6709\u591a\u4e2a\u5355\u8bcd\uff0c\u5219\u4e24\u7aef\u5bf9\u9f50\n        # 27. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5982\u679c\u6709\u591a\u4e2a\u5355\u8bcd\uff0c\u5219\u4e24\u7aef\u5bf9\u9f50\n        # 28. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5982\u679c\u6709\u591a\u4e2a\u5355\u8bcd\uff0c\u5219\u4e24\u7aef\u5bf9\u9f50\n        # 29. \u5bf9\u4e8e\u6bcf\u4e2a\u5b50\u6570\u7ec4\uff0c\u5982\u679c\u53ea\u6709\u4e00\u4e2a\u5355\u8bcd\uff0c\u5219\u5de6\u5bf9\u9f50\uff0c\u5982\u679c\u6709\u591a\u4e2a\u5355\u8bcd\uff0c"}], "binary-tree-postorder-traversal": [{"task_id": "binary-tree-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        # Recursive solution\n        # if root is None:\n        #     return []\n        # return self.postorderTraversal(root.left) + self.postorderTraversal(root.right) + [root.val]\n        \n        # Iterative solution\n        if root is None:\n            return []\n        stack = [root]\n        res = []\n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            if node.left:\n                stack.append(node.left)\n            if node.right:\n                stack.append(node.right)\n        return res[::-1]"}, {"task_id": "binary-tree-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        # Recursive solution\n        # if root is None:\n        #     return []\n        # return self.postorderTraversal(root.left) + self.postorderTraversal(root.right) + [root.val]\n        \n        # Iterative solution\n        if root is None:\n            return []\n        stack = [root]\n        res = []\n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            if node.left:\n                stack.append(node.left)\n            if node.right:\n                stack.append(node.right)\n        return res[::-1]"}, {"task_id": "binary-tree-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        # Recursive solution\n        # if not root:\n        #     return []\n        # return self.postorderTraversal(root.left) + self.postorderTraversal(root.right) + [root.val]\n        \n        # Iterative solution\n        if not root:\n            return []\n        stack = [root]\n        res = []\n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            if node.left:\n                stack.append(node.left)\n            if node.right:\n                stack.append(node.right)\n        return res[::-1]"}, {"task_id": "binary-tree-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        # Recursive solution\n        # if root is None:\n        #     return []\n        # return self.postorderTraversal(root.left) + self.postorderTraversal(root.right) + [root.val]\n        \n        # Iterative solution\n        if root is None:\n            return []\n        stack = [root]\n        res = []\n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            if node.left:\n                stack.append(node.left)\n            if node.right:\n                stack.append(node.right)\n        return res[::-1]"}, {"task_id": "binary-tree-postorder-traversal", "completion": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def postorderTraversal(self, root):\n        \"\"\"\n        :type root: TreeNode\n        :rtype: List[int]\n        \"\"\"\n        \n        # Recursive solution\n        # if root is None:\n        #     return []\n        # return self.postorderTraversal(root.left) + self.postorderTraversal(root.right) + [root.val]\n        \n        # Iterative solution\n        if root is None:\n            return []\n        stack = [root]\n        res = []\n        while stack:\n            node = stack.pop()\n            res.append(node.val)\n            if node.left:\n                stack.append(node.left)\n            if node.right:\n                stack.append(node.right)\n        return res[::-1]"}], "container-with-most-water": [{"task_id": "container-with-most-water", "completion": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 2 pointer approach\n        # time complexity: O(n)\n        # space complexity: O(1)\n        \n        left = 0\n        right = len(height) - 1\n        max_area = 0\n        \n        while left < right:\n            max_area = max(max_area, min(height[left], height[right]) * (right - left))\n            if height[left] < height[right]:\n                left += 1\n            else:\n                right -= 1\n                \n        return max_area"}, {"task_id": "container-with-most-water", "completion": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 2 pointer approach\n        # time complexity: O(n)\n        # space complexity: O(1)\n        \n        left = 0\n        right = len(height) - 1\n        max_area = 0\n        \n        while left < right:\n            max_area = max(max_area, min(height[left], height[right]) * (right - left))\n            if height[left] < height[right]:\n                left += 1\n            else:\n                right -= 1\n                \n        return max_area"}, {"task_id": "container-with-most-water", "completion": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 2 pointer approach\n        # time complexity: O(n)\n        # space complexity: O(1)\n        \n        left = 0\n        right = len(height) - 1\n        max_area = 0\n        \n        while left < right:\n            max_area = max(max_area, min(height[left], height[right]) * (right - left))\n            if height[left] < height[right]:\n                left += 1\n            else:\n                right -= 1\n                \n        return max_area"}, {"task_id": "container-with-most-water", "completion": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 2 pointer approach\n        # time complexity: O(n)\n        # space complexity: O(1)\n        \n        left = 0\n        right = len(height) - 1\n        max_area = 0\n        \n        while left < right:\n            max_area = max(max_area, min(height[left], height[right]) * (right - left))\n            if height[left] < height[right]:\n                left += 1\n            else:\n                right -= 1\n                \n        return max_area"}, {"task_id": "container-with-most-water", "completion": "class Solution(object):\n    def maxArea(self, height):\n        \"\"\"\n        :type height: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 2 pointer approach\n        # time complexity: O(n)\n        # space complexity: O(1)\n        \n        left = 0\n        right = len(height) - 1\n        max_area = 0\n        \n        while left < right:\n            max_area = max(max_area, min(height[left], height[right]) * (right - left))\n            if height[left] < height[right]:\n                left += 1\n            else:\n                right -= 1\n                \n        return max_area"}], "concatenated-words": [{"task_id": "concatenated-words", "completion": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        words.sort(key=lambda x: len(x))\n        word_set = set()\n        res = []\n        \n        for word in words:\n            if self.dfs(word, word_set):\n                res.append(word)\n            word_set.add(word)\n        return res\n    \n    def dfs(self, word, word_set):\n        for i in range(1, len(word)):\n            prefix = word[:i]\n            suffix = word[i:]\n            if prefix in word_set and suffix in word_set:\n                return True\n            if prefix in word_set and self.dfs(suffix, word_set):\n                return True\n        return False"}, {"task_id": "concatenated-words", "completion": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        words.sort(key=lambda x: len(x))\n        words_set = set(words)\n        res = []\n        \n        def dfs(word):\n            if word in words_set:\n                return True\n            for i in range(1, len(word)):\n                prefix = word[:i]\n                suffix = word[i:]\n                if prefix in words_set and dfs(suffix):\n                    return True\n            return False\n        \n        for word in words:\n            if dfs(word):\n                res.append(word)\n        return res"}, {"task_id": "concatenated-words", "completion": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        words.sort(key=lambda x: len(x))\n        words_set = set(words)\n        res = []\n        \n        def dfs(word):\n            if word in words_set:\n                return True\n            for i in range(1, len(word)):\n                prefix = word[:i]\n                suffix = word[i:]\n                if prefix in words_set and dfs(suffix):\n                    return True\n            return False\n        \n        for word in words:\n            if dfs(word):\n                res.append(word)\n        return res"}, {"task_id": "concatenated-words", "completion": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        words.sort(key=lambda x: len(x))\n        words_set = set(words)\n        res = []\n        \n        def dfs(word):\n            if word in words_set:\n                return True\n            for i in range(1, len(word)):\n                prefix = word[:i]\n                suffix = word[i:]\n                if prefix in words_set and dfs(suffix):\n                    return True\n            return False\n        \n        for word in words:\n            if dfs(word):\n                res.append(word)\n        return res"}, {"task_id": "concatenated-words", "completion": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        \n        words.sort(key=lambda x: len(x))\n        word_set = set()\n        res = []\n        \n        def dfs(word):\n            if word in word_set:\n                return True\n            for i in range(1, len(word)):\n                prefix = word[:i]\n                suffix = word[i:]\n                if prefix in word_set and suffix in word_set:\n                    return True\n                if prefix in word_set and dfs(suffix):\n                    return True\n            return False\n        \n        for word in words:\n            if dfs(word):\n                res.append(word)\n            word_set.add(word)\n        return res"}], "base-7": [{"task_id": "base-7", "completion": "class Solution(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        if num < 0:\n            return \"-\" + self.convertToBase7(-num)\n        \n        res = \"\"\n        while num > 0:\n            res = str(num % 7) + res\n            num = num // 7\n        \n        return res"}, {"task_id": "base-7", "completion": "class Solution(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        if num < 0:\n            return \"-\" + self.convertToBase7(-num)\n        \n        res = \"\"\n        while num > 0:\n            res = str(num % 7) + res\n            num //= 7\n        \n        return res"}, {"task_id": "base-7", "completion": "class Solution(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        if num < 0:\n            return \"-\" + self.convertToBase7(-num)\n        \n        res = \"\"\n        while num > 0:\n            res = str(num % 7) + res\n            num = num // 7\n        \n        return res"}, {"task_id": "base-7", "completion": "class Solution(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        if num < 0:\n            return \"-\" + self.convertToBase7(-num)\n        \n        res = \"\"\n        while num > 0:\n            res = str(num % 7) + res\n            num = num // 7\n        \n        return res"}, {"task_id": "base-7", "completion": "class Solution(object):\n    def convertToBase7(self, num):\n        \"\"\"\n        :type num: int\n        :rtype: str\n        \"\"\"\n        \n        if num == 0:\n            return \"0\"\n        \n        if num < 0:\n            return \"-\" + self.convertToBase7(-num)\n        \n        res = \"\"\n        while num > 0:\n            res = str(num % 7) + res\n            num //= 7\n        \n        return res"}], "nim-game": [{"task_id": "nim-game", "completion": "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 3:\n            return True\n        if n == 4:\n            return False\n        if n == 5:\n            return True\n        if n == 6:\n            return True\n        if n == 7:\n            return True\n        if n == 8:\n            return False\n        if n == 9:\n            return True\n        if n == 10:\n            return True\n        if n == 11:\n            return True\n        if n == 12:\n            return False\n        if n == 13:\n            return True\n        if n == 14:\n            return True\n        if n == 15:\n            return True\n        if n == 16:\n            return False\n        if n == 17:\n            return True\n        if n == 18:\n            return True\n        if n == 19:\n            return True\n        if n == 20:\n            return False\n        if n == 21:\n            return True\n        if n == 22:\n            return True\n        if n == 23:\n            return True\n        if n == 24:\n            return False\n        if n == 25:\n            return True\n        if n == 26:\n            return True\n        if n == 27:\n            return True\n        if n == 28:\n            return False\n        if n == 29:\n            return True\n        if n == 30:\n            return True\n        if n == 31:\n            return True\n        if n == 32:\n            return False\n        if n == 33:\n            return True\n        if n == 34:\n            return True\n        if n == 35:\n            return True\n        if n == 36:\n            return False\n        if n == 37:\n            return True\n        if n == 38:\n            return True\n        if n == 39:\n            return True\n        if n == 40:\n            return False\n        if n == 41:\n            return True\n        if n == 42:\n            return True\n        if n == 43:\n            return True\n        if n == 44:\n            return False\n        if n == 45:\n            return True\n        if n == 46:\n            return True\n        if n == 47:\n            return True\n        if n == 48:\n            return False\n        if n == 49:\n            return True\n        if n == 50:\n            return True\n        if n == 51:\n            return True\n        if n == 52:\n            return False\n        if n == 53:\n            return True\n        if n == 54:\n            return True\n        if n == 55:\n            return True\n        if n == 56:\n            return False\n        if n == 57:\n            return True\n        if n == 58:\n            return True\n        if n == 59:\n            return True\n        if n == 60:\n            return False\n        if n == 61:\n            return True\n        if n == 62:\n            return True\n        if n == 63:\n            return True\n        if n == 64:\n            return False\n        if n == 65:\n            return True\n        if n == 66:\n            return True\n        if n == 67:\n            return True\n        if n == 68:\n            return False\n        if n == 69:\n            return True\n        if n == 70:\n            return True\n        if n == 71:\n            return True\n        if n == 72:\n            return False\n        if n == 73:\n            return True\n        if n == 74:\n            return True\n        if n == 75:\n            return True\n        if n == 76:\n            return False\n        if n == 77:\n            return True\n        if n == 78:\n            return True\n        if n == 79:\n            return True\n        if n == 80:\n            return False\n        if n == 81:\n            return True\n        if n == 82:\n            return True\n        if n == 83:\n            return True\n        if n == 84:\n            return False\n        if n == 85:\n            return True\n        if n == 86:\n            return True\n        if n == 87:\n            return True\n        if n == 88:\n            return"}, {"task_id": "nim-game", "completion": "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 3:\n            return True\n        if n == 4:\n            return False\n        if n == 5:\n            return True\n        if n == 6:\n            return True\n        if n == 7:\n            return True\n        if n == 8:\n            return False\n        if n == 9:\n            return True\n        if n == 10:\n            return True\n        if n == 11:\n            return True\n        if n == 12:\n            return False\n        if n == 13:\n            return True\n        if n == 14:\n            return True\n        if n == 15:\n            return True\n        if n == 16:\n            return False\n        if n == 17:\n            return True\n        if n == 18:\n            return True\n        if n == 19:\n            return True\n        if n == 20:\n            return False\n        if n == 21:\n            return True\n        if n == 22:\n            return True\n        if n == 23:\n            return True\n        if n == 24:\n            return False\n        if n == 25:\n            return True\n        if n == 26:\n            return True\n        if n == 27:\n            return True\n        if n == 28:\n            return False\n        if n == 29:\n            return True\n        if n == 30:\n            return True\n        if n == 31:\n            return True\n        if n == 32:\n            return False\n        if n == 33:\n            return True\n        if n == 34:\n            return True\n        if n == 35:\n            return True\n        if n == 36:\n            return False\n        if n == 37:\n            return True\n        if n == 38:\n            return True\n        if n == 39:\n            return True\n        if n == 40:\n            return False\n        if n == 41:\n            return True\n        if n == 42:\n            return True\n        if n == 43:\n            return True\n        if n == 44:\n            return False\n        if n == 45:\n            return True\n        if n == 46:\n            return True\n        if n == 47:\n            return True\n        if n == 48:\n            return False\n        if n == 49:\n            return True\n        if n == 50:\n            return True\n        if n == 51:\n            return True\n        if n == 52:\n            return False\n        if n == 53:\n            return True\n        if n == 54:\n            return True\n        if n == 55:\n            return True\n        if n == 56:\n            return False\n        if n == 57:\n            return True\n        if n == 58:\n            return True\n        if n == 59:\n            return True\n        if n == 60:\n            return False\n        if n == 61:\n            return True\n        if n == 62:\n            return True\n        if n == 63:\n            return True\n        if n == 64:\n            return False\n        if n == 65:\n            return True\n        if n == 66:\n            return True\n        if n == 67:\n            return True\n        if n == 68:\n            return False\n        if n == 69:\n            return True\n        if n == 70:\n            return True\n        if n == 71:\n            return True\n        if n == 72:\n            return False\n        if n == 73:\n            return True\n        if n == 74:\n            return True\n        if n == 75:\n            return True\n        if n == 76:\n            return False\n        if n == 77:\n            return True\n        if n == 78:\n            return True\n        if n == 79:\n            return True\n        if n == 80:\n            return False\n        if n == 81:\n            return True\n        if n == 82:\n            return True\n        if n == 83:\n            return True\n        if n == 84:\n            return False\n        if n == 85:\n            return True\n        if n == 86:\n            return True\n        if n == 87:\n            return True\n        if n == 88:\n            return"}, {"task_id": "nim-game", "completion": "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 3:\n            return True\n        if n == 4:\n            return False\n        if n == 5:\n            return True\n        if n == 6:\n            return True\n        if n == 7:\n            return True\n        if n == 8:\n            return False\n        if n == 9:\n            return True\n        if n == 10:\n            return True\n        if n == 11:\n            return True\n        if n == 12:\n            return False\n        if n == 13:\n            return True\n        if n == 14:\n            return True\n        if n == 15:\n            return True\n        if n == 16:\n            return False\n        if n == 17:\n            return True\n        if n == 18:\n            return True\n        if n == 19:\n            return True\n        if n == 20:\n            return False\n        if n == 21:\n            return True\n        if n == 22:\n            return True\n        if n == 23:\n            return True\n        if n == 24:\n            return False\n        if n == 25:\n            return True\n        if n == 26:\n            return True\n        if n == 27:\n            return True\n        if n == 28:\n            return False\n        if n == 29:\n            return True\n        if n == 30:\n            return True\n        if n == 31:\n            return True\n        if n == 32:\n            return False\n        if n == 33:\n            return True\n        if n == 34:\n            return True\n        if n == 35:\n            return True\n        if n == 36:\n            return False\n        if n == 37:\n            return True\n        if n == 38:\n            return True\n        if n == 39:\n            return True\n        if n == 40:\n            return False\n        if n == 41:\n            return True\n        if n == 42:\n            return True\n        if n == 43:\n            return True\n        if n == 44:\n            return False\n        if n == 45:\n            return True\n        if n == 46:\n            return True\n        if n == 47:\n            return True\n        if n == 48:\n            return False\n        if n == 49:\n            return True\n        if n == 50:\n            return True\n        if n == 51:\n            return True\n        if n == 52:\n            return False\n        if n == 53:\n            return True\n        if n == 54:\n            return True\n        if n == 55:\n            return True\n        if n == 56:\n            return False\n        if n == 57:\n            return True\n        if n == 58:\n            return True\n        if n == 59:\n            return True\n        if n == 60:\n            return False\n        if n == 61:\n            return True\n        if n == 62:\n            return True\n        if n == 63:\n            return True\n        if n == 64:\n            return False\n        if n == 65:\n            return True\n        if n == 66:\n            return True\n        if n == 67:\n            return True\n        if n == 68:\n            return False\n        if n == 69:\n            return True\n        if n == 70:\n            return True\n        if n == 71:\n            return True\n        if n == 72:\n            return False\n        if n == 73:\n            return True\n        if n == 74:\n            return True\n        if n == 75:\n            return True\n        if n == 76:\n            return False\n        if n == 77:\n            return True\n        if n == 78:\n            return True\n        if n == 79:\n            return True\n        if n == 80:\n            return False\n        if n == 81:\n            return True\n        if n == 82:\n            return True\n        if n == 83:\n            return True\n        if n == 84:\n            return False\n        if n == 85:\n            return True\n        if n == 86:\n            return True\n        if n == 87:\n            return True\n        if n == 88:\n            return"}, {"task_id": "nim-game", "completion": "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 3:\n            return True\n        if n == 4:\n            return False\n        if n == 5:\n            return True\n        if n == 6:\n            return True\n        if n == 7:\n            return True\n        if n == 8:\n            return False\n        if n == 9:\n            return True\n        if n == 10:\n            return True\n        if n == 11:\n            return True\n        if n == 12:\n            return False\n        if n == 13:\n            return True\n        if n == 14:\n            return True\n        if n == 15:\n            return True\n        if n == 16:\n            return False\n        if n == 17:\n            return True\n        if n == 18:\n            return True\n        if n == 19:\n            return True\n        if n == 20:\n            return False\n        if n == 21:\n            return True\n        if n == 22:\n            return True\n        if n == 23:\n            return True\n        if n == 24:\n            return False\n        if n == 25:\n            return True\n        if n == 26:\n            return True\n        if n == 27:\n            return True\n        if n == 28:\n            return False\n        if n == 29:\n            return True\n        if n == 30:\n            return True\n        if n == 31:\n            return True\n        if n == 32:\n            return False\n        if n == 33:\n            return True\n        if n == 34:\n            return True\n        if n == 35:\n            return True\n        if n == 36:\n            return False\n        if n == 37:\n            return True\n        if n == 38:\n            return True\n        if n == 39:\n            return True\n        if n == 40:\n            return False\n        if n == 41:\n            return True\n        if n == 42:\n            return True\n        if n == 43:\n            return True\n        if n == 44:\n            return False\n        if n == 45:\n            return True\n        if n == 46:\n            return True\n        if n == 47:\n            return True\n        if n == 48:\n            return False\n        if n == 49:\n            return True\n        if n == 50:\n            return True\n        if n == 51:\n            return True\n        if n == 52:\n            return False\n        if n == 53:\n            return True\n        if n == 54:\n            return True\n        if n == 55:\n            return True\n        if n == 56:\n            return False\n        if n == 57:\n            return True\n        if n == 58:\n            return True\n        if n == 59:\n            return True\n        if n == 60:\n            return False\n        if n == 61:\n            return True\n        if n == 62:\n            return True\n        if n == 63:\n            return True\n        if n == 64:\n            return False\n        if n == 65:\n            return True\n        if n == 66:\n            return True\n        if n == 67:\n            return True\n        if n == 68:\n            return False\n        if n == 69:\n            return True\n        if n == 70:\n            return True\n        if n == 71:\n            return True\n        if n == 72:\n            return False\n        if n == 73:\n            return True\n        if n == 74:\n            return True\n        if n == 75:\n            return True\n        if n == 76:\n            return False\n        if n == 77:\n            return True\n        if n == 78:\n            return True\n        if n == 79:\n            return True\n        if n == 80:\n            return False\n        if n == 81:\n            return True\n        if n == 82:\n            return True\n        if n == 83:\n            return True\n        if n == 84:\n            return False\n        if n == 85:\n            return True\n        if n == 86:\n            return True\n        if n == 87:\n            return True\n        if n == 88:\n            return"}, {"task_id": "nim-game", "completion": "class Solution(object):\n    def canWinNim(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: bool\n        \"\"\"\n        \n        if n <= 3:\n            return True\n        if n == 4:\n            return False\n        if n == 5:\n            return True\n        if n == 6:\n            return True\n        if n == 7:\n            return True\n        if n == 8:\n            return False\n        if n == 9:\n            return True\n        if n == 10:\n            return True\n        if n == 11:\n            return True\n        if n == 12:\n            return False\n        if n == 13:\n            return True\n        if n == 14:\n            return True\n        if n == 15:\n            return True\n        if n == 16:\n            return False\n        if n == 17:\n            return True\n        if n == 18:\n            return True\n        if n == 19:\n            return True\n        if n == 20:\n            return False\n        if n == 21:\n            return True\n        if n == 22:\n            return True\n        if n == 23:\n            return True\n        if n == 24:\n            return False\n        if n == 25:\n            return True\n        if n == 26:\n            return True\n        if n == 27:\n            return True\n        if n == 28:\n            return False\n        if n == 29:\n            return True\n        if n == 30:\n            return True\n        if n == 31:\n            return True\n        if n == 32:\n            return False\n        if n == 33:\n            return True\n        if n == 34:\n            return True\n        if n == 35:\n            return True\n        if n == 36:\n            return False\n        if n == 37:\n            return True\n        if n == 38:\n            return True\n        if n == 39:\n            return True\n        if n == 40:\n            return False\n        if n == 41:\n            return True\n        if n == 42:\n            return True\n        if n == 43:\n            return True\n        if n == 44:\n            return False\n        if n == 45:\n            return True\n        if n == 46:\n            return True\n        if n == 47:\n            return True\n        if n == 48:\n            return False\n        if n == 49:\n            return True\n        if n == 50:\n            return True\n        if n == 51:\n            return True\n        if n == 52:\n            return False\n        if n == 53:\n            return True\n        if n == 54:\n            return True\n        if n == 55:\n            return True\n        if n == 56:\n            return False\n        if n == 57:\n            return True\n        if n == 58:\n            return True\n        if n == 59:\n            return True\n        if n == 60:\n            return False\n        if n == 61:\n            return True\n        if n == 62:\n            return True\n        if n == 63:\n            return True\n        if n == 64:\n            return False\n        if n == 65:\n            return True\n        if n == 66:\n            return True\n        if n == 67:\n            return True\n        if n == 68:\n            return False\n        if n == 69:\n            return True\n        if n == 70:\n            return True\n        if n == 71:\n            return True\n        if n == 72:\n            return False\n        if n == 73:\n            return True\n        if n == 74:\n            return True\n        if n == 75:\n            return True\n        if n == 76:\n            return False\n        if n == 77:\n            return True\n        if n == 78:\n            return True\n        if n == 79:\n            return True\n        if n == 80:\n            return False\n        if n == 81:\n            return True\n        if n == 82:\n            return True\n        if n == 83:\n            return True\n        if n == 84:\n            return False\n        if n == 85:\n            return True\n        if n == 86:\n            return True\n        if n == 87:\n            return True\n        if n == 88:\n            return"}], "n-queens-ii": [{"task_id": "n-queens-ii", "completion": "class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        def dfs(queens, xy_dif, xy_sum):\n            p = len(queens)\n            if p == n:\n                return 1\n            else:\n                ans = 0\n                for q in range(n):\n                    if q not in queens and p-q not in xy_dif and p+q not in xy_sum:\n                        ans += dfs(queens+[q], xy_dif+[p-q], xy_sum+[p+q])\n                return ans\n        \n        return dfs([], [], [])"}, {"task_id": "n-queens-ii", "completion": "class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        def dfs(queens, xy_dif, xy_sum):\n            p = len(queens)\n            if p==n:\n                return 1\n            else:\n                ans = 0\n                for q in range(n):\n                    if q not in queens and p-q not in xy_dif and p+q not in xy_sum:\n                        ans += dfs(queens+[q], xy_dif+[p-q], xy_sum+[p+q])\n                return ans\n        \n        return dfs([], [], [])"}, {"task_id": "n-queens-ii", "completion": "class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        def dfs(queens, xy_dif, xy_sum):\n            p = len(queens)\n            if p==n:\n                self.count += 1\n                return None\n            for q in range(n):\n                if q not in queens and p-q not in xy_dif and p+q not in xy_sum:\n                    dfs(queens+[q], xy_dif+[p-q], xy_sum+[p+q])\n        \n        self.count = 0\n        dfs([],[],[])\n        return self.count"}, {"task_id": "n-queens-ii", "completion": "class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        def dfs(queens, xy_dif, xy_sum):\n            p = len(queens)\n            if p==n:\n                self.count += 1\n                return None\n            for q in range(n):\n                if q not in queens and p-q not in xy_dif and p+q not in xy_sum:\n                    dfs(queens+[q], xy_dif+[p-q], xy_sum+[p+q])\n        \n        self.count = 0\n        dfs([],[],[])\n        return self.count"}, {"task_id": "n-queens-ii", "completion": "class Solution(object):\n    def totalNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: int\n        \"\"\"\n        \n        def dfs(queens, xy_dif, xy_sum):\n            p = len(queens)\n            if p==n:\n                self.count += 1\n                return None\n            for q in range(n):\n                if q not in queens and p-q not in xy_dif and p+q not in xy_sum:\n                    dfs(queens+[q], xy_dif+[p-q], xy_sum+[p+q])\n        \n        self.count = 0\n        dfs([],[],[])\n        return self.count"}], "n-queens": [{"task_id": "n-queens", "completion": "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def dfs(queens, xy_dif, xy_sum):\n            p = len(queens)\n            if p==n:\n                result.append(queens)\n                return None\n            for q in range(n):\n                if q not in queens and p-q not in xy_dif and p+q not in xy_sum:\n                    dfs(queens+[q], xy_dif+[p-q], xy_sum+[p+q])\n        \n        result = []\n        dfs([],[],[])\n        return [[\".\"*i + \"Q\" + \".\"*(n-i-1) for i in sol] for sol in result]"}, {"task_id": "n-queens", "completion": "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def dfs(queens, xy_dif, xy_sum):\n            p = len(queens)\n            if p==n:\n                result.append(queens)\n                return None\n            for q in range(n):\n                if q not in queens and p-q not in xy_dif and p+q not in xy_sum: \n                    dfs(queens+[q], xy_dif+[p-q], xy_sum+[p+q])  \n        result = []\n        dfs([],[],[])\n        return [ [\".\"*i + \"Q\" + \".\"*(n-i-1) for i in sol] for sol in result]"}, {"task_id": "n-queens", "completion": "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def dfs(queens, xy_dif, xy_sum):\n            p = len(queens)\n            if p==n:\n                result.append(queens)\n                return None\n            for q in range(n):\n                if q not in queens and p-q not in xy_dif and p+q not in xy_sum:\n                    dfs(queens+[q], xy_dif+[p-q], xy_sum+[p+q])\n        \n        result = []\n        dfs([],[],[])\n        return [[\".\"*i + \"Q\" + \".\"*(n-i-1) for i in sol] for sol in result]"}, {"task_id": "n-queens", "completion": "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def dfs(queens, xy_dif, xy_sum):\n            p = len(queens)\n            if p==n:\n                result.append(queens)\n                return None\n            for q in range(n):\n                if q not in queens and p-q not in xy_dif and p+q not in xy_sum: \n                    dfs(queens+[q], xy_dif+[p-q], xy_sum+[p+q])  \n        result = []\n        dfs([],[],[])\n        return [ [\".\"*i + \"Q\" + \".\"*(n-i-1) for i in sol] for sol in result]"}, {"task_id": "n-queens", "completion": "class Solution(object):\n    def solveNQueens(self, n):\n        \"\"\"\n        :type n: int\n        :rtype: List[List[str]]\n        \"\"\"\n        \n        def dfs(queens, xy_dif, xy_sum):\n            p = len(queens)\n            if p==n:\n                result.append(queens)\n                return None\n            for q in range(n):\n                if q not in queens and p-q not in xy_dif and p+q not in xy_sum:\n                    dfs(queens+[q], xy_dif+[p-q], xy_sum+[p+q])\n        \n        result = []\n        dfs([],[],[])\n        return [[\".\"*i + \"Q\" + \".\"*(n-i-1) for i in sol] for sol in result]"}], "word-search": [{"task_id": "word-search", "completion": "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(board, word, i, j, visited):\n            if len(word) == 0:\n                return True\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or (i, j) in visited or board[i][j] != word[0]:\n                return False\n            visited.add((i, j))\n            res = dfs(board, word[1:], i + 1, j, visited) or dfs(board, word[1:], i - 1, j, visited) or dfs(board, word[1:], i, j + 1, visited) or dfs(board, word[1:], i, j - 1, visited)\n            visited.remove((i, j))\n            return res\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if dfs(board, word, i, j, set()):\n                    return True\n        return False"}, {"task_id": "word-search", "completion": "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(board, i, j, word):\n            if len(word) == 0:\n                return True\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[0]:\n                return False\n            temp = board[i][j]\n            board[i][j] = '#'\n            res = dfs(board, i+1, j, word[1:]) or dfs(board, i-1, j, word[1:]) or dfs(board, i, j+1, word[1:]) or dfs(board, i, j-1, word[1:])\n            board[i][j] = temp\n            return res\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if dfs(board, i, j, word):\n                    return True\n        return False"}, {"task_id": "word-search", "completion": "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(board, i, j, word):\n            if len(word) == 0:\n                return True\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[0]:\n                return False\n            tmp = board[i][j]\n            board[i][j] = '#'\n            res = dfs(board, i+1, j, word[1:]) or dfs(board, i-1, j, word[1:]) or dfs(board, i, j+1, word[1:]) or dfs(board, i, j-1, word[1:])\n            board[i][j] = tmp\n            return res\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if dfs(board, i, j, word):\n                    return True\n        return False"}, {"task_id": "word-search", "completion": "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(board, i, j, word):\n            if len(word) == 0:\n                return True\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[0]:\n                return False\n            temp = board[i][j]\n            board[i][j] = '#'\n            res = dfs(board, i+1, j, word[1:]) or dfs(board, i-1, j, word[1:]) or dfs(board, i, j+1, word[1:]) or dfs(board, i, j-1, word[1:])\n            board[i][j] = temp\n            return res\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if dfs(board, i, j, word):\n                    return True\n        return False"}, {"task_id": "word-search", "completion": "class Solution(object):\n    def exist(self, board, word):\n        \"\"\"\n        :type board: List[List[str]]\n        :type word: str\n        :rtype: bool\n        \"\"\"\n        \n        def dfs(board, i, j, word):\n            if len(word) == 0:\n                return True\n            if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]) or board[i][j] != word[0]:\n                return False\n            temp = board[i][j]\n            board[i][j] = '#'\n            res = dfs(board, i+1, j, word[1:]) or dfs(board, i-1, j, word[1:]) or dfs(board, i, j+1, word[1:]) or dfs(board, i, j-1, word[1:])\n            board[i][j] = temp\n            return res\n        \n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                if dfs(board, i, j, word):\n                    return True\n        return False"}], "merge-sorted-array": [{"task_id": "merge-sorted-array", "completion": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        \n        # 1. create a copy of nums1\n        nums1_copy = nums1[:m]\n        \n        # 2. create two pointers for nums1_copy and nums2\n        p1 = 0\n        p2 = 0\n        \n        # 3. create a pointer for nums1\n        p = 0\n        \n        # 4. compare the elements at p1 and p2 and add the smaller one to nums1\n        while p1 < m and p2 < n:\n            if nums1_copy[p1] < nums2[p2]:\n                nums1[p] = nums1_copy[p1]\n                p1 += 1\n            else:\n                nums1[p] = nums2[p2]\n                p2 += 1\n            p += 1\n        \n        # 5. add the remaining elements of nums1_copy to nums1\n        while p1 < m:\n            nums1[p] = nums1_copy[p1]\n            p1 += 1\n            p += 1\n        \n        # 6. add the remaining elements of nums2 to nums1\n        while p2 < n:\n            nums1[p] = nums2[p2]\n            p2 += 1\n            p += 1\n        \n        return nums1"}, {"task_id": "merge-sorted-array", "completion": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        \n        # 1. \n        # nums1[m:] = nums2[:n]\n        # nums1.sort()\n        \n        # 2.\n        # nums1[m:] = nums2[:n]\n        # nums1.sort()\n        \n        # 3.\n        # nums1[m:] = nums2[:n]\n        # nums1.sort()\n        \n        # 4.\n        # nums1[m:] = nums2[:n]\n        # nums1.sort()\n        \n        # 5.\n        # nums1[m:] = nums2[:n]\n        # nums1.sort()\n        \n        # 6.\n        # nums1[m:] = nums2[:n]\n        # nums1.sort()\n        \n        # 7.\n        # nums1[m:] = nums2[:n]\n        # nums1.sort()\n        \n        # 8.\n        # nums1[m:] = nums2[:n]\n        # nums1.sort()\n        \n        # 9.\n        # nums1[m:] = nums2[:n]\n        # nums1.sort()\n        \n        # 10.\n        # nums1[m:] = nums2[:n]\n        # nums1.sort()\n        \n        # 11.\n        # nums1[m:] = nums2[:n]\n        # nums1.sort()\n        \n        # 12.\n        # nums1[m:] = nums2[:n]\n        # nums1.sort()\n        \n        # 13.\n        # nums1[m:] = nums2[:n]\n        # nums1.sort()\n        \n        # 14.\n        # nums1[m:] = nums2[:n]\n        # nums1.sort()\n        \n        # 15.\n        # nums1[m:] = nums2[:n]\n        # nums1.sort()\n        \n        # 16.\n        # nums1[m:] = nums2[:n]\n        # nums1.sort()\n        \n        # 17.\n        # nums1[m:] = nums2[:n]\n        # nums1.sort()\n        \n        # 18.\n        # nums1[m:] = nums2[:n]\n        # nums1.sort()\n        \n        # 19.\n        # nums1[m:] = nums2[:n]\n        # nums1.sort()\n        \n        # 20.\n        # nums1[m:] = nums2[:n]\n        # nums1.sort()\n        \n        # 21.\n        # nums1[m:] = nums2[:n]\n        # nums1.sort()\n        \n        # 22.\n        # nums1[m:] = nums2[:n]\n        # nums1.sort()\n        \n        # 23.\n        # nums1[m:] = nums2[:n]\n        # nums1.sort()\n        \n        # 24.\n        # nums1[m:] = nums2[:n]\n        # nums1.sort()\n        \n        # 25.\n        # nums1[m:] = nums2[:n]\n        # nums1.sort()\n        \n        # 26.\n        # nums1[m:] = nums2[:n]\n        # nums1.sort()\n        \n        # 27.\n        # nums1[m:] = nums2[:n]\n        # nums1.sort()\n        \n        # 28.\n        # nums1[m:] = nums2[:n]\n        # nums1.sort()\n        \n        # 29.\n        # nums1[m:] = nums2[:n]\n        # nums1.sort()\n        \n        # 30.\n        # nums1[m:] = nums2[:n]\n        # nums1.sort()\n        \n        # 31.\n        # nums1"}, {"task_id": "merge-sorted-array", "completion": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        \n        # 1. create a new array to store the merged array\n        # 2. create two pointers, one for nums1 and one for nums2\n        # 3. compare the values of the two pointers and add the smaller value to the new array\n        # 4. increment the pointer of the array with the smaller value\n        # 5. repeat step 3 and 4 until one of the pointers reaches the end of its array\n        # 6. add the remaining values of the other array to the new array\n        # 7. copy the new array to nums1\n        \n        # create a new array to store the merged array\n        merged = []\n        \n        # create two pointers, one for nums1 and one for nums2\n        i = 0\n        j = 0\n        \n        # compare the values of the two pointers and add the smaller value to the new array\n        while i < m and j < n:\n            if nums1[i] < nums2[j]:\n                merged.append(nums1[i])\n                i += 1\n            else:\n                merged.append(nums2[j])\n                j += 1\n        \n        # add the remaining values of the other array to the new array\n        while i < m:\n            merged.append(nums1[i])\n            i += 1\n        \n        while j < n:\n            merged.append(nums2[j])\n            j += 1\n        \n        # copy the new array to nums1\n        for i in range(len(merged)):\n            nums1[i] = merged[i]\n        \n        return nums1"}, {"task_id": "merge-sorted-array", "completion": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        \n        # 1. \n        # nums1[m:] = nums2[:n]\n        # nums1.sort()\n        \n        # 2.\n        # nums1[m:] = nums2[:n]\n        # nums1.sort()\n        \n        # 3.\n        # nums1[m:] = nums2[:n]\n        # nums1.sort()\n        \n        # 4.\n        # nums1[m:] = nums2[:n]\n        # nums1.sort()\n        \n        # 5.\n        # nums1[m:] = nums2[:n]\n        # nums1.sort()\n        \n        # 6.\n        # nums1[m:] = nums2[:n]\n        # nums1.sort()\n        \n        # 7.\n        # nums1[m:] = nums2[:n]\n        # nums1.sort()\n        \n        # 8.\n        # nums1[m:] = nums2[:n]\n        # nums1.sort()\n        \n        # 9.\n        # nums1[m:] = nums2[:n]\n        # nums1.sort()\n        \n        # 10.\n        # nums1[m:] = nums2[:n]\n        # nums1.sort()\n        \n        # 11.\n        # nums1[m:] = nums2[:n]\n        # nums1.sort()\n        \n        # 12.\n        # nums1[m:] = nums2[:n]\n        # nums1.sort()\n        \n        # 13.\n        # nums1[m:] = nums2[:n]\n        # nums1.sort()\n        \n        # 14.\n        # nums1[m:] = nums2[:n]\n        # nums1.sort()\n        \n        # 15.\n        # nums1[m:] = nums2[:n]\n        # nums1.sort()\n        \n        # 16.\n        # nums1[m:] = nums2[:n]\n        # nums1.sort()\n        \n        # 17.\n        # nums1[m:] = nums2[:n]\n        # nums1.sort()\n        \n        # 18.\n        # nums1[m:] = nums2[:n]\n        # nums1.sort()\n        \n        # 19.\n        # nums1[m:] = nums2[:n]\n        # nums1.sort()\n        \n        # 20.\n        # nums1[m:] = nums2[:n]\n        # nums1.sort()\n        \n        # 21.\n        # nums1[m:] = nums2[:n]\n        # nums1.sort()\n        \n        # 22.\n        # nums1[m:] = nums2[:n]\n        # nums1.sort()\n        \n        # 23.\n        # nums1[m:] = nums2[:n]\n        # nums1.sort()\n        \n        # 24.\n        # nums1[m:] = nums2[:n]\n        # nums1.sort()\n        \n        # 25.\n        # nums1[m:] = nums2[:n]\n        # nums1.sort()\n        \n        # 26.\n        # nums1[m:] = nums2[:n]\n        # nums1.sort()\n        \n        # 27.\n        # nums1[m:] = nums2[:n]\n        # nums1.sort()\n        \n        # 28.\n        # nums1[m:] = nums2[:n]\n        # nums1.sort()\n        \n        # 29.\n        # nums1[m:] = nums2[:n]\n        # nums1.sort()\n        \n        # 30.\n        # nums1[m:] = nums2[:n]\n        # nums1.sort()\n        \n        # 31.\n        # nums1"}, {"task_id": "merge-sorted-array", "completion": "class Solution(object):\n    def merge(self, nums1, m, nums2, n):\n        \"\"\"\n        :type nums1: List[int]\n        :type m: int\n        :type nums2: List[int]\n        :type n: int\n        :rtype: None Do not return anything, modify nums1 in-place instead.\n        \"\"\"\n        \n        # 1. create a copy of nums1\n        nums1_copy = nums1[:m]\n        \n        # 2. create two pointers for nums1_copy and nums2\n        p1 = 0\n        p2 = 0\n        \n        # 3. create a pointer for nums1\n        p = 0\n        \n        # 4. compare the values of nums1_copy and nums2\n        while p1 < m and p2 < n:\n            if nums1_copy[p1] < nums2[p2]:\n                nums1[p] = nums1_copy[p1]\n                p1 += 1\n            else:\n                nums1[p] = nums2[p2]\n                p2 += 1\n            p += 1\n            \n        # 5. if there are any remaining values in nums1_copy, add them to nums1\n        while p1 < m:\n            nums1[p] = nums1_copy[p1]\n            p1 += 1\n            p += 1\n            \n        # 6. if there are any remaining values in nums2, add them to nums1\n        while p2 < n:\n            nums1[p] = nums2[p2]\n            p2 += 1\n            p += 1\n        \n        return nums1"}], "third-maximum-number": [{"task_id": "third-maximum-number", "completion": "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc911\ubcf5 \uc81c\uac70\n        # 2. \uc815\ub82c\n        # 3. \uc815\ub82c\ub41c \ubc30\uc5f4\uc758 \uae38\uc774\uac00 3\ubcf4\ub2e4 \uc791\uc73c\uba74 \uac00\uc7a5 \ud070 \uc218 \ubc18\ud658\n        # 4. \uc815\ub82c\ub41c \ubc30\uc5f4\uc758 \uae38\uc774\uac00 3\ubcf4\ub2e4 \ud06c\uba74 3\ubc88\uc9f8 \uc218 \ubc18\ud658\n        \n        nums = list(set(nums))\n        nums.sort(reverse=True)\n        \n        if len(nums) < 3:\n            return nums[0]\n        else:\n            return nums[2]"}, {"task_id": "third-maximum-number", "completion": "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. sort the array\n        # 2. find the third maximum\n        # 3. if there is no third maximum, return the maximum\n        # 4. if there is a third maximum, return the third maximum\n        \n        # 1. sort the array\n        nums.sort()\n        \n        # 2. find the third maximum\n        # 3. if there is no third maximum, return the maximum\n        # 4. if there is a third maximum, return the third maximum\n        if len(nums) < 3:\n            return nums[-1]\n        else:\n            return nums[-3]"}, {"task_id": "third-maximum-number", "completion": "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc911\ubcf5 \uc81c\uac70\n        # 2. \uc815\ub82c\n        # 3. \uc815\ub82c\ub41c \ub9ac\uc2a4\ud2b8\uc5d0\uc11c \uc138\ubc88\uc9f8 \uc6d0\uc18c \ubc18\ud658\n        \n        nums = list(set(nums))\n        nums.sort(reverse=True)\n        \n        if len(nums) < 3:\n            return nums[0]\n        else:\n            return nums[2]"}, {"task_id": "third-maximum-number", "completion": "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. \uc911\ubcf5 \uc81c\uac70\n        # 2. \uc815\ub82c\n        # 3. \uc138\ubc88\uc9f8 \ucd5c\ub300\uac12 \ubc18\ud658\n        \n        nums = list(set(nums))\n        nums.sort(reverse=True)\n        \n        if len(nums) < 3:\n            return nums[0]\n        else:\n            return nums[2]"}, {"task_id": "third-maximum-number", "completion": "class Solution(object):\n    def thirdMax(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        \n        # 1. sort the list\n        # 2. find the third maximum\n        # 3. return the third maximum\n        \n        # 1. sort the list\n        nums.sort()\n        \n        # 2. find the third maximum\n        # 3. return the third maximum\n        if len(nums) < 3:\n            return nums[-1]\n        else:\n            return nums[-3]"}]}